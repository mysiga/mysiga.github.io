<!DOCTYPE html>
<html>

<head>
  <meta http-equiv="Content-Type" content="text/html" charset="UTF-8" >
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
  <title>动画 | Wilson</title>
  <meta name="description" content="自强不息 厚德载物" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="MobileOptimized" content="320" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <link rel="stylesheet" type="text/css" href="/css/screen.css" />
  <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Noto+Serif:400,700,400italic|Open+Sans:700,400" />

  <meta name="generator" content="Wilson">

  
  
  

  
</head>


<body class="post-template">

  <header class="site-head"  style="background-image: url(//blog.ghost.org/content/images/2013/Nov/cover.png)" >
    <div class="vertical">
        <div class="site-head-content inner">
             <a class="blog-logo" href="/"><img src="//https://mysiga.cn/img/avatar.png" alt="Blog Logo"/></a> 
            <h1 class="blog-title">Wilson</h1>
            <h2 class="blog-description">自强不息 厚德载物</h2>
        </div>
    </div>
</header>
  

<main class="content" role="main">
  <article class="post">
    <span class="post-meta">
      <time datetime="2015-11-18T10:30:00.000Z" itemprop="datePublished">
          2015-11-18
      </time>
    
</span>
    <h1 class="post-title">动画</h1>
    <section class="post-content">
      <h2 id="Android-L动画-吴明"><a href="#Android-L动画-吴明" class="headerlink" title="Android L动画  - 吴明"></a>Android L动画  - 吴明</h2><ul>
<li>Touch feedback（触摸反馈）<ul>
<li>波纹有边界</li>
<li>波纹超出边界</li>
<li>波纹颜色</li>
</ul>
</li>
<li>Reveal effect（揭露效果）</li>
<li>liecap<ul>
<li>Circular Reveal动画</li>
</ul>
</li>
<li>Activity transitions（Activity转换效果）<ul>
<li>Enter（进入）<ul>
<li>普通Transition<ul>
<li>explode：从场景的中心移入或移出 </li>
<li>slide：从场景的边缘移入或移出 </li>
<li>fade：调整透明度产生渐变效果</li>
</ul>
</li>
<li>Shared Elements Transition 共享元素转换:共享两个                acitivity中共同的元素<ul>
<li>changeBounds -  改变目标视图的布局边界</li>
<li>changeClipBounds - 裁剪目标视图边界</li>
<li>changeTransform - 改变目标视图的缩放比例和旋转角度        changeImageTransform - 改变目标图片的大小和缩放比例</li>
</ul>
</li>
</ul>
</li>
<li>Exit（退出）</li>
<li><a target="_blank" rel="noopener" href="http://pan.baidu.com/s/1o6Kngnw">demo地址</a><br><img src="http://7xn0ue.com1.z0.glb.clouddn.com/Untitled123.gif" alt="Markdown preferences pane"></li>
</ul>
</li>
</ul>
<h2 id="objectorAnimator-动画-王进"><a href="#objectorAnimator-动画-王进" class="headerlink" title="objectorAnimator 动画  王进"></a>objectorAnimator 动画  王进</h2><h3 id="动画类型"><a href="#动画类型" class="headerlink" title="动画类型"></a>动画类型</h3><ul>
<li>View Animation(Tween Animation 补间动画)<br>  只能支持简单的缩放、平移、旋转、透明度等基本的动画，且有一定的局限性<br>  动画时View的真正的View的属性保持不变，实际位置未改变<br>  原理：提供动画的起始和结束状态信息，中间的状态根据上述类里差值器算法填充</li>
<li>  Drawable Animation（Frame Animation 帧动画）</li>
<li>  Property Animation(属性动画)<br>它更改的是对象的实际属性，</li>
</ul>
<h3 id="Property-Animation属性"><a href="#Property-Animation属性" class="headerlink" title="Property Animation属性"></a>Property Animation属性</h3><ul>
<li>  Duration：动画的持续时间</li>
<li>  TimeInterpolation：属性值的计算方式，如先快后慢</li>
<li>  TypeEvaluator：根据属性的开始、结束值与TimeInterpolation计算出的因子计算出当前时间的属性值</li>
<li>  Repeat Count and behavoir：重复次数与方式，如播放3次、5次、无限循环，可以此动画一直重复，或播放完时再反向播放</li>
<li>  Animation sets：动画集合，即可以同时对一个对象应用几个动画，这些动画可以同时播放也可以对不同动画设置不同开始偏移</li>
<li>  Frame refreash delay：多少时间刷新一次，即每隔多少时间计算一次属性值，默认为10ms，最终刷新时间还受系统进程调度与硬件的影响</li>
</ul>
<h3 id="Property-Animation-动画流程"><a href="#Property-Animation-动画流程" class="headerlink" title="Property Animation 动画流程"></a>Property Animation 动画流程</h3><p><img src="http://pic002.cnblogs.com/images/2011/168097/2011120119191590.png"></p>
<h3 id="ValueAnimator"><a href="#ValueAnimator" class="headerlink" title="ValueAnimator"></a>ValueAnimator</h3><p>ValueAnimator包含Property Animation动画的所有核心功能，如动画时间，开始、结束属性值，相应时间属性值计算方法等。应用Property Animation有两个步聚：</p>
<ol>
<li> 计算属性值</li>
<li>根据属性值执行相应的动作，如改变对象的某一属性。（需要在onAnimationUpdate中传入执行动画的对象）<pre><code>ValueAnimator animation = ValueAnimator.ofFloat(0f, 1f);
animation.setDuration(1000);
animation.addUpdateListener(new AnimatorUpdateListener() &#123;
 @Override
 public void onAnimationUpdate(ValueAnimator animation) &#123;
     Log.i(&quot;update&quot;, ((Float) animation.getAnimatedValue()).toString());
     //这个函数中会传入ValueAnimator对象做为参数，通过这个ValueAnimator对象的getAnimatedValue()函数可以得到当前的属性值
 &#125;
&#125;);
animation.setInterpolator(new CycleInterpolator(3));
animation.start();
</code></pre>
</li>
</ol>
<h3 id="ObjectAnimator"><a href="#ObjectAnimator" class="headerlink" title="ObjectAnimator"></a>ObjectAnimator</h3><p>ObjectAnimator继承自ValueAnimator，要指定一个对象及该对象的一个属性,例如</p>
<ul>
<li>常用方法有ofFloat()，ofInt()，ofObject()，ofArgb()，ofPropertyValuesHolder()。</li>
<li>属性动画可用的属性<br>答案是：任何一切带有set开头的方法属性名字。可能我们常用的有：</li>
<li>平移 translationX，translationY, X，Y。 </li>
<li>缩放 scaleX，scaleY。 </li>
<li>旋转 rotationX， rotationY。</li>
<li>透明度 alpha。</li>
</ul>
<p> 也就是说我们所有控件都有以上setTranslationX(),setScaleX(),setRotationX(),setAlpha()等方法。<br>我们不仅限于这几个属性，就拿TextView控件来说，只要是TextView有的属性都可以用来实现动画效果，比如 字体大小：“textColor”，字体颜色“textSize”等。</p>
<blockquote>
<p>限制：对象应该有一个setter函数：set<PropertyName>（驼峰命名法）及要有相应属性的getter方法：get<PropertyName><br>且应返回值类型应与相应的setter方法的参数类型一致。<br>如果上述条件不满足，则不能用ObjectAnimator，应用ValueAnimator代替。</p>
</blockquote>
<pre><code> ObjectAnimator animator = ObjectAnimator.ofFloat(imageView, &#39;alpha&#39;, 1.0f, 0.3f, 1.0F);
        animator.setDuration(2000);//动画时间
        animator.setInterpolator(new BounceInterpolator());//动画插值
        animator.setRepeatCount(-1);//设置动画重复次数
        animator.setRepeatMode(ValueAnimator.RESTART);//动画重复模式
        animator.setStartDelay(1000);//动画延时执行
        animator.start();//启动动画
</code></pre>
<blockquote>
<p>根据应用动画的对象或属性的不同，可能需要在onAnimationUpdate函数中调用invalidate()函数刷新视图。</p>
</blockquote>
<h3 id="组合动画"><a href="#组合动画" class="headerlink" title="组合动画"></a>组合动画</h3><ul>
<li><strong>组合动画1–AnimatorSet的使用</strong><br>这个类提供了一个play()方法，如果我们向这个方法中传入一个Animator对象(ValueAnimator或ObjectAnimator)将会返回一个AnimatorSet.Builder的实例，AnimatorSet.Builder中包括以下四个方法：<ul>
<li>after(Animator anim) 将现有动画插入到传入的动画之后执行</li>
<li>after(long delay) 将现有动画延迟指定毫秒后执行</li>
<li>before(Animator anim) 将现有动画插入到传入的动画之前执行</li>
<li>with(Animator anim) 将现有动画和传入的动画同时执行</li>
</ul>
<blockquote>
<p>Android 除了提供play(),还有playSequentially(),playTogether() 可供使用，可传入一个或者多个动画对象（，隔开），或者动画集合</p>
</blockquote>
</li>
</ul>
<pre><code>   ObjectAnimator animator = ObjectAnimator.ofInt(container, &quot;backgroundColor&quot;, 0xFFFF0000, 0xFFFF00FF);
                ObjectAnimator animator1 = ObjectAnimator.ofFloat(view, &quot;translationX&quot;, 0.0f, 200.0f, 0f);
                ObjectAnimator animator2 = ObjectAnimator.ofFloat(view, &quot;scaleX&quot;, 1.0f, 2.0f);
                ObjectAnimator animator3 = ObjectAnimator.ofFloat(view, &quot;rotationX&quot;, 0.0f, 90.0f, 0.0F);
                ObjectAnimator animator4 = ObjectAnimator.ofFloat(view, &quot;alpha&quot;, 1.0f, 0.2f, 1.0F);

                //组合动画方式1
                AnimatorSet set = new AnimatorSet();
               ((set.play(animator).with(animator1).before(animator2)).before(animator3)).after(animator4);
                set.setDuration(5000);
                set.start();
</code></pre>
<ul>
<li><p><strong>组合动画2–PropertyValuesHolder的使用</strong><br>使用方法ObjectAnimator.ofPropertyValuesHolder(Object target,PropertyValuesHolder… values)；第一个参数是动画的目标对象，之后的参数是PropertyValuesHolder类的实例，可以有多个这样的实例。代码如下：</p>
<pre><code>PropertyValuesHolder valuesHolder = PropertyValuesHolder.ofFloat(&quot;translationX&quot;, 0.0f, 300.0f);
              PropertyValuesHolder valuesHolder1 = PropertyValuesHolder.ofFloat(&quot;scaleX&quot;, 1.0f, 1.5f);
              PropertyValuesHolder valuesHolder2 = PropertyValuesHolder.ofFloat(&quot;rotationX&quot;, 0.0f, 90.0f, 0.0F);
              PropertyValuesHolder valuesHolder3 = PropertyValuesHolder.ofFloat(&quot;alpha&quot;, 1.0f, 0.3f, 1.0F);

              ObjectAnimator objectAnimator = ObjectAnimator.ofPropertyValuesHolder(view, valuesHolder, valuesHolder1, valuesHolder2, valuesHolder3);
              objectAnimator.setDuration(2000).start();
              //类似于AnimatorSet.playTogether(Animator... items);
</code></pre>
</li>
<li><p><strong>组合动画3-ViewPropertyAnimator（多属性动画）</strong></p>
<pre><code>ViewPropertyAnimator animator5 = imageView.animate();
animator5.translationX(200).scaleX(2).setDuration(2000).start();
</code></pre>
<blockquote>
<p>注意：使用ViewPropertyAnimator类需要API&gt;=12</p>
</blockquote>
</li>
</ul>
<h3 id="动画监听"><a href="#动画监听" class="headerlink" title="动画监听"></a>动画监听</h3><ul>
<li>animator.addListener(new Animator.AnimatorListener(){});//监听动画开始，结束，取消，重复（四种都包括）</li>
<li>animator.addListener(new  AnimatorListenerAdapter(){});<br>推荐，可代替AnimatorListener，需要监听动画开始，结束，取消，重复那种就直接实现那种方法就行<br>其实AnimatorListenerAdapter的源码只是一个实现了AnimatorListener接口的抽象类而已</li>
<li>animator.addUpdateListener(new  ValueAnimator.AnimatorUpdateListener(){});<br>更加精确的方法来时刻监听当前动画的执行情况，可以读取到动画的每个更新值了<pre><code>animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;
          @Override
          public void onAnimationUpdate(ValueAnimator animation) &#123;
              float value = (float) animation.getAnimatedValue();
              //可以根据自己的需要来获取动画更新值。
              Log.e(&#39;TAG&#39;, &#39;the animation value is &#39; + value);
          &#125;
      &#125;);
</code></pre>
</li>
</ul>
<h3 id="Keyframes"><a href="#Keyframes" class="headerlink" title="Keyframes"></a>Keyframes</h3><p>keyFrame是一个 时间/值 对，通过它可以定义一个在特定时间的特定状态，即关键帧，而且在两个keyFrame之间可以定义不同的Interpolator，就好像多个动画的拼接，第一个动画的结束点是第二个动画的开始点。KeyFrame是抽象类，要通过ofInt(),ofFloat(),ofObject()获得适当的KeyFrame，然后通过PropertyValuesHolder.ofKeyframe获得PropertyValuesHolder对象，如以下例子：</p>
<pre><code>/*
*   动画效果：btn对象的width属性值使其：
*   开始时 Width=400
*   动画开始1/4时 Width=200
*   动画开始1/2时 Width=400
*   动画开始3/4时 Width=100
*   动画结束时 Width=500
*/
Keyframe kf0 = Keyframe.ofInt(0, 400);
Keyframe kf1 = Keyframe.ofInt(0.25f, 200);
Keyframe kf2 = Keyframe.ofInt(0.5f, 400);
Keyframe kf4 = Keyframe.ofInt(0.75f, 100);
Keyframe kf3 = Keyframe.ofInt(1f, 500);
PropertyValuesHolder pvhRotation = PropertyValuesHolder.ofKeyframe(&quot;width&quot;, kf0, kf1, kf2, kf4, kf3);
ObjectAnimator rotationAnim = ObjectAnimator.ofPropertyValuesHolder(btn2, pvhRotation);
rotationAnim.setDuration(2000);
</code></pre>
<h3 id="Property-Animation在XML中使用"><a href="#Property-Animation在XML中使用" class="headerlink" title="Property Animation在XML中使用"></a>Property Animation在XML中使用</h3><ul>
<li><p>xml文件放在res/animator/中</p>
<pre><code>&lt;set xmlns:android=&#39;http://schemas.android.com/apk/res/android&#39;
  android:duration=&#39;2000&#39;
  android:ordering=&#39;sequentially&#39;&gt;&lt;!--动画执行顺序 sequentially：顺序执行；together：同时执行。 --&gt;

  &lt;objectAnimator
      android:propertyName=&#39;translationX&#39;
      android:valueFrom=&#39;0&#39;
      android:valueTo=&#39;200&#39;
      android:valueType=&#39;floatType&#39; /&gt;

  &lt;set android:ordering=&#39;together&#39;&gt;
      &lt;objectAnimator
          android:propertyName=&#39;scaleX&#39;
          android:valueFrom=&#39;1&#39;
          android:valueTo=&#39;2&#39;
          android:valueType=&#39;floatType&#39; /&gt;
      &lt;objectAnimator
          android:propertyName=&#39;rotationX&#39;
          android:valueFrom=&#39;0&#39;
          android:valueTo=&#39;90&#39;
          android:valueType=&#39;floatType&#39; /&gt;&lt;!--动画值的类型--&gt;

  &lt;/set&gt;
</code></pre>
</li>
<li><p>通过AnimatorInflater.loadAnimator方法加载xml动画返回一个Animator的对象，然后调用setTarget方法给动画设置对象调用哪个start启动动画即可完成xml动画效果</p>
<pre><code>Animator animator = AnimatorInflater.loadAnimator(context, R.animator.anim_file);
animator.setTarget(view);  
animator.start();
</code></pre>
</li>
</ul>
<h2 id="花花绿绿的ProgressBar-杨俊构"><a href="#花花绿绿的ProgressBar-杨俊构" class="headerlink" title="花花绿绿的ProgressBar  杨俊构"></a>花花绿绿的ProgressBar  杨俊构</h2><p><em>参考<a target="_blank" rel="noopener" href="http://www.runoob.com/w3cnote/android-tutorial-progressbar.html">Android 基础入门教程</a></em></p>
<ul>
<li>ProgressBar(进度条)是Android基本UI控件，ProgressBar的应用场景很多，比如 用户登录时，后台在发请求，以及等待服务器返回信息，这个时候会用到进度条；或者当在进行一些比较 耗时的操作，需要等待一段较长的时间，这个时候如果没有提示，用户可能会以为程序Carsh或者手机死机 了，这样会大大降低用户体验，所以在需要进行耗时操作的地方，添加上进度条，让用户知道当前的程序 在执行中，也可以直观的告诉用户当前任务的执行进度等！使用进度条可以给我带来这样的便利！ </li>
</ul>
<ul>
<li>ProgressBar<a target="_blank" rel="noopener" href="http://androiddoc.qiniudn.com/reference/android/widget/ProgressBar.html">官方API文档</a>，ProgressBar继承与View类，直接子类有AbsSeekBar和ContentLoadingProgressBar， 其中AbsSeekBar的子类有SeekBar和RatingBar，可见这二者也是基于ProgressBar实现的</li>
</ul>
<p><img src="http://7xohph.com1.z0.glb.clouddn.com/46760225.jpg"></p>
<ul>
<li>常用属性详解：</li>
</ul>
<blockquote>
<ul>
<li>android:max：进度条的最大值</li>
<li>android:progress：进度条已完成进度值</li>
<li>android:progressDrawable：设置轨道对应的Drawable对象</li>
<li>android:indeterminate：如果设置成true，则进度条不精确显示进度</li>
<li>android:indeterminateDrawable：设置不显示进度的进度条的Drawable对象</li>
<li>android:indeterminateDuration：设置不精确显示进度的持续时间</li>
<li>android:secondaryProgress：二级进度条，类似于视频播放的一条是当前播放进度，一条是缓冲进度，前者通过progress属性进行设置！</li>
</ul>
</blockquote>
<ul>
<li>对应的再Java中我们可调用下述方法：</li>
</ul>
<blockquote>
<ul>
<li>getMax()：返回这个进度条的范围的上限</li>
<li>getProgress()：返回进度</li>
<li>getSecondaryProgress()：返回次要进度</li>
<li>incrementProgressBy(int diff)：指定增加的进度</li>
<li>isIndeterminate()：指示进度条是否在不确定模式下</li>
<li>setIndeterminate(boolean indeterminate)：设置不确定模式下</li>
</ul>
</blockquote>
<ul>
<li>系统默认进度条使用实例：</li>
</ul>
<p><img src="http://7xohph.com1.z0.glb.clouddn.com/34906854.jpg"></p>
<h3 id="耀眼的IOS的ProgressBar-，参看开源中国IOS代码库"><a href="#耀眼的IOS的ProgressBar-，参看开源中国IOS代码库" class="headerlink" title="耀眼的IOS的ProgressBar ，参看开源中国IOS代码库"></a>耀眼的IOS的ProgressBar ，参看<a target="_blank" rel="noopener" href="http://www.oschina.net/ios/codingList/373/ios-progress">开源中国IOS代码库</a></h3><h3 id="圆形进度条"><a href="#圆形进度条" class="headerlink" title="圆形进度条"></a>圆形进度条</h3><blockquote>
<p>网上一个简单的自定义圆形进度条！代码还是比较简单，容易理解，有兴趣可以看看，或者进行相关扩展~</p>
</blockquote>
<p><img src="http://7xohph.com1.z0.glb.clouddn.com/17272953.jpg"></p>
<ul>
<li>实现代码：自定义View类：</li>
</ul>
<pre><code class="java">    
    /**
     * Created by Jay on 2015/8/5 0005.
     */
    public class CirclePgBar extends View &#123;
    
    
        private Paint mBackPaint;
        private Paint mFrontPaint;
        private Paint mTextPaint;
        private float mStrokeWidth = 50;
        private float mHalfStrokeWidth = mStrokeWidth / 2;
        private float mRadius = 200;
        private RectF mRect;
        private int mProgress = 0;
        //目标值，想改多少就改多少
        private int mTargetProgress = 90;
        private int mMax = 100;
        private int mWidth;
        private int mHeight;
    
    
        public CirclePgBar(Context context) &#123;
            super(context);
            init();
        &#125;
    
        public CirclePgBar(Context context, AttributeSet attrs) &#123;
            super(context, attrs);
            init();
        &#125;
    
        public CirclePgBar(Context context, AttributeSet attrs, int defStyleAttr) &#123;
            super(context, attrs, defStyleAttr);
            init();
        &#125;
    
    
        //完成相关参数初始化
        private void init() &#123;
            mBackPaint = new Paint();
            mBackPaint.setColor(Color.WHITE);
            mBackPaint.setAntiAlias(true);
            mBackPaint.setStyle(Paint.Style.STROKE);
            mBackPaint.setStrokeWidth(mStrokeWidth);
    
            mFrontPaint = new Paint();
            mFrontPaint.setColor(Color.GREEN);
            mFrontPaint.setAntiAlias(true);
            mFrontPaint.setStyle(Paint.Style.STROKE);
            mFrontPaint.setStrokeWidth(mStrokeWidth);
    
    
            mTextPaint = new Paint();
            mTextPaint.setColor(Color.GREEN);
            mTextPaint.setAntiAlias(true);
            mTextPaint.setTextSize(80);
            mTextPaint.setTextAlign(Paint.Align.CENTER);
        &#125;
    
    
        //重写测量大小的onMeasure方法和绘制View的核心方法onDraw()
        @Override
        protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;
            super.onMeasure(widthMeasureSpec, heightMeasureSpec);
            mWidth = getRealSize(widthMeasureSpec);
            mHeight = getRealSize(heightMeasureSpec);
            setMeasuredDimension(mWidth, mHeight);
    
        &#125;
    
    
        @Override
        protected void onDraw(Canvas canvas) &#123;
            initRect();
            float angle = mProgress / (float) mMax * 360;
            canvas.drawCircle(mWidth / 2, mHeight / 2, mRadius, mBackPaint);
            canvas.drawArc(mRect, -90, angle, false, mFrontPaint);
            canvas.drawText(mProgress + &quot;%&quot;, mWidth / 2 + mHalfStrokeWidth, mHeight / 2 + mHalfStrokeWidth, mTextPaint);
            if (mProgress &lt; mTargetProgress) &#123;
                mProgress += 1;
                invalidate();
            &#125;
    
        &#125;
    
        public int getRealSize(int measureSpec) &#123;
            int result = 1;
            int mode = MeasureSpec.getMode(measureSpec);
            int size = MeasureSpec.getSize(measureSpec);
    
            if (mode == MeasureSpec.AT_MOST || mode == MeasureSpec.UNSPECIFIED) &#123;
                //自己计算
                result = (int) (mRadius * 2 + mStrokeWidth);
            &#125; else &#123;
                result = size;
            &#125;
    
            return result;
        &#125;
    
        private void initRect() &#123;
            if (mRect == null) &#123;
                mRect = new RectF();
                int viewSize = (int) (mRadius * 2);
                int left = (mWidth - viewSize) / 2;
                int top = (mHeight - viewSize) / 2;
                int right = left + viewSize;
                int bottom = top + viewSize;
                mRect.set(left, top, right, bottom);
            &#125;
        &#125;
    
    
    &#125;
</code></pre>
<ul>
<li>然后在布局文件中加上：</li>
</ul>
<pre><code class="xml">
     &lt;com.jay.progressbardemo.CirclePgBar
       android:layout_width=&quot;match_parent&quot;
       android:layout_height=&quot;match_parent&quot;/&gt;
</code></pre>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>progressbar是Android中的常用控件，在实际开发中和动画结合较多，好的进度条可以缓解使用者焦躁的情趣，自定义圆形进度条可以自行完善，然后用到实际开发中！</li>
</ul>
<h2 id="layer-list实现阴影效果——xpleemoon"><a href="#layer-list实现阴影效果——xpleemoon" class="headerlink" title="layer-list实现阴影效果——xpleemoon"></a>layer-list实现阴影效果——xpleemoon</h2><ul>
<li><p>为控件实现阴影效果，可以有多种方式：</p>
<ul>
<li>多个drawable层叠在一起（不好的实现是多个View层叠达到多个drawable的层叠效果，相对好的实现是在同一个View钟实现多个drawable的层叠）</li>
<li>自定义view</li>
<li>Material Design中设置Z轴的方式</li>
</ul>
</li>
<li><p>本文的思路是多个drawable叠在一起，但是不额外使用View，通过layer-list可以将多个item按照顺序层叠在一起显示。首先来看效果图：</p>
</li>
</ul>
<p><img src="https://github.com/xpleemoon/layer-list-shadow-demo/blob/master/gif/LayerShadow.gif?raw=true" alt="LayerShadow"></p>
<ul>
<li><p>第一个和第二个控件是用来展示layer-list实现阴影效果的基本款，而第三个控件是综合上述两个控件效果，再集合selector实现的。</p>
</li>
<li><p>默认状态：</p>
</li>
</ul>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;layer-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;
    &lt;!-- 阴影：左偏移2dp，上偏移4dp --&gt;
    &lt;item
        android:left=&quot;2dp&quot;
        android:top=&quot;4dp&quot;&gt;
        &lt;shape&gt;
            &lt;solid android:color=&quot;@android:color/holo_blue_dark&quot; /&gt;
            &lt;corners android:radius=&quot;10dp&quot; /&gt;
        &lt;/shape&gt;
    &lt;/item&gt;
    &lt;!-- 前景：：底偏移4dp，右偏移2dp --&gt;
    &lt;item
        android:bottom=&quot;4dp&quot;
        android:right=&quot;2dp&quot;&gt;
        &lt;shape&gt;
            &lt;solid android:color=&quot;@android:color/holo_blue_bright&quot; /&gt;
            &lt;corners android:radius=&quot;10dp&quot; /&gt;
        &lt;/shape&gt;
    &lt;/item&gt;
&lt;/layer-list&gt;
</code></pre>
<ul>
<li>点击状态：</li>
</ul>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;layer-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;
    &lt;!-- 为了达到点击的真实感，将原来默认状态的前景色设置为阴影，并将前景设为无透明--&gt;
    &lt;item
        android:left=&quot;2dp&quot;
        android:top=&quot;4dp&quot;&gt;
        &lt;shape&gt;
            &lt;solid android:color=&quot;@android:color/holo_blue_bright&quot; /&gt;
            &lt;corners android:radius=&quot;10dp&quot; /&gt;
        &lt;/shape&gt;
    &lt;/item&gt;
    &lt;item
        android:bottom=&quot;4dp&quot;
        android:right=&quot;2dp&quot;&gt;
        &lt;shape&gt;
            &lt;corners android:radius=&quot;10dp&quot; /&gt;
        &lt;/shape&gt;
    &lt;/item&gt;
&lt;/layer-list&gt;
</code></pre>
<blockquote>
<p>layer-list的item可以通过以下属性设置偏移量：</p>
<ul>
<li>android:top 顶部的偏移量</li>
<li>android:bottom 底部的偏移量</li>
<li>android:left 左边的偏移量</li>
<li>android:right 右边的偏移量</li>
</ul>
</blockquote>
<ul>
<li>selector，使用上述layer-list：</li>
</ul>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;
    &lt;item android:drawable=&quot;@drawable/layer_list_btn_pressed&quot; android:state_pressed=&quot;true&quot; /&gt;
    &lt;item android:drawable=&quot;@drawable/layer_list_btn_pressed&quot; android:state_selected=&quot;true&quot; /&gt;
    &lt;item android:drawable=&quot;@drawable/layer_list_btn&quot; /&gt;

&lt;/selector&gt;
</code></pre>
<ul>
<li>最后再来看下，布局代码：</li>
</ul>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:orientation=&quot;vertical&quot;
    android:paddingBottom=&quot;@dimen/activity_vertical_margin&quot;
    android:paddingLeft=&quot;@dimen/activity_horizontal_margin&quot;
    android:paddingRight=&quot;@dimen/activity_horizontal_margin&quot;
    android:paddingTop=&quot;@dimen/activity_vertical_margin&quot;
    tools:context=&quot;.MainActivity&quot;&gt;

    &lt;TextView
        android:layout_width=&quot;100dp&quot;
        android:layout_height=&quot;50dp&quot;
        android:background=&quot;@drawable/layer_list_btn&quot;
        android:clickable=&quot;true&quot;
        android:gravity=&quot;center&quot;
        android:text=&quot;默认状态&quot; /&gt;

    &lt;TextView
        android:layout_width=&quot;100dp&quot;
        android:layout_height=&quot;50dp&quot;
        android:layout_marginTop=&quot;@dimen/activity_vertical_margin&quot;
        android:background=&quot;@drawable/layer_list_btn_pressed&quot;
        android:clickable=&quot;true&quot;
        android:gravity=&quot;center&quot;
        android:text=&quot;点击状态&quot; /&gt;

    &lt;TextView
        android:layout_width=&quot;100dp&quot;
        android:layout_height=&quot;50dp&quot;
        android:layout_marginTop=&quot;@dimen/activity_vertical_margin&quot;
        android:background=&quot;@drawable/selector_btn&quot;
        android:clickable=&quot;true&quot;
        android:gravity=&quot;center&quot;
        android:text=&quot;点我&quot; /&gt;
&lt;/LinearLayout&gt;
</code></pre>
<ul>
<li><p>第一个和第二个TextView分别引用了对应的layer-list（默认和点击）作为背景，第三个引用了selector</p>
</li>
<li><p><em><strong><a target="_blank" rel="noopener" href="https://github.com/xpleemoon/layer-list-shadow-demo">源码地址</a></strong></em></p>
</li>
</ul>
<h2 id="零部署的云服务-王胜"><a href="#零部署的云服务-王胜" class="headerlink" title="零部署的云服务 - 王胜"></a>零部署的云服务 - 王胜</h2><blockquote>
<p>本周的分享主题是动画，但之前7月份我已经分享过一次，<a target="_blank" rel="noopener" href="http://51offer.github.io/2015/07/07/%E7%A7%BB%E5%8A%A8%E7%BB%84%E5%91%A8%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB-%E7%9F%A5%E5%85%B6%E6%89%80%E4%BB%A5%E7%84%B6/">知其所以然</a> 。再加上前面几位已经对android的动画介绍的很完整了，所以我就分享另一个话题『云平台下的零部署开发网站』。</p>
</blockquote>
<h3 id="牵扯的技能"><a href="#牵扯的技能" class="headerlink" title="牵扯的技能"></a>牵扯的技能</h3><ul>
<li>Git</li>
<li>任何一门后端开发语言</li>
</ul>
<h3 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h3><p><a target="_blank" rel="noopener" href="https://tryappservice.azure.com/zh-cn">AZURE</a> -&gt; 点击 <a target="_blank" rel="noopener" href="https://azure.microsoft.com/zh-cn/services/app-service/web/">Web应用模块</a> -&gt; 选择语言，点击<strong>创建Web应用</strong> -&gt; 选择模板，点击<strong>创建</strong>，至此，应用以创建，点击页面上站点url，就能看到新创建的Web站点了。</p>
<h3 id="修改代码，Git提交自动完成部署"><a href="#修改代码，Git提交自动完成部署" class="headerlink" title="修改代码，Git提交自动完成部署"></a>修改代码，Git提交自动完成部署</h3><p>复制创建成功页面『使用 Git 克隆或推送』里的Git地址，将初始化源码clone到本地，然后编辑代码，修改功能。完成后，直接push到远程，云平台自动完成部署。再看看网页是不是已经发生变化了。</p>
<pre><code class="Shell">Victors-MPB:azure wangsheng$ git clone https://$4f743e5d-0ee0-4-231-b9ee:WSc8Szx4Rf30apo3Ky7hpw6mXAadAZYvn1zagCvMaboj7mHFyJ2vzuYn9i12@4f743e5d-0ee0-4-231-b9ee.scm.azurewebsites.net/4f743e5d-0ee0-4-231-b9ee.git
Cloning into &#39;4f743e5d-0ee0-4-231-b9ee&#39;...
remote: Counting objects: 4, done.
remote: Compressing objects: 100% (3/3), done.
remote: Total 4 (delta 0), reused 0 (delta 0)
Unpacking objects: 100% (4/4), done.
Checking connectivity... done.
Victors-MPB:azure wangsheng$ ls
4f743e5d-0ee0-4-231-b9ee
Victors-MPB:azure wangsheng$ cd 4f743e5d-0ee0-4-231-b9ee/
Victors-MPB:4f743e5d-0ee0-4-231-b9ee wangsheng$ git br
* master
Victors-MPB:4f743e5d-0ee0-4-231-b9ee wangsheng$ git log
commit cf6edda65210ef7254f9bc545c778489f123620e
Author: windowsazure &lt;windowsazure&gt;
Date:   Fri Nov 20 03:53:00 2015 +0000

    Initial Commit
Victors-MPB:4f743e5d-0ee0-4-231-b9ee wangsheng$ ls
favicon.ico    index.php
Victors-MPB:4f743e5d-0ee0-4-231-b9ee wangsheng$ vi index.php
Victors-MPB:4f743e5d-0ee0-4-231-b9ee wangsheng$ git st
On branch master
Your branch is up-to-date with &#39;origin/master&#39;.
Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

    modified:   index.php

no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
Victors-MPB:4f743e5d-0ee0-4-231-b9ee wangsheng$ git diff
diff --git a/index.php b/index.php
&lt;?php
index 712f825..50a17e7 100644
--- a/index.php
+++ b/index.php
@@ -1,3 +1,4 @@
 &lt;?php
     echo &quot;Hello World&quot;
-?&gt;
\ No newline at end of file
+    echo &quot;hack it.&quot;
+?&gt;
Victors-MPB:4f743e5d-0ee0-4-231-b9ee wangsheng$ git ci -am &quot;add one line.&quot;
[master 6c5551f] add one line.
 1 file changed, 2 insertions(+), 1 deletion(-)
Victors-MPB:4f743e5d-0ee0-4-231-b9ee wangsheng$ git push origin master
Counting objects: 3, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 324 bytes | 0 bytes/s, done.
Total 3 (delta 0), reused 0 (delta 0)
remote: Updating branch &#39;master&#39;.
remote: Updating submodules.
remote: Preparing deployment for commit id &#39;6c5551f090&#39;.
remote: Generating deployment script.
remote: Generating deployment script for Web Site
remote: Generated deployment script files
remote: Running deployment command...
remote: Handling Basic Web Site deployment.
remote: Finished successfully.
remote: Deployment successful.
</code></pre>
<p>对，后端开发可以如此简单快乐地开发部署！！！</p>

    </section>
    <footer class="post-footer">
      <section class="author">
    <h4>Wilson</h4>
    <p>A designer, developer and entrepreneur. Spends his time travelling the world with a bag of kites. Likes journalism and publishing platforms.</p>
</section>
      <section class="share">
    <h4>Share this post</h4>
    <a class="icon-twitter" target="_blank" rel="noopener" href="http://twitter.com/share?url=https://mysiga.cn/2015/11/18/Android动画/"
       onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
        <span class="hidden">Twitter</span>
    </a>
    <a class="icon-facebook" target="_blank" rel="noopener" href="https://www.facebook.com/sharer/sharer.php?u=https://mysiga.cn/2015/11/18/Android动画/"
       onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
        <span class="hidden">Facebook</span>
    </a>
    <a class="icon-google-plus" target="_blank" rel="noopener" href="https://plus.google.com/share?url=https://mysiga.cn/2015/11/18/Android动画/"
       onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
        <span class="hidden">Google+</span>
    </a>
</section>
    </footer>
  </article>
  <nav class="pagination" role="pagination">
    
    <a class="newer-posts" href="/2015/12/02/%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%EF%BC%881%EF%BC%89/">
        ← 前端入门（1）
    </a>
    
    <span class="page-number">•</span>
    
    <a class="older-posts" href="/2015/11/13/Swift%E5%85%A5%E9%97%A8%E4%B8%93%E9%A2%98/">
        Swift入门专题 →
    </a>
    
</nav>
  <div id="comment" class="comments-area">
    <h1 class="title"><a href="#disqus_comments" name="disqus_comments">Comments</a></h1>

    
</div>
</main>


  
<footer class="site-footer">
  
  <div class="inner">
     <section class="copyright">All content copyright <a href="/">Wilson</a> &copy; 2014 &bull; All rights reserved.</section>
     <section class="poweredby">Proudly published with <a class="icon-ghost" target="_blank" rel="noopener" href="http://zespia.tw/hexo/">Hexo</a></section>
  </div>
</footer>

  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>

<script type="text/javascript" src="/js/jquery.fitvids.js"></script>
<script type="text/javascript" src="/js/index.js"></script>






</body>
</html>

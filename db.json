{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"themes/casper/source/css/normalize.css","path":"css/normalize.css","modified":1,"renderable":1},{"_id":"themes/casper/source/css/screen.css","path":"css/screen.css","modified":1,"renderable":1},{"_id":"themes/casper/source/fonts/icons.dev.svg","path":"fonts/icons.dev.svg","modified":1,"renderable":1},{"_id":"themes/casper/source/fonts/icons.eot","path":"fonts/icons.eot","modified":1,"renderable":1},{"_id":"themes/casper/source/fonts/icons.svg","path":"fonts/icons.svg","modified":1,"renderable":1},{"_id":"themes/casper/source/fonts/icons.ttf","path":"fonts/icons.ttf","modified":1,"renderable":1},{"_id":"themes/casper/source/fonts/icons.woff","path":"fonts/icons.woff","modified":1,"renderable":1},{"_id":"themes/casper/source/js/index.js","path":"js/index.js","modified":1,"renderable":1},{"_id":"themes/casper/source/js/jquery.fitvids.js","path":"js/jquery.fitvids.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"549aa7e1b52381a804a2be1433ab7c9b5cc16041","modified":1631330956414},{"_id":"source/CNAME","hash":"428c5f19b2964bc853e8c2bc38c96afab716a87f","modified":1631339047907},{"_id":"themes/casper/.gitignore","hash":"854da42f35444ed19a8164cb7c213f66ae0e178c","modified":1631332745586},{"_id":"themes/casper/LICENSE","hash":"7bc66e9632b475079619f585722930b551c3c081","modified":1631332745587},{"_id":"themes/casper/README.md","hash":"8a50fc48959d4fbe71643174cf4792a5db45bb0c","modified":1631332745587},{"_id":"themes/casper/_config.yml","hash":"3d57e6e64ab38f5ac87d0b0e29d2e656b0e2ed29","modified":1631340746321},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1631333087508},{"_id":"source/_posts/Andoid最近搜索记录.md","hash":"506543f43ed656764d494464868a69caee3412da","modified":1631257461934},{"_id":"source/_posts/Activity的启动四种模式.md","hash":"0407c015780aaae75ee45aa2ff88ac7a4bfcb64b","modified":1631257461933},{"_id":"source/_posts/Android Studio分享.md","hash":"53bd905bba769b3ae1958bf77ad3e33c6e864e0f","modified":1631257461934},{"_id":"source/_posts/Android Studio常用快捷(mac).md","hash":"9259850357cab2011bc5dc90edeb30d5c71cb4ba","modified":1631339806864},{"_id":"source/_posts/Android emoji表情分享.md","hash":"7af683e74ed0fa2424dc8037f21ce178dc74eb64","modified":1631257461935},{"_id":"source/_posts/Android与iOS开发相关区别.md","hash":"ced0612d1e0ca5e248f209f566a8070df6c5af02","modified":1631339632657},{"_id":"source/_posts/Android使用枚举正确姿态.md","hash":"91adea916c5344fc59415774e1508cc0a478e83e","modified":1631257461935},{"_id":"source/_posts/Android动画.md","hash":"3a5f2f611201c5db650f5ec290b680eefc167c42","modified":1631257461935},{"_id":"source/_posts/Android单元测试框架.md","hash":"5589b2af69c7cf35cc68e470c0a15b451998b441","modified":1631257461936},{"_id":"source/_posts/Android各个版本新特性.md","hash":"2e91911953bef5c90ef631cde83e818182c04e52","modified":1631257461936},{"_id":"source/_posts/Android多国语言适配.md","hash":"33782b51b33148f94712fa4b4e0eb6edd8191d34","modified":1631257461936},{"_id":"source/_posts/Android面试.md","hash":"e1cf57583fd46bb00e8032f54a55d83bf489facf","modified":1631257461940},{"_id":"source/_posts/App共享文件权限.md","hash":"28b307d1b56aa25987d43ba5bdeef0b4293d1c05","modified":1631257461941},{"_id":"source/_posts/Android微信抢红包.md","hash":"e035e9d82da0fb96ff9c927170f8c51c8f09138e","modified":1631257461936},{"_id":"source/_posts/Axure工具分享.md","hash":"84c8731398a54a0621e36a64a18faca125e9c692","modified":1631257461941},{"_id":"source/_posts/Excption与Error包结构.md","hash":"e56648cd4b5ef6457c92ecfa75cc0f3e0c4ab39d","modified":1631257461941},{"_id":"source/_posts/Java7_Switch_String.md","hash":"96cd6018c1a127190cfbf1e5fad445f0f11c6e25","modified":1631257461941},{"_id":"source/_posts/Java7之强引用_弱引用_软引用_虚引用.md","hash":"3b44c5c27c5cf9c383b8904e9297b9749b8e9ad5","modified":1631257461942},{"_id":"source/_posts/Java垃圾回收机制.md","hash":"4bffd96a70797ea4351dad624d1492d60a728f90","modified":1631257461942},{"_id":"source/_posts/Java单例模式.md","hash":"93f65dd23f0846c5209864e8e47210f531fb20ae","modified":1631257461942},{"_id":"source/_posts/Java异常.md","hash":"e302113455e046b1156e818667491958e2ced552","modified":1631257461943},{"_id":"source/_posts/Java类初始化顺序.md","hash":"a074813627ccdd070a850d15a079c033d08f5c6a","modified":1631257461943},{"_id":"source/_posts/Java线程.md","hash":"4ac7a57c987c87b824cceb7055b1ec6532bab950","modified":1631257461943},{"_id":"source/_posts/Jenkins配置Android深坑.md","hash":"db90f71302842fb33a7accdad42c865703d7aedc","modified":1631257461943},{"_id":"source/_posts/Moto 360 Sport初体验.md","hash":"31ee36444be5c0e93659229651ae9cc0f06bcea8","modified":1631257461944},{"_id":"source/_posts/Swift入门专题.md","hash":"360ebbd563ebc4b86536fd35f45778d0c87e0207","modified":1631257461944},{"_id":"source/_posts/Why-Git-Learn-It.md","hash":"50108094986cd2309f0c3d4116a47c3eef4cdca7","modified":1631257461944},{"_id":"source/_posts/代码效率.md","hash":"7a59115a529ac8e5af49e6f97ddbdff51bb5ff25","modified":1631257461945},{"_id":"source/_posts/tablayout方法setupWithViewPager()坑.md","hash":"b7fa223dce7a27fd7692629271b149b7a7181746","modified":1631257461944},{"_id":"source/_posts/优秀APP推荐.md","hash":"e78860c2b2588e0ee17469f420a0412af38dd3a1","modified":1631257461945},{"_id":"source/_posts/前端入门（2）.md","hash":"6e3ae55d06a9c65e4e15c017c57f966456218f78","modified":1631257461946},{"_id":"source/_posts/前端入门（1）.md","hash":"b91f6747e49930bbe773a5eae2854cceaa2fbaf2","modified":1631257461945},{"_id":"source/_posts/单位和度量.md","hash":"57012e74851e0ff7a17e4e4e5fbba7b3b7a2df7b","modified":1631257461946},{"_id":"source/_posts/单元测试.md","hash":"1ffd1ddeee418de0bc4b16ae6a846dee24bb6788","modified":1631257461946},{"_id":"source/_posts/博客分享.md","hash":"6f1fb4963679e8feaf39dd6fbf3ab85063d63071","modified":1631257461946},{"_id":"source/_posts/开源.md","hash":"41da4bfa6e4b89e80d192acada4f90e0c2bbc629","modified":1631257461947},{"_id":"source/_posts/爱的五种能力.md","hash":"0f9fa8c27fb3f0b4d258204c2fb030baf1479207","modified":1631257461947},{"_id":"source/_posts/微信公众号开发.md","hash":"001a752425be740e26c4f4b831c86471e46b04d6","modified":1631257461947},{"_id":"source/_posts/知其所以然.md","hash":"7b2d07452337b767fb84413fd7e70c04a249a622","modified":1631257461947},{"_id":"source/_posts/研发路上的那些事儿.md","hash":"d7fe75191a4363b55b2f939d885935e49aa32ad9","modified":1631257461948},{"_id":"source/_posts/程序员装逼指南.md","hash":"1d74de0bad65f3daa971df6c73d56d135d9451dc","modified":1631257461948},{"_id":"source/_posts/线程并发和同步.md","hash":"5f8828ffe1ea28968315975b74bc788abdc5d0ed","modified":1631257461949},{"_id":"source/_posts/网络信息安全.md","hash":"fdd86f68e381bc010830d072c5aef87a2b1b85f8","modified":1631257461949},{"_id":"source/_posts/简单谈谈计算机网络.md","hash":"3e03b6ed415e44f816d63b821189ef1ed9027040","modified":1631257461948},{"_id":"source/_posts/聊聊提高代码质量.md","hash":"aac58c7a2c49b21fba047265f92efe002feb8a9f","modified":1631257461950},{"_id":"source/_posts/英语.md","hash":"3ca5d5932a5ab4748eaf45911c085cf82dc24c07","modified":1631257461950},{"_id":"source/_posts/装逼指南二期.md","hash":"38b9bb48fc75f29bcb7bcdfce5bb88c15260c04c","modified":1631257461950},{"_id":"source/_posts/那些年我们用过的第三方库.md","hash":"9e6f98fe8b922858c24a1d8ae73775fe5290cf37","modified":1631257461951},{"_id":"source/_posts/谈谈未来，职业规划，梦想.md","hash":"f8afe7ddd5e19cdcfba906fb767cee4f0af39fa8","modified":1631257461950},{"_id":"source/about/index.md","hash":"fc36156cfaea13838c6023eec5b9e1fd7813afd8","modified":1631339047907},{"_id":"source/tags/index.md","hash":"4fe2b80878b3025c4a9327241bf96b8cb1d29abf","modified":1631339047907},{"_id":"themes/casper/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1631332745583},{"_id":"themes/casper/.git/config","hash":"ee0192a29e31bd3f6a48e077e8fba5e54600f497","modified":1631332745585},{"_id":"themes/casper/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1631332742636},{"_id":"themes/casper/.git/index","hash":"b9290967ca7acb798817b56bb09f3ef860c02bba","modified":1631332745594},{"_id":"themes/casper/.git/packed-refs","hash":"d16b3f74d39c5fb4248e1afb1642ee4e6be6152f","modified":1631332745580},{"_id":"themes/casper/layout/archive.ejs","hash":"eaf7e49f416afce6685e36a24a65a01bb3fe9ae7","modified":1631332745587},{"_id":"themes/casper/layout/category.ejs","hash":"eaf7e49f416afce6685e36a24a65a01bb3fe9ae7","modified":1631332745589},{"_id":"themes/casper/layout/index.ejs","hash":"eaf7e49f416afce6685e36a24a65a01bb3fe9ae7","modified":1631332745589},{"_id":"themes/casper/layout/layout.ejs","hash":"e3c9598002a8c8bd991aa7f0373ff984b643044a","modified":1631332745590},{"_id":"themes/casper/layout/page.ejs","hash":"13a176d843e7d44921e2705203011f0fcb46fcda","modified":1631332745590},{"_id":"themes/casper/layout/post.ejs","hash":"13a176d843e7d44921e2705203011f0fcb46fcda","modified":1631332745590},{"_id":"themes/casper/layout/tag.ejs","hash":"eaf7e49f416afce6685e36a24a65a01bb3fe9ae7","modified":1631332745590},{"_id":"themes/casper/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1631332742637},{"_id":"themes/casper/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1631332742637},{"_id":"themes/casper/.git/hooks/fsmonitor-watchman.sample","hash":"118ff5509f187039734d04456bf01e44c933ac19","modified":1631332742637},{"_id":"themes/casper/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1631332742639},{"_id":"themes/casper/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1631332742638},{"_id":"themes/casper/.git/hooks/pre-commit.sample","hash":"a79d057388ee2c2fe6561d7697f1f5efcff96f23","modified":1631332742637},{"_id":"themes/casper/.git/hooks/pre-merge-commit.sample","hash":"04c64e58bc25c149482ed45dbd79e40effb89eb7","modified":1631332742638},{"_id":"themes/casper/.git/hooks/pre-push.sample","hash":"a599b773b930ca83dbc3a5c7c13059ac4a6eaedc","modified":1631332742639},{"_id":"themes/casper/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1631332742637},{"_id":"themes/casper/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1631332742638},{"_id":"themes/casper/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1631332742638},{"_id":"themes/casper/.git/hooks/push-to-checkout.sample","hash":"508240328c8b55f8157c93c43bf5e291e5d2fbcb","modified":1631332742639},{"_id":"themes/casper/.git/hooks/update.sample","hash":"730e6bd5225478bab6147b7a62a6e2ae21d40507","modified":1631332742639},{"_id":"themes/casper/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1631332742636},{"_id":"themes/casper/.git/logs/HEAD","hash":"c24e6ed756d0e4b6f1e8c41e38681b77a7787c93","modified":1631332745584},{"_id":"themes/casper/layout/casper/after_all.ejs","hash":"e7cd492d5efe3186e22525d41176c5d5d6321e8c","modified":1631332745587},{"_id":"themes/casper/layout/casper/head.ejs","hash":"88f7bcc882f2e5fae701af8940eaa7d476db0bb5","modified":1631332745588},{"_id":"themes/casper/layout/casper/footer.ejs","hash":"1ebcfcb2305d34f1aba4501c0e2c7cd08049f8db","modified":1631332745588},{"_id":"themes/casper/layout/casper/header.ejs","hash":"f103e0d38c6412d1c5c47100ea7fbebcc2f990c5","modified":1631332745588},{"_id":"themes/casper/layout/casper/index.ejs","hash":"4dbc6044a87a0ccbad204e3c5719763d0bc4f440","modified":1631332745588},{"_id":"themes/casper/layout/casper/post.ejs","hash":"30c608f686a6ac462faa2964608c857b39e39fbf","modified":1631332745588},{"_id":"themes/casper/source/css/normalize.css","hash":"163c60d3a6c1f786754ba07426afbee0dfe82329","modified":1631332745591},{"_id":"themes/casper/source/css/screen.css","hash":"993c3ae25fbc216054f525c32df2eed3d57bd1a5","modified":1631332745591},{"_id":"themes/casper/source/fonts/icons.dev.svg","hash":"193cbbeadd27a72dadb809aa7344df5b9d965d8d","modified":1631332745592},{"_id":"themes/casper/source/fonts/icons.eot","hash":"d1abd4ac9fc6794570a73a5facaaf91492eed03c","modified":1631332745592},{"_id":"themes/casper/source/fonts/icons.svg","hash":"e8deb79bc630c3aa21ccdca71f6f6a43ca8035c1","modified":1631332745592},{"_id":"themes/casper/source/fonts/icons.ttf","hash":"e5247503ef56fd03361442ed082c8f9321e860b8","modified":1631332745593},{"_id":"themes/casper/source/fonts/icons.woff","hash":"31dc8eba4c3c2c799996658b01a5926267ae6af6","modified":1631332745593},{"_id":"themes/casper/source/js/index.js","hash":"a04c311b0818023c97446c79a8facdef067a04d1","modified":1631332745593},{"_id":"themes/casper/source/js/jquery.fitvids.js","hash":"0d9ee59f102516b1a988490f27ed37440713cc8b","modified":1631332745593},{"_id":"themes/casper/.git/objects/pack/pack-1261661652324bdbabdd863cbb10b4a48a3d5e8d.idx","hash":"ee750405d97dde69e30a3e9efc25059e68e6d071","modified":1631332745568},{"_id":"themes/casper/.git/refs/heads/master","hash":"2afa54037e0c271a532c1cab7ca85fb0bf5faabf","modified":1631332745583},{"_id":"themes/casper/layout/casper/post/author.ejs","hash":"d7eb9e85d3bd514cdc03100c4b91f088ad92b539","modified":1631332745588},{"_id":"themes/casper/layout/casper/post/comments.ejs","hash":"66024ffeb7dcd21b6679c29ab4e78fb876d1d807","modified":1631332745589},{"_id":"themes/casper/layout/casper/post/meta.ejs","hash":"c984cdc774bc884b33c8d87e3b59728cfdee773c","modified":1631332745589},{"_id":"themes/casper/layout/casper/post/navigation.ejs","hash":"2ed662189bbc0d305147fdc12b9f120e57722ac5","modified":1631332745589},{"_id":"themes/casper/layout/casper/post/share.ejs","hash":"1090719e3c49d4adadd7981eeff876b1c014d3e2","modified":1631332745589},{"_id":"themes/casper/.git/logs/refs/heads/master","hash":"c24e6ed756d0e4b6f1e8c41e38681b77a7787c93","modified":1631332745584},{"_id":"themes/casper/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1631332745582},{"_id":"themes/casper/.git/logs/refs/remotes/origin/HEAD","hash":"c24e6ed756d0e4b6f1e8c41e38681b77a7787c93","modified":1631332745582},{"_id":"themes/casper/.git/objects/pack/pack-1261661652324bdbabdd863cbb10b4a48a3d5e8d.pack","hash":"3164332bd081b552bf05aa736afb1099b83f2a65","modified":1631332745567}],"Category":[{"name":"Android","_id":"cktfeap350004c2xxipki8rmg"},{"name":"移动组周分享","_id":"cktfeap3i000hc2xxnrjrafmu"},{"name":"单元测试","_id":"cktfeap3m000nc2xx5yvorc8p"},{"name":"Java","_id":"cktfeap3s000zc2xx20ec1094"},{"name":"其他","_id":"cktfeap42001mc2xxra2ucy3y"},{"name":"其他，读书","_id":"cktfeap4e002jc2xxbf8605cy"}],"Data":[],"Page":[{"title":"关于我","date":"2017-05-24T19:22:01.000Z","_content":"\n## 简介\n\n## Android开发工程师\n","source":"about/index.md","raw":"---\ntitle: 关于我\ndate: 2017-05-24 19:22:01\n---\n\n## 简介\n\n## Android开发工程师\n","updated":"2021-09-11T05:44:07.907Z","path":"about/index.html","comments":1,"layout":"page","_id":"cktfeap320001c2xxup1fy2gq","content":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><h2 id=\"Android开发工程师\"><a href=\"#Android开发工程师\" class=\"headerlink\" title=\"Android开发工程师\"></a>Android开发工程师</h2>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><h2 id=\"Android开发工程师\"><a href=\"#Android开发工程师\" class=\"headerlink\" title=\"Android开发工程师\"></a>Android开发工程师</h2>"},{"title":"tags","date":"2017-05-24T19:20:43.000Z","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2017-05-24 19:20:43\n---\n","updated":"2021-09-11T05:44:07.907Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cktfeap350003c2xxmvgzj5fe","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Andoid最近搜索记录","date":"2016-02-26T15:42:29.000Z","_content":"\n\n#### Andoid最近搜索记录\n- 原生搜\n\t-  ![Alt Image Text](http://upload-images.jianshu.io/upload_images/1534431-ff9822bdf5ef0a4c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\t- [Android搜索记录(需翻墙)](http://developer.android.com/intl/zh-cn/guide/topics/search/search-dialog.html) \n\t-  问题:没有清除历史记录界面\n- APP最近搜索记录\n\t-  ![Alt Image Text](http://upload-images.jianshu.io/upload_images/1534431-00100d6b2829dadf.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n- 实现\n\t- SearchView+ListPopupWindow+SQLite\n\t-   ![Alt Image Text](http://upload-images.jianshu.io/upload_images/1534431-51bf7c68dee5de24.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\t- [托管代码](https://github.com/milin411/TestProject.git)","source":"_posts/Andoid最近搜索记录.md","raw":"title: Andoid最近搜索记录\ndate: 2016-02-26 15:42:29\ntags:\ncategories: Android\n---\n\n\n#### Andoid最近搜索记录\n- 原生搜\n\t-  ![Alt Image Text](http://upload-images.jianshu.io/upload_images/1534431-ff9822bdf5ef0a4c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\t- [Android搜索记录(需翻墙)](http://developer.android.com/intl/zh-cn/guide/topics/search/search-dialog.html) \n\t-  问题:没有清除历史记录界面\n- APP最近搜索记录\n\t-  ![Alt Image Text](http://upload-images.jianshu.io/upload_images/1534431-00100d6b2829dadf.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n- 实现\n\t- SearchView+ListPopupWindow+SQLite\n\t-   ![Alt Image Text](http://upload-images.jianshu.io/upload_images/1534431-51bf7c68dee5de24.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\t- [托管代码](https://github.com/milin411/TestProject.git)","slug":"Andoid最近搜索记录","published":1,"updated":"2021-09-10T07:04:21.934Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cktfeap2y0000c2xx5paq3lzc","content":"<h4 id=\"Andoid最近搜索记录\"><a href=\"#Andoid最近搜索记录\" class=\"headerlink\" title=\"Andoid最近搜索记录\"></a>Andoid最近搜索记录</h4><ul>\n<li>原生搜<ul>\n<li><img src=\"http://upload-images.jianshu.io/upload_images/1534431-ff9822bdf5ef0a4c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Alt Image Text\"></li>\n<li><a href=\"http://developer.android.com/intl/zh-cn/guide/topics/search/search-dialog.html\" target=\"_blank\" rel=\"noopener\">Android搜索记录(需翻墙)</a> </li>\n<li>问题:没有清除历史记录界面</li>\n</ul>\n</li>\n<li>APP最近搜索记录<ul>\n<li><img src=\"http://upload-images.jianshu.io/upload_images/1534431-00100d6b2829dadf.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Alt Image Text\"></li>\n</ul>\n</li>\n<li>实现<ul>\n<li>SearchView+ListPopupWindow+SQLite</li>\n<li><img src=\"http://upload-images.jianshu.io/upload_images/1534431-51bf7c68dee5de24.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Alt Image Text\"></li>\n<li><a href=\"https://github.com/milin411/TestProject.git\" target=\"_blank\" rel=\"noopener\">托管代码</a></li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"Andoid最近搜索记录\"><a href=\"#Andoid最近搜索记录\" class=\"headerlink\" title=\"Andoid最近搜索记录\"></a>Andoid最近搜索记录</h4><ul>\n<li>原生搜<ul>\n<li><img src=\"http://upload-images.jianshu.io/upload_images/1534431-ff9822bdf5ef0a4c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Alt Image Text\"></li>\n<li><a href=\"http://developer.android.com/intl/zh-cn/guide/topics/search/search-dialog.html\" target=\"_blank\" rel=\"noopener\">Android搜索记录(需翻墙)</a> </li>\n<li>问题:没有清除历史记录界面</li>\n</ul>\n</li>\n<li>APP最近搜索记录<ul>\n<li><img src=\"http://upload-images.jianshu.io/upload_images/1534431-00100d6b2829dadf.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Alt Image Text\"></li>\n</ul>\n</li>\n<li>实现<ul>\n<li>SearchView+ListPopupWindow+SQLite</li>\n<li><img src=\"http://upload-images.jianshu.io/upload_images/1534431-51bf7c68dee5de24.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Alt Image Text\"></li>\n<li><a href=\"https://github.com/milin411/TestProject.git\" target=\"_blank\" rel=\"noopener\">托管代码</a></li>\n</ul>\n</li>\n</ul>\n"},{"title":"Activity的启动四种模式","date":"2016-03-05T17:42:29.000Z","_content":"\n\n#### Activity的启动四种模式\n- standard(默认)\n\t- 每次使用startActivity方法启动Activity时\n   都会创建该Activity的新实例\n \t- Activity的多个实例可以位于同一个task中\n   也可以分布在不同的task里\n \t- 在当前task中使用startActivity方法启动Activity\n   也在当前task中创建和运行\n- singleTop：栈顶复用模式\n \t- 当设置为singleTop模式Activity，未处于栈顶时\n   其运行特点与标准模式下一致\n \t- 当其位于栈顶时，如果使用startActivity方法\n   再次启动该Activity，则不会创建该Activity的新实例\n   而是直接使用栈顶的实例响应启动操作.并且调用该实例\n   的onNewIntent方法，将本次启动的intent传入到实例中\n- singleTask：栈内复用模式\n \t- 设置singleTask的Activity，具有全局唯一性\n   即同一时刻在Android系统中只能存在该Activity\n   的一个实例\n \t- 当使用startActivity方法启动设置为singleTask的Activity时\n  如果该Activity的实例尚不存在，则创建该实例\n  否则，不会重复创建实例，而是将已经存在的实例重新带回到栈顶\n  如果在该实例上存在其他实例，则销毁这些实例后，将该实例重新\n  带回栈顶\n  - 在创建该Activity的实例时，\n  如果当前任务的taskAffinity值与该Activity的taskAffinity值相同，\n   则在当前任务中创建实例，\n  否则，在一个新的任务中创建实例\n  - 具有clearTop的效果，如果再次启动具有实例的singleTask的Acitivity会清除它上面的Activity出栈\n\n- singleInstance\n \t- 设置singleInstance的Activity，具有全局唯一性\n   即同一时刻在Android系统中只能存在该Activity\n   的一个实例\n \t- 当使用startActivity方法启动该Activity的实例时\n   如果该Activity的实例尚不存在，则直接在新的任务\n   中创建该实例。\n   如果该实例已经存在，则直接显示该实例\n \t- 该Activity的实例，不与其他activity的实例共存于一个\n   任务中,所以通过该实例启动的其他Activity的实例，只能\n   被创建在其他的task里，如果已经存在于新创建的activity实例\n   taskAffinity值相同的task，则直接在该task中创建实例，否则\n   就在一个新的任务中创建实例\n\n- Acitivity启动模式优先级\n \t- 第一种\n \t\n ````\n <activity\n            android:name=\".launchmode.SingleTopActivity\"\n            android:label=\"@string/title_activity_single_top\"\n            android:launchMode=\"singleTop\"\n            android:theme=\"@style/AppTheme\" />\n ````\n \t- 第二种\n \t\n \t````\n \tIntent intent=new Intent(this,SingleTopActivity.class);\n                intent.addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP);\n                startActivity(intent);\n \t````\n \t第二种优先第一种，如果同时存在则以第二种方式为准\n \t\n- Activity的Flags(标记位)\t\n \t- FLAG_ACTIVITY_SINGLE_TOP:Activity的SingleTop\t启动模式 \n \t- FLAG_ACTIVITY_NEW_TASK:Activity的SingleTask\t启动模式 \n \t- FLAG_ACTIVITY_CLEAR_TOP:同一个任务栈中所有位于它上面的Activity都要出栈，一般和FLAG_ACTIVITY_NEW_TASK一起使用，如果被启动的activity为standard模式则先连同启动的acivity一起出栈，在创建新的acticity实例放入栈顶\n \t- FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS:等同android:excludeFromRecents=\"true\"\n\n#### 任务栈属性:\n- 分类\n  - 前台任务栈：\n  - 后台任务栈：Acitivity位于暂停状态，用户可以通过切换将后台任务栈再次调到前台\n- 属性\n    - TaskAffinity:任务栈名字，Activity和application默认为应用包名\n    - allowTaskReparenting(与字面理解相同，本属性允许activity重新指定Task。默认值是false)\n\n\t````\n \t<application\n        android:allowBackup=\"true\"\n        android:icon=\"@mipmap/ic_launcher\"\n        android:label=\"@string/app_name\"\n        android:supportsRtl=\"true\"\n        android:taskAffinity=\"\"\n        android:allowTaskReparenting=\"\"\n        android:theme=\"@style/AppTheme\">\n        <activity android:name=\".MainActivity\">\n\t````\n\t````\n\t<activity \t\tandroid:name=\".defaultsearch.DefaultSearchSuggestionActivity\"\n            android:taskAffinity=\"\"\n            android:allowTaskReparenting=\"\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.SEARCH\" />\n            </intent-filter>\n\t````\n\n\n ####   Activity的IntentFilter\n- activity可以多个intentFilter\n- action:一个intentFilter可以多个action，多个action只要匹配一个action就算匹配action成功。\n- category：一个intentFilter可以多个category\n- data：一个intentFilter可以多个data\n\n````\n<data android:scheme=\"string\"\n          android:host=\"string\"\n          android:port=\"string\"\n          android:path=\"string\"\n          android:pathPattern=\"string\"\n          android:pathPrefix=\"string\"\n          android:mimeType=\"string\"/>\n````\n  - mimeType:指媒体类型，如:image/jpeg,audio/mpeg4-generic和video/*\n  - URI:<scheme>://<host>:<post>/[<path>/<pathPrefix>/<pathPattern>]\n\n \t  \n- [demo代码](https://github.com/milin411/TestProject)","source":"_posts/Activity的启动四种模式.md","raw":"title: Activity的启动四种模式\ndate: 2016-03-05 17:42:29\ntags:\ncategories: Android\n---\n\n\n#### Activity的启动四种模式\n- standard(默认)\n\t- 每次使用startActivity方法启动Activity时\n   都会创建该Activity的新实例\n \t- Activity的多个实例可以位于同一个task中\n   也可以分布在不同的task里\n \t- 在当前task中使用startActivity方法启动Activity\n   也在当前task中创建和运行\n- singleTop：栈顶复用模式\n \t- 当设置为singleTop模式Activity，未处于栈顶时\n   其运行特点与标准模式下一致\n \t- 当其位于栈顶时，如果使用startActivity方法\n   再次启动该Activity，则不会创建该Activity的新实例\n   而是直接使用栈顶的实例响应启动操作.并且调用该实例\n   的onNewIntent方法，将本次启动的intent传入到实例中\n- singleTask：栈内复用模式\n \t- 设置singleTask的Activity，具有全局唯一性\n   即同一时刻在Android系统中只能存在该Activity\n   的一个实例\n \t- 当使用startActivity方法启动设置为singleTask的Activity时\n  如果该Activity的实例尚不存在，则创建该实例\n  否则，不会重复创建实例，而是将已经存在的实例重新带回到栈顶\n  如果在该实例上存在其他实例，则销毁这些实例后，将该实例重新\n  带回栈顶\n  - 在创建该Activity的实例时，\n  如果当前任务的taskAffinity值与该Activity的taskAffinity值相同，\n   则在当前任务中创建实例，\n  否则，在一个新的任务中创建实例\n  - 具有clearTop的效果，如果再次启动具有实例的singleTask的Acitivity会清除它上面的Activity出栈\n\n- singleInstance\n \t- 设置singleInstance的Activity，具有全局唯一性\n   即同一时刻在Android系统中只能存在该Activity\n   的一个实例\n \t- 当使用startActivity方法启动该Activity的实例时\n   如果该Activity的实例尚不存在，则直接在新的任务\n   中创建该实例。\n   如果该实例已经存在，则直接显示该实例\n \t- 该Activity的实例，不与其他activity的实例共存于一个\n   任务中,所以通过该实例启动的其他Activity的实例，只能\n   被创建在其他的task里，如果已经存在于新创建的activity实例\n   taskAffinity值相同的task，则直接在该task中创建实例，否则\n   就在一个新的任务中创建实例\n\n- Acitivity启动模式优先级\n \t- 第一种\n \t\n ````\n <activity\n            android:name=\".launchmode.SingleTopActivity\"\n            android:label=\"@string/title_activity_single_top\"\n            android:launchMode=\"singleTop\"\n            android:theme=\"@style/AppTheme\" />\n ````\n \t- 第二种\n \t\n \t````\n \tIntent intent=new Intent(this,SingleTopActivity.class);\n                intent.addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP);\n                startActivity(intent);\n \t````\n \t第二种优先第一种，如果同时存在则以第二种方式为准\n \t\n- Activity的Flags(标记位)\t\n \t- FLAG_ACTIVITY_SINGLE_TOP:Activity的SingleTop\t启动模式 \n \t- FLAG_ACTIVITY_NEW_TASK:Activity的SingleTask\t启动模式 \n \t- FLAG_ACTIVITY_CLEAR_TOP:同一个任务栈中所有位于它上面的Activity都要出栈，一般和FLAG_ACTIVITY_NEW_TASK一起使用，如果被启动的activity为standard模式则先连同启动的acivity一起出栈，在创建新的acticity实例放入栈顶\n \t- FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS:等同android:excludeFromRecents=\"true\"\n\n#### 任务栈属性:\n- 分类\n  - 前台任务栈：\n  - 后台任务栈：Acitivity位于暂停状态，用户可以通过切换将后台任务栈再次调到前台\n- 属性\n    - TaskAffinity:任务栈名字，Activity和application默认为应用包名\n    - allowTaskReparenting(与字面理解相同，本属性允许activity重新指定Task。默认值是false)\n\n\t````\n \t<application\n        android:allowBackup=\"true\"\n        android:icon=\"@mipmap/ic_launcher\"\n        android:label=\"@string/app_name\"\n        android:supportsRtl=\"true\"\n        android:taskAffinity=\"\"\n        android:allowTaskReparenting=\"\"\n        android:theme=\"@style/AppTheme\">\n        <activity android:name=\".MainActivity\">\n\t````\n\t````\n\t<activity \t\tandroid:name=\".defaultsearch.DefaultSearchSuggestionActivity\"\n            android:taskAffinity=\"\"\n            android:allowTaskReparenting=\"\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.SEARCH\" />\n            </intent-filter>\n\t````\n\n\n ####   Activity的IntentFilter\n- activity可以多个intentFilter\n- action:一个intentFilter可以多个action，多个action只要匹配一个action就算匹配action成功。\n- category：一个intentFilter可以多个category\n- data：一个intentFilter可以多个data\n\n````\n<data android:scheme=\"string\"\n          android:host=\"string\"\n          android:port=\"string\"\n          android:path=\"string\"\n          android:pathPattern=\"string\"\n          android:pathPrefix=\"string\"\n          android:mimeType=\"string\"/>\n````\n  - mimeType:指媒体类型，如:image/jpeg,audio/mpeg4-generic和video/*\n  - URI:<scheme>://<host>:<post>/[<path>/<pathPrefix>/<pathPattern>]\n\n \t  \n- [demo代码](https://github.com/milin411/TestProject)","slug":"Activity的启动四种模式","published":1,"updated":"2021-09-10T07:04:21.933Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cktfeap330002c2xxm39fue5j","content":"<h4 id=\"Activity的启动四种模式\"><a href=\"#Activity的启动四种模式\" class=\"headerlink\" title=\"Activity的启动四种模式\"></a>Activity的启动四种模式</h4><ul>\n<li>standard(默认)<ul>\n<li>每次使用startActivity方法启动Activity时<br>都会创建该Activity的新实例<ul>\n<li>Activity的多个实例可以位于同一个task中<br>也可以分布在不同的task里</li>\n<li>在当前task中使用startActivity方法启动Activity<br>也在当前task中创建和运行</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>singleTop：栈顶复用模式<ul>\n<li>当设置为singleTop模式Activity，未处于栈顶时<br>其运行特点与标准模式下一致</li>\n<li>当其位于栈顶时，如果使用startActivity方法<br>再次启动该Activity，则不会创建该Activity的新实例<br>而是直接使用栈顶的实例响应启动操作.并且调用该实例<br>的onNewIntent方法，将本次启动的intent传入到实例中</li>\n</ul>\n</li>\n<li><p>singleTask：栈内复用模式</p>\n<ul>\n<li>设置singleTask的Activity，具有全局唯一性<br>即同一时刻在Android系统中只能存在该Activity<br>的一个实例</li>\n<li>当使用startActivity方法启动设置为singleTask的Activity时<br>如果该Activity的实例尚不存在，则创建该实例<br>否则，不会重复创建实例，而是将已经存在的实例重新带回到栈顶<br>如果在该实例上存在其他实例，则销毁这些实例后，将该实例重新<br>带回栈顶<ul>\n<li>在创建该Activity的实例时，<br>如果当前任务的taskAffinity值与该Activity的taskAffinity值相同，<br>则在当前任务中创建实例，<br>否则，在一个新的任务中创建实例</li>\n<li>具有clearTop的效果，如果再次启动具有实例的singleTask的Acitivity会清除它上面的Activity出栈</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>singleInstance</p>\n<ul>\n<li>设置singleInstance的Activity，具有全局唯一性<br>即同一时刻在Android系统中只能存在该Activity<br>的一个实例</li>\n<li>当使用startActivity方法启动该Activity的实例时<br>如果该Activity的实例尚不存在，则直接在新的任务<br>中创建该实例。<br>如果该实例已经存在，则直接显示该实例</li>\n<li>该Activity的实例，不与其他activity的实例共存于一个<br>任务中,所以通过该实例启动的其他Activity的实例，只能<br>被创建在其他的task里，如果已经存在于新创建的activity实例<br>taskAffinity值相同的task，则直接在该task中创建实例，否则<br>就在一个新的任务中创建实例</li>\n</ul>\n</li>\n<li><p>Acitivity启动模式优先级</p>\n<ul>\n<li>第一种</li>\n</ul>\n<pre><code>&lt;activity\n          android:name=&quot;.launchmode.SingleTopActivity&quot;\n          android:label=&quot;@string/title_activity_single_top&quot;\n          android:launchMode=&quot;singleTop&quot;\n          android:theme=&quot;@style/AppTheme&quot; /&gt;\n</code></pre><ul>\n<li><p>第二种</p>\n<pre><code>Intent intent=new Intent(this,SingleTopActivity.class);\n         intent.addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP);\n         startActivity(intent);\n</code></pre><p>第二种优先第一种，如果同时存在则以第二种方式为准</p>\n</li>\n</ul>\n</li>\n<li><p>Activity的Flags(标记位)    </p>\n<ul>\n<li>FLAG_ACTIVITY_SINGLE_TOP:Activity的SingleTop    启动模式 </li>\n<li>FLAG_ACTIVITY_NEW_TASK:Activity的SingleTask    启动模式 </li>\n<li>FLAG_ACTIVITY_CLEAR_TOP:同一个任务栈中所有位于它上面的Activity都要出栈，一般和FLAG_ACTIVITY_NEW_TASK一起使用，如果被启动的activity为standard模式则先连同启动的acivity一起出栈，在创建新的acticity实例放入栈顶</li>\n<li>FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS:等同android:excludeFromRecents=”true”</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"任务栈属性\"><a href=\"#任务栈属性\" class=\"headerlink\" title=\"任务栈属性:\"></a>任务栈属性:</h4><ul>\n<li>分类<ul>\n<li>前台任务栈：</li>\n<li>后台任务栈：Acitivity位于暂停状态，用户可以通过切换将后台任务栈再次调到前台</li>\n</ul>\n</li>\n<li><p>属性</p>\n<ul>\n<li>TaskAffinity:任务栈名字，Activity和application默认为应用包名</li>\n<li><p>allowTaskReparenting(与字面理解相同，本属性允许activity重新指定Task。默认值是false)</p>\n<pre><code>&lt;application\n  android:allowBackup=&quot;true&quot;\n  android:icon=&quot;@mipmap/ic_launcher&quot;\n  android:label=&quot;@string/app_name&quot;\n  android:supportsRtl=&quot;true&quot;\n  android:taskAffinity=&quot;&quot;\n  android:allowTaskReparenting=&quot;&quot;\n  android:theme=&quot;@style/AppTheme&quot;&gt;\n  &lt;activity android:name=&quot;.MainActivity&quot;&gt;\n</code></pre><pre><code>&lt;activity         android:name=&quot;.defaultsearch.DefaultSearchSuggestionActivity&quot;\n      android:taskAffinity=&quot;&quot;\n      android:allowTaskReparenting=&quot;&quot;&gt;\n      &lt;intent-filter&gt;\n          &lt;action android:name=&quot;android.intent.action.SEARCH&quot; /&gt;\n      &lt;/intent-filter&gt;\n</code></pre></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Activity的IntentFilter\"><a href=\"#Activity的IntentFilter\" class=\"headerlink\" title=\"Activity的IntentFilter\"></a>Activity的IntentFilter</h4><ul>\n<li>activity可以多个intentFilter</li>\n<li>action:一个intentFilter可以多个action，多个action只要匹配一个action就算匹配action成功。</li>\n<li>category：一个intentFilter可以多个category</li>\n<li>data：一个intentFilter可以多个data</li>\n</ul>\n<pre><code>&lt;data android:scheme=&quot;string&quot;\n          android:host=&quot;string&quot;\n          android:port=&quot;string&quot;\n          android:path=&quot;string&quot;\n          android:pathPattern=&quot;string&quot;\n          android:pathPrefix=&quot;string&quot;\n          android:mimeType=&quot;string&quot;/&gt;\n</code></pre><ul>\n<li>mimeType:指媒体类型，如:image/jpeg,audio/mpeg4-generic和video/*</li>\n<li>URI:<scheme>://<host>:<post>/[<path>/<pathprefix>/<pathpattern>]</pathpattern></pathprefix></path></post></host></scheme></li>\n</ul>\n<ul>\n<li><a href=\"https://github.com/milin411/TestProject\" target=\"_blank\" rel=\"noopener\">demo代码</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"Activity的启动四种模式\"><a href=\"#Activity的启动四种模式\" class=\"headerlink\" title=\"Activity的启动四种模式\"></a>Activity的启动四种模式</h4><ul>\n<li>standard(默认)<ul>\n<li>每次使用startActivity方法启动Activity时<br>都会创建该Activity的新实例<ul>\n<li>Activity的多个实例可以位于同一个task中<br>也可以分布在不同的task里</li>\n<li>在当前task中使用startActivity方法启动Activity<br>也在当前task中创建和运行</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>singleTop：栈顶复用模式<ul>\n<li>当设置为singleTop模式Activity，未处于栈顶时<br>其运行特点与标准模式下一致</li>\n<li>当其位于栈顶时，如果使用startActivity方法<br>再次启动该Activity，则不会创建该Activity的新实例<br>而是直接使用栈顶的实例响应启动操作.并且调用该实例<br>的onNewIntent方法，将本次启动的intent传入到实例中</li>\n</ul>\n</li>\n<li><p>singleTask：栈内复用模式</p>\n<ul>\n<li>设置singleTask的Activity，具有全局唯一性<br>即同一时刻在Android系统中只能存在该Activity<br>的一个实例</li>\n<li>当使用startActivity方法启动设置为singleTask的Activity时<br>如果该Activity的实例尚不存在，则创建该实例<br>否则，不会重复创建实例，而是将已经存在的实例重新带回到栈顶<br>如果在该实例上存在其他实例，则销毁这些实例后，将该实例重新<br>带回栈顶<ul>\n<li>在创建该Activity的实例时，<br>如果当前任务的taskAffinity值与该Activity的taskAffinity值相同，<br>则在当前任务中创建实例，<br>否则，在一个新的任务中创建实例</li>\n<li>具有clearTop的效果，如果再次启动具有实例的singleTask的Acitivity会清除它上面的Activity出栈</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>singleInstance</p>\n<ul>\n<li>设置singleInstance的Activity，具有全局唯一性<br>即同一时刻在Android系统中只能存在该Activity<br>的一个实例</li>\n<li>当使用startActivity方法启动该Activity的实例时<br>如果该Activity的实例尚不存在，则直接在新的任务<br>中创建该实例。<br>如果该实例已经存在，则直接显示该实例</li>\n<li>该Activity的实例，不与其他activity的实例共存于一个<br>任务中,所以通过该实例启动的其他Activity的实例，只能<br>被创建在其他的task里，如果已经存在于新创建的activity实例<br>taskAffinity值相同的task，则直接在该task中创建实例，否则<br>就在一个新的任务中创建实例</li>\n</ul>\n</li>\n<li><p>Acitivity启动模式优先级</p>\n<ul>\n<li>第一种</li>\n</ul>\n<pre><code>&lt;activity\n          android:name=&quot;.launchmode.SingleTopActivity&quot;\n          android:label=&quot;@string/title_activity_single_top&quot;\n          android:launchMode=&quot;singleTop&quot;\n          android:theme=&quot;@style/AppTheme&quot; /&gt;\n</code></pre><ul>\n<li><p>第二种</p>\n<pre><code>Intent intent=new Intent(this,SingleTopActivity.class);\n         intent.addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP);\n         startActivity(intent);\n</code></pre><p>第二种优先第一种，如果同时存在则以第二种方式为准</p>\n</li>\n</ul>\n</li>\n<li><p>Activity的Flags(标记位)    </p>\n<ul>\n<li>FLAG_ACTIVITY_SINGLE_TOP:Activity的SingleTop    启动模式 </li>\n<li>FLAG_ACTIVITY_NEW_TASK:Activity的SingleTask    启动模式 </li>\n<li>FLAG_ACTIVITY_CLEAR_TOP:同一个任务栈中所有位于它上面的Activity都要出栈，一般和FLAG_ACTIVITY_NEW_TASK一起使用，如果被启动的activity为standard模式则先连同启动的acivity一起出栈，在创建新的acticity实例放入栈顶</li>\n<li>FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS:等同android:excludeFromRecents=”true”</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"任务栈属性\"><a href=\"#任务栈属性\" class=\"headerlink\" title=\"任务栈属性:\"></a>任务栈属性:</h4><ul>\n<li>分类<ul>\n<li>前台任务栈：</li>\n<li>后台任务栈：Acitivity位于暂停状态，用户可以通过切换将后台任务栈再次调到前台</li>\n</ul>\n</li>\n<li><p>属性</p>\n<ul>\n<li>TaskAffinity:任务栈名字，Activity和application默认为应用包名</li>\n<li><p>allowTaskReparenting(与字面理解相同，本属性允许activity重新指定Task。默认值是false)</p>\n<pre><code>&lt;application\n  android:allowBackup=&quot;true&quot;\n  android:icon=&quot;@mipmap/ic_launcher&quot;\n  android:label=&quot;@string/app_name&quot;\n  android:supportsRtl=&quot;true&quot;\n  android:taskAffinity=&quot;&quot;\n  android:allowTaskReparenting=&quot;&quot;\n  android:theme=&quot;@style/AppTheme&quot;&gt;\n  &lt;activity android:name=&quot;.MainActivity&quot;&gt;\n</code></pre><pre><code>&lt;activity         android:name=&quot;.defaultsearch.DefaultSearchSuggestionActivity&quot;\n      android:taskAffinity=&quot;&quot;\n      android:allowTaskReparenting=&quot;&quot;&gt;\n      &lt;intent-filter&gt;\n          &lt;action android:name=&quot;android.intent.action.SEARCH&quot; /&gt;\n      &lt;/intent-filter&gt;\n</code></pre></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Activity的IntentFilter\"><a href=\"#Activity的IntentFilter\" class=\"headerlink\" title=\"Activity的IntentFilter\"></a>Activity的IntentFilter</h4><ul>\n<li>activity可以多个intentFilter</li>\n<li>action:一个intentFilter可以多个action，多个action只要匹配一个action就算匹配action成功。</li>\n<li>category：一个intentFilter可以多个category</li>\n<li>data：一个intentFilter可以多个data</li>\n</ul>\n<pre><code>&lt;data android:scheme=&quot;string&quot;\n          android:host=&quot;string&quot;\n          android:port=&quot;string&quot;\n          android:path=&quot;string&quot;\n          android:pathPattern=&quot;string&quot;\n          android:pathPrefix=&quot;string&quot;\n          android:mimeType=&quot;string&quot;/&gt;\n</code></pre><ul>\n<li>mimeType:指媒体类型，如:image/jpeg,audio/mpeg4-generic和video/*</li>\n<li>URI:<scheme>://<host>:<post>/[<path>/<pathprefix>/<pathpattern>]</pathpattern></pathprefix></path></post></host></scheme></li>\n</ul>\n<ul>\n<li><a href=\"https://github.com/milin411/TestProject\" target=\"_blank\" rel=\"noopener\">demo代码</a></li>\n</ul>\n"},{"title":"Android Studio分享","date":"2015-05-22T23:04:29.000Z","_content":"\n\n####  Android Studio分享\n- android studio是google的亲儿子，肯定以后是必然形势。\n- android studio总体运行速度比Eclipse快。\n- android studio和Eclipse对比：\n   - 比Eclipse漂亮\n         - android studio可以设置开发代码的背景，而Eclipse只能用那一直到死用的开发背景，有时候想换换背景换换心情都不行。Android Stuido自带的Darcula主题的炫酷黑界面都还可以。想换别的主题也可以自己下载导入的。\n\n    - 比Eclipse速度快\n        - android studio的启动速度，响应速度，内存占用等等全面领先与Eclipse。\n\n    - 提示，补全更加智能，更加人性化。\n        - 自动提示补全(有点开发ios的味道)，现在android studio可以把快捷键设置为Eclipse的快捷方式\n\n    - 整合了Gradle构建工具\n         - gradle是一个基于Apache Ant和Apache Maven概念的项目自动化建构工具。它使用一种基于Groovy的特定领域语言来声明项目设置，而不是传统的XML。gradle能够完成构建、测试、发布和其他诸如软件打包、生成注释文档等等功能\n\n    - 支持Google Cloud Platform\n         - Android Studio支持本地的Google Cloud Platform(谷歌的云平台)，就是说你可以运行服务器端的代码。\n\n    - 强大的UI编辑器\n         - Android Studio的编辑器非常的智能。比如新建一个控件，控件的width和height属性会自动的补全，不用每次都要手动的打上两行 android:layout_width和android:layout_height。还有定义颜色后会自动把颜色显示在旁边（这个对我超级好用）。等等还有其他很多小细节做的都非常不错，大大提高了编辑UI的效率。\n\n    - 更完善的插件系统\n        - Android Studio中可以像Apple store那样浏览所有的插件，直接搜索，下载和管理它.\n\n    - 完美的整合版本控制软件\n        - 安装的时候就自带了如GitHub, CVN等等流行的版本控制工具\n\n    - Android Studio是Google推出的\n       -  Android Stuido是Google推出，专门为ANDROID“量身订做”的，Google的亲儿子。作为Android Developer大腿一定要抱紧。\n\n","source":"_posts/Android Studio分享.md","raw":"title: Android Studio分享\ndate: 2015-05-22 23:04:29\ntags:\ncategories: Android\n---\n\n\n####  Android Studio分享\n- android studio是google的亲儿子，肯定以后是必然形势。\n- android studio总体运行速度比Eclipse快。\n- android studio和Eclipse对比：\n   - 比Eclipse漂亮\n         - android studio可以设置开发代码的背景，而Eclipse只能用那一直到死用的开发背景，有时候想换换背景换换心情都不行。Android Stuido自带的Darcula主题的炫酷黑界面都还可以。想换别的主题也可以自己下载导入的。\n\n    - 比Eclipse速度快\n        - android studio的启动速度，响应速度，内存占用等等全面领先与Eclipse。\n\n    - 提示，补全更加智能，更加人性化。\n        - 自动提示补全(有点开发ios的味道)，现在android studio可以把快捷键设置为Eclipse的快捷方式\n\n    - 整合了Gradle构建工具\n         - gradle是一个基于Apache Ant和Apache Maven概念的项目自动化建构工具。它使用一种基于Groovy的特定领域语言来声明项目设置，而不是传统的XML。gradle能够完成构建、测试、发布和其他诸如软件打包、生成注释文档等等功能\n\n    - 支持Google Cloud Platform\n         - Android Studio支持本地的Google Cloud Platform(谷歌的云平台)，就是说你可以运行服务器端的代码。\n\n    - 强大的UI编辑器\n         - Android Studio的编辑器非常的智能。比如新建一个控件，控件的width和height属性会自动的补全，不用每次都要手动的打上两行 android:layout_width和android:layout_height。还有定义颜色后会自动把颜色显示在旁边（这个对我超级好用）。等等还有其他很多小细节做的都非常不错，大大提高了编辑UI的效率。\n\n    - 更完善的插件系统\n        - Android Studio中可以像Apple store那样浏览所有的插件，直接搜索，下载和管理它.\n\n    - 完美的整合版本控制软件\n        - 安装的时候就自带了如GitHub, CVN等等流行的版本控制工具\n\n    - Android Studio是Google推出的\n       -  Android Stuido是Google推出，专门为ANDROID“量身订做”的，Google的亲儿子。作为Android Developer大腿一定要抱紧。\n\n","slug":"Android-Studio分享","published":1,"updated":"2021-09-10T07:04:21.934Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cktfeap370005c2xxbpdqkx6u","content":"<h4 id=\"Android-Studio分享\"><a href=\"#Android-Studio分享\" class=\"headerlink\" title=\"Android Studio分享\"></a>Android Studio分享</h4><ul>\n<li>android studio是google的亲儿子，肯定以后是必然形势。</li>\n<li>android studio总体运行速度比Eclipse快。</li>\n<li><p>android studio和Eclipse对比：</p>\n<ul>\n<li><p>比Eclipse漂亮</p>\n<pre><code>- android studio可以设置开发代码的背景，而Eclipse只能用那一直到死用的开发背景，有时候想换换背景换换心情都不行。Android Stuido自带的Darcula主题的炫酷黑界面都还可以。想换别的主题也可以自己下载导入的。\n</code></pre><ul>\n<li><p>比Eclipse速度快</p>\n<ul>\n<li>android studio的启动速度，响应速度，内存占用等等全面领先与Eclipse。</li>\n</ul>\n</li>\n<li><p>提示，补全更加智能，更加人性化。</p>\n<ul>\n<li>自动提示补全(有点开发ios的味道)，现在android studio可以把快捷键设置为Eclipse的快捷方式</li>\n</ul>\n</li>\n<li><p>整合了Gradle构建工具</p>\n<ul>\n<li>gradle是一个基于Apache Ant和Apache Maven概念的项目自动化建构工具。它使用一种基于Groovy的特定领域语言来声明项目设置，而不是传统的XML。gradle能够完成构建、测试、发布和其他诸如软件打包、生成注释文档等等功能</li>\n</ul>\n</li>\n<li><p>支持Google Cloud Platform</p>\n<ul>\n<li>Android Studio支持本地的Google Cloud Platform(谷歌的云平台)，就是说你可以运行服务器端的代码。</li>\n</ul>\n</li>\n<li><p>强大的UI编辑器</p>\n<ul>\n<li>Android Studio的编辑器非常的智能。比如新建一个控件，控件的width和height属性会自动的补全，不用每次都要手动的打上两行 android:layout_width和android:layout_height。还有定义颜色后会自动把颜色显示在旁边（这个对我超级好用）。等等还有其他很多小细节做的都非常不错，大大提高了编辑UI的效率。</li>\n</ul>\n</li>\n<li><p>更完善的插件系统</p>\n<ul>\n<li>Android Studio中可以像Apple store那样浏览所有的插件，直接搜索，下载和管理它.</li>\n</ul>\n</li>\n<li><p>完美的整合版本控制软件</p>\n<ul>\n<li>安装的时候就自带了如GitHub, CVN等等流行的版本控制工具</li>\n</ul>\n</li>\n<li><p>Android Studio是Google推出的</p>\n<ul>\n<li>Android Stuido是Google推出，专门为ANDROID“量身订做”的，Google的亲儿子。作为Android Developer大腿一定要抱紧。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"Android-Studio分享\"><a href=\"#Android-Studio分享\" class=\"headerlink\" title=\"Android Studio分享\"></a>Android Studio分享</h4><ul>\n<li>android studio是google的亲儿子，肯定以后是必然形势。</li>\n<li>android studio总体运行速度比Eclipse快。</li>\n<li><p>android studio和Eclipse对比：</p>\n<ul>\n<li><p>比Eclipse漂亮</p>\n<pre><code>- android studio可以设置开发代码的背景，而Eclipse只能用那一直到死用的开发背景，有时候想换换背景换换心情都不行。Android Stuido自带的Darcula主题的炫酷黑界面都还可以。想换别的主题也可以自己下载导入的。\n</code></pre><ul>\n<li><p>比Eclipse速度快</p>\n<ul>\n<li>android studio的启动速度，响应速度，内存占用等等全面领先与Eclipse。</li>\n</ul>\n</li>\n<li><p>提示，补全更加智能，更加人性化。</p>\n<ul>\n<li>自动提示补全(有点开发ios的味道)，现在android studio可以把快捷键设置为Eclipse的快捷方式</li>\n</ul>\n</li>\n<li><p>整合了Gradle构建工具</p>\n<ul>\n<li>gradle是一个基于Apache Ant和Apache Maven概念的项目自动化建构工具。它使用一种基于Groovy的特定领域语言来声明项目设置，而不是传统的XML。gradle能够完成构建、测试、发布和其他诸如软件打包、生成注释文档等等功能</li>\n</ul>\n</li>\n<li><p>支持Google Cloud Platform</p>\n<ul>\n<li>Android Studio支持本地的Google Cloud Platform(谷歌的云平台)，就是说你可以运行服务器端的代码。</li>\n</ul>\n</li>\n<li><p>强大的UI编辑器</p>\n<ul>\n<li>Android Studio的编辑器非常的智能。比如新建一个控件，控件的width和height属性会自动的补全，不用每次都要手动的打上两行 android:layout_width和android:layout_height。还有定义颜色后会自动把颜色显示在旁边（这个对我超级好用）。等等还有其他很多小细节做的都非常不错，大大提高了编辑UI的效率。</li>\n</ul>\n</li>\n<li><p>更完善的插件系统</p>\n<ul>\n<li>Android Studio中可以像Apple store那样浏览所有的插件，直接搜索，下载和管理它.</li>\n</ul>\n</li>\n<li><p>完美的整合版本控制软件</p>\n<ul>\n<li>安装的时候就自带了如GitHub, CVN等等流行的版本控制工具</li>\n</ul>\n</li>\n<li><p>Android Studio是Google推出的</p>\n<ul>\n<li>Android Stuido是Google推出，专门为ANDROID“量身订做”的，Google的亲儿子。作为Android Developer大腿一定要抱紧。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n"},{"title":"Android emoji表情分享","date":"2015-05-15T23:04:29.000Z","_content":"\n\n## Android emoji表情分享\n\n- 什么是emoji表情？\n\n\t- 一套起源于日本的12x12像素表情符号，由栗田穣崇（Shigetaka Kurit）创作，最早在日本网络及手机用户中流行.\n\n- emoji表情手机的支持？\n    - IOS\n\t\t- iOS 4以及之前版本, 采用Softbank编码.\n\t\t- iOS 5以及之后的版本，或者OSX Lion之后的系统, 则改为使用了Unicode6.0编码\n\n    - Android\n\t    - 在android4.4开始支持emoji表情，Unicode编码,如sougou，谷歌等输入法都支持emoji表情。\n\n\n- emoji展示过程\n\n\t- 显示emoji表情----选中emoji表情----unicod编码字符串----ios或者android对unicode编码字符串处理-----如果是emoji表情编码---则从系统中显示相应的emoji表情图片。\n\n- emoji表情的存储\n\n    - iPhone：统一用unicode6.0编码保存\n\n\t- android或wp其他手机： 如果没有emoji表情库，将无法输入。针对输入问题,将统一采用unicode6.0编码存储，UBB代码.\n\n    - 数据库存储：存数据以UTF-8编码用3个字节去存储的，而emoji表情要用4个字节的utf8，也就是utf8mb4格式.\n        - 数据库编码转为utf8mb4,\n \t\t- emoji表情转为支持的utf-8，如转为UBB代码([emoji]2600[/emoji])，HTML转义字符(&#x2600)\n- emoji表情不支持处理\n    - [链接地址1](http://ragnraok.github.io/android-emoji-font-method.html)\n    - [链接地址2](http://bbs.csdn.net/topics/390055415)\n\n","source":"_posts/Android emoji表情分享.md","raw":"title: Android emoji表情分享\ndate: 2015-05-15 23:04:29\ntags:\ncategories: Android\n---\n\n\n## Android emoji表情分享\n\n- 什么是emoji表情？\n\n\t- 一套起源于日本的12x12像素表情符号，由栗田穣崇（Shigetaka Kurit）创作，最早在日本网络及手机用户中流行.\n\n- emoji表情手机的支持？\n    - IOS\n\t\t- iOS 4以及之前版本, 采用Softbank编码.\n\t\t- iOS 5以及之后的版本，或者OSX Lion之后的系统, 则改为使用了Unicode6.0编码\n\n    - Android\n\t    - 在android4.4开始支持emoji表情，Unicode编码,如sougou，谷歌等输入法都支持emoji表情。\n\n\n- emoji展示过程\n\n\t- 显示emoji表情----选中emoji表情----unicod编码字符串----ios或者android对unicode编码字符串处理-----如果是emoji表情编码---则从系统中显示相应的emoji表情图片。\n\n- emoji表情的存储\n\n    - iPhone：统一用unicode6.0编码保存\n\n\t- android或wp其他手机： 如果没有emoji表情库，将无法输入。针对输入问题,将统一采用unicode6.0编码存储，UBB代码.\n\n    - 数据库存储：存数据以UTF-8编码用3个字节去存储的，而emoji表情要用4个字节的utf8，也就是utf8mb4格式.\n        - 数据库编码转为utf8mb4,\n \t\t- emoji表情转为支持的utf-8，如转为UBB代码([emoji]2600[/emoji])，HTML转义字符(&#x2600)\n- emoji表情不支持处理\n    - [链接地址1](http://ragnraok.github.io/android-emoji-font-method.html)\n    - [链接地址2](http://bbs.csdn.net/topics/390055415)\n\n","slug":"Android-emoji表情分享","published":1,"updated":"2021-09-10T07:04:21.935Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cktfeap380006c2xxglhs1q8f","content":"<h2 id=\"Android-emoji表情分享\"><a href=\"#Android-emoji表情分享\" class=\"headerlink\" title=\"Android emoji表情分享\"></a>Android emoji表情分享</h2><ul>\n<li><p>什么是emoji表情？</p>\n<ul>\n<li>一套起源于日本的12x12像素表情符号，由栗田穣崇（Shigetaka Kurit）创作，最早在日本网络及手机用户中流行.</li>\n</ul>\n</li>\n<li><p>emoji表情手机的支持？</p>\n<ul>\n<li><p>IOS</p>\n<ul>\n<li>iOS 4以及之前版本, 采用Softbank编码.</li>\n<li>iOS 5以及之后的版本，或者OSX Lion之后的系统, 则改为使用了Unicode6.0编码</li>\n</ul>\n</li>\n<li><p>Android</p>\n<ul>\n<li>在android4.4开始支持emoji表情，Unicode编码,如sougou，谷歌等输入法都支持emoji表情。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>emoji展示过程</p>\n<ul>\n<li>显示emoji表情—-选中emoji表情—-unicod编码字符串—-ios或者android对unicode编码字符串处理—–如果是emoji表情编码—则从系统中显示相应的emoji表情图片。</li>\n</ul>\n</li>\n<li><p>emoji表情的存储</p>\n<ul>\n<li><p>iPhone：统一用unicode6.0编码保存</p>\n</li>\n<li><p>android或wp其他手机： 如果没有emoji表情库，将无法输入。针对输入问题,将统一采用unicode6.0编码存储，UBB代码.</p>\n</li>\n<li><p>数据库存储：存数据以UTF-8编码用3个字节去存储的，而emoji表情要用4个字节的utf8，也就是utf8mb4格式.</p>\n<ul>\n<li>数据库编码转为utf8mb4,<ul>\n<li>emoji表情转为支持的utf-8，如转为UBB代码([emoji]2600[/emoji])，HTML转义字符(&amp;#x2600)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>emoji表情不支持处理<ul>\n<li><a href=\"http://ragnraok.github.io/android-emoji-font-method.html\" target=\"_blank\" rel=\"noopener\">链接地址1</a></li>\n<li><a href=\"http://bbs.csdn.net/topics/390055415\" target=\"_blank\" rel=\"noopener\">链接地址2</a></li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Android-emoji表情分享\"><a href=\"#Android-emoji表情分享\" class=\"headerlink\" title=\"Android emoji表情分享\"></a>Android emoji表情分享</h2><ul>\n<li><p>什么是emoji表情？</p>\n<ul>\n<li>一套起源于日本的12x12像素表情符号，由栗田穣崇（Shigetaka Kurit）创作，最早在日本网络及手机用户中流行.</li>\n</ul>\n</li>\n<li><p>emoji表情手机的支持？</p>\n<ul>\n<li><p>IOS</p>\n<ul>\n<li>iOS 4以及之前版本, 采用Softbank编码.</li>\n<li>iOS 5以及之后的版本，或者OSX Lion之后的系统, 则改为使用了Unicode6.0编码</li>\n</ul>\n</li>\n<li><p>Android</p>\n<ul>\n<li>在android4.4开始支持emoji表情，Unicode编码,如sougou，谷歌等输入法都支持emoji表情。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>emoji展示过程</p>\n<ul>\n<li>显示emoji表情—-选中emoji表情—-unicod编码字符串—-ios或者android对unicode编码字符串处理—–如果是emoji表情编码—则从系统中显示相应的emoji表情图片。</li>\n</ul>\n</li>\n<li><p>emoji表情的存储</p>\n<ul>\n<li><p>iPhone：统一用unicode6.0编码保存</p>\n</li>\n<li><p>android或wp其他手机： 如果没有emoji表情库，将无法输入。针对输入问题,将统一采用unicode6.0编码存储，UBB代码.</p>\n</li>\n<li><p>数据库存储：存数据以UTF-8编码用3个字节去存储的，而emoji表情要用4个字节的utf8，也就是utf8mb4格式.</p>\n<ul>\n<li>数据库编码转为utf8mb4,<ul>\n<li>emoji表情转为支持的utf-8，如转为UBB代码([emoji]2600[/emoji])，HTML转义字符(&amp;#x2600)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>emoji表情不支持处理<ul>\n<li><a href=\"http://ragnraok.github.io/android-emoji-font-method.html\" target=\"_blank\" rel=\"noopener\">链接地址1</a></li>\n<li><a href=\"http://bbs.csdn.net/topics/390055415\" target=\"_blank\" rel=\"noopener\">链接地址2</a></li>\n</ul>\n</li>\n</ul>\n"},{"title":"Android Stuido常用快捷键（Mac）","date":"2018-12-15T11:30:00.000Z","_content":"\n\n- 提取内部类（内部类移除类新建一个外部类）\n1. 选中内部类-->F6\n2. 选择\n```\nmove inner class xxx to upper level\n```\n\n- 局部变量，全局变量切换大小写\n  ```\n   command+option+U\n  ```\n\n- 格式化代码\n```\n   command+option+L\n```\n\n- 删除多余的导入包\n```\n   option+control+O\n```\n- 搜索指定类\n```\n   command+option+O\n```\n- 全局搜索指定关键字\n```\n   command+shift+F\n```\n- 指定类搜索关键字\n```\n   command+shift+F\n```\n- 提取代码块生成方法\n```\n   command+option+M\n```\n- 查找方法调用处\n```\noption + F7\n```\n- 查看该类所有变量和方法\n```\n   command+F12\n```\n- 查看继承该类的所有类\n```\n   control+H\n```\n- 选中一部分代码块被if/elseif，try/catch包装起来快捷键\n```\n   command+option+T\n```\n- 替换字符串\n```\n  command+shift+R\n```\n- 自动生成get/set\n```\n  control+N\n```\n- 快速中文提取到res资源下，如strings.xml,arrarys.xml\n```\n  option+enter\n```","source":"_posts/Android Studio常用快捷(mac).md","raw":"title: Android Stuido常用快捷键（Mac）\ndate: 2018-12-15 11:30:00\ntags:\ncategories: Android\n---\n\n\n- 提取内部类（内部类移除类新建一个外部类）\n1. 选中内部类-->F6\n2. 选择\n```\nmove inner class xxx to upper level\n```\n\n- 局部变量，全局变量切换大小写\n  ```\n   command+option+U\n  ```\n\n- 格式化代码\n```\n   command+option+L\n```\n\n- 删除多余的导入包\n```\n   option+control+O\n```\n- 搜索指定类\n```\n   command+option+O\n```\n- 全局搜索指定关键字\n```\n   command+shift+F\n```\n- 指定类搜索关键字\n```\n   command+shift+F\n```\n- 提取代码块生成方法\n```\n   command+option+M\n```\n- 查找方法调用处\n```\noption + F7\n```\n- 查看该类所有变量和方法\n```\n   command+F12\n```\n- 查看继承该类的所有类\n```\n   control+H\n```\n- 选中一部分代码块被if/elseif，try/catch包装起来快捷键\n```\n   command+option+T\n```\n- 替换字符串\n```\n  command+shift+R\n```\n- 自动生成get/set\n```\n  control+N\n```\n- 快速中文提取到res资源下，如strings.xml,arrarys.xml\n```\n  option+enter\n```","slug":"Android-Studio常用快捷-mac","published":1,"updated":"2021-09-11T05:56:46.864Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cktfeap390007c2xxksfz29nt","content":"<ul>\n<li>提取内部类（内部类移除类新建一个外部类）</li>\n</ul>\n<ol>\n<li>选中内部类–&gt;F6</li>\n<li>选择<pre><code>move inner class xxx to upper level\n</code></pre></li>\n</ol>\n<ul>\n<li><p>局部变量，全局变量切换大小写</p>\n<pre><code> command+option+U\n</code></pre></li>\n<li><p>格式化代码</p>\n<pre><code> command+option+L\n</code></pre></li>\n<li><p>删除多余的导入包</p>\n<pre><code> option+control+O\n</code></pre></li>\n<li>搜索指定类<pre><code> command+option+O\n</code></pre></li>\n<li>全局搜索指定关键字<pre><code> command+shift+F\n</code></pre></li>\n<li>指定类搜索关键字<pre><code> command+shift+F\n</code></pre></li>\n<li>提取代码块生成方法<pre><code> command+option+M\n</code></pre></li>\n<li>查找方法调用处<pre><code>option + F7\n</code></pre></li>\n<li>查看该类所有变量和方法<pre><code> command+F12\n</code></pre></li>\n<li>查看继承该类的所有类<pre><code> control+H\n</code></pre></li>\n<li>选中一部分代码块被if/elseif，try/catch包装起来快捷键<pre><code> command+option+T\n</code></pre></li>\n<li>替换字符串<pre><code>command+shift+R\n</code></pre></li>\n<li>自动生成get/set<pre><code>control+N\n</code></pre></li>\n<li>快速中文提取到res资源下，如strings.xml,arrarys.xml<pre><code>option+enter\n</code></pre></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>提取内部类（内部类移除类新建一个外部类）</li>\n</ul>\n<ol>\n<li>选中内部类–&gt;F6</li>\n<li>选择<pre><code>move inner class xxx to upper level\n</code></pre></li>\n</ol>\n<ul>\n<li><p>局部变量，全局变量切换大小写</p>\n<pre><code> command+option+U\n</code></pre></li>\n<li><p>格式化代码</p>\n<pre><code> command+option+L\n</code></pre></li>\n<li><p>删除多余的导入包</p>\n<pre><code> option+control+O\n</code></pre></li>\n<li>搜索指定类<pre><code> command+option+O\n</code></pre></li>\n<li>全局搜索指定关键字<pre><code> command+shift+F\n</code></pre></li>\n<li>指定类搜索关键字<pre><code> command+shift+F\n</code></pre></li>\n<li>提取代码块生成方法<pre><code> command+option+M\n</code></pre></li>\n<li>查找方法调用处<pre><code>option + F7\n</code></pre></li>\n<li>查看该类所有变量和方法<pre><code> command+F12\n</code></pre></li>\n<li>查看继承该类的所有类<pre><code> control+H\n</code></pre></li>\n<li>选中一部分代码块被if/elseif，try/catch包装起来快捷键<pre><code> command+option+T\n</code></pre></li>\n<li>替换字符串<pre><code>command+shift+R\n</code></pre></li>\n<li>自动生成get/set<pre><code>control+N\n</code></pre></li>\n<li>快速中文提取到res资源下，如strings.xml,arrarys.xml<pre><code>option+enter\n</code></pre></li>\n</ul>\n"},{"title":"Android与iOS开发相关区别","date":"2017-06-19T18:30:29.000Z","_content":"## Android与iOS开发相关区别\n### 时间搓\n- Java取时间戳为13位\n- iOS取时间戳10位\n- 解决方案：统一用13位，后台Java写的，其他平台调用都是以13位取\n### 下拉刷新\n- Android下拉刷新View没有偏移\n- iOS下拉刷新有偏移\n- 解决方案:下拉有偏移体验更好，Android重新写view，根据移动偏移计算偏移位置，github有很多成型的项目","source":"_posts/Android与iOS开发相关区别.md","raw":"title: Android与iOS开发相关区别\ndate: 2017-06-19 18:30:29\ntags:\ncategories: Android\n\n---\n## Android与iOS开发相关区别\n### 时间搓\n- Java取时间戳为13位\n- iOS取时间戳10位\n- 解决方案：统一用13位，后台Java写的，其他平台调用都是以13位取\n### 下拉刷新\n- Android下拉刷新View没有偏移\n- iOS下拉刷新有偏移\n- 解决方案:下拉有偏移体验更好，Android重新写view，根据移动偏移计算偏移位置，github有很多成型的项目","slug":"Android与iOS开发相关区别","published":1,"updated":"2021-09-11T05:53:52.657Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cktfeap3c0009c2xxc9n289kn","content":"<h2 id=\"Android与iOS开发相关区别\"><a href=\"#Android与iOS开发相关区别\" class=\"headerlink\" title=\"Android与iOS开发相关区别\"></a>Android与iOS开发相关区别</h2><h3 id=\"时间搓\"><a href=\"#时间搓\" class=\"headerlink\" title=\"时间搓\"></a>时间搓</h3><ul>\n<li>Java取时间戳为13位</li>\n<li>iOS取时间戳10位</li>\n<li>解决方案：统一用13位，后台Java写的，其他平台调用都是以13位取<h3 id=\"下拉刷新\"><a href=\"#下拉刷新\" class=\"headerlink\" title=\"下拉刷新\"></a>下拉刷新</h3></li>\n<li>Android下拉刷新View没有偏移</li>\n<li>iOS下拉刷新有偏移</li>\n<li>解决方案:下拉有偏移体验更好，Android重新写view，根据移动偏移计算偏移位置，github有很多成型的项目</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Android与iOS开发相关区别\"><a href=\"#Android与iOS开发相关区别\" class=\"headerlink\" title=\"Android与iOS开发相关区别\"></a>Android与iOS开发相关区别</h2><h3 id=\"时间搓\"><a href=\"#时间搓\" class=\"headerlink\" title=\"时间搓\"></a>时间搓</h3><ul>\n<li>Java取时间戳为13位</li>\n<li>iOS取时间戳10位</li>\n<li>解决方案：统一用13位，后台Java写的，其他平台调用都是以13位取<h3 id=\"下拉刷新\"><a href=\"#下拉刷新\" class=\"headerlink\" title=\"下拉刷新\"></a>下拉刷新</h3></li>\n<li>Android下拉刷新View没有偏移</li>\n<li>iOS下拉刷新有偏移</li>\n<li>解决方案:下拉有偏移体验更好，Android重新写view，根据移动偏移计算偏移位置，github有很多成型的项目</li>\n</ul>\n"},{"title":"Android使用枚举正确姿态","date":"2017-06-19T18:30:29.000Z","_content":"- [大家应该都知道Android建议不要用Java枚举，它占用内存很大](https://developer.android.com/topic/performance/memory.html)\n ![图片](http://static.codeceo.com/images/2015/08/0F3D1FC7-6CFC-41D7-9A43-C9A9C9DD45D5.jpg)\n \n 那实际开发中肯定是要用Java枚举的，那有没有什么解决办法了。答案肯定是有的，[只是换成另外一种方式](https://developer.android.com/reference/android/support/annotation/StringDef.html)\n \n  ```\n  /**\n * Android枚举\n */\npublic class TestEnum {\n    /**\n     * @Retention(RetentionPolicy.SOURCE) 注解可以告知编译器不将枚举的注解数据存储在 .class 文件中\n     *\n     */\n    /**\n     * @StringDef创建整型和字符串集的枚举注解来验证其他类型的代码引用\n     * 具体详细看官网{@link https://developer.android.com/studio/write/annotations.html?hl=zh-cn#adding-annotations}\n     */\n    @Retention(RetentionPolicy.SOURCE)\n    @StringDef({\n            POWER_SERVICE,\n            WINDOW_SERVICE,\n            LAYOUT_INFLATER_SERVICE\n    })\n    //@interface这是Java用来定义一个注解类。\n    public @interface ServiceName {}\n    public static final String POWER_SERVICE = \"power\";\n    public static final String WINDOW_SERVICE = \"window\";\n    public static final String LAYOUT_INFLATER_SERVICE = \"layout_inflater\";\n    public static String getSystemService(@ServiceName String name) {\n        if (POWER_SERVICE.equals(name)) {\n            return POWER_SERVICE;\n        } else if (WINDOW_SERVICE.equals(name)) {\n            return WINDOW_SERVICE;\n        } else if (LAYOUT_INFLATER_SERVICE.equals(name)) {\n            return LAYOUT_INFLATER_SERVICE;\n        }\n        return null;\n    }\n    public static void main(String[] args) {\n        //使用\nSystem.out.println(TestEnum.getSystemService(TestEnum.LAYOUT_INFLATER_SERVICE));\n    }\n}\n  ```\n  这就是官网的写法了。可是发现没有每次传的参数是\n  \n  ```\n  TestEnum.LAYOUT_INFLATER_SERVICE\n  或者\n  TestEnum.POWER_SERVICE\n  ```\n  \n  而不是像我们Java枚举的传参\n  \n  ```\n  ServiceName.LAYOUT_INFLATER_SERVICE\n  ```\n  那是不是需要改造下。[查看资料](https://stackoverflow.com/questions/35625247/android-is-it-ok-to-put-intdef-values-inside-interface)可以这样写\n  \n```\n/**\n * Android枚举\n */\npublic class TestEnum {\n    /**\n     * @Retention(RetentionPolicy.SOURCE) 注解可以告知编译器不将枚举的注解数据存储在 .class 文件中\n     *\n     */\n    /**\n     * @StringDef创建整型和字符串集的枚举注解来验证其他类型的代码引用 具体详细看官网{@link https://developer.android.com/studio/write/annotations.html?hl=zh-cn#adding-annotations}\n     */\n    @Retention(RetentionPolicy.SOURCE)\n    @StringDef({\n            ServiceName.POWER_SERVICE,\n            ServiceName.WINDOW_SERVICE,\n            ServiceName.LAYOUT_INFLATER_SERVICE\n    })\n    //@interface这是Java用来定义一个注解类。\n    public @interface ServiceName {\n        String POWER_SERVICE = \"power\";\n        String WINDOW_SERVICE = \"window\";\n        String LAYOUT_INFLATER_SERVICE = \"layout_inflater\";\n    }\n\n    public static String getSystemService(@ServiceName String name) {\n        if (ServiceName.POWER_SERVICE.equals(name)) {\n            return ServiceName.POWER_SERVICE;\n        } else if (ServiceName.WINDOW_SERVICE.equals(name)) {\n            return ServiceName.WINDOW_SERVICE;\n        } else if (ServiceName.LAYOUT_INFLATER_SERVICE.equals(name)) {\n            return ServiceName.LAYOUT_INFLATER_SERVICE;\n        }\n        return null;\n    }\n\n    public static void main(String[] args) {\n        //使用\n        System.out.println(TestEnum.getSystemService(ServiceName.LAYOUT_INFLATER_SERVICE));\n    }\n}\n```\n不错，就是把常量放到里面去了。这个时候差不多好了，怎么看\n\n```\npublic static String getSystemService(@ServiceName String name) {\n        if (ServiceName.POWER_SERVICE.equals(name)) {\n            return ServiceName.POWER_SERVICE;\n        } else if (ServiceName.WINDOW_SERVICE.equals(name)) {\n            return ServiceName.WINDOW_SERVICE;\n        } else if (ServiceName.LAYOUT_INFLATER_SERVICE.equals(name)) {\n            return ServiceName.LAYOUT_INFLATER_SERVICE;\n        }\n        return null;\n    }\n```\n这个代码还是有点怪怪的，在Java中可以通过enum.values()获取所有enum的值，找了好像没有只能通过反射获取所有的public的参数和参数值了\n\n```\npublic static String getSystemService(@ServiceName String name) {\n        Field[] fields = ServiceName.class.getDeclaredFields();\n        for (Field field : fields) {\n            //在反射对象中设置 accessible 标志允许具有足够特权的复杂应用程序（比如 Java Object Serialization 或其他持久性机制）以某种通常禁止使用的方式来操作对象\n            field.setAccessible(true);\n            String value = null;\n            try {\n                value = String.valueOf(field.get(field.getName()));\n            } catch (IllegalAccessException e) {\n                e.printStackTrace();\n            }\n            if (value != null && value.equals(name)) {\n                return value;\n            }\n        }\n        return null;\n    }\n```\nok完成，[代码地址](https://github.com/mysiga/TestProject/blob/master/app/src/main/java/com/mysiga/testproject/TestEnum.java)\n\n这里有几个知识点参考资料链接看下\n\n- [@Retention](@Retention)\n- [@StringDef](https://developer.android.com/reference/android/support/annotation/StringDef.html?hl=zh-cn)\n- [@interface](http://www.cnblogs.com/bingoidea/archive/2011/03/31/2000726.html)\n- [Java反射](http://wiki.jikexueyuan.com/project/java-reflection/java-classes.html)","source":"_posts/Android使用枚举正确姿态.md","raw":"title: Android使用枚举正确姿态\ndate: 2017-06-19 18:30:29\ntags:\ncategories: Android\n\n---\n- [大家应该都知道Android建议不要用Java枚举，它占用内存很大](https://developer.android.com/topic/performance/memory.html)\n ![图片](http://static.codeceo.com/images/2015/08/0F3D1FC7-6CFC-41D7-9A43-C9A9C9DD45D5.jpg)\n \n 那实际开发中肯定是要用Java枚举的，那有没有什么解决办法了。答案肯定是有的，[只是换成另外一种方式](https://developer.android.com/reference/android/support/annotation/StringDef.html)\n \n  ```\n  /**\n * Android枚举\n */\npublic class TestEnum {\n    /**\n     * @Retention(RetentionPolicy.SOURCE) 注解可以告知编译器不将枚举的注解数据存储在 .class 文件中\n     *\n     */\n    /**\n     * @StringDef创建整型和字符串集的枚举注解来验证其他类型的代码引用\n     * 具体详细看官网{@link https://developer.android.com/studio/write/annotations.html?hl=zh-cn#adding-annotations}\n     */\n    @Retention(RetentionPolicy.SOURCE)\n    @StringDef({\n            POWER_SERVICE,\n            WINDOW_SERVICE,\n            LAYOUT_INFLATER_SERVICE\n    })\n    //@interface这是Java用来定义一个注解类。\n    public @interface ServiceName {}\n    public static final String POWER_SERVICE = \"power\";\n    public static final String WINDOW_SERVICE = \"window\";\n    public static final String LAYOUT_INFLATER_SERVICE = \"layout_inflater\";\n    public static String getSystemService(@ServiceName String name) {\n        if (POWER_SERVICE.equals(name)) {\n            return POWER_SERVICE;\n        } else if (WINDOW_SERVICE.equals(name)) {\n            return WINDOW_SERVICE;\n        } else if (LAYOUT_INFLATER_SERVICE.equals(name)) {\n            return LAYOUT_INFLATER_SERVICE;\n        }\n        return null;\n    }\n    public static void main(String[] args) {\n        //使用\nSystem.out.println(TestEnum.getSystemService(TestEnum.LAYOUT_INFLATER_SERVICE));\n    }\n}\n  ```\n  这就是官网的写法了。可是发现没有每次传的参数是\n  \n  ```\n  TestEnum.LAYOUT_INFLATER_SERVICE\n  或者\n  TestEnum.POWER_SERVICE\n  ```\n  \n  而不是像我们Java枚举的传参\n  \n  ```\n  ServiceName.LAYOUT_INFLATER_SERVICE\n  ```\n  那是不是需要改造下。[查看资料](https://stackoverflow.com/questions/35625247/android-is-it-ok-to-put-intdef-values-inside-interface)可以这样写\n  \n```\n/**\n * Android枚举\n */\npublic class TestEnum {\n    /**\n     * @Retention(RetentionPolicy.SOURCE) 注解可以告知编译器不将枚举的注解数据存储在 .class 文件中\n     *\n     */\n    /**\n     * @StringDef创建整型和字符串集的枚举注解来验证其他类型的代码引用 具体详细看官网{@link https://developer.android.com/studio/write/annotations.html?hl=zh-cn#adding-annotations}\n     */\n    @Retention(RetentionPolicy.SOURCE)\n    @StringDef({\n            ServiceName.POWER_SERVICE,\n            ServiceName.WINDOW_SERVICE,\n            ServiceName.LAYOUT_INFLATER_SERVICE\n    })\n    //@interface这是Java用来定义一个注解类。\n    public @interface ServiceName {\n        String POWER_SERVICE = \"power\";\n        String WINDOW_SERVICE = \"window\";\n        String LAYOUT_INFLATER_SERVICE = \"layout_inflater\";\n    }\n\n    public static String getSystemService(@ServiceName String name) {\n        if (ServiceName.POWER_SERVICE.equals(name)) {\n            return ServiceName.POWER_SERVICE;\n        } else if (ServiceName.WINDOW_SERVICE.equals(name)) {\n            return ServiceName.WINDOW_SERVICE;\n        } else if (ServiceName.LAYOUT_INFLATER_SERVICE.equals(name)) {\n            return ServiceName.LAYOUT_INFLATER_SERVICE;\n        }\n        return null;\n    }\n\n    public static void main(String[] args) {\n        //使用\n        System.out.println(TestEnum.getSystemService(ServiceName.LAYOUT_INFLATER_SERVICE));\n    }\n}\n```\n不错，就是把常量放到里面去了。这个时候差不多好了，怎么看\n\n```\npublic static String getSystemService(@ServiceName String name) {\n        if (ServiceName.POWER_SERVICE.equals(name)) {\n            return ServiceName.POWER_SERVICE;\n        } else if (ServiceName.WINDOW_SERVICE.equals(name)) {\n            return ServiceName.WINDOW_SERVICE;\n        } else if (ServiceName.LAYOUT_INFLATER_SERVICE.equals(name)) {\n            return ServiceName.LAYOUT_INFLATER_SERVICE;\n        }\n        return null;\n    }\n```\n这个代码还是有点怪怪的，在Java中可以通过enum.values()获取所有enum的值，找了好像没有只能通过反射获取所有的public的参数和参数值了\n\n```\npublic static String getSystemService(@ServiceName String name) {\n        Field[] fields = ServiceName.class.getDeclaredFields();\n        for (Field field : fields) {\n            //在反射对象中设置 accessible 标志允许具有足够特权的复杂应用程序（比如 Java Object Serialization 或其他持久性机制）以某种通常禁止使用的方式来操作对象\n            field.setAccessible(true);\n            String value = null;\n            try {\n                value = String.valueOf(field.get(field.getName()));\n            } catch (IllegalAccessException e) {\n                e.printStackTrace();\n            }\n            if (value != null && value.equals(name)) {\n                return value;\n            }\n        }\n        return null;\n    }\n```\nok完成，[代码地址](https://github.com/mysiga/TestProject/blob/master/app/src/main/java/com/mysiga/testproject/TestEnum.java)\n\n这里有几个知识点参考资料链接看下\n\n- [@Retention](@Retention)\n- [@StringDef](https://developer.android.com/reference/android/support/annotation/StringDef.html?hl=zh-cn)\n- [@interface](http://www.cnblogs.com/bingoidea/archive/2011/03/31/2000726.html)\n- [Java反射](http://wiki.jikexueyuan.com/project/java-reflection/java-classes.html)","slug":"Android使用枚举正确姿态","published":1,"updated":"2021-09-10T07:04:21.935Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cktfeap3d000ac2xxf0c4vn8u","content":"<ul>\n<li><p><a href=\"https://developer.android.com/topic/performance/memory.html\" target=\"_blank\" rel=\"noopener\">大家应该都知道Android建议不要用Java枚举，它占用内存很大</a><br><img src=\"http://static.codeceo.com/images/2015/08/0F3D1FC7-6CFC-41D7-9A43-C9A9C9DD45D5.jpg\" alt=\"图片\"></p>\n<p>那实际开发中肯定是要用Java枚举的，那有没有什么解决办法了。答案肯定是有的，<a href=\"https://developer.android.com/reference/android/support/annotation/StringDef.html\" target=\"_blank\" rel=\"noopener\">只是换成另外一种方式</a></p>\n<pre><code>/**\n* Android枚举\n*/\npublic class TestEnum {\n  /**\n   * @Retention(RetentionPolicy.SOURCE) 注解可以告知编译器不将枚举的注解数据存储在 .class 文件中\n   *\n   */\n  /**\n   * @StringDef创建整型和字符串集的枚举注解来验证其他类型的代码引用\n   * 具体详细看官网{@link https://developer.android.com/studio/write/annotations.html?hl=zh-cn#adding-annotations}\n   */\n  @Retention(RetentionPolicy.SOURCE)\n  @StringDef({\n          POWER_SERVICE,\n          WINDOW_SERVICE,\n          LAYOUT_INFLATER_SERVICE\n  })\n  //@interface这是Java用来定义一个注解类。\n  public @interface ServiceName {}\n  public static final String POWER_SERVICE = &quot;power&quot;;\n  public static final String WINDOW_SERVICE = &quot;window&quot;;\n  public static final String LAYOUT_INFLATER_SERVICE = &quot;layout_inflater&quot;;\n  public static String getSystemService(@ServiceName String name) {\n      if (POWER_SERVICE.equals(name)) {\n          return POWER_SERVICE;\n      } else if (WINDOW_SERVICE.equals(name)) {\n          return WINDOW_SERVICE;\n      } else if (LAYOUT_INFLATER_SERVICE.equals(name)) {\n          return LAYOUT_INFLATER_SERVICE;\n      }\n      return null;\n  }\n  public static void main(String[] args) {\n      //使用\nSystem.out.println(TestEnum.getSystemService(TestEnum.LAYOUT_INFLATER_SERVICE));\n  }\n}\n</code></pre><p>这就是官网的写法了。可是发现没有每次传的参数是</p>\n<pre><code>TestEnum.LAYOUT_INFLATER_SERVICE\n或者\nTestEnum.POWER_SERVICE\n</code></pre><p>而不是像我们Java枚举的传参</p>\n<pre><code>ServiceName.LAYOUT_INFLATER_SERVICE\n</code></pre><p>那是不是需要改造下。<a href=\"https://stackoverflow.com/questions/35625247/android-is-it-ok-to-put-intdef-values-inside-interface\" target=\"_blank\" rel=\"noopener\">查看资料</a>可以这样写</p>\n</li>\n</ul>\n<pre><code>/**\n * Android枚举\n */\npublic class TestEnum {\n    /**\n     * @Retention(RetentionPolicy.SOURCE) 注解可以告知编译器不将枚举的注解数据存储在 .class 文件中\n     *\n     */\n    /**\n     * @StringDef创建整型和字符串集的枚举注解来验证其他类型的代码引用 具体详细看官网{@link https://developer.android.com/studio/write/annotations.html?hl=zh-cn#adding-annotations}\n     */\n    @Retention(RetentionPolicy.SOURCE)\n    @StringDef({\n            ServiceName.POWER_SERVICE,\n            ServiceName.WINDOW_SERVICE,\n            ServiceName.LAYOUT_INFLATER_SERVICE\n    })\n    //@interface这是Java用来定义一个注解类。\n    public @interface ServiceName {\n        String POWER_SERVICE = &quot;power&quot;;\n        String WINDOW_SERVICE = &quot;window&quot;;\n        String LAYOUT_INFLATER_SERVICE = &quot;layout_inflater&quot;;\n    }\n\n    public static String getSystemService(@ServiceName String name) {\n        if (ServiceName.POWER_SERVICE.equals(name)) {\n            return ServiceName.POWER_SERVICE;\n        } else if (ServiceName.WINDOW_SERVICE.equals(name)) {\n            return ServiceName.WINDOW_SERVICE;\n        } else if (ServiceName.LAYOUT_INFLATER_SERVICE.equals(name)) {\n            return ServiceName.LAYOUT_INFLATER_SERVICE;\n        }\n        return null;\n    }\n\n    public static void main(String[] args) {\n        //使用\n        System.out.println(TestEnum.getSystemService(ServiceName.LAYOUT_INFLATER_SERVICE));\n    }\n}\n</code></pre><p>不错，就是把常量放到里面去了。这个时候差不多好了，怎么看</p>\n<pre><code>public static String getSystemService(@ServiceName String name) {\n        if (ServiceName.POWER_SERVICE.equals(name)) {\n            return ServiceName.POWER_SERVICE;\n        } else if (ServiceName.WINDOW_SERVICE.equals(name)) {\n            return ServiceName.WINDOW_SERVICE;\n        } else if (ServiceName.LAYOUT_INFLATER_SERVICE.equals(name)) {\n            return ServiceName.LAYOUT_INFLATER_SERVICE;\n        }\n        return null;\n    }\n</code></pre><p>这个代码还是有点怪怪的，在Java中可以通过enum.values()获取所有enum的值，找了好像没有只能通过反射获取所有的public的参数和参数值了</p>\n<pre><code>public static String getSystemService(@ServiceName String name) {\n        Field[] fields = ServiceName.class.getDeclaredFields();\n        for (Field field : fields) {\n            //在反射对象中设置 accessible 标志允许具有足够特权的复杂应用程序（比如 Java Object Serialization 或其他持久性机制）以某种通常禁止使用的方式来操作对象\n            field.setAccessible(true);\n            String value = null;\n            try {\n                value = String.valueOf(field.get(field.getName()));\n            } catch (IllegalAccessException e) {\n                e.printStackTrace();\n            }\n            if (value != null &amp;&amp; value.equals(name)) {\n                return value;\n            }\n        }\n        return null;\n    }\n</code></pre><p>ok完成，<a href=\"https://github.com/mysiga/TestProject/blob/master/app/src/main/java/com/mysiga/testproject/TestEnum.java\" target=\"_blank\" rel=\"noopener\">代码地址</a></p>\n<p>这里有几个知识点参考资料链接看下</p>\n<ul>\n<li><a href=\"@Retention\">@Retention</a></li>\n<li><a href=\"https://developer.android.com/reference/android/support/annotation/StringDef.html?hl=zh-cn\" target=\"_blank\" rel=\"noopener\">@StringDef</a></li>\n<li><a href=\"http://www.cnblogs.com/bingoidea/archive/2011/03/31/2000726.html\" target=\"_blank\" rel=\"noopener\">@interface</a></li>\n<li><a href=\"http://wiki.jikexueyuan.com/project/java-reflection/java-classes.html\" target=\"_blank\" rel=\"noopener\">Java反射</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li><p><a href=\"https://developer.android.com/topic/performance/memory.html\" target=\"_blank\" rel=\"noopener\">大家应该都知道Android建议不要用Java枚举，它占用内存很大</a><br><img src=\"http://static.codeceo.com/images/2015/08/0F3D1FC7-6CFC-41D7-9A43-C9A9C9DD45D5.jpg\" alt=\"图片\"></p>\n<p>那实际开发中肯定是要用Java枚举的，那有没有什么解决办法了。答案肯定是有的，<a href=\"https://developer.android.com/reference/android/support/annotation/StringDef.html\" target=\"_blank\" rel=\"noopener\">只是换成另外一种方式</a></p>\n<pre><code>/**\n* Android枚举\n*/\npublic class TestEnum {\n  /**\n   * @Retention(RetentionPolicy.SOURCE) 注解可以告知编译器不将枚举的注解数据存储在 .class 文件中\n   *\n   */\n  /**\n   * @StringDef创建整型和字符串集的枚举注解来验证其他类型的代码引用\n   * 具体详细看官网{@link https://developer.android.com/studio/write/annotations.html?hl=zh-cn#adding-annotations}\n   */\n  @Retention(RetentionPolicy.SOURCE)\n  @StringDef({\n          POWER_SERVICE,\n          WINDOW_SERVICE,\n          LAYOUT_INFLATER_SERVICE\n  })\n  //@interface这是Java用来定义一个注解类。\n  public @interface ServiceName {}\n  public static final String POWER_SERVICE = &quot;power&quot;;\n  public static final String WINDOW_SERVICE = &quot;window&quot;;\n  public static final String LAYOUT_INFLATER_SERVICE = &quot;layout_inflater&quot;;\n  public static String getSystemService(@ServiceName String name) {\n      if (POWER_SERVICE.equals(name)) {\n          return POWER_SERVICE;\n      } else if (WINDOW_SERVICE.equals(name)) {\n          return WINDOW_SERVICE;\n      } else if (LAYOUT_INFLATER_SERVICE.equals(name)) {\n          return LAYOUT_INFLATER_SERVICE;\n      }\n      return null;\n  }\n  public static void main(String[] args) {\n      //使用\nSystem.out.println(TestEnum.getSystemService(TestEnum.LAYOUT_INFLATER_SERVICE));\n  }\n}\n</code></pre><p>这就是官网的写法了。可是发现没有每次传的参数是</p>\n<pre><code>TestEnum.LAYOUT_INFLATER_SERVICE\n或者\nTestEnum.POWER_SERVICE\n</code></pre><p>而不是像我们Java枚举的传参</p>\n<pre><code>ServiceName.LAYOUT_INFLATER_SERVICE\n</code></pre><p>那是不是需要改造下。<a href=\"https://stackoverflow.com/questions/35625247/android-is-it-ok-to-put-intdef-values-inside-interface\" target=\"_blank\" rel=\"noopener\">查看资料</a>可以这样写</p>\n</li>\n</ul>\n<pre><code>/**\n * Android枚举\n */\npublic class TestEnum {\n    /**\n     * @Retention(RetentionPolicy.SOURCE) 注解可以告知编译器不将枚举的注解数据存储在 .class 文件中\n     *\n     */\n    /**\n     * @StringDef创建整型和字符串集的枚举注解来验证其他类型的代码引用 具体详细看官网{@link https://developer.android.com/studio/write/annotations.html?hl=zh-cn#adding-annotations}\n     */\n    @Retention(RetentionPolicy.SOURCE)\n    @StringDef({\n            ServiceName.POWER_SERVICE,\n            ServiceName.WINDOW_SERVICE,\n            ServiceName.LAYOUT_INFLATER_SERVICE\n    })\n    //@interface这是Java用来定义一个注解类。\n    public @interface ServiceName {\n        String POWER_SERVICE = &quot;power&quot;;\n        String WINDOW_SERVICE = &quot;window&quot;;\n        String LAYOUT_INFLATER_SERVICE = &quot;layout_inflater&quot;;\n    }\n\n    public static String getSystemService(@ServiceName String name) {\n        if (ServiceName.POWER_SERVICE.equals(name)) {\n            return ServiceName.POWER_SERVICE;\n        } else if (ServiceName.WINDOW_SERVICE.equals(name)) {\n            return ServiceName.WINDOW_SERVICE;\n        } else if (ServiceName.LAYOUT_INFLATER_SERVICE.equals(name)) {\n            return ServiceName.LAYOUT_INFLATER_SERVICE;\n        }\n        return null;\n    }\n\n    public static void main(String[] args) {\n        //使用\n        System.out.println(TestEnum.getSystemService(ServiceName.LAYOUT_INFLATER_SERVICE));\n    }\n}\n</code></pre><p>不错，就是把常量放到里面去了。这个时候差不多好了，怎么看</p>\n<pre><code>public static String getSystemService(@ServiceName String name) {\n        if (ServiceName.POWER_SERVICE.equals(name)) {\n            return ServiceName.POWER_SERVICE;\n        } else if (ServiceName.WINDOW_SERVICE.equals(name)) {\n            return ServiceName.WINDOW_SERVICE;\n        } else if (ServiceName.LAYOUT_INFLATER_SERVICE.equals(name)) {\n            return ServiceName.LAYOUT_INFLATER_SERVICE;\n        }\n        return null;\n    }\n</code></pre><p>这个代码还是有点怪怪的，在Java中可以通过enum.values()获取所有enum的值，找了好像没有只能通过反射获取所有的public的参数和参数值了</p>\n<pre><code>public static String getSystemService(@ServiceName String name) {\n        Field[] fields = ServiceName.class.getDeclaredFields();\n        for (Field field : fields) {\n            //在反射对象中设置 accessible 标志允许具有足够特权的复杂应用程序（比如 Java Object Serialization 或其他持久性机制）以某种通常禁止使用的方式来操作对象\n            field.setAccessible(true);\n            String value = null;\n            try {\n                value = String.valueOf(field.get(field.getName()));\n            } catch (IllegalAccessException e) {\n                e.printStackTrace();\n            }\n            if (value != null &amp;&amp; value.equals(name)) {\n                return value;\n            }\n        }\n        return null;\n    }\n</code></pre><p>ok完成，<a href=\"https://github.com/mysiga/TestProject/blob/master/app/src/main/java/com/mysiga/testproject/TestEnum.java\" target=\"_blank\" rel=\"noopener\">代码地址</a></p>\n<p>这里有几个知识点参考资料链接看下</p>\n<ul>\n<li><a href=\"@Retention\">@Retention</a></li>\n<li><a href=\"https://developer.android.com/reference/android/support/annotation/StringDef.html?hl=zh-cn\" target=\"_blank\" rel=\"noopener\">@StringDef</a></li>\n<li><a href=\"http://www.cnblogs.com/bingoidea/archive/2011/03/31/2000726.html\" target=\"_blank\" rel=\"noopener\">@interface</a></li>\n<li><a href=\"http://wiki.jikexueyuan.com/project/java-reflection/java-classes.html\" target=\"_blank\" rel=\"noopener\">Java反射</a></li>\n</ul>\n"},{"title":"动画","date":"2015-11-18T10:30:00.000Z","_content":"\n## Android L动画  - 吴明\n- Touch feedback（触摸反馈）\n\t- 波纹有边界\n\t- 波纹超出边界\n\t- 波纹颜色\n- Reveal effect（揭露效果）\n- liecap\n\t- Circular Reveal动画\n- Activity transitions（Activity转换效果）\n\t- Enter（进入）\n\t\t- 普通Transition\n\t\t\t- explode：从场景的中心移入或移出 \n\t\t\t- slide：从场景的边缘移入或移出 \n\t\t\t- fade：调整透明度产生渐变效果\n\t\t- Shared Elements Transition 共享元素转换:共享两个\t\t\t\tacitivity中共同的元素\n\t\t\t- changeBounds -  改变目标视图的布局边界\n\t\t\t- changeClipBounds - 裁剪目标视图边界\n\t\t\t- changeTransform - 改变目标视图的缩放比例和旋转角度\t\tchangeImageTransform - 改变目标图片的大小和缩放比例\n\t- Exit（退出）\n\t- [demo地址](http://pan.baidu.com/s/1o6Kngnw)\n![Markdown preferences pane](http://7xn0ue.com1.z0.glb.clouddn.com/Untitled123.gif)\n\n\n## objectorAnimator 动画  王进\n### 动画类型\n*   View Animation(Tween Animation 补间动画)\n    只能支持简单的缩放、平移、旋转、透明度等基本的动画，且有一定的局限性\n    动画时View的真正的View的属性保持不变，实际位置未改变\n    原理：提供动画的起始和结束状态信息，中间的状态根据上述类里差值器算法填充\n*   Drawable Animation（Frame Animation 帧动画）\n*   Property Animation(属性动画)\n它更改的是对象的实际属性，\n\n### Property Animation属性\n*   Duration：动画的持续时间\n*   TimeInterpolation：属性值的计算方式，如先快后慢\n*   TypeEvaluator：根据属性的开始、结束值与TimeInterpolation计算出的因子计算出当前时间的属性值\n*   Repeat Count and behavoir：重复次数与方式，如播放3次、5次、无限循环，可以此动画一直重复，或播放完时再反向播放\n*   Animation sets：动画集合，即可以同时对一个对象应用几个动画，这些动画可以同时播放也可以对不同动画设置不同开始偏移\n*   Frame refreash delay：多少时间刷新一次，即每隔多少时间计算一次属性值，默认为10ms，最终刷新时间还受系统进程调度与硬件的影响\n\n### Property Animation 动画流程\n![](http://pic002.cnblogs.com/images/2011/168097/2011120119191590.png)\n\n### ValueAnimator \nValueAnimator包含Property Animation动画的所有核心功能，如动画时间，开始、结束属性值，相应时间属性值计算方法等。应用Property Animation有两个步聚：\n\n1.  计算属性值\n2.  根据属性值执行相应的动作，如改变对象的某一属性。（需要在onAnimationUpdate中传入执行动画的对象）\n```\nValueAnimator animation = ValueAnimator.ofFloat(0f, 1f);\nanimation.setDuration(1000);\nanimation.addUpdateListener(new AnimatorUpdateListener() {\n    @Override\n    public void onAnimationUpdate(ValueAnimator animation) {\n        Log.i(\"update\", ((Float) animation.getAnimatedValue()).toString());\n        //这个函数中会传入ValueAnimator对象做为参数，通过这个ValueAnimator对象的getAnimatedValue()函数可以得到当前的属性值\n    }\n});\nanimation.setInterpolator(new CycleInterpolator(3));\nanimation.start();\n```\n\n### ObjectAnimator\nObjectAnimator继承自ValueAnimator，要指定一个对象及该对象的一个属性,例如\n- 常用方法有ofFloat()，ofInt()，ofObject()，ofArgb()，ofPropertyValuesHolder()。\n- 属性动画可用的属性\n答案是：任何一切带有set开头的方法属性名字。可能我们常用的有：\n - 平移 translationX，translationY, X，Y。 \n - 缩放 scaleX，scaleY。 \n - 旋转 rotationX， rotationY。\n - 透明度 alpha。\n \n 也就是说我们所有控件都有以上setTranslationX(),setScaleX(),setRotationX(),setAlpha()等方法。\n我们不仅限于这几个属性，就拿TextView控件来说，只要是TextView有的属性都可以用来实现动画效果，比如 字体大小：“textColor”，字体颜色“textSize”等。\n> 限制：对象应该有一个setter函数：set<PropertyName>（驼峰命名法）及要有相应属性的getter方法：get<PropertyName>\n且应返回值类型应与相应的setter方法的参数类型一致。\n如果上述条件不满足，则不能用ObjectAnimator，应用ValueAnimator代替。\n\n```\n ObjectAnimator animator = ObjectAnimator.ofFloat(imageView, 'alpha', 1.0f, 0.3f, 1.0F);\n        animator.setDuration(2000);//动画时间\n        animator.setInterpolator(new BounceInterpolator());//动画插值\n        animator.setRepeatCount(-1);//设置动画重复次数\n        animator.setRepeatMode(ValueAnimator.RESTART);//动画重复模式\n        animator.setStartDelay(1000);//动画延时执行\n        animator.start();//启动动画\n```\n> 根据应用动画的对象或属性的不同，可能需要在onAnimationUpdate函数中调用invalidate()函数刷新视图。\n\n### 组合动画\n - **组合动画1–AnimatorSet的使用**\n这个类提供了一个play()方法，如果我们向这个方法中传入一个Animator对象(ValueAnimator或ObjectAnimator)将会返回一个AnimatorSet.Builder的实例，AnimatorSet.Builder中包括以下四个方法：\n   - after(Animator anim) 将现有动画插入到传入的动画之后执行\n   - after(long delay) 将现有动画延迟指定毫秒后执行\n   - before(Animator anim) 将现有动画插入到传入的动画之前执行\n   - with(Animator anim) 将现有动画和传入的动画同时执行\n   \n   > Android 除了提供play(),还有playSequentially(),playTogether() 可供使用，可传入一个或者多个动画对象（，隔开），或者动画集合\n   \n```\n   ObjectAnimator animator = ObjectAnimator.ofInt(container, \"backgroundColor\", 0xFFFF0000, 0xFFFF00FF);\n                ObjectAnimator animator1 = ObjectAnimator.ofFloat(view, \"translationX\", 0.0f, 200.0f, 0f);\n                ObjectAnimator animator2 = ObjectAnimator.ofFloat(view, \"scaleX\", 1.0f, 2.0f);\n                ObjectAnimator animator3 = ObjectAnimator.ofFloat(view, \"rotationX\", 0.0f, 90.0f, 0.0F);\n                ObjectAnimator animator4 = ObjectAnimator.ofFloat(view, \"alpha\", 1.0f, 0.2f, 1.0F);\n\n                //组合动画方式1\n                AnimatorSet set = new AnimatorSet();\n               ((set.play(animator).with(animator1).before(animator2)).before(animator3)).after(animator4);\n                set.setDuration(5000);\n                set.start();\n```\n   \n- **组合动画2–PropertyValuesHolder的使用**\n使用方法ObjectAnimator.ofPropertyValuesHolder(Object target,PropertyValuesHolder… values)；第一个参数是动画的目标对象，之后的参数是PropertyValuesHolder类的实例，可以有多个这样的实例。代码如下：\n```\nPropertyValuesHolder valuesHolder = PropertyValuesHolder.ofFloat(\"translationX\", 0.0f, 300.0f);\n                PropertyValuesHolder valuesHolder1 = PropertyValuesHolder.ofFloat(\"scaleX\", 1.0f, 1.5f);\n                PropertyValuesHolder valuesHolder2 = PropertyValuesHolder.ofFloat(\"rotationX\", 0.0f, 90.0f, 0.0F);\n                PropertyValuesHolder valuesHolder3 = PropertyValuesHolder.ofFloat(\"alpha\", 1.0f, 0.3f, 1.0F);\n\n                ObjectAnimator objectAnimator = ObjectAnimator.ofPropertyValuesHolder(view, valuesHolder, valuesHolder1, valuesHolder2, valuesHolder3);\n                objectAnimator.setDuration(2000).start();\n                //类似于AnimatorSet.playTogether(Animator... items);\n```\n- **组合动画3-ViewPropertyAnimator（多属性动画）**\n```\nViewPropertyAnimator animator5 = imageView.animate();\nanimator5.translationX(200).scaleX(2).setDuration(2000).start();\n```\n> 注意：使用ViewPropertyAnimator类需要API>=12\n\n### 动画监听\n- animator.addListener(new Animator.AnimatorListener(){});//监听动画开始，结束，取消，重复（四种都包括）\n- animator.addListener(new  AnimatorListenerAdapter(){});\n推荐，可代替AnimatorListener，需要监听动画开始，结束，取消，重复那种就直接实现那种方法就行\n其实AnimatorListenerAdapter的源码只是一个实现了AnimatorListener接口的抽象类而已\n- animator.addUpdateListener(new  ValueAnimator.AnimatorUpdateListener(){}); \n更加精确的方法来时刻监听当前动画的执行情况，可以读取到动画的每个更新值了\n```\nanimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n            @Override\n            public void onAnimationUpdate(ValueAnimator animation) {\n                float value = (float) animation.getAnimatedValue();\n                //可以根据自己的需要来获取动画更新值。\n                Log.e('TAG', 'the animation value is ' + value);\n            }\n        });\n```\n\n### Keyframes \nkeyFrame是一个 时间/值 对，通过它可以定义一个在特定时间的特定状态，即关键帧，而且在两个keyFrame之间可以定义不同的Interpolator，就好像多个动画的拼接，第一个动画的结束点是第二个动画的开始点。KeyFrame是抽象类，要通过ofInt(),ofFloat(),ofObject()获得适当的KeyFrame，然后通过PropertyValuesHolder.ofKeyframe获得PropertyValuesHolder对象，如以下例子：\n```\n/*\n*   动画效果：btn对象的width属性值使其：\n*   开始时 Width=400\n*   动画开始1/4时 Width=200\n*   动画开始1/2时 Width=400\n*   动画开始3/4时 Width=100\n*   动画结束时 Width=500\n*/\nKeyframe kf0 = Keyframe.ofInt(0, 400);\nKeyframe kf1 = Keyframe.ofInt(0.25f, 200);\nKeyframe kf2 = Keyframe.ofInt(0.5f, 400);\nKeyframe kf4 = Keyframe.ofInt(0.75f, 100);\nKeyframe kf3 = Keyframe.ofInt(1f, 500);\nPropertyValuesHolder pvhRotation = PropertyValuesHolder.ofKeyframe(\"width\", kf0, kf1, kf2, kf4, kf3);\nObjectAnimator rotationAnim = ObjectAnimator.ofPropertyValuesHolder(btn2, pvhRotation);\nrotationAnim.setDuration(2000);\n```\n### Property Animation在XML中使用\n- xml文件放在res/animator/中\n```\n<set xmlns:android='http://schemas.android.com/apk/res/android'\n    android:duration='2000'\n    android:ordering='sequentially'><!--动画执行顺序 sequentially：顺序执行；together：同时执行。 -->\n\n    <objectAnimator\n        android:propertyName='translationX'\n        android:valueFrom='0'\n        android:valueTo='200'\n        android:valueType='floatType' />\n\n    <set android:ordering='together'>\n        <objectAnimator\n            android:propertyName='scaleX'\n            android:valueFrom='1'\n            android:valueTo='2'\n            android:valueType='floatType' />\n        <objectAnimator\n            android:propertyName='rotationX'\n            android:valueFrom='0'\n            android:valueTo='90'\n            android:valueType='floatType' /><!--动画值的类型-->\n\n    </set>\n```\n- 通过AnimatorInflater.loadAnimator方法加载xml动画返回一个Animator的对象，然后调用setTarget方法给动画设置对象调用哪个start启动动画即可完成xml动画效果\n```\nAnimator animator = AnimatorInflater.loadAnimator(context, R.animator.anim_file);\nanimator.setTarget(view);  \nanimator.start();\n```\n\n\n\n\n## 花花绿绿的ProgressBar  杨俊构\n\n*参考[Android 基础入门教程]( http://www.runoob.com/w3cnote/android-tutorial-progressbar.html)*\n\n- ProgressBar(进度条)是Android基本UI控件，ProgressBar的应用场景很多，比如 用户登录时，后台在发请求，以及等待服务器返回信息，这个时候会用到进度条；或者当在进行一些比较 耗时的操作，需要等待一段较长的时间，这个时候如果没有提示，用户可能会以为程序Carsh或者手机死机 了，这样会大大降低用户体验，所以在需要进行耗时操作的地方，添加上进度条，让用户知道当前的程序 在执行中，也可以直观的告诉用户当前任务的执行进度等！使用进度条可以给我带来这样的便利！ \n\n\n- ProgressBar[官方API文档](http://androiddoc.qiniudn.com/reference/android/widget/ProgressBar.html)，ProgressBar继承与View类，直接子类有AbsSeekBar和ContentLoadingProgressBar， 其中AbsSeekBar的子类有SeekBar和RatingBar，可见这二者也是基于ProgressBar实现的\n\n![](http://7xohph.com1.z0.glb.clouddn.com/46760225.jpg)\n\n- 常用属性详解：\n\n> - android:max：进度条的最大值\n> - android:progress：进度条已完成进度值\n> - android:progressDrawable：设置轨道对应的Drawable对象\n> - android:indeterminate：如果设置成true，则进度条不精确显示进度\n> - android:indeterminateDrawable：设置不显示进度的进度条的Drawable对象\n> - android:indeterminateDuration：设置不精确显示进度的持续时间\n> - android:secondaryProgress：二级进度条，类似于视频播放的一条是当前播放进度，一条是缓冲进度，前者通过progress属性进行设置！\n\n- 对应的再Java中我们可调用下述方法：\n\n> - getMax()：返回这个进度条的范围的上限\n> - getProgress()：返回进度\n> - getSecondaryProgress()：返回次要进度\n> - incrementProgressBy(int diff)：指定增加的进度\n> - isIndeterminate()：指示进度条是否在不确定模式下\n> - setIndeterminate(boolean indeterminate)：设置不确定模式下\n\n- 系统默认进度条使用实例：\n\n![](http://7xohph.com1.z0.glb.clouddn.com/34906854.jpg)\n\n### 耀眼的IOS的ProgressBar ，参看[开源中国IOS代码库](http://www.oschina.net/ios/codingList/373/ios-progress) \n\n\n### 圆形进度条\n\n> 网上一个简单的自定义圆形进度条！代码还是比较简单，容易理解，有兴趣可以看看，或者进行相关扩展~\n\n![](http://7xohph.com1.z0.glb.clouddn.com/17272953.jpg)\n\n- 实现代码：自定义View类：\n\n```java\n\t\n\t/**\n\t * Created by Jay on 2015/8/5 0005.\n\t */\n\tpublic class CirclePgBar extends View {\n\t\n\t\n\t    private Paint mBackPaint;\n\t    private Paint mFrontPaint;\n\t    private Paint mTextPaint;\n\t    private float mStrokeWidth = 50;\n\t    private float mHalfStrokeWidth = mStrokeWidth / 2;\n\t    private float mRadius = 200;\n\t    private RectF mRect;\n\t    private int mProgress = 0;\n\t    //目标值，想改多少就改多少\n\t    private int mTargetProgress = 90;\n\t    private int mMax = 100;\n\t    private int mWidth;\n\t    private int mHeight;\n\t\n\t\n\t    public CirclePgBar(Context context) {\n\t        super(context);\n\t        init();\n\t    }\n\t\n\t    public CirclePgBar(Context context, AttributeSet attrs) {\n\t        super(context, attrs);\n\t        init();\n\t    }\n\t\n\t    public CirclePgBar(Context context, AttributeSet attrs, int defStyleAttr) {\n\t        super(context, attrs, defStyleAttr);\n\t        init();\n\t    }\n\t\n\t\n\t    //完成相关参数初始化\n\t    private void init() {\n\t        mBackPaint = new Paint();\n\t        mBackPaint.setColor(Color.WHITE);\n\t        mBackPaint.setAntiAlias(true);\n\t        mBackPaint.setStyle(Paint.Style.STROKE);\n\t        mBackPaint.setStrokeWidth(mStrokeWidth);\n\t\n\t        mFrontPaint = new Paint();\n\t        mFrontPaint.setColor(Color.GREEN);\n\t        mFrontPaint.setAntiAlias(true);\n\t        mFrontPaint.setStyle(Paint.Style.STROKE);\n\t        mFrontPaint.setStrokeWidth(mStrokeWidth);\n\t\n\t\n\t        mTextPaint = new Paint();\n\t        mTextPaint.setColor(Color.GREEN);\n\t        mTextPaint.setAntiAlias(true);\n\t        mTextPaint.setTextSize(80);\n\t        mTextPaint.setTextAlign(Paint.Align.CENTER);\n\t    }\n\t\n\t\n\t    //重写测量大小的onMeasure方法和绘制View的核心方法onDraw()\n\t    @Override\n\t    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n\t        super.onMeasure(widthMeasureSpec, heightMeasureSpec);\n\t        mWidth = getRealSize(widthMeasureSpec);\n\t        mHeight = getRealSize(heightMeasureSpec);\n\t        setMeasuredDimension(mWidth, mHeight);\n\t\n\t    }\n\t\n\t\n\t    @Override\n\t    protected void onDraw(Canvas canvas) {\n\t        initRect();\n\t        float angle = mProgress / (float) mMax * 360;\n\t        canvas.drawCircle(mWidth / 2, mHeight / 2, mRadius, mBackPaint);\n\t        canvas.drawArc(mRect, -90, angle, false, mFrontPaint);\n\t        canvas.drawText(mProgress + \"%\", mWidth / 2 + mHalfStrokeWidth, mHeight / 2 + mHalfStrokeWidth, mTextPaint);\n\t        if (mProgress < mTargetProgress) {\n\t            mProgress += 1;\n\t            invalidate();\n\t        }\n\t\n\t    }\n\t\n\t    public int getRealSize(int measureSpec) {\n\t        int result = 1;\n\t        int mode = MeasureSpec.getMode(measureSpec);\n\t        int size = MeasureSpec.getSize(measureSpec);\n\t\n\t        if (mode == MeasureSpec.AT_MOST || mode == MeasureSpec.UNSPECIFIED) {\n\t            //自己计算\n\t            result = (int) (mRadius * 2 + mStrokeWidth);\n\t        } else {\n\t            result = size;\n\t        }\n\t\n\t        return result;\n\t    }\n\t\n\t    private void initRect() {\n\t        if (mRect == null) {\n\t            mRect = new RectF();\n\t            int viewSize = (int) (mRadius * 2);\n\t            int left = (mWidth - viewSize) / 2;\n\t            int top = (mHeight - viewSize) / 2;\n\t            int right = left + viewSize;\n\t            int bottom = top + viewSize;\n\t            mRect.set(left, top, right, bottom);\n\t        }\n\t    }\n\t\n\t\n\t}\n\n```\n\n\n- 然后在布局文件中加上：\n\n``` xml\n\n\t <com.jay.progressbardemo.CirclePgBar\n       android:layout_width=\"match_parent\"\n\t   android:layout_height=\"match_parent\"/>\n\n```\n\n### 总结\n - progressbar是Android中的常用控件，在实际开发中和动画结合较多，好的进度条可以缓解使用者焦躁的情趣，自定义圆形进度条可以自行完善，然后用到实际开发中！\n\n\n\n\n\n\n\n\n## layer-list实现阴影效果——xpleemoon\n- 为控件实现阴影效果，可以有多种方式：\n\t- 多个drawable层叠在一起（不好的实现是多个View层叠达到多个drawable的层叠效果，相对好的实现是在同一个View钟实现多个drawable的层叠）\n\t- 自定义view\n\t- Material Design中设置Z轴的方式\n\n- 本文的思路是多个drawable叠在一起，但是不额外使用View，通过layer-list可以将多个item按照顺序层叠在一起显示。首先来看效果图：\n\n![LayerShadow](https://github.com/xpleemoon/layer-list-shadow-demo/blob/master/gif/LayerShadow.gif?raw=true)\n\n- 第一个和第二个控件是用来展示layer-list实现阴影效果的基本款，而第三个控件是综合上述两个控件效果，再集合selector实现的。\n\n- 默认状态：\n\n``` xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<layer-list xmlns:android=\"http://schemas.android.com/apk/res/android\">\n    <!-- 阴影：左偏移2dp，上偏移4dp -->\n    <item\n        android:left=\"2dp\"\n        android:top=\"4dp\">\n        <shape>\n            <solid android:color=\"@android:color/holo_blue_dark\" />\n            <corners android:radius=\"10dp\" />\n        </shape>\n    </item>\n    <!-- 前景：：底偏移4dp，右偏移2dp -->\n    <item\n        android:bottom=\"4dp\"\n        android:right=\"2dp\">\n        <shape>\n            <solid android:color=\"@android:color/holo_blue_bright\" />\n            <corners android:radius=\"10dp\" />\n        </shape>\n    </item>\n</layer-list>\n```\n\n- 点击状态：\n\n``` xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<layer-list xmlns:android=\"http://schemas.android.com/apk/res/android\">\n    <!-- 为了达到点击的真实感，将原来默认状态的前景色设置为阴影，并将前景设为无透明-->\n    <item\n        android:left=\"2dp\"\n        android:top=\"4dp\">\n        <shape>\n            <solid android:color=\"@android:color/holo_blue_bright\" />\n            <corners android:radius=\"10dp\" />\n        </shape>\n    </item>\n    <item\n        android:bottom=\"4dp\"\n        android:right=\"2dp\">\n        <shape>\n            <corners android:radius=\"10dp\" />\n        </shape>\n    </item>\n</layer-list>\n```\n\n> layer-list的item可以通过以下属性设置偏移量：\n> \n> - android:top 顶部的偏移量\n> - android:bottom 底部的偏移量\n> - android:left 左边的偏移量\n> - android:right 右边的偏移量\n\n- selector，使用上述layer-list：\n\n``` xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<selector xmlns:android=\"http://schemas.android.com/apk/res/android\">\n    <item android:drawable=\"@drawable/layer_list_btn_pressed\" android:state_pressed=\"true\" />\n    <item android:drawable=\"@drawable/layer_list_btn_pressed\" android:state_selected=\"true\" />\n    <item android:drawable=\"@drawable/layer_list_btn\" />\n\n</selector>\n```\n- 最后再来看下，布局代码：\n\n``` xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:orientation=\"vertical\"\n    android:paddingBottom=\"@dimen/activity_vertical_margin\"\n    android:paddingLeft=\"@dimen/activity_horizontal_margin\"\n    android:paddingRight=\"@dimen/activity_horizontal_margin\"\n    android:paddingTop=\"@dimen/activity_vertical_margin\"\n    tools:context=\".MainActivity\">\n\n    <TextView\n        android:layout_width=\"100dp\"\n        android:layout_height=\"50dp\"\n        android:background=\"@drawable/layer_list_btn\"\n        android:clickable=\"true\"\n        android:gravity=\"center\"\n        android:text=\"默认状态\" />\n\n    <TextView\n        android:layout_width=\"100dp\"\n        android:layout_height=\"50dp\"\n        android:layout_marginTop=\"@dimen/activity_vertical_margin\"\n        android:background=\"@drawable/layer_list_btn_pressed\"\n        android:clickable=\"true\"\n        android:gravity=\"center\"\n        android:text=\"点击状态\" />\n\n    <TextView\n        android:layout_width=\"100dp\"\n        android:layout_height=\"50dp\"\n        android:layout_marginTop=\"@dimen/activity_vertical_margin\"\n        android:background=\"@drawable/selector_btn\"\n        android:clickable=\"true\"\n        android:gravity=\"center\"\n        android:text=\"点我\" />\n</LinearLayout>\n```\n- 第一个和第二个TextView分别引用了对应的layer-list（默认和点击）作为背景，第三个引用了selector\n\n- ***[源码地址](https://github.com/xpleemoon/layer-list-shadow-demo)***\n\n\n## 零部署的云服务 - 王胜\n\n> 本周的分享主题是动画，但之前7月份我已经分享过一次，[知其所以然](http://51offer.github.io/2015/07/07/%E7%A7%BB%E5%8A%A8%E7%BB%84%E5%91%A8%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB-%E7%9F%A5%E5%85%B6%E6%89%80%E4%BB%A5%E7%84%B6/) 。再加上前面几位已经对android的动画介绍的很完整了，所以我就分享另一个话题『云平台下的零部署开发网站』。\n\n### 牵扯的技能\n\n- Git\n- 任何一门后端开发语言\n\n### 搭建步骤\n\n[AZURE](https://tryappservice.azure.com/zh-cn) -> 点击 [Web应用模块](https://azure.microsoft.com/zh-cn/services/app-service/web/) -> 选择语言，点击**创建Web应用** -> 选择模板，点击**创建**，至此，应用以创建，点击页面上站点url，就能看到新创建的Web站点了。\n\n### 修改代码，Git提交自动完成部署\n\n复制创建成功页面『使用 Git 克隆或推送』里的Git地址，将初始化源码clone到本地，然后编辑代码，修改功能。完成后，直接push到远程，云平台自动完成部署。再看看网页是不是已经发生变化了。\n\n```Shell\nVictors-MPB:azure wangsheng$ git clone https://$4f743e5d-0ee0-4-231-b9ee:WSc8Szx4Rf30apo3Ky7hpw6mXAadAZYvn1zagCvMaboj7mHFyJ2vzuYn9i12@4f743e5d-0ee0-4-231-b9ee.scm.azurewebsites.net/4f743e5d-0ee0-4-231-b9ee.git\nCloning into '4f743e5d-0ee0-4-231-b9ee'...\nremote: Counting objects: 4, done.\nremote: Compressing objects: 100% (3/3), done.\nremote: Total 4 (delta 0), reused 0 (delta 0)\nUnpacking objects: 100% (4/4), done.\nChecking connectivity... done.\nVictors-MPB:azure wangsheng$ ls\n4f743e5d-0ee0-4-231-b9ee\nVictors-MPB:azure wangsheng$ cd 4f743e5d-0ee0-4-231-b9ee/\nVictors-MPB:4f743e5d-0ee0-4-231-b9ee wangsheng$ git br\n* master\nVictors-MPB:4f743e5d-0ee0-4-231-b9ee wangsheng$ git log\ncommit cf6edda65210ef7254f9bc545c778489f123620e\nAuthor: windowsazure <windowsazure>\nDate:   Fri Nov 20 03:53:00 2015 +0000\n\n    Initial Commit\nVictors-MPB:4f743e5d-0ee0-4-231-b9ee wangsheng$ ls\nfavicon.ico\tindex.php\nVictors-MPB:4f743e5d-0ee0-4-231-b9ee wangsheng$ vi index.php\nVictors-MPB:4f743e5d-0ee0-4-231-b9ee wangsheng$ git st\nOn branch master\nYour branch is up-to-date with 'origin/master'.\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n\tmodified:   index.php\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\nVictors-MPB:4f743e5d-0ee0-4-231-b9ee wangsheng$ git diff\ndiff --git a/index.php b/index.php\n<?php\nindex 712f825..50a17e7 100644\n--- a/index.php\n+++ b/index.php\n@@ -1,3 +1,4 @@\n <?php\n     echo \"Hello World\"\n-?>\n\\ No newline at end of file\n+    echo \"hack it.\"\n+?>\nVictors-MPB:4f743e5d-0ee0-4-231-b9ee wangsheng$ git ci -am \"add one line.\"\n[master 6c5551f] add one line.\n 1 file changed, 2 insertions(+), 1 deletion(-)\nVictors-MPB:4f743e5d-0ee0-4-231-b9ee wangsheng$ git push origin master\nCounting objects: 3, done.\nDelta compression using up to 4 threads.\nCompressing objects: 100% (3/3), done.\nWriting objects: 100% (3/3), 324 bytes | 0 bytes/s, done.\nTotal 3 (delta 0), reused 0 (delta 0)\nremote: Updating branch 'master'.\nremote: Updating submodules.\nremote: Preparing deployment for commit id '6c5551f090'.\nremote: Generating deployment script.\nremote: Generating deployment script for Web Site\nremote: Generated deployment script files\nremote: Running deployment command...\nremote: Handling Basic Web Site deployment.\nremote: Finished successfully.\nremote: Deployment successful.\n```\n\n对，后端开发可以如此简单快乐地开发部署！！！\n\n\n\n","source":"_posts/Android动画.md","raw":"title: 动画\ndate: 2015-11-18  10:30:00\ntags:\ncategories: 移动组周分享\n---\n\n## Android L动画  - 吴明\n- Touch feedback（触摸反馈）\n\t- 波纹有边界\n\t- 波纹超出边界\n\t- 波纹颜色\n- Reveal effect（揭露效果）\n- liecap\n\t- Circular Reveal动画\n- Activity transitions（Activity转换效果）\n\t- Enter（进入）\n\t\t- 普通Transition\n\t\t\t- explode：从场景的中心移入或移出 \n\t\t\t- slide：从场景的边缘移入或移出 \n\t\t\t- fade：调整透明度产生渐变效果\n\t\t- Shared Elements Transition 共享元素转换:共享两个\t\t\t\tacitivity中共同的元素\n\t\t\t- changeBounds -  改变目标视图的布局边界\n\t\t\t- changeClipBounds - 裁剪目标视图边界\n\t\t\t- changeTransform - 改变目标视图的缩放比例和旋转角度\t\tchangeImageTransform - 改变目标图片的大小和缩放比例\n\t- Exit（退出）\n\t- [demo地址](http://pan.baidu.com/s/1o6Kngnw)\n![Markdown preferences pane](http://7xn0ue.com1.z0.glb.clouddn.com/Untitled123.gif)\n\n\n## objectorAnimator 动画  王进\n### 动画类型\n*   View Animation(Tween Animation 补间动画)\n    只能支持简单的缩放、平移、旋转、透明度等基本的动画，且有一定的局限性\n    动画时View的真正的View的属性保持不变，实际位置未改变\n    原理：提供动画的起始和结束状态信息，中间的状态根据上述类里差值器算法填充\n*   Drawable Animation（Frame Animation 帧动画）\n*   Property Animation(属性动画)\n它更改的是对象的实际属性，\n\n### Property Animation属性\n*   Duration：动画的持续时间\n*   TimeInterpolation：属性值的计算方式，如先快后慢\n*   TypeEvaluator：根据属性的开始、结束值与TimeInterpolation计算出的因子计算出当前时间的属性值\n*   Repeat Count and behavoir：重复次数与方式，如播放3次、5次、无限循环，可以此动画一直重复，或播放完时再反向播放\n*   Animation sets：动画集合，即可以同时对一个对象应用几个动画，这些动画可以同时播放也可以对不同动画设置不同开始偏移\n*   Frame refreash delay：多少时间刷新一次，即每隔多少时间计算一次属性值，默认为10ms，最终刷新时间还受系统进程调度与硬件的影响\n\n### Property Animation 动画流程\n![](http://pic002.cnblogs.com/images/2011/168097/2011120119191590.png)\n\n### ValueAnimator \nValueAnimator包含Property Animation动画的所有核心功能，如动画时间，开始、结束属性值，相应时间属性值计算方法等。应用Property Animation有两个步聚：\n\n1.  计算属性值\n2.  根据属性值执行相应的动作，如改变对象的某一属性。（需要在onAnimationUpdate中传入执行动画的对象）\n```\nValueAnimator animation = ValueAnimator.ofFloat(0f, 1f);\nanimation.setDuration(1000);\nanimation.addUpdateListener(new AnimatorUpdateListener() {\n    @Override\n    public void onAnimationUpdate(ValueAnimator animation) {\n        Log.i(\"update\", ((Float) animation.getAnimatedValue()).toString());\n        //这个函数中会传入ValueAnimator对象做为参数，通过这个ValueAnimator对象的getAnimatedValue()函数可以得到当前的属性值\n    }\n});\nanimation.setInterpolator(new CycleInterpolator(3));\nanimation.start();\n```\n\n### ObjectAnimator\nObjectAnimator继承自ValueAnimator，要指定一个对象及该对象的一个属性,例如\n- 常用方法有ofFloat()，ofInt()，ofObject()，ofArgb()，ofPropertyValuesHolder()。\n- 属性动画可用的属性\n答案是：任何一切带有set开头的方法属性名字。可能我们常用的有：\n - 平移 translationX，translationY, X，Y。 \n - 缩放 scaleX，scaleY。 \n - 旋转 rotationX， rotationY。\n - 透明度 alpha。\n \n 也就是说我们所有控件都有以上setTranslationX(),setScaleX(),setRotationX(),setAlpha()等方法。\n我们不仅限于这几个属性，就拿TextView控件来说，只要是TextView有的属性都可以用来实现动画效果，比如 字体大小：“textColor”，字体颜色“textSize”等。\n> 限制：对象应该有一个setter函数：set<PropertyName>（驼峰命名法）及要有相应属性的getter方法：get<PropertyName>\n且应返回值类型应与相应的setter方法的参数类型一致。\n如果上述条件不满足，则不能用ObjectAnimator，应用ValueAnimator代替。\n\n```\n ObjectAnimator animator = ObjectAnimator.ofFloat(imageView, 'alpha', 1.0f, 0.3f, 1.0F);\n        animator.setDuration(2000);//动画时间\n        animator.setInterpolator(new BounceInterpolator());//动画插值\n        animator.setRepeatCount(-1);//设置动画重复次数\n        animator.setRepeatMode(ValueAnimator.RESTART);//动画重复模式\n        animator.setStartDelay(1000);//动画延时执行\n        animator.start();//启动动画\n```\n> 根据应用动画的对象或属性的不同，可能需要在onAnimationUpdate函数中调用invalidate()函数刷新视图。\n\n### 组合动画\n - **组合动画1–AnimatorSet的使用**\n这个类提供了一个play()方法，如果我们向这个方法中传入一个Animator对象(ValueAnimator或ObjectAnimator)将会返回一个AnimatorSet.Builder的实例，AnimatorSet.Builder中包括以下四个方法：\n   - after(Animator anim) 将现有动画插入到传入的动画之后执行\n   - after(long delay) 将现有动画延迟指定毫秒后执行\n   - before(Animator anim) 将现有动画插入到传入的动画之前执行\n   - with(Animator anim) 将现有动画和传入的动画同时执行\n   \n   > Android 除了提供play(),还有playSequentially(),playTogether() 可供使用，可传入一个或者多个动画对象（，隔开），或者动画集合\n   \n```\n   ObjectAnimator animator = ObjectAnimator.ofInt(container, \"backgroundColor\", 0xFFFF0000, 0xFFFF00FF);\n                ObjectAnimator animator1 = ObjectAnimator.ofFloat(view, \"translationX\", 0.0f, 200.0f, 0f);\n                ObjectAnimator animator2 = ObjectAnimator.ofFloat(view, \"scaleX\", 1.0f, 2.0f);\n                ObjectAnimator animator3 = ObjectAnimator.ofFloat(view, \"rotationX\", 0.0f, 90.0f, 0.0F);\n                ObjectAnimator animator4 = ObjectAnimator.ofFloat(view, \"alpha\", 1.0f, 0.2f, 1.0F);\n\n                //组合动画方式1\n                AnimatorSet set = new AnimatorSet();\n               ((set.play(animator).with(animator1).before(animator2)).before(animator3)).after(animator4);\n                set.setDuration(5000);\n                set.start();\n```\n   \n- **组合动画2–PropertyValuesHolder的使用**\n使用方法ObjectAnimator.ofPropertyValuesHolder(Object target,PropertyValuesHolder… values)；第一个参数是动画的目标对象，之后的参数是PropertyValuesHolder类的实例，可以有多个这样的实例。代码如下：\n```\nPropertyValuesHolder valuesHolder = PropertyValuesHolder.ofFloat(\"translationX\", 0.0f, 300.0f);\n                PropertyValuesHolder valuesHolder1 = PropertyValuesHolder.ofFloat(\"scaleX\", 1.0f, 1.5f);\n                PropertyValuesHolder valuesHolder2 = PropertyValuesHolder.ofFloat(\"rotationX\", 0.0f, 90.0f, 0.0F);\n                PropertyValuesHolder valuesHolder3 = PropertyValuesHolder.ofFloat(\"alpha\", 1.0f, 0.3f, 1.0F);\n\n                ObjectAnimator objectAnimator = ObjectAnimator.ofPropertyValuesHolder(view, valuesHolder, valuesHolder1, valuesHolder2, valuesHolder3);\n                objectAnimator.setDuration(2000).start();\n                //类似于AnimatorSet.playTogether(Animator... items);\n```\n- **组合动画3-ViewPropertyAnimator（多属性动画）**\n```\nViewPropertyAnimator animator5 = imageView.animate();\nanimator5.translationX(200).scaleX(2).setDuration(2000).start();\n```\n> 注意：使用ViewPropertyAnimator类需要API>=12\n\n### 动画监听\n- animator.addListener(new Animator.AnimatorListener(){});//监听动画开始，结束，取消，重复（四种都包括）\n- animator.addListener(new  AnimatorListenerAdapter(){});\n推荐，可代替AnimatorListener，需要监听动画开始，结束，取消，重复那种就直接实现那种方法就行\n其实AnimatorListenerAdapter的源码只是一个实现了AnimatorListener接口的抽象类而已\n- animator.addUpdateListener(new  ValueAnimator.AnimatorUpdateListener(){}); \n更加精确的方法来时刻监听当前动画的执行情况，可以读取到动画的每个更新值了\n```\nanimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n            @Override\n            public void onAnimationUpdate(ValueAnimator animation) {\n                float value = (float) animation.getAnimatedValue();\n                //可以根据自己的需要来获取动画更新值。\n                Log.e('TAG', 'the animation value is ' + value);\n            }\n        });\n```\n\n### Keyframes \nkeyFrame是一个 时间/值 对，通过它可以定义一个在特定时间的特定状态，即关键帧，而且在两个keyFrame之间可以定义不同的Interpolator，就好像多个动画的拼接，第一个动画的结束点是第二个动画的开始点。KeyFrame是抽象类，要通过ofInt(),ofFloat(),ofObject()获得适当的KeyFrame，然后通过PropertyValuesHolder.ofKeyframe获得PropertyValuesHolder对象，如以下例子：\n```\n/*\n*   动画效果：btn对象的width属性值使其：\n*   开始时 Width=400\n*   动画开始1/4时 Width=200\n*   动画开始1/2时 Width=400\n*   动画开始3/4时 Width=100\n*   动画结束时 Width=500\n*/\nKeyframe kf0 = Keyframe.ofInt(0, 400);\nKeyframe kf1 = Keyframe.ofInt(0.25f, 200);\nKeyframe kf2 = Keyframe.ofInt(0.5f, 400);\nKeyframe kf4 = Keyframe.ofInt(0.75f, 100);\nKeyframe kf3 = Keyframe.ofInt(1f, 500);\nPropertyValuesHolder pvhRotation = PropertyValuesHolder.ofKeyframe(\"width\", kf0, kf1, kf2, kf4, kf3);\nObjectAnimator rotationAnim = ObjectAnimator.ofPropertyValuesHolder(btn2, pvhRotation);\nrotationAnim.setDuration(2000);\n```\n### Property Animation在XML中使用\n- xml文件放在res/animator/中\n```\n<set xmlns:android='http://schemas.android.com/apk/res/android'\n    android:duration='2000'\n    android:ordering='sequentially'><!--动画执行顺序 sequentially：顺序执行；together：同时执行。 -->\n\n    <objectAnimator\n        android:propertyName='translationX'\n        android:valueFrom='0'\n        android:valueTo='200'\n        android:valueType='floatType' />\n\n    <set android:ordering='together'>\n        <objectAnimator\n            android:propertyName='scaleX'\n            android:valueFrom='1'\n            android:valueTo='2'\n            android:valueType='floatType' />\n        <objectAnimator\n            android:propertyName='rotationX'\n            android:valueFrom='0'\n            android:valueTo='90'\n            android:valueType='floatType' /><!--动画值的类型-->\n\n    </set>\n```\n- 通过AnimatorInflater.loadAnimator方法加载xml动画返回一个Animator的对象，然后调用setTarget方法给动画设置对象调用哪个start启动动画即可完成xml动画效果\n```\nAnimator animator = AnimatorInflater.loadAnimator(context, R.animator.anim_file);\nanimator.setTarget(view);  \nanimator.start();\n```\n\n\n\n\n## 花花绿绿的ProgressBar  杨俊构\n\n*参考[Android 基础入门教程]( http://www.runoob.com/w3cnote/android-tutorial-progressbar.html)*\n\n- ProgressBar(进度条)是Android基本UI控件，ProgressBar的应用场景很多，比如 用户登录时，后台在发请求，以及等待服务器返回信息，这个时候会用到进度条；或者当在进行一些比较 耗时的操作，需要等待一段较长的时间，这个时候如果没有提示，用户可能会以为程序Carsh或者手机死机 了，这样会大大降低用户体验，所以在需要进行耗时操作的地方，添加上进度条，让用户知道当前的程序 在执行中，也可以直观的告诉用户当前任务的执行进度等！使用进度条可以给我带来这样的便利！ \n\n\n- ProgressBar[官方API文档](http://androiddoc.qiniudn.com/reference/android/widget/ProgressBar.html)，ProgressBar继承与View类，直接子类有AbsSeekBar和ContentLoadingProgressBar， 其中AbsSeekBar的子类有SeekBar和RatingBar，可见这二者也是基于ProgressBar实现的\n\n![](http://7xohph.com1.z0.glb.clouddn.com/46760225.jpg)\n\n- 常用属性详解：\n\n> - android:max：进度条的最大值\n> - android:progress：进度条已完成进度值\n> - android:progressDrawable：设置轨道对应的Drawable对象\n> - android:indeterminate：如果设置成true，则进度条不精确显示进度\n> - android:indeterminateDrawable：设置不显示进度的进度条的Drawable对象\n> - android:indeterminateDuration：设置不精确显示进度的持续时间\n> - android:secondaryProgress：二级进度条，类似于视频播放的一条是当前播放进度，一条是缓冲进度，前者通过progress属性进行设置！\n\n- 对应的再Java中我们可调用下述方法：\n\n> - getMax()：返回这个进度条的范围的上限\n> - getProgress()：返回进度\n> - getSecondaryProgress()：返回次要进度\n> - incrementProgressBy(int diff)：指定增加的进度\n> - isIndeterminate()：指示进度条是否在不确定模式下\n> - setIndeterminate(boolean indeterminate)：设置不确定模式下\n\n- 系统默认进度条使用实例：\n\n![](http://7xohph.com1.z0.glb.clouddn.com/34906854.jpg)\n\n### 耀眼的IOS的ProgressBar ，参看[开源中国IOS代码库](http://www.oschina.net/ios/codingList/373/ios-progress) \n\n\n### 圆形进度条\n\n> 网上一个简单的自定义圆形进度条！代码还是比较简单，容易理解，有兴趣可以看看，或者进行相关扩展~\n\n![](http://7xohph.com1.z0.glb.clouddn.com/17272953.jpg)\n\n- 实现代码：自定义View类：\n\n```java\n\t\n\t/**\n\t * Created by Jay on 2015/8/5 0005.\n\t */\n\tpublic class CirclePgBar extends View {\n\t\n\t\n\t    private Paint mBackPaint;\n\t    private Paint mFrontPaint;\n\t    private Paint mTextPaint;\n\t    private float mStrokeWidth = 50;\n\t    private float mHalfStrokeWidth = mStrokeWidth / 2;\n\t    private float mRadius = 200;\n\t    private RectF mRect;\n\t    private int mProgress = 0;\n\t    //目标值，想改多少就改多少\n\t    private int mTargetProgress = 90;\n\t    private int mMax = 100;\n\t    private int mWidth;\n\t    private int mHeight;\n\t\n\t\n\t    public CirclePgBar(Context context) {\n\t        super(context);\n\t        init();\n\t    }\n\t\n\t    public CirclePgBar(Context context, AttributeSet attrs) {\n\t        super(context, attrs);\n\t        init();\n\t    }\n\t\n\t    public CirclePgBar(Context context, AttributeSet attrs, int defStyleAttr) {\n\t        super(context, attrs, defStyleAttr);\n\t        init();\n\t    }\n\t\n\t\n\t    //完成相关参数初始化\n\t    private void init() {\n\t        mBackPaint = new Paint();\n\t        mBackPaint.setColor(Color.WHITE);\n\t        mBackPaint.setAntiAlias(true);\n\t        mBackPaint.setStyle(Paint.Style.STROKE);\n\t        mBackPaint.setStrokeWidth(mStrokeWidth);\n\t\n\t        mFrontPaint = new Paint();\n\t        mFrontPaint.setColor(Color.GREEN);\n\t        mFrontPaint.setAntiAlias(true);\n\t        mFrontPaint.setStyle(Paint.Style.STROKE);\n\t        mFrontPaint.setStrokeWidth(mStrokeWidth);\n\t\n\t\n\t        mTextPaint = new Paint();\n\t        mTextPaint.setColor(Color.GREEN);\n\t        mTextPaint.setAntiAlias(true);\n\t        mTextPaint.setTextSize(80);\n\t        mTextPaint.setTextAlign(Paint.Align.CENTER);\n\t    }\n\t\n\t\n\t    //重写测量大小的onMeasure方法和绘制View的核心方法onDraw()\n\t    @Override\n\t    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n\t        super.onMeasure(widthMeasureSpec, heightMeasureSpec);\n\t        mWidth = getRealSize(widthMeasureSpec);\n\t        mHeight = getRealSize(heightMeasureSpec);\n\t        setMeasuredDimension(mWidth, mHeight);\n\t\n\t    }\n\t\n\t\n\t    @Override\n\t    protected void onDraw(Canvas canvas) {\n\t        initRect();\n\t        float angle = mProgress / (float) mMax * 360;\n\t        canvas.drawCircle(mWidth / 2, mHeight / 2, mRadius, mBackPaint);\n\t        canvas.drawArc(mRect, -90, angle, false, mFrontPaint);\n\t        canvas.drawText(mProgress + \"%\", mWidth / 2 + mHalfStrokeWidth, mHeight / 2 + mHalfStrokeWidth, mTextPaint);\n\t        if (mProgress < mTargetProgress) {\n\t            mProgress += 1;\n\t            invalidate();\n\t        }\n\t\n\t    }\n\t\n\t    public int getRealSize(int measureSpec) {\n\t        int result = 1;\n\t        int mode = MeasureSpec.getMode(measureSpec);\n\t        int size = MeasureSpec.getSize(measureSpec);\n\t\n\t        if (mode == MeasureSpec.AT_MOST || mode == MeasureSpec.UNSPECIFIED) {\n\t            //自己计算\n\t            result = (int) (mRadius * 2 + mStrokeWidth);\n\t        } else {\n\t            result = size;\n\t        }\n\t\n\t        return result;\n\t    }\n\t\n\t    private void initRect() {\n\t        if (mRect == null) {\n\t            mRect = new RectF();\n\t            int viewSize = (int) (mRadius * 2);\n\t            int left = (mWidth - viewSize) / 2;\n\t            int top = (mHeight - viewSize) / 2;\n\t            int right = left + viewSize;\n\t            int bottom = top + viewSize;\n\t            mRect.set(left, top, right, bottom);\n\t        }\n\t    }\n\t\n\t\n\t}\n\n```\n\n\n- 然后在布局文件中加上：\n\n``` xml\n\n\t <com.jay.progressbardemo.CirclePgBar\n       android:layout_width=\"match_parent\"\n\t   android:layout_height=\"match_parent\"/>\n\n```\n\n### 总结\n - progressbar是Android中的常用控件，在实际开发中和动画结合较多，好的进度条可以缓解使用者焦躁的情趣，自定义圆形进度条可以自行完善，然后用到实际开发中！\n\n\n\n\n\n\n\n\n## layer-list实现阴影效果——xpleemoon\n- 为控件实现阴影效果，可以有多种方式：\n\t- 多个drawable层叠在一起（不好的实现是多个View层叠达到多个drawable的层叠效果，相对好的实现是在同一个View钟实现多个drawable的层叠）\n\t- 自定义view\n\t- Material Design中设置Z轴的方式\n\n- 本文的思路是多个drawable叠在一起，但是不额外使用View，通过layer-list可以将多个item按照顺序层叠在一起显示。首先来看效果图：\n\n![LayerShadow](https://github.com/xpleemoon/layer-list-shadow-demo/blob/master/gif/LayerShadow.gif?raw=true)\n\n- 第一个和第二个控件是用来展示layer-list实现阴影效果的基本款，而第三个控件是综合上述两个控件效果，再集合selector实现的。\n\n- 默认状态：\n\n``` xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<layer-list xmlns:android=\"http://schemas.android.com/apk/res/android\">\n    <!-- 阴影：左偏移2dp，上偏移4dp -->\n    <item\n        android:left=\"2dp\"\n        android:top=\"4dp\">\n        <shape>\n            <solid android:color=\"@android:color/holo_blue_dark\" />\n            <corners android:radius=\"10dp\" />\n        </shape>\n    </item>\n    <!-- 前景：：底偏移4dp，右偏移2dp -->\n    <item\n        android:bottom=\"4dp\"\n        android:right=\"2dp\">\n        <shape>\n            <solid android:color=\"@android:color/holo_blue_bright\" />\n            <corners android:radius=\"10dp\" />\n        </shape>\n    </item>\n</layer-list>\n```\n\n- 点击状态：\n\n``` xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<layer-list xmlns:android=\"http://schemas.android.com/apk/res/android\">\n    <!-- 为了达到点击的真实感，将原来默认状态的前景色设置为阴影，并将前景设为无透明-->\n    <item\n        android:left=\"2dp\"\n        android:top=\"4dp\">\n        <shape>\n            <solid android:color=\"@android:color/holo_blue_bright\" />\n            <corners android:radius=\"10dp\" />\n        </shape>\n    </item>\n    <item\n        android:bottom=\"4dp\"\n        android:right=\"2dp\">\n        <shape>\n            <corners android:radius=\"10dp\" />\n        </shape>\n    </item>\n</layer-list>\n```\n\n> layer-list的item可以通过以下属性设置偏移量：\n> \n> - android:top 顶部的偏移量\n> - android:bottom 底部的偏移量\n> - android:left 左边的偏移量\n> - android:right 右边的偏移量\n\n- selector，使用上述layer-list：\n\n``` xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<selector xmlns:android=\"http://schemas.android.com/apk/res/android\">\n    <item android:drawable=\"@drawable/layer_list_btn_pressed\" android:state_pressed=\"true\" />\n    <item android:drawable=\"@drawable/layer_list_btn_pressed\" android:state_selected=\"true\" />\n    <item android:drawable=\"@drawable/layer_list_btn\" />\n\n</selector>\n```\n- 最后再来看下，布局代码：\n\n``` xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:orientation=\"vertical\"\n    android:paddingBottom=\"@dimen/activity_vertical_margin\"\n    android:paddingLeft=\"@dimen/activity_horizontal_margin\"\n    android:paddingRight=\"@dimen/activity_horizontal_margin\"\n    android:paddingTop=\"@dimen/activity_vertical_margin\"\n    tools:context=\".MainActivity\">\n\n    <TextView\n        android:layout_width=\"100dp\"\n        android:layout_height=\"50dp\"\n        android:background=\"@drawable/layer_list_btn\"\n        android:clickable=\"true\"\n        android:gravity=\"center\"\n        android:text=\"默认状态\" />\n\n    <TextView\n        android:layout_width=\"100dp\"\n        android:layout_height=\"50dp\"\n        android:layout_marginTop=\"@dimen/activity_vertical_margin\"\n        android:background=\"@drawable/layer_list_btn_pressed\"\n        android:clickable=\"true\"\n        android:gravity=\"center\"\n        android:text=\"点击状态\" />\n\n    <TextView\n        android:layout_width=\"100dp\"\n        android:layout_height=\"50dp\"\n        android:layout_marginTop=\"@dimen/activity_vertical_margin\"\n        android:background=\"@drawable/selector_btn\"\n        android:clickable=\"true\"\n        android:gravity=\"center\"\n        android:text=\"点我\" />\n</LinearLayout>\n```\n- 第一个和第二个TextView分别引用了对应的layer-list（默认和点击）作为背景，第三个引用了selector\n\n- ***[源码地址](https://github.com/xpleemoon/layer-list-shadow-demo)***\n\n\n## 零部署的云服务 - 王胜\n\n> 本周的分享主题是动画，但之前7月份我已经分享过一次，[知其所以然](http://51offer.github.io/2015/07/07/%E7%A7%BB%E5%8A%A8%E7%BB%84%E5%91%A8%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB-%E7%9F%A5%E5%85%B6%E6%89%80%E4%BB%A5%E7%84%B6/) 。再加上前面几位已经对android的动画介绍的很完整了，所以我就分享另一个话题『云平台下的零部署开发网站』。\n\n### 牵扯的技能\n\n- Git\n- 任何一门后端开发语言\n\n### 搭建步骤\n\n[AZURE](https://tryappservice.azure.com/zh-cn) -> 点击 [Web应用模块](https://azure.microsoft.com/zh-cn/services/app-service/web/) -> 选择语言，点击**创建Web应用** -> 选择模板，点击**创建**，至此，应用以创建，点击页面上站点url，就能看到新创建的Web站点了。\n\n### 修改代码，Git提交自动完成部署\n\n复制创建成功页面『使用 Git 克隆或推送』里的Git地址，将初始化源码clone到本地，然后编辑代码，修改功能。完成后，直接push到远程，云平台自动完成部署。再看看网页是不是已经发生变化了。\n\n```Shell\nVictors-MPB:azure wangsheng$ git clone https://$4f743e5d-0ee0-4-231-b9ee:WSc8Szx4Rf30apo3Ky7hpw6mXAadAZYvn1zagCvMaboj7mHFyJ2vzuYn9i12@4f743e5d-0ee0-4-231-b9ee.scm.azurewebsites.net/4f743e5d-0ee0-4-231-b9ee.git\nCloning into '4f743e5d-0ee0-4-231-b9ee'...\nremote: Counting objects: 4, done.\nremote: Compressing objects: 100% (3/3), done.\nremote: Total 4 (delta 0), reused 0 (delta 0)\nUnpacking objects: 100% (4/4), done.\nChecking connectivity... done.\nVictors-MPB:azure wangsheng$ ls\n4f743e5d-0ee0-4-231-b9ee\nVictors-MPB:azure wangsheng$ cd 4f743e5d-0ee0-4-231-b9ee/\nVictors-MPB:4f743e5d-0ee0-4-231-b9ee wangsheng$ git br\n* master\nVictors-MPB:4f743e5d-0ee0-4-231-b9ee wangsheng$ git log\ncommit cf6edda65210ef7254f9bc545c778489f123620e\nAuthor: windowsazure <windowsazure>\nDate:   Fri Nov 20 03:53:00 2015 +0000\n\n    Initial Commit\nVictors-MPB:4f743e5d-0ee0-4-231-b9ee wangsheng$ ls\nfavicon.ico\tindex.php\nVictors-MPB:4f743e5d-0ee0-4-231-b9ee wangsheng$ vi index.php\nVictors-MPB:4f743e5d-0ee0-4-231-b9ee wangsheng$ git st\nOn branch master\nYour branch is up-to-date with 'origin/master'.\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n\tmodified:   index.php\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\nVictors-MPB:4f743e5d-0ee0-4-231-b9ee wangsheng$ git diff\ndiff --git a/index.php b/index.php\n<?php\nindex 712f825..50a17e7 100644\n--- a/index.php\n+++ b/index.php\n@@ -1,3 +1,4 @@\n <?php\n     echo \"Hello World\"\n-?>\n\\ No newline at end of file\n+    echo \"hack it.\"\n+?>\nVictors-MPB:4f743e5d-0ee0-4-231-b9ee wangsheng$ git ci -am \"add one line.\"\n[master 6c5551f] add one line.\n 1 file changed, 2 insertions(+), 1 deletion(-)\nVictors-MPB:4f743e5d-0ee0-4-231-b9ee wangsheng$ git push origin master\nCounting objects: 3, done.\nDelta compression using up to 4 threads.\nCompressing objects: 100% (3/3), done.\nWriting objects: 100% (3/3), 324 bytes | 0 bytes/s, done.\nTotal 3 (delta 0), reused 0 (delta 0)\nremote: Updating branch 'master'.\nremote: Updating submodules.\nremote: Preparing deployment for commit id '6c5551f090'.\nremote: Generating deployment script.\nremote: Generating deployment script for Web Site\nremote: Generated deployment script files\nremote: Running deployment command...\nremote: Handling Basic Web Site deployment.\nremote: Finished successfully.\nremote: Deployment successful.\n```\n\n对，后端开发可以如此简单快乐地开发部署！！！\n\n\n\n","slug":"Android动画","published":1,"updated":"2021-09-10T07:04:21.935Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cktfeap3g000dc2xxlhb0ffz8","content":"<h2 id=\"Android-L动画-吴明\"><a href=\"#Android-L动画-吴明\" class=\"headerlink\" title=\"Android L动画  - 吴明\"></a>Android L动画  - 吴明</h2><ul>\n<li>Touch feedback（触摸反馈）<ul>\n<li>波纹有边界</li>\n<li>波纹超出边界</li>\n<li>波纹颜色</li>\n</ul>\n</li>\n<li>Reveal effect（揭露效果）</li>\n<li>liecap<ul>\n<li>Circular Reveal动画</li>\n</ul>\n</li>\n<li>Activity transitions（Activity转换效果）<ul>\n<li>Enter（进入）<ul>\n<li>普通Transition<ul>\n<li>explode：从场景的中心移入或移出 </li>\n<li>slide：从场景的边缘移入或移出 </li>\n<li>fade：调整透明度产生渐变效果</li>\n</ul>\n</li>\n<li>Shared Elements Transition 共享元素转换:共享两个                acitivity中共同的元素<ul>\n<li>changeBounds -  改变目标视图的布局边界</li>\n<li>changeClipBounds - 裁剪目标视图边界</li>\n<li>changeTransform - 改变目标视图的缩放比例和旋转角度        changeImageTransform - 改变目标图片的大小和缩放比例</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Exit（退出）</li>\n<li><a href=\"http://pan.baidu.com/s/1o6Kngnw\" target=\"_blank\" rel=\"noopener\">demo地址</a><br><img src=\"http://7xn0ue.com1.z0.glb.clouddn.com/Untitled123.gif\" alt=\"Markdown preferences pane\"></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"objectorAnimator-动画-王进\"><a href=\"#objectorAnimator-动画-王进\" class=\"headerlink\" title=\"objectorAnimator 动画  王进\"></a>objectorAnimator 动画  王进</h2><h3 id=\"动画类型\"><a href=\"#动画类型\" class=\"headerlink\" title=\"动画类型\"></a>动画类型</h3><ul>\n<li>View Animation(Tween Animation 补间动画)<br>只能支持简单的缩放、平移、旋转、透明度等基本的动画，且有一定的局限性<br>动画时View的真正的View的属性保持不变，实际位置未改变<br>原理：提供动画的起始和结束状态信息，中间的状态根据上述类里差值器算法填充</li>\n<li>Drawable Animation（Frame Animation 帧动画）</li>\n<li>Property Animation(属性动画)<br>它更改的是对象的实际属性，</li>\n</ul>\n<h3 id=\"Property-Animation属性\"><a href=\"#Property-Animation属性\" class=\"headerlink\" title=\"Property Animation属性\"></a>Property Animation属性</h3><ul>\n<li>Duration：动画的持续时间</li>\n<li>TimeInterpolation：属性值的计算方式，如先快后慢</li>\n<li>TypeEvaluator：根据属性的开始、结束值与TimeInterpolation计算出的因子计算出当前时间的属性值</li>\n<li>Repeat Count and behavoir：重复次数与方式，如播放3次、5次、无限循环，可以此动画一直重复，或播放完时再反向播放</li>\n<li>Animation sets：动画集合，即可以同时对一个对象应用几个动画，这些动画可以同时播放也可以对不同动画设置不同开始偏移</li>\n<li>Frame refreash delay：多少时间刷新一次，即每隔多少时间计算一次属性值，默认为10ms，最终刷新时间还受系统进程调度与硬件的影响</li>\n</ul>\n<h3 id=\"Property-Animation-动画流程\"><a href=\"#Property-Animation-动画流程\" class=\"headerlink\" title=\"Property Animation 动画流程\"></a>Property Animation 动画流程</h3><p><img src=\"http://pic002.cnblogs.com/images/2011/168097/2011120119191590.png\" alt></p>\n<h3 id=\"ValueAnimator\"><a href=\"#ValueAnimator\" class=\"headerlink\" title=\"ValueAnimator\"></a>ValueAnimator</h3><p>ValueAnimator包含Property Animation动画的所有核心功能，如动画时间，开始、结束属性值，相应时间属性值计算方法等。应用Property Animation有两个步聚：</p>\n<ol>\n<li>计算属性值</li>\n<li>根据属性值执行相应的动作，如改变对象的某一属性。（需要在onAnimationUpdate中传入执行动画的对象）<pre><code>ValueAnimator animation = ValueAnimator.ofFloat(0f, 1f);\nanimation.setDuration(1000);\nanimation.addUpdateListener(new AnimatorUpdateListener() {\n@Override\npublic void onAnimationUpdate(ValueAnimator animation) {\n    Log.i(&quot;update&quot;, ((Float) animation.getAnimatedValue()).toString());\n    //这个函数中会传入ValueAnimator对象做为参数，通过这个ValueAnimator对象的getAnimatedValue()函数可以得到当前的属性值\n}\n});\nanimation.setInterpolator(new CycleInterpolator(3));\nanimation.start();\n</code></pre></li>\n</ol>\n<h3 id=\"ObjectAnimator\"><a href=\"#ObjectAnimator\" class=\"headerlink\" title=\"ObjectAnimator\"></a>ObjectAnimator</h3><p>ObjectAnimator继承自ValueAnimator，要指定一个对象及该对象的一个属性,例如</p>\n<ul>\n<li>常用方法有ofFloat()，ofInt()，ofObject()，ofArgb()，ofPropertyValuesHolder()。</li>\n<li><p>属性动画可用的属性<br>答案是：任何一切带有set开头的方法属性名字。可能我们常用的有：</p>\n<ul>\n<li>平移 translationX，translationY, X，Y。 </li>\n<li>缩放 scaleX，scaleY。 </li>\n<li>旋转 rotationX， rotationY。</li>\n<li>透明度 alpha。</li>\n</ul>\n<p>也就是说我们所有控件都有以上setTranslationX(),setScaleX(),setRotationX(),setAlpha()等方法。<br>我们不仅限于这几个属性，就拿TextView控件来说，只要是TextView有的属性都可以用来实现动画效果，比如 字体大小：“textColor”，字体颜色“textSize”等。</p>\n<blockquote>\n<p>限制：对象应该有一个setter函数：set<propertyname>（驼峰命名法）及要有相应属性的getter方法：get<propertyname><br>且应返回值类型应与相应的setter方法的参数类型一致。<br>如果上述条件不满足，则不能用ObjectAnimator，应用ValueAnimator代替。</propertyname></propertyname></p>\n</blockquote>\n</li>\n</ul>\n<pre><code> ObjectAnimator animator = ObjectAnimator.ofFloat(imageView, &#39;alpha&#39;, 1.0f, 0.3f, 1.0F);\n        animator.setDuration(2000);//动画时间\n        animator.setInterpolator(new BounceInterpolator());//动画插值\n        animator.setRepeatCount(-1);//设置动画重复次数\n        animator.setRepeatMode(ValueAnimator.RESTART);//动画重复模式\n        animator.setStartDelay(1000);//动画延时执行\n        animator.start();//启动动画\n</code></pre><blockquote>\n<p>根据应用动画的对象或属性的不同，可能需要在onAnimationUpdate函数中调用invalidate()函数刷新视图。</p>\n</blockquote>\n<h3 id=\"组合动画\"><a href=\"#组合动画\" class=\"headerlink\" title=\"组合动画\"></a>组合动画</h3><ul>\n<li><p><strong>组合动画1–AnimatorSet的使用</strong><br>这个类提供了一个play()方法，如果我们向这个方法中传入一个Animator对象(ValueAnimator或ObjectAnimator)将会返回一个AnimatorSet.Builder的实例，AnimatorSet.Builder中包括以下四个方法：</p>\n<ul>\n<li>after(Animator anim) 将现有动画插入到传入的动画之后执行</li>\n<li>after(long delay) 将现有动画延迟指定毫秒后执行</li>\n<li>before(Animator anim) 将现有动画插入到传入的动画之前执行</li>\n<li>with(Animator anim) 将现有动画和传入的动画同时执行</li>\n</ul>\n<blockquote>\n<p>Android 除了提供play(),还有playSequentially(),playTogether() 可供使用，可传入一个或者多个动画对象（，隔开），或者动画集合</p>\n</blockquote>\n</li>\n</ul>\n<pre><code>   ObjectAnimator animator = ObjectAnimator.ofInt(container, &quot;backgroundColor&quot;, 0xFFFF0000, 0xFFFF00FF);\n                ObjectAnimator animator1 = ObjectAnimator.ofFloat(view, &quot;translationX&quot;, 0.0f, 200.0f, 0f);\n                ObjectAnimator animator2 = ObjectAnimator.ofFloat(view, &quot;scaleX&quot;, 1.0f, 2.0f);\n                ObjectAnimator animator3 = ObjectAnimator.ofFloat(view, &quot;rotationX&quot;, 0.0f, 90.0f, 0.0F);\n                ObjectAnimator animator4 = ObjectAnimator.ofFloat(view, &quot;alpha&quot;, 1.0f, 0.2f, 1.0F);\n\n                //组合动画方式1\n                AnimatorSet set = new AnimatorSet();\n               ((set.play(animator).with(animator1).before(animator2)).before(animator3)).after(animator4);\n                set.setDuration(5000);\n                set.start();\n</code></pre><ul>\n<li><p><strong>组合动画2–PropertyValuesHolder的使用</strong><br>使用方法ObjectAnimator.ofPropertyValuesHolder(Object target,PropertyValuesHolder… values)；第一个参数是动画的目标对象，之后的参数是PropertyValuesHolder类的实例，可以有多个这样的实例。代码如下：</p>\n<pre><code>PropertyValuesHolder valuesHolder = PropertyValuesHolder.ofFloat(&quot;translationX&quot;, 0.0f, 300.0f);\n              PropertyValuesHolder valuesHolder1 = PropertyValuesHolder.ofFloat(&quot;scaleX&quot;, 1.0f, 1.5f);\n              PropertyValuesHolder valuesHolder2 = PropertyValuesHolder.ofFloat(&quot;rotationX&quot;, 0.0f, 90.0f, 0.0F);\n              PropertyValuesHolder valuesHolder3 = PropertyValuesHolder.ofFloat(&quot;alpha&quot;, 1.0f, 0.3f, 1.0F);\n\n              ObjectAnimator objectAnimator = ObjectAnimator.ofPropertyValuesHolder(view, valuesHolder, valuesHolder1, valuesHolder2, valuesHolder3);\n              objectAnimator.setDuration(2000).start();\n              //类似于AnimatorSet.playTogether(Animator... items);\n</code></pre></li>\n<li><strong>组合动画3-ViewPropertyAnimator（多属性动画）</strong><pre><code>ViewPropertyAnimator animator5 = imageView.animate();\nanimator5.translationX(200).scaleX(2).setDuration(2000).start();\n</code></pre><blockquote>\n<p>注意：使用ViewPropertyAnimator类需要API&gt;=12</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"动画监听\"><a href=\"#动画监听\" class=\"headerlink\" title=\"动画监听\"></a>动画监听</h3><ul>\n<li>animator.addListener(new Animator.AnimatorListener(){});//监听动画开始，结束，取消，重复（四种都包括）</li>\n<li>animator.addListener(new  AnimatorListenerAdapter(){});<br>推荐，可代替AnimatorListener，需要监听动画开始，结束，取消，重复那种就直接实现那种方法就行<br>其实AnimatorListenerAdapter的源码只是一个实现了AnimatorListener接口的抽象类而已</li>\n<li>animator.addUpdateListener(new  ValueAnimator.AnimatorUpdateListener(){});<br>更加精确的方法来时刻监听当前动画的执行情况，可以读取到动画的每个更新值了<pre><code>animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n          @Override\n          public void onAnimationUpdate(ValueAnimator animation) {\n              float value = (float) animation.getAnimatedValue();\n              //可以根据自己的需要来获取动画更新值。\n              Log.e(&#39;TAG&#39;, &#39;the animation value is &#39; + value);\n          }\n      });\n</code></pre></li>\n</ul>\n<h3 id=\"Keyframes\"><a href=\"#Keyframes\" class=\"headerlink\" title=\"Keyframes\"></a>Keyframes</h3><p>keyFrame是一个 时间/值 对，通过它可以定义一个在特定时间的特定状态，即关键帧，而且在两个keyFrame之间可以定义不同的Interpolator，就好像多个动画的拼接，第一个动画的结束点是第二个动画的开始点。KeyFrame是抽象类，要通过ofInt(),ofFloat(),ofObject()获得适当的KeyFrame，然后通过PropertyValuesHolder.ofKeyframe获得PropertyValuesHolder对象，如以下例子：</p>\n<pre><code>/*\n*   动画效果：btn对象的width属性值使其：\n*   开始时 Width=400\n*   动画开始1/4时 Width=200\n*   动画开始1/2时 Width=400\n*   动画开始3/4时 Width=100\n*   动画结束时 Width=500\n*/\nKeyframe kf0 = Keyframe.ofInt(0, 400);\nKeyframe kf1 = Keyframe.ofInt(0.25f, 200);\nKeyframe kf2 = Keyframe.ofInt(0.5f, 400);\nKeyframe kf4 = Keyframe.ofInt(0.75f, 100);\nKeyframe kf3 = Keyframe.ofInt(1f, 500);\nPropertyValuesHolder pvhRotation = PropertyValuesHolder.ofKeyframe(&quot;width&quot;, kf0, kf1, kf2, kf4, kf3);\nObjectAnimator rotationAnim = ObjectAnimator.ofPropertyValuesHolder(btn2, pvhRotation);\nrotationAnim.setDuration(2000);\n</code></pre><h3 id=\"Property-Animation在XML中使用\"><a href=\"#Property-Animation在XML中使用\" class=\"headerlink\" title=\"Property Animation在XML中使用\"></a>Property Animation在XML中使用</h3><ul>\n<li><p>xml文件放在res/animator/中</p>\n<pre><code>&lt;set xmlns:android=&#39;http://schemas.android.com/apk/res/android&#39;\n  android:duration=&#39;2000&#39;\n  android:ordering=&#39;sequentially&#39;&gt;&lt;!--动画执行顺序 sequentially：顺序执行；together：同时执行。 --&gt;\n\n  &lt;objectAnimator\n      android:propertyName=&#39;translationX&#39;\n      android:valueFrom=&#39;0&#39;\n      android:valueTo=&#39;200&#39;\n      android:valueType=&#39;floatType&#39; /&gt;\n\n  &lt;set android:ordering=&#39;together&#39;&gt;\n      &lt;objectAnimator\n          android:propertyName=&#39;scaleX&#39;\n          android:valueFrom=&#39;1&#39;\n          android:valueTo=&#39;2&#39;\n          android:valueType=&#39;floatType&#39; /&gt;\n      &lt;objectAnimator\n          android:propertyName=&#39;rotationX&#39;\n          android:valueFrom=&#39;0&#39;\n          android:valueTo=&#39;90&#39;\n          android:valueType=&#39;floatType&#39; /&gt;&lt;!--动画值的类型--&gt;\n\n  &lt;/set&gt;\n</code></pre></li>\n<li>通过AnimatorInflater.loadAnimator方法加载xml动画返回一个Animator的对象，然后调用setTarget方法给动画设置对象调用哪个start启动动画即可完成xml动画效果<pre><code>Animator animator = AnimatorInflater.loadAnimator(context, R.animator.anim_file);\nanimator.setTarget(view);  \nanimator.start();\n</code></pre></li>\n</ul>\n<h2 id=\"花花绿绿的ProgressBar-杨俊构\"><a href=\"#花花绿绿的ProgressBar-杨俊构\" class=\"headerlink\" title=\"花花绿绿的ProgressBar  杨俊构\"></a>花花绿绿的ProgressBar  杨俊构</h2><p><em>参考<a href=\"http://www.runoob.com/w3cnote/android-tutorial-progressbar.html\" target=\"_blank\" rel=\"noopener\">Android 基础入门教程</a></em></p>\n<ul>\n<li>ProgressBar(进度条)是Android基本UI控件，ProgressBar的应用场景很多，比如 用户登录时，后台在发请求，以及等待服务器返回信息，这个时候会用到进度条；或者当在进行一些比较 耗时的操作，需要等待一段较长的时间，这个时候如果没有提示，用户可能会以为程序Carsh或者手机死机 了，这样会大大降低用户体验，所以在需要进行耗时操作的地方，添加上进度条，让用户知道当前的程序 在执行中，也可以直观的告诉用户当前任务的执行进度等！使用进度条可以给我带来这样的便利！ </li>\n</ul>\n<ul>\n<li>ProgressBar<a href=\"http://androiddoc.qiniudn.com/reference/android/widget/ProgressBar.html\" target=\"_blank\" rel=\"noopener\">官方API文档</a>，ProgressBar继承与View类，直接子类有AbsSeekBar和ContentLoadingProgressBar， 其中AbsSeekBar的子类有SeekBar和RatingBar，可见这二者也是基于ProgressBar实现的</li>\n</ul>\n<p><img src=\"http://7xohph.com1.z0.glb.clouddn.com/46760225.jpg\" alt></p>\n<ul>\n<li>常用属性详解：</li>\n</ul>\n<blockquote>\n<ul>\n<li>android:max：进度条的最大值</li>\n<li>android:progress：进度条已完成进度值</li>\n<li>android:progressDrawable：设置轨道对应的Drawable对象</li>\n<li>android:indeterminate：如果设置成true，则进度条不精确显示进度</li>\n<li>android:indeterminateDrawable：设置不显示进度的进度条的Drawable对象</li>\n<li>android:indeterminateDuration：设置不精确显示进度的持续时间</li>\n<li>android:secondaryProgress：二级进度条，类似于视频播放的一条是当前播放进度，一条是缓冲进度，前者通过progress属性进行设置！</li>\n</ul>\n</blockquote>\n<ul>\n<li>对应的再Java中我们可调用下述方法：</li>\n</ul>\n<blockquote>\n<ul>\n<li>getMax()：返回这个进度条的范围的上限</li>\n<li>getProgress()：返回进度</li>\n<li>getSecondaryProgress()：返回次要进度</li>\n<li>incrementProgressBy(int diff)：指定增加的进度</li>\n<li>isIndeterminate()：指示进度条是否在不确定模式下</li>\n<li>setIndeterminate(boolean indeterminate)：设置不确定模式下</li>\n</ul>\n</blockquote>\n<ul>\n<li>系统默认进度条使用实例：</li>\n</ul>\n<p><img src=\"http://7xohph.com1.z0.glb.clouddn.com/34906854.jpg\" alt></p>\n<h3 id=\"耀眼的IOS的ProgressBar-，参看开源中国IOS代码库\"><a href=\"#耀眼的IOS的ProgressBar-，参看开源中国IOS代码库\" class=\"headerlink\" title=\"耀眼的IOS的ProgressBar ，参看开源中国IOS代码库\"></a>耀眼的IOS的ProgressBar ，参看<a href=\"http://www.oschina.net/ios/codingList/373/ios-progress\" target=\"_blank\" rel=\"noopener\">开源中国IOS代码库</a></h3><h3 id=\"圆形进度条\"><a href=\"#圆形进度条\" class=\"headerlink\" title=\"圆形进度条\"></a>圆形进度条</h3><blockquote>\n<p>网上一个简单的自定义圆形进度条！代码还是比较简单，容易理解，有兴趣可以看看，或者进行相关扩展~</p>\n</blockquote>\n<p><img src=\"http://7xohph.com1.z0.glb.clouddn.com/17272953.jpg\" alt></p>\n<ul>\n<li>实现代码：自定义View类：</li>\n</ul>\n<pre><code class=\"java\">\n    /**\n     * Created by Jay on 2015/8/5 0005.\n     */\n    public class CirclePgBar extends View {\n\n\n        private Paint mBackPaint;\n        private Paint mFrontPaint;\n        private Paint mTextPaint;\n        private float mStrokeWidth = 50;\n        private float mHalfStrokeWidth = mStrokeWidth / 2;\n        private float mRadius = 200;\n        private RectF mRect;\n        private int mProgress = 0;\n        //目标值，想改多少就改多少\n        private int mTargetProgress = 90;\n        private int mMax = 100;\n        private int mWidth;\n        private int mHeight;\n\n\n        public CirclePgBar(Context context) {\n            super(context);\n            init();\n        }\n\n        public CirclePgBar(Context context, AttributeSet attrs) {\n            super(context, attrs);\n            init();\n        }\n\n        public CirclePgBar(Context context, AttributeSet attrs, int defStyleAttr) {\n            super(context, attrs, defStyleAttr);\n            init();\n        }\n\n\n        //完成相关参数初始化\n        private void init() {\n            mBackPaint = new Paint();\n            mBackPaint.setColor(Color.WHITE);\n            mBackPaint.setAntiAlias(true);\n            mBackPaint.setStyle(Paint.Style.STROKE);\n            mBackPaint.setStrokeWidth(mStrokeWidth);\n\n            mFrontPaint = new Paint();\n            mFrontPaint.setColor(Color.GREEN);\n            mFrontPaint.setAntiAlias(true);\n            mFrontPaint.setStyle(Paint.Style.STROKE);\n            mFrontPaint.setStrokeWidth(mStrokeWidth);\n\n\n            mTextPaint = new Paint();\n            mTextPaint.setColor(Color.GREEN);\n            mTextPaint.setAntiAlias(true);\n            mTextPaint.setTextSize(80);\n            mTextPaint.setTextAlign(Paint.Align.CENTER);\n        }\n\n\n        //重写测量大小的onMeasure方法和绘制View的核心方法onDraw()\n        @Override\n        protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n            super.onMeasure(widthMeasureSpec, heightMeasureSpec);\n            mWidth = getRealSize(widthMeasureSpec);\n            mHeight = getRealSize(heightMeasureSpec);\n            setMeasuredDimension(mWidth, mHeight);\n\n        }\n\n\n        @Override\n        protected void onDraw(Canvas canvas) {\n            initRect();\n            float angle = mProgress / (float) mMax * 360;\n            canvas.drawCircle(mWidth / 2, mHeight / 2, mRadius, mBackPaint);\n            canvas.drawArc(mRect, -90, angle, false, mFrontPaint);\n            canvas.drawText(mProgress + &quot;%&quot;, mWidth / 2 + mHalfStrokeWidth, mHeight / 2 + mHalfStrokeWidth, mTextPaint);\n            if (mProgress &lt; mTargetProgress) {\n                mProgress += 1;\n                invalidate();\n            }\n\n        }\n\n        public int getRealSize(int measureSpec) {\n            int result = 1;\n            int mode = MeasureSpec.getMode(measureSpec);\n            int size = MeasureSpec.getSize(measureSpec);\n\n            if (mode == MeasureSpec.AT_MOST || mode == MeasureSpec.UNSPECIFIED) {\n                //自己计算\n                result = (int) (mRadius * 2 + mStrokeWidth);\n            } else {\n                result = size;\n            }\n\n            return result;\n        }\n\n        private void initRect() {\n            if (mRect == null) {\n                mRect = new RectF();\n                int viewSize = (int) (mRadius * 2);\n                int left = (mWidth - viewSize) / 2;\n                int top = (mHeight - viewSize) / 2;\n                int right = left + viewSize;\n                int bottom = top + viewSize;\n                mRect.set(left, top, right, bottom);\n            }\n        }\n\n\n    }\n</code></pre>\n<ul>\n<li>然后在布局文件中加上：</li>\n</ul>\n<pre><code class=\"xml\">\n     &lt;com.jay.progressbardemo.CirclePgBar\n       android:layout_width=&quot;match_parent&quot;\n       android:layout_height=&quot;match_parent&quot;/&gt;\n</code></pre>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li>progressbar是Android中的常用控件，在实际开发中和动画结合较多，好的进度条可以缓解使用者焦躁的情趣，自定义圆形进度条可以自行完善，然后用到实际开发中！</li>\n</ul>\n<h2 id=\"layer-list实现阴影效果——xpleemoon\"><a href=\"#layer-list实现阴影效果——xpleemoon\" class=\"headerlink\" title=\"layer-list实现阴影效果——xpleemoon\"></a>layer-list实现阴影效果——xpleemoon</h2><ul>\n<li><p>为控件实现阴影效果，可以有多种方式：</p>\n<ul>\n<li>多个drawable层叠在一起（不好的实现是多个View层叠达到多个drawable的层叠效果，相对好的实现是在同一个View钟实现多个drawable的层叠）</li>\n<li>自定义view</li>\n<li>Material Design中设置Z轴的方式</li>\n</ul>\n</li>\n<li><p>本文的思路是多个drawable叠在一起，但是不额外使用View，通过layer-list可以将多个item按照顺序层叠在一起显示。首先来看效果图：</p>\n</li>\n</ul>\n<p><img src=\"https://github.com/xpleemoon/layer-list-shadow-demo/blob/master/gif/LayerShadow.gif?raw=true\" alt=\"LayerShadow\"></p>\n<ul>\n<li><p>第一个和第二个控件是用来展示layer-list实现阴影效果的基本款，而第三个控件是综合上述两个控件效果，再集合selector实现的。</p>\n</li>\n<li><p>默认状态：</p>\n</li>\n</ul>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;layer-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;\n    &lt;!-- 阴影：左偏移2dp，上偏移4dp --&gt;\n    &lt;item\n        android:left=&quot;2dp&quot;\n        android:top=&quot;4dp&quot;&gt;\n        &lt;shape&gt;\n            &lt;solid android:color=&quot;@android:color/holo_blue_dark&quot; /&gt;\n            &lt;corners android:radius=&quot;10dp&quot; /&gt;\n        &lt;/shape&gt;\n    &lt;/item&gt;\n    &lt;!-- 前景：：底偏移4dp，右偏移2dp --&gt;\n    &lt;item\n        android:bottom=&quot;4dp&quot;\n        android:right=&quot;2dp&quot;&gt;\n        &lt;shape&gt;\n            &lt;solid android:color=&quot;@android:color/holo_blue_bright&quot; /&gt;\n            &lt;corners android:radius=&quot;10dp&quot; /&gt;\n        &lt;/shape&gt;\n    &lt;/item&gt;\n&lt;/layer-list&gt;\n</code></pre>\n<ul>\n<li>点击状态：</li>\n</ul>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;layer-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;\n    &lt;!-- 为了达到点击的真实感，将原来默认状态的前景色设置为阴影，并将前景设为无透明--&gt;\n    &lt;item\n        android:left=&quot;2dp&quot;\n        android:top=&quot;4dp&quot;&gt;\n        &lt;shape&gt;\n            &lt;solid android:color=&quot;@android:color/holo_blue_bright&quot; /&gt;\n            &lt;corners android:radius=&quot;10dp&quot; /&gt;\n        &lt;/shape&gt;\n    &lt;/item&gt;\n    &lt;item\n        android:bottom=&quot;4dp&quot;\n        android:right=&quot;2dp&quot;&gt;\n        &lt;shape&gt;\n            &lt;corners android:radius=&quot;10dp&quot; /&gt;\n        &lt;/shape&gt;\n    &lt;/item&gt;\n&lt;/layer-list&gt;\n</code></pre>\n<blockquote>\n<p>layer-list的item可以通过以下属性设置偏移量：</p>\n<ul>\n<li>android:top 顶部的偏移量</li>\n<li>android:bottom 底部的偏移量</li>\n<li>android:left 左边的偏移量</li>\n<li>android:right 右边的偏移量</li>\n</ul>\n</blockquote>\n<ul>\n<li>selector，使用上述layer-list：</li>\n</ul>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;\n    &lt;item android:drawable=&quot;@drawable/layer_list_btn_pressed&quot; android:state_pressed=&quot;true&quot; /&gt;\n    &lt;item android:drawable=&quot;@drawable/layer_list_btn_pressed&quot; android:state_selected=&quot;true&quot; /&gt;\n    &lt;item android:drawable=&quot;@drawable/layer_list_btn&quot; /&gt;\n\n&lt;/selector&gt;\n</code></pre>\n<ul>\n<li>最后再来看下，布局代码：</li>\n</ul>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n    xmlns:tools=&quot;http://schemas.android.com/tools&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;match_parent&quot;\n    android:orientation=&quot;vertical&quot;\n    android:paddingBottom=&quot;@dimen/activity_vertical_margin&quot;\n    android:paddingLeft=&quot;@dimen/activity_horizontal_margin&quot;\n    android:paddingRight=&quot;@dimen/activity_horizontal_margin&quot;\n    android:paddingTop=&quot;@dimen/activity_vertical_margin&quot;\n    tools:context=&quot;.MainActivity&quot;&gt;\n\n    &lt;TextView\n        android:layout_width=&quot;100dp&quot;\n        android:layout_height=&quot;50dp&quot;\n        android:background=&quot;@drawable/layer_list_btn&quot;\n        android:clickable=&quot;true&quot;\n        android:gravity=&quot;center&quot;\n        android:text=&quot;默认状态&quot; /&gt;\n\n    &lt;TextView\n        android:layout_width=&quot;100dp&quot;\n        android:layout_height=&quot;50dp&quot;\n        android:layout_marginTop=&quot;@dimen/activity_vertical_margin&quot;\n        android:background=&quot;@drawable/layer_list_btn_pressed&quot;\n        android:clickable=&quot;true&quot;\n        android:gravity=&quot;center&quot;\n        android:text=&quot;点击状态&quot; /&gt;\n\n    &lt;TextView\n        android:layout_width=&quot;100dp&quot;\n        android:layout_height=&quot;50dp&quot;\n        android:layout_marginTop=&quot;@dimen/activity_vertical_margin&quot;\n        android:background=&quot;@drawable/selector_btn&quot;\n        android:clickable=&quot;true&quot;\n        android:gravity=&quot;center&quot;\n        android:text=&quot;点我&quot; /&gt;\n&lt;/LinearLayout&gt;\n</code></pre>\n<ul>\n<li><p>第一个和第二个TextView分别引用了对应的layer-list（默认和点击）作为背景，第三个引用了selector</p>\n</li>\n<li><p><strong><em><a href=\"https://github.com/xpleemoon/layer-list-shadow-demo\" target=\"_blank\" rel=\"noopener\">源码地址</a></em></strong></p>\n</li>\n</ul>\n<h2 id=\"零部署的云服务-王胜\"><a href=\"#零部署的云服务-王胜\" class=\"headerlink\" title=\"零部署的云服务 - 王胜\"></a>零部署的云服务 - 王胜</h2><blockquote>\n<p>本周的分享主题是动画，但之前7月份我已经分享过一次，<a href=\"http://51offer.github.io/2015/07/07/%E7%A7%BB%E5%8A%A8%E7%BB%84%E5%91%A8%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB-%E7%9F%A5%E5%85%B6%E6%89%80%E4%BB%A5%E7%84%B6/\" target=\"_blank\" rel=\"noopener\">知其所以然</a> 。再加上前面几位已经对android的动画介绍的很完整了，所以我就分享另一个话题『云平台下的零部署开发网站』。</p>\n</blockquote>\n<h3 id=\"牵扯的技能\"><a href=\"#牵扯的技能\" class=\"headerlink\" title=\"牵扯的技能\"></a>牵扯的技能</h3><ul>\n<li>Git</li>\n<li>任何一门后端开发语言</li>\n</ul>\n<h3 id=\"搭建步骤\"><a href=\"#搭建步骤\" class=\"headerlink\" title=\"搭建步骤\"></a>搭建步骤</h3><p><a href=\"https://tryappservice.azure.com/zh-cn\" target=\"_blank\" rel=\"noopener\">AZURE</a> -&gt; 点击 <a href=\"https://azure.microsoft.com/zh-cn/services/app-service/web/\" target=\"_blank\" rel=\"noopener\">Web应用模块</a> -&gt; 选择语言，点击<strong>创建Web应用</strong> -&gt; 选择模板，点击<strong>创建</strong>，至此，应用以创建，点击页面上站点url，就能看到新创建的Web站点了。</p>\n<h3 id=\"修改代码，Git提交自动完成部署\"><a href=\"#修改代码，Git提交自动完成部署\" class=\"headerlink\" title=\"修改代码，Git提交自动完成部署\"></a>修改代码，Git提交自动完成部署</h3><p>复制创建成功页面『使用 Git 克隆或推送』里的Git地址，将初始化源码clone到本地，然后编辑代码，修改功能。完成后，直接push到远程，云平台自动完成部署。再看看网页是不是已经发生变化了。</p>\n<pre><code class=\"Shell\">Victors-MPB:azure wangsheng$ git clone https://$4f743e5d-0ee0-4-231-b9ee:WSc8Szx4Rf30apo3Ky7hpw6mXAadAZYvn1zagCvMaboj7mHFyJ2vzuYn9i12@4f743e5d-0ee0-4-231-b9ee.scm.azurewebsites.net/4f743e5d-0ee0-4-231-b9ee.git\nCloning into &#39;4f743e5d-0ee0-4-231-b9ee&#39;...\nremote: Counting objects: 4, done.\nremote: Compressing objects: 100% (3/3), done.\nremote: Total 4 (delta 0), reused 0 (delta 0)\nUnpacking objects: 100% (4/4), done.\nChecking connectivity... done.\nVictors-MPB:azure wangsheng$ ls\n4f743e5d-0ee0-4-231-b9ee\nVictors-MPB:azure wangsheng$ cd 4f743e5d-0ee0-4-231-b9ee/\nVictors-MPB:4f743e5d-0ee0-4-231-b9ee wangsheng$ git br\n* master\nVictors-MPB:4f743e5d-0ee0-4-231-b9ee wangsheng$ git log\ncommit cf6edda65210ef7254f9bc545c778489f123620e\nAuthor: windowsazure &lt;windowsazure&gt;\nDate:   Fri Nov 20 03:53:00 2015 +0000\n\n    Initial Commit\nVictors-MPB:4f743e5d-0ee0-4-231-b9ee wangsheng$ ls\nfavicon.ico    index.php\nVictors-MPB:4f743e5d-0ee0-4-231-b9ee wangsheng$ vi index.php\nVictors-MPB:4f743e5d-0ee0-4-231-b9ee wangsheng$ git st\nOn branch master\nYour branch is up-to-date with &#39;origin/master&#39;.\nChanges not staged for commit:\n  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)\n  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)\n\n    modified:   index.php\n\nno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)\nVictors-MPB:4f743e5d-0ee0-4-231-b9ee wangsheng$ git diff\ndiff --git a/index.php b/index.php\n&lt;?php\nindex 712f825..50a17e7 100644\n--- a/index.php\n+++ b/index.php\n@@ -1,3 +1,4 @@\n &lt;?php\n     echo &quot;Hello World&quot;\n-?&gt;\n\\ No newline at end of file\n+    echo &quot;hack it.&quot;\n+?&gt;\nVictors-MPB:4f743e5d-0ee0-4-231-b9ee wangsheng$ git ci -am &quot;add one line.&quot;\n[master 6c5551f] add one line.\n 1 file changed, 2 insertions(+), 1 deletion(-)\nVictors-MPB:4f743e5d-0ee0-4-231-b9ee wangsheng$ git push origin master\nCounting objects: 3, done.\nDelta compression using up to 4 threads.\nCompressing objects: 100% (3/3), done.\nWriting objects: 100% (3/3), 324 bytes | 0 bytes/s, done.\nTotal 3 (delta 0), reused 0 (delta 0)\nremote: Updating branch &#39;master&#39;.\nremote: Updating submodules.\nremote: Preparing deployment for commit id &#39;6c5551f090&#39;.\nremote: Generating deployment script.\nremote: Generating deployment script for Web Site\nremote: Generated deployment script files\nremote: Running deployment command...\nremote: Handling Basic Web Site deployment.\nremote: Finished successfully.\nremote: Deployment successful.\n</code></pre>\n<p>对，后端开发可以如此简单快乐地开发部署！！！</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Android-L动画-吴明\"><a href=\"#Android-L动画-吴明\" class=\"headerlink\" title=\"Android L动画  - 吴明\"></a>Android L动画  - 吴明</h2><ul>\n<li>Touch feedback（触摸反馈）<ul>\n<li>波纹有边界</li>\n<li>波纹超出边界</li>\n<li>波纹颜色</li>\n</ul>\n</li>\n<li>Reveal effect（揭露效果）</li>\n<li>liecap<ul>\n<li>Circular Reveal动画</li>\n</ul>\n</li>\n<li>Activity transitions（Activity转换效果）<ul>\n<li>Enter（进入）<ul>\n<li>普通Transition<ul>\n<li>explode：从场景的中心移入或移出 </li>\n<li>slide：从场景的边缘移入或移出 </li>\n<li>fade：调整透明度产生渐变效果</li>\n</ul>\n</li>\n<li>Shared Elements Transition 共享元素转换:共享两个                acitivity中共同的元素<ul>\n<li>changeBounds -  改变目标视图的布局边界</li>\n<li>changeClipBounds - 裁剪目标视图边界</li>\n<li>changeTransform - 改变目标视图的缩放比例和旋转角度        changeImageTransform - 改变目标图片的大小和缩放比例</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Exit（退出）</li>\n<li><a href=\"http://pan.baidu.com/s/1o6Kngnw\" target=\"_blank\" rel=\"noopener\">demo地址</a><br><img src=\"http://7xn0ue.com1.z0.glb.clouddn.com/Untitled123.gif\" alt=\"Markdown preferences pane\"></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"objectorAnimator-动画-王进\"><a href=\"#objectorAnimator-动画-王进\" class=\"headerlink\" title=\"objectorAnimator 动画  王进\"></a>objectorAnimator 动画  王进</h2><h3 id=\"动画类型\"><a href=\"#动画类型\" class=\"headerlink\" title=\"动画类型\"></a>动画类型</h3><ul>\n<li>View Animation(Tween Animation 补间动画)<br>只能支持简单的缩放、平移、旋转、透明度等基本的动画，且有一定的局限性<br>动画时View的真正的View的属性保持不变，实际位置未改变<br>原理：提供动画的起始和结束状态信息，中间的状态根据上述类里差值器算法填充</li>\n<li>Drawable Animation（Frame Animation 帧动画）</li>\n<li>Property Animation(属性动画)<br>它更改的是对象的实际属性，</li>\n</ul>\n<h3 id=\"Property-Animation属性\"><a href=\"#Property-Animation属性\" class=\"headerlink\" title=\"Property Animation属性\"></a>Property Animation属性</h3><ul>\n<li>Duration：动画的持续时间</li>\n<li>TimeInterpolation：属性值的计算方式，如先快后慢</li>\n<li>TypeEvaluator：根据属性的开始、结束值与TimeInterpolation计算出的因子计算出当前时间的属性值</li>\n<li>Repeat Count and behavoir：重复次数与方式，如播放3次、5次、无限循环，可以此动画一直重复，或播放完时再反向播放</li>\n<li>Animation sets：动画集合，即可以同时对一个对象应用几个动画，这些动画可以同时播放也可以对不同动画设置不同开始偏移</li>\n<li>Frame refreash delay：多少时间刷新一次，即每隔多少时间计算一次属性值，默认为10ms，最终刷新时间还受系统进程调度与硬件的影响</li>\n</ul>\n<h3 id=\"Property-Animation-动画流程\"><a href=\"#Property-Animation-动画流程\" class=\"headerlink\" title=\"Property Animation 动画流程\"></a>Property Animation 动画流程</h3><p><img src=\"http://pic002.cnblogs.com/images/2011/168097/2011120119191590.png\" alt></p>\n<h3 id=\"ValueAnimator\"><a href=\"#ValueAnimator\" class=\"headerlink\" title=\"ValueAnimator\"></a>ValueAnimator</h3><p>ValueAnimator包含Property Animation动画的所有核心功能，如动画时间，开始、结束属性值，相应时间属性值计算方法等。应用Property Animation有两个步聚：</p>\n<ol>\n<li>计算属性值</li>\n<li>根据属性值执行相应的动作，如改变对象的某一属性。（需要在onAnimationUpdate中传入执行动画的对象）<pre><code>ValueAnimator animation = ValueAnimator.ofFloat(0f, 1f);\nanimation.setDuration(1000);\nanimation.addUpdateListener(new AnimatorUpdateListener() {\n@Override\npublic void onAnimationUpdate(ValueAnimator animation) {\n    Log.i(&quot;update&quot;, ((Float) animation.getAnimatedValue()).toString());\n    //这个函数中会传入ValueAnimator对象做为参数，通过这个ValueAnimator对象的getAnimatedValue()函数可以得到当前的属性值\n}\n});\nanimation.setInterpolator(new CycleInterpolator(3));\nanimation.start();\n</code></pre></li>\n</ol>\n<h3 id=\"ObjectAnimator\"><a href=\"#ObjectAnimator\" class=\"headerlink\" title=\"ObjectAnimator\"></a>ObjectAnimator</h3><p>ObjectAnimator继承自ValueAnimator，要指定一个对象及该对象的一个属性,例如</p>\n<ul>\n<li>常用方法有ofFloat()，ofInt()，ofObject()，ofArgb()，ofPropertyValuesHolder()。</li>\n<li><p>属性动画可用的属性<br>答案是：任何一切带有set开头的方法属性名字。可能我们常用的有：</p>\n<ul>\n<li>平移 translationX，translationY, X，Y。 </li>\n<li>缩放 scaleX，scaleY。 </li>\n<li>旋转 rotationX， rotationY。</li>\n<li>透明度 alpha。</li>\n</ul>\n<p>也就是说我们所有控件都有以上setTranslationX(),setScaleX(),setRotationX(),setAlpha()等方法。<br>我们不仅限于这几个属性，就拿TextView控件来说，只要是TextView有的属性都可以用来实现动画效果，比如 字体大小：“textColor”，字体颜色“textSize”等。</p>\n<blockquote>\n<p>限制：对象应该有一个setter函数：set<propertyname>（驼峰命名法）及要有相应属性的getter方法：get<propertyname><br>且应返回值类型应与相应的setter方法的参数类型一致。<br>如果上述条件不满足，则不能用ObjectAnimator，应用ValueAnimator代替。</propertyname></propertyname></p>\n</blockquote>\n</li>\n</ul>\n<pre><code> ObjectAnimator animator = ObjectAnimator.ofFloat(imageView, &#39;alpha&#39;, 1.0f, 0.3f, 1.0F);\n        animator.setDuration(2000);//动画时间\n        animator.setInterpolator(new BounceInterpolator());//动画插值\n        animator.setRepeatCount(-1);//设置动画重复次数\n        animator.setRepeatMode(ValueAnimator.RESTART);//动画重复模式\n        animator.setStartDelay(1000);//动画延时执行\n        animator.start();//启动动画\n</code></pre><blockquote>\n<p>根据应用动画的对象或属性的不同，可能需要在onAnimationUpdate函数中调用invalidate()函数刷新视图。</p>\n</blockquote>\n<h3 id=\"组合动画\"><a href=\"#组合动画\" class=\"headerlink\" title=\"组合动画\"></a>组合动画</h3><ul>\n<li><p><strong>组合动画1–AnimatorSet的使用</strong><br>这个类提供了一个play()方法，如果我们向这个方法中传入一个Animator对象(ValueAnimator或ObjectAnimator)将会返回一个AnimatorSet.Builder的实例，AnimatorSet.Builder中包括以下四个方法：</p>\n<ul>\n<li>after(Animator anim) 将现有动画插入到传入的动画之后执行</li>\n<li>after(long delay) 将现有动画延迟指定毫秒后执行</li>\n<li>before(Animator anim) 将现有动画插入到传入的动画之前执行</li>\n<li>with(Animator anim) 将现有动画和传入的动画同时执行</li>\n</ul>\n<blockquote>\n<p>Android 除了提供play(),还有playSequentially(),playTogether() 可供使用，可传入一个或者多个动画对象（，隔开），或者动画集合</p>\n</blockquote>\n</li>\n</ul>\n<pre><code>   ObjectAnimator animator = ObjectAnimator.ofInt(container, &quot;backgroundColor&quot;, 0xFFFF0000, 0xFFFF00FF);\n                ObjectAnimator animator1 = ObjectAnimator.ofFloat(view, &quot;translationX&quot;, 0.0f, 200.0f, 0f);\n                ObjectAnimator animator2 = ObjectAnimator.ofFloat(view, &quot;scaleX&quot;, 1.0f, 2.0f);\n                ObjectAnimator animator3 = ObjectAnimator.ofFloat(view, &quot;rotationX&quot;, 0.0f, 90.0f, 0.0F);\n                ObjectAnimator animator4 = ObjectAnimator.ofFloat(view, &quot;alpha&quot;, 1.0f, 0.2f, 1.0F);\n\n                //组合动画方式1\n                AnimatorSet set = new AnimatorSet();\n               ((set.play(animator).with(animator1).before(animator2)).before(animator3)).after(animator4);\n                set.setDuration(5000);\n                set.start();\n</code></pre><ul>\n<li><p><strong>组合动画2–PropertyValuesHolder的使用</strong><br>使用方法ObjectAnimator.ofPropertyValuesHolder(Object target,PropertyValuesHolder… values)；第一个参数是动画的目标对象，之后的参数是PropertyValuesHolder类的实例，可以有多个这样的实例。代码如下：</p>\n<pre><code>PropertyValuesHolder valuesHolder = PropertyValuesHolder.ofFloat(&quot;translationX&quot;, 0.0f, 300.0f);\n              PropertyValuesHolder valuesHolder1 = PropertyValuesHolder.ofFloat(&quot;scaleX&quot;, 1.0f, 1.5f);\n              PropertyValuesHolder valuesHolder2 = PropertyValuesHolder.ofFloat(&quot;rotationX&quot;, 0.0f, 90.0f, 0.0F);\n              PropertyValuesHolder valuesHolder3 = PropertyValuesHolder.ofFloat(&quot;alpha&quot;, 1.0f, 0.3f, 1.0F);\n\n              ObjectAnimator objectAnimator = ObjectAnimator.ofPropertyValuesHolder(view, valuesHolder, valuesHolder1, valuesHolder2, valuesHolder3);\n              objectAnimator.setDuration(2000).start();\n              //类似于AnimatorSet.playTogether(Animator... items);\n</code></pre></li>\n<li><strong>组合动画3-ViewPropertyAnimator（多属性动画）</strong><pre><code>ViewPropertyAnimator animator5 = imageView.animate();\nanimator5.translationX(200).scaleX(2).setDuration(2000).start();\n</code></pre><blockquote>\n<p>注意：使用ViewPropertyAnimator类需要API&gt;=12</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"动画监听\"><a href=\"#动画监听\" class=\"headerlink\" title=\"动画监听\"></a>动画监听</h3><ul>\n<li>animator.addListener(new Animator.AnimatorListener(){});//监听动画开始，结束，取消，重复（四种都包括）</li>\n<li>animator.addListener(new  AnimatorListenerAdapter(){});<br>推荐，可代替AnimatorListener，需要监听动画开始，结束，取消，重复那种就直接实现那种方法就行<br>其实AnimatorListenerAdapter的源码只是一个实现了AnimatorListener接口的抽象类而已</li>\n<li>animator.addUpdateListener(new  ValueAnimator.AnimatorUpdateListener(){});<br>更加精确的方法来时刻监听当前动画的执行情况，可以读取到动画的每个更新值了<pre><code>animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n          @Override\n          public void onAnimationUpdate(ValueAnimator animation) {\n              float value = (float) animation.getAnimatedValue();\n              //可以根据自己的需要来获取动画更新值。\n              Log.e(&#39;TAG&#39;, &#39;the animation value is &#39; + value);\n          }\n      });\n</code></pre></li>\n</ul>\n<h3 id=\"Keyframes\"><a href=\"#Keyframes\" class=\"headerlink\" title=\"Keyframes\"></a>Keyframes</h3><p>keyFrame是一个 时间/值 对，通过它可以定义一个在特定时间的特定状态，即关键帧，而且在两个keyFrame之间可以定义不同的Interpolator，就好像多个动画的拼接，第一个动画的结束点是第二个动画的开始点。KeyFrame是抽象类，要通过ofInt(),ofFloat(),ofObject()获得适当的KeyFrame，然后通过PropertyValuesHolder.ofKeyframe获得PropertyValuesHolder对象，如以下例子：</p>\n<pre><code>/*\n*   动画效果：btn对象的width属性值使其：\n*   开始时 Width=400\n*   动画开始1/4时 Width=200\n*   动画开始1/2时 Width=400\n*   动画开始3/4时 Width=100\n*   动画结束时 Width=500\n*/\nKeyframe kf0 = Keyframe.ofInt(0, 400);\nKeyframe kf1 = Keyframe.ofInt(0.25f, 200);\nKeyframe kf2 = Keyframe.ofInt(0.5f, 400);\nKeyframe kf4 = Keyframe.ofInt(0.75f, 100);\nKeyframe kf3 = Keyframe.ofInt(1f, 500);\nPropertyValuesHolder pvhRotation = PropertyValuesHolder.ofKeyframe(&quot;width&quot;, kf0, kf1, kf2, kf4, kf3);\nObjectAnimator rotationAnim = ObjectAnimator.ofPropertyValuesHolder(btn2, pvhRotation);\nrotationAnim.setDuration(2000);\n</code></pre><h3 id=\"Property-Animation在XML中使用\"><a href=\"#Property-Animation在XML中使用\" class=\"headerlink\" title=\"Property Animation在XML中使用\"></a>Property Animation在XML中使用</h3><ul>\n<li><p>xml文件放在res/animator/中</p>\n<pre><code>&lt;set xmlns:android=&#39;http://schemas.android.com/apk/res/android&#39;\n  android:duration=&#39;2000&#39;\n  android:ordering=&#39;sequentially&#39;&gt;&lt;!--动画执行顺序 sequentially：顺序执行；together：同时执行。 --&gt;\n\n  &lt;objectAnimator\n      android:propertyName=&#39;translationX&#39;\n      android:valueFrom=&#39;0&#39;\n      android:valueTo=&#39;200&#39;\n      android:valueType=&#39;floatType&#39; /&gt;\n\n  &lt;set android:ordering=&#39;together&#39;&gt;\n      &lt;objectAnimator\n          android:propertyName=&#39;scaleX&#39;\n          android:valueFrom=&#39;1&#39;\n          android:valueTo=&#39;2&#39;\n          android:valueType=&#39;floatType&#39; /&gt;\n      &lt;objectAnimator\n          android:propertyName=&#39;rotationX&#39;\n          android:valueFrom=&#39;0&#39;\n          android:valueTo=&#39;90&#39;\n          android:valueType=&#39;floatType&#39; /&gt;&lt;!--动画值的类型--&gt;\n\n  &lt;/set&gt;\n</code></pre></li>\n<li>通过AnimatorInflater.loadAnimator方法加载xml动画返回一个Animator的对象，然后调用setTarget方法给动画设置对象调用哪个start启动动画即可完成xml动画效果<pre><code>Animator animator = AnimatorInflater.loadAnimator(context, R.animator.anim_file);\nanimator.setTarget(view);  \nanimator.start();\n</code></pre></li>\n</ul>\n<h2 id=\"花花绿绿的ProgressBar-杨俊构\"><a href=\"#花花绿绿的ProgressBar-杨俊构\" class=\"headerlink\" title=\"花花绿绿的ProgressBar  杨俊构\"></a>花花绿绿的ProgressBar  杨俊构</h2><p><em>参考<a href=\"http://www.runoob.com/w3cnote/android-tutorial-progressbar.html\" target=\"_blank\" rel=\"noopener\">Android 基础入门教程</a></em></p>\n<ul>\n<li>ProgressBar(进度条)是Android基本UI控件，ProgressBar的应用场景很多，比如 用户登录时，后台在发请求，以及等待服务器返回信息，这个时候会用到进度条；或者当在进行一些比较 耗时的操作，需要等待一段较长的时间，这个时候如果没有提示，用户可能会以为程序Carsh或者手机死机 了，这样会大大降低用户体验，所以在需要进行耗时操作的地方，添加上进度条，让用户知道当前的程序 在执行中，也可以直观的告诉用户当前任务的执行进度等！使用进度条可以给我带来这样的便利！ </li>\n</ul>\n<ul>\n<li>ProgressBar<a href=\"http://androiddoc.qiniudn.com/reference/android/widget/ProgressBar.html\" target=\"_blank\" rel=\"noopener\">官方API文档</a>，ProgressBar继承与View类，直接子类有AbsSeekBar和ContentLoadingProgressBar， 其中AbsSeekBar的子类有SeekBar和RatingBar，可见这二者也是基于ProgressBar实现的</li>\n</ul>\n<p><img src=\"http://7xohph.com1.z0.glb.clouddn.com/46760225.jpg\" alt></p>\n<ul>\n<li>常用属性详解：</li>\n</ul>\n<blockquote>\n<ul>\n<li>android:max：进度条的最大值</li>\n<li>android:progress：进度条已完成进度值</li>\n<li>android:progressDrawable：设置轨道对应的Drawable对象</li>\n<li>android:indeterminate：如果设置成true，则进度条不精确显示进度</li>\n<li>android:indeterminateDrawable：设置不显示进度的进度条的Drawable对象</li>\n<li>android:indeterminateDuration：设置不精确显示进度的持续时间</li>\n<li>android:secondaryProgress：二级进度条，类似于视频播放的一条是当前播放进度，一条是缓冲进度，前者通过progress属性进行设置！</li>\n</ul>\n</blockquote>\n<ul>\n<li>对应的再Java中我们可调用下述方法：</li>\n</ul>\n<blockquote>\n<ul>\n<li>getMax()：返回这个进度条的范围的上限</li>\n<li>getProgress()：返回进度</li>\n<li>getSecondaryProgress()：返回次要进度</li>\n<li>incrementProgressBy(int diff)：指定增加的进度</li>\n<li>isIndeterminate()：指示进度条是否在不确定模式下</li>\n<li>setIndeterminate(boolean indeterminate)：设置不确定模式下</li>\n</ul>\n</blockquote>\n<ul>\n<li>系统默认进度条使用实例：</li>\n</ul>\n<p><img src=\"http://7xohph.com1.z0.glb.clouddn.com/34906854.jpg\" alt></p>\n<h3 id=\"耀眼的IOS的ProgressBar-，参看开源中国IOS代码库\"><a href=\"#耀眼的IOS的ProgressBar-，参看开源中国IOS代码库\" class=\"headerlink\" title=\"耀眼的IOS的ProgressBar ，参看开源中国IOS代码库\"></a>耀眼的IOS的ProgressBar ，参看<a href=\"http://www.oschina.net/ios/codingList/373/ios-progress\" target=\"_blank\" rel=\"noopener\">开源中国IOS代码库</a></h3><h3 id=\"圆形进度条\"><a href=\"#圆形进度条\" class=\"headerlink\" title=\"圆形进度条\"></a>圆形进度条</h3><blockquote>\n<p>网上一个简单的自定义圆形进度条！代码还是比较简单，容易理解，有兴趣可以看看，或者进行相关扩展~</p>\n</blockquote>\n<p><img src=\"http://7xohph.com1.z0.glb.clouddn.com/17272953.jpg\" alt></p>\n<ul>\n<li>实现代码：自定义View类：</li>\n</ul>\n<pre><code class=\"java\">\n    /**\n     * Created by Jay on 2015/8/5 0005.\n     */\n    public class CirclePgBar extends View {\n\n\n        private Paint mBackPaint;\n        private Paint mFrontPaint;\n        private Paint mTextPaint;\n        private float mStrokeWidth = 50;\n        private float mHalfStrokeWidth = mStrokeWidth / 2;\n        private float mRadius = 200;\n        private RectF mRect;\n        private int mProgress = 0;\n        //目标值，想改多少就改多少\n        private int mTargetProgress = 90;\n        private int mMax = 100;\n        private int mWidth;\n        private int mHeight;\n\n\n        public CirclePgBar(Context context) {\n            super(context);\n            init();\n        }\n\n        public CirclePgBar(Context context, AttributeSet attrs) {\n            super(context, attrs);\n            init();\n        }\n\n        public CirclePgBar(Context context, AttributeSet attrs, int defStyleAttr) {\n            super(context, attrs, defStyleAttr);\n            init();\n        }\n\n\n        //完成相关参数初始化\n        private void init() {\n            mBackPaint = new Paint();\n            mBackPaint.setColor(Color.WHITE);\n            mBackPaint.setAntiAlias(true);\n            mBackPaint.setStyle(Paint.Style.STROKE);\n            mBackPaint.setStrokeWidth(mStrokeWidth);\n\n            mFrontPaint = new Paint();\n            mFrontPaint.setColor(Color.GREEN);\n            mFrontPaint.setAntiAlias(true);\n            mFrontPaint.setStyle(Paint.Style.STROKE);\n            mFrontPaint.setStrokeWidth(mStrokeWidth);\n\n\n            mTextPaint = new Paint();\n            mTextPaint.setColor(Color.GREEN);\n            mTextPaint.setAntiAlias(true);\n            mTextPaint.setTextSize(80);\n            mTextPaint.setTextAlign(Paint.Align.CENTER);\n        }\n\n\n        //重写测量大小的onMeasure方法和绘制View的核心方法onDraw()\n        @Override\n        protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n            super.onMeasure(widthMeasureSpec, heightMeasureSpec);\n            mWidth = getRealSize(widthMeasureSpec);\n            mHeight = getRealSize(heightMeasureSpec);\n            setMeasuredDimension(mWidth, mHeight);\n\n        }\n\n\n        @Override\n        protected void onDraw(Canvas canvas) {\n            initRect();\n            float angle = mProgress / (float) mMax * 360;\n            canvas.drawCircle(mWidth / 2, mHeight / 2, mRadius, mBackPaint);\n            canvas.drawArc(mRect, -90, angle, false, mFrontPaint);\n            canvas.drawText(mProgress + &quot;%&quot;, mWidth / 2 + mHalfStrokeWidth, mHeight / 2 + mHalfStrokeWidth, mTextPaint);\n            if (mProgress &lt; mTargetProgress) {\n                mProgress += 1;\n                invalidate();\n            }\n\n        }\n\n        public int getRealSize(int measureSpec) {\n            int result = 1;\n            int mode = MeasureSpec.getMode(measureSpec);\n            int size = MeasureSpec.getSize(measureSpec);\n\n            if (mode == MeasureSpec.AT_MOST || mode == MeasureSpec.UNSPECIFIED) {\n                //自己计算\n                result = (int) (mRadius * 2 + mStrokeWidth);\n            } else {\n                result = size;\n            }\n\n            return result;\n        }\n\n        private void initRect() {\n            if (mRect == null) {\n                mRect = new RectF();\n                int viewSize = (int) (mRadius * 2);\n                int left = (mWidth - viewSize) / 2;\n                int top = (mHeight - viewSize) / 2;\n                int right = left + viewSize;\n                int bottom = top + viewSize;\n                mRect.set(left, top, right, bottom);\n            }\n        }\n\n\n    }\n</code></pre>\n<ul>\n<li>然后在布局文件中加上：</li>\n</ul>\n<pre><code class=\"xml\">\n     &lt;com.jay.progressbardemo.CirclePgBar\n       android:layout_width=&quot;match_parent&quot;\n       android:layout_height=&quot;match_parent&quot;/&gt;\n</code></pre>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li>progressbar是Android中的常用控件，在实际开发中和动画结合较多，好的进度条可以缓解使用者焦躁的情趣，自定义圆形进度条可以自行完善，然后用到实际开发中！</li>\n</ul>\n<h2 id=\"layer-list实现阴影效果——xpleemoon\"><a href=\"#layer-list实现阴影效果——xpleemoon\" class=\"headerlink\" title=\"layer-list实现阴影效果——xpleemoon\"></a>layer-list实现阴影效果——xpleemoon</h2><ul>\n<li><p>为控件实现阴影效果，可以有多种方式：</p>\n<ul>\n<li>多个drawable层叠在一起（不好的实现是多个View层叠达到多个drawable的层叠效果，相对好的实现是在同一个View钟实现多个drawable的层叠）</li>\n<li>自定义view</li>\n<li>Material Design中设置Z轴的方式</li>\n</ul>\n</li>\n<li><p>本文的思路是多个drawable叠在一起，但是不额外使用View，通过layer-list可以将多个item按照顺序层叠在一起显示。首先来看效果图：</p>\n</li>\n</ul>\n<p><img src=\"https://github.com/xpleemoon/layer-list-shadow-demo/blob/master/gif/LayerShadow.gif?raw=true\" alt=\"LayerShadow\"></p>\n<ul>\n<li><p>第一个和第二个控件是用来展示layer-list实现阴影效果的基本款，而第三个控件是综合上述两个控件效果，再集合selector实现的。</p>\n</li>\n<li><p>默认状态：</p>\n</li>\n</ul>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;layer-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;\n    &lt;!-- 阴影：左偏移2dp，上偏移4dp --&gt;\n    &lt;item\n        android:left=&quot;2dp&quot;\n        android:top=&quot;4dp&quot;&gt;\n        &lt;shape&gt;\n            &lt;solid android:color=&quot;@android:color/holo_blue_dark&quot; /&gt;\n            &lt;corners android:radius=&quot;10dp&quot; /&gt;\n        &lt;/shape&gt;\n    &lt;/item&gt;\n    &lt;!-- 前景：：底偏移4dp，右偏移2dp --&gt;\n    &lt;item\n        android:bottom=&quot;4dp&quot;\n        android:right=&quot;2dp&quot;&gt;\n        &lt;shape&gt;\n            &lt;solid android:color=&quot;@android:color/holo_blue_bright&quot; /&gt;\n            &lt;corners android:radius=&quot;10dp&quot; /&gt;\n        &lt;/shape&gt;\n    &lt;/item&gt;\n&lt;/layer-list&gt;\n</code></pre>\n<ul>\n<li>点击状态：</li>\n</ul>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;layer-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;\n    &lt;!-- 为了达到点击的真实感，将原来默认状态的前景色设置为阴影，并将前景设为无透明--&gt;\n    &lt;item\n        android:left=&quot;2dp&quot;\n        android:top=&quot;4dp&quot;&gt;\n        &lt;shape&gt;\n            &lt;solid android:color=&quot;@android:color/holo_blue_bright&quot; /&gt;\n            &lt;corners android:radius=&quot;10dp&quot; /&gt;\n        &lt;/shape&gt;\n    &lt;/item&gt;\n    &lt;item\n        android:bottom=&quot;4dp&quot;\n        android:right=&quot;2dp&quot;&gt;\n        &lt;shape&gt;\n            &lt;corners android:radius=&quot;10dp&quot; /&gt;\n        &lt;/shape&gt;\n    &lt;/item&gt;\n&lt;/layer-list&gt;\n</code></pre>\n<blockquote>\n<p>layer-list的item可以通过以下属性设置偏移量：</p>\n<ul>\n<li>android:top 顶部的偏移量</li>\n<li>android:bottom 底部的偏移量</li>\n<li>android:left 左边的偏移量</li>\n<li>android:right 右边的偏移量</li>\n</ul>\n</blockquote>\n<ul>\n<li>selector，使用上述layer-list：</li>\n</ul>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;\n    &lt;item android:drawable=&quot;@drawable/layer_list_btn_pressed&quot; android:state_pressed=&quot;true&quot; /&gt;\n    &lt;item android:drawable=&quot;@drawable/layer_list_btn_pressed&quot; android:state_selected=&quot;true&quot; /&gt;\n    &lt;item android:drawable=&quot;@drawable/layer_list_btn&quot; /&gt;\n\n&lt;/selector&gt;\n</code></pre>\n<ul>\n<li>最后再来看下，布局代码：</li>\n</ul>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n    xmlns:tools=&quot;http://schemas.android.com/tools&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;match_parent&quot;\n    android:orientation=&quot;vertical&quot;\n    android:paddingBottom=&quot;@dimen/activity_vertical_margin&quot;\n    android:paddingLeft=&quot;@dimen/activity_horizontal_margin&quot;\n    android:paddingRight=&quot;@dimen/activity_horizontal_margin&quot;\n    android:paddingTop=&quot;@dimen/activity_vertical_margin&quot;\n    tools:context=&quot;.MainActivity&quot;&gt;\n\n    &lt;TextView\n        android:layout_width=&quot;100dp&quot;\n        android:layout_height=&quot;50dp&quot;\n        android:background=&quot;@drawable/layer_list_btn&quot;\n        android:clickable=&quot;true&quot;\n        android:gravity=&quot;center&quot;\n        android:text=&quot;默认状态&quot; /&gt;\n\n    &lt;TextView\n        android:layout_width=&quot;100dp&quot;\n        android:layout_height=&quot;50dp&quot;\n        android:layout_marginTop=&quot;@dimen/activity_vertical_margin&quot;\n        android:background=&quot;@drawable/layer_list_btn_pressed&quot;\n        android:clickable=&quot;true&quot;\n        android:gravity=&quot;center&quot;\n        android:text=&quot;点击状态&quot; /&gt;\n\n    &lt;TextView\n        android:layout_width=&quot;100dp&quot;\n        android:layout_height=&quot;50dp&quot;\n        android:layout_marginTop=&quot;@dimen/activity_vertical_margin&quot;\n        android:background=&quot;@drawable/selector_btn&quot;\n        android:clickable=&quot;true&quot;\n        android:gravity=&quot;center&quot;\n        android:text=&quot;点我&quot; /&gt;\n&lt;/LinearLayout&gt;\n</code></pre>\n<ul>\n<li><p>第一个和第二个TextView分别引用了对应的layer-list（默认和点击）作为背景，第三个引用了selector</p>\n</li>\n<li><p><strong><em><a href=\"https://github.com/xpleemoon/layer-list-shadow-demo\" target=\"_blank\" rel=\"noopener\">源码地址</a></em></strong></p>\n</li>\n</ul>\n<h2 id=\"零部署的云服务-王胜\"><a href=\"#零部署的云服务-王胜\" class=\"headerlink\" title=\"零部署的云服务 - 王胜\"></a>零部署的云服务 - 王胜</h2><blockquote>\n<p>本周的分享主题是动画，但之前7月份我已经分享过一次，<a href=\"http://51offer.github.io/2015/07/07/%E7%A7%BB%E5%8A%A8%E7%BB%84%E5%91%A8%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB-%E7%9F%A5%E5%85%B6%E6%89%80%E4%BB%A5%E7%84%B6/\" target=\"_blank\" rel=\"noopener\">知其所以然</a> 。再加上前面几位已经对android的动画介绍的很完整了，所以我就分享另一个话题『云平台下的零部署开发网站』。</p>\n</blockquote>\n<h3 id=\"牵扯的技能\"><a href=\"#牵扯的技能\" class=\"headerlink\" title=\"牵扯的技能\"></a>牵扯的技能</h3><ul>\n<li>Git</li>\n<li>任何一门后端开发语言</li>\n</ul>\n<h3 id=\"搭建步骤\"><a href=\"#搭建步骤\" class=\"headerlink\" title=\"搭建步骤\"></a>搭建步骤</h3><p><a href=\"https://tryappservice.azure.com/zh-cn\" target=\"_blank\" rel=\"noopener\">AZURE</a> -&gt; 点击 <a href=\"https://azure.microsoft.com/zh-cn/services/app-service/web/\" target=\"_blank\" rel=\"noopener\">Web应用模块</a> -&gt; 选择语言，点击<strong>创建Web应用</strong> -&gt; 选择模板，点击<strong>创建</strong>，至此，应用以创建，点击页面上站点url，就能看到新创建的Web站点了。</p>\n<h3 id=\"修改代码，Git提交自动完成部署\"><a href=\"#修改代码，Git提交自动完成部署\" class=\"headerlink\" title=\"修改代码，Git提交自动完成部署\"></a>修改代码，Git提交自动完成部署</h3><p>复制创建成功页面『使用 Git 克隆或推送』里的Git地址，将初始化源码clone到本地，然后编辑代码，修改功能。完成后，直接push到远程，云平台自动完成部署。再看看网页是不是已经发生变化了。</p>\n<pre><code class=\"Shell\">Victors-MPB:azure wangsheng$ git clone https://$4f743e5d-0ee0-4-231-b9ee:WSc8Szx4Rf30apo3Ky7hpw6mXAadAZYvn1zagCvMaboj7mHFyJ2vzuYn9i12@4f743e5d-0ee0-4-231-b9ee.scm.azurewebsites.net/4f743e5d-0ee0-4-231-b9ee.git\nCloning into &#39;4f743e5d-0ee0-4-231-b9ee&#39;...\nremote: Counting objects: 4, done.\nremote: Compressing objects: 100% (3/3), done.\nremote: Total 4 (delta 0), reused 0 (delta 0)\nUnpacking objects: 100% (4/4), done.\nChecking connectivity... done.\nVictors-MPB:azure wangsheng$ ls\n4f743e5d-0ee0-4-231-b9ee\nVictors-MPB:azure wangsheng$ cd 4f743e5d-0ee0-4-231-b9ee/\nVictors-MPB:4f743e5d-0ee0-4-231-b9ee wangsheng$ git br\n* master\nVictors-MPB:4f743e5d-0ee0-4-231-b9ee wangsheng$ git log\ncommit cf6edda65210ef7254f9bc545c778489f123620e\nAuthor: windowsazure &lt;windowsazure&gt;\nDate:   Fri Nov 20 03:53:00 2015 +0000\n\n    Initial Commit\nVictors-MPB:4f743e5d-0ee0-4-231-b9ee wangsheng$ ls\nfavicon.ico    index.php\nVictors-MPB:4f743e5d-0ee0-4-231-b9ee wangsheng$ vi index.php\nVictors-MPB:4f743e5d-0ee0-4-231-b9ee wangsheng$ git st\nOn branch master\nYour branch is up-to-date with &#39;origin/master&#39;.\nChanges not staged for commit:\n  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)\n  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)\n\n    modified:   index.php\n\nno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)\nVictors-MPB:4f743e5d-0ee0-4-231-b9ee wangsheng$ git diff\ndiff --git a/index.php b/index.php\n&lt;?php\nindex 712f825..50a17e7 100644\n--- a/index.php\n+++ b/index.php\n@@ -1,3 +1,4 @@\n &lt;?php\n     echo &quot;Hello World&quot;\n-?&gt;\n\\ No newline at end of file\n+    echo &quot;hack it.&quot;\n+?&gt;\nVictors-MPB:4f743e5d-0ee0-4-231-b9ee wangsheng$ git ci -am &quot;add one line.&quot;\n[master 6c5551f] add one line.\n 1 file changed, 2 insertions(+), 1 deletion(-)\nVictors-MPB:4f743e5d-0ee0-4-231-b9ee wangsheng$ git push origin master\nCounting objects: 3, done.\nDelta compression using up to 4 threads.\nCompressing objects: 100% (3/3), done.\nWriting objects: 100% (3/3), 324 bytes | 0 bytes/s, done.\nTotal 3 (delta 0), reused 0 (delta 0)\nremote: Updating branch &#39;master&#39;.\nremote: Updating submodules.\nremote: Preparing deployment for commit id &#39;6c5551f090&#39;.\nremote: Generating deployment script.\nremote: Generating deployment script for Web Site\nremote: Generated deployment script files\nremote: Running deployment command...\nremote: Handling Basic Web Site deployment.\nremote: Finished successfully.\nremote: Deployment successful.\n</code></pre>\n<p>对，后端开发可以如此简单快乐地开发部署！！！</p>\n"},{"title":"Android单元测试框架","date":"2016-03-18T10:30:00.000Z","_content":"- Android单元测试\n\t- 在Android项目中，单元测试的对象是组件状态、控件行为、界面元素和自定义函数。不推荐对每个函数进行一对一的测试，像onStart()、onDestroy()这些周期函数并不需要全部覆盖到。  \n- 框架比较\n\t- JUnit\n\t\t- 原生单元测试\n\t\t- 不能让Activity执行到resume的状态\n\t\t- @王进已讲\n\t- AndroidTest\n\t\t- 运行在Android环境\n\t- Instrumentation\n\t\t- 运行在模拟器上\n\t- Robotium\n\t\t- 类似于Selenium的测试框架\n\t\t- 运行在模拟器上\n\t\t- 通过对模拟器的操作或者mock，来触发函数调用，进而对其结果进行验证\n\t- Robolectric+Mock(Mockito)\n\t\t- 运行在JVM上速度快\n\t\t- Jenkins周期性执行\n\t\t- 无需准备Android环境\n\t\t- 实现了Android中对XML的解析，模拟了View，Layout，以及资源的加载\n\t\t- 一些测试对象依赖度较高而需要解除依赖的场景(如网络)使用Mock框架\n- [Robolectric](http://robolectric.org/getting-started/)\n\t- Android Studio配置\n\t\t-  build.gradle添加库\n\t\t\n\t\t````\n\t\ttestCompile \"org.robolectric:robolectric:3.0\"\n\t\t````\n\t\t- Build Variants设置\n\t\t![Unit Tests](http://robolectric.org/images/android-studio-enable-unit-tests-f15bd816.png)\n\t\t- Linux和Mac平台的需要配置下才能运行:在Android Studio中run边上有一个app选择，这里选择\"Edit Configurations\" 出现编辑界面\n\t\t![Run/Debug Configurations]()\n\t\t在左边中新建JUnit，Default->JUnit\n\t\t- 测试代码\n\t\t- 中间出现问题\n\t\t\t- Android SDK目前只支持到22，5.1\n- 单元测试的目标函数主要有三种：\n\t1. 有明确的返回值，如上图的dosomething(Boolean param)，做单元测试时，只需调用这个函数，然后验证函数的返回值是否符合预期结果。\n\t2. 这个函数只改变其对象内部的一些属性或者状态，函数本身没有返回值，就验证它所改变的属性和状态。\n\t3. \t一些函数没有返回值，也没有直接改变哪个值的状态，这就需要验证其行为，比如点击事件。 \n\t\n\t- 既没有返回值，也没有改变状态，又没有触发行为的函数是不可测试的，在项目中不应该存在。当存在同时具备上述多种特性时，本文建议采用多个case来真对每一种特性逐一验证，或者采用一个case，逐一执行目标函数并验证其影响。\n\t- 构造用例的原则是测试用例与函数一对一，实现条件覆盖与路径覆盖。Java单元测试中，良好的单元测试是需要保证所有函数执行正确的，即所有边界条件都验证过，一个用例只测一个函数，便于维护。在Android单元测试中，并不要求对所有函数都覆盖到，像Android SDK中的函数回调则不用测试。\n- 测试用例\n\t- 组件\n\t\t- Activity测试\n\t\t\n\t\t````\n\t\t@Test\n    public void testLifecycle() {\n        ActivityController<MainActivity> activityController = Robolectric.buildActivity(MainActivity.class).create().start();\n        Activity activity = activityController.get();\n        Button action_next = (Button) activity.findViewById(R.id.next);\n        Assert.assertEquals(\"next\", action_next.getText().toString());\n//        error\n//        Assert.assertEquals(\"testLifecycle\", action_next.getText().toString());\n    }\n\n\t\t````  \n\t\t- Service\n\t\t- BroadcastReceiver\n\t\t- Fragment \n\t- 控件行为\n\t\t- 跳转\n\t- 界面元素\n\t\t- Toast\n\t\t\n\t\t````\n\t\t@Test\n    public void testToast() {\n        Button action_toast = (Button) mActivity.findViewById(R.id.action_toast);\n        action_toast.performClick();\n        Assert.assertEquals(\"hello\", ShadowToast.getTextOfLatestToast());\n    }\n\t\t````\n\t\t- Dialog\n\t\t- UI控件\n\t\t\n\t\t````\n\t\t @Test\n    public void testStartEndActivity() {\n        Button action_next = (Button) mActivity.findViewById(R.id.next);\n        action_next.performClick();\n\n        Intent intent = new Intent(mActivity, EndActivity.class);\n\n        Intent actionIntent = ShadowApplication.getInstance().getNextStartedActivity();\n        Assert.assertEquals(intent, actionIntent);\n    }\n\t\t````\n\t- 自定义函数\n\t- 网络请求\n- assertJ-android断言库\n- 资料\n\t- [参考1](https://hkliya.gitbooks.io/unit-test-android-with-robolectric/content/0-introduction.html)\n\t- [美团Android单元测试](http://tech.meituan.com/Android_unit_test.html)\n\t- [测试用例](http://www.jianshu.com/p/9d988a2f8ff7)\n\t","source":"_posts/Android单元测试框架.md","raw":"title: Android单元测试框架\ndate: 2016-03-18  10:30:00\ntags:\ncategories: 单元测试\n\n---\n- Android单元测试\n\t- 在Android项目中，单元测试的对象是组件状态、控件行为、界面元素和自定义函数。不推荐对每个函数进行一对一的测试，像onStart()、onDestroy()这些周期函数并不需要全部覆盖到。  \n- 框架比较\n\t- JUnit\n\t\t- 原生单元测试\n\t\t- 不能让Activity执行到resume的状态\n\t\t- @王进已讲\n\t- AndroidTest\n\t\t- 运行在Android环境\n\t- Instrumentation\n\t\t- 运行在模拟器上\n\t- Robotium\n\t\t- 类似于Selenium的测试框架\n\t\t- 运行在模拟器上\n\t\t- 通过对模拟器的操作或者mock，来触发函数调用，进而对其结果进行验证\n\t- Robolectric+Mock(Mockito)\n\t\t- 运行在JVM上速度快\n\t\t- Jenkins周期性执行\n\t\t- 无需准备Android环境\n\t\t- 实现了Android中对XML的解析，模拟了View，Layout，以及资源的加载\n\t\t- 一些测试对象依赖度较高而需要解除依赖的场景(如网络)使用Mock框架\n- [Robolectric](http://robolectric.org/getting-started/)\n\t- Android Studio配置\n\t\t-  build.gradle添加库\n\t\t\n\t\t````\n\t\ttestCompile \"org.robolectric:robolectric:3.0\"\n\t\t````\n\t\t- Build Variants设置\n\t\t![Unit Tests](http://robolectric.org/images/android-studio-enable-unit-tests-f15bd816.png)\n\t\t- Linux和Mac平台的需要配置下才能运行:在Android Studio中run边上有一个app选择，这里选择\"Edit Configurations\" 出现编辑界面\n\t\t![Run/Debug Configurations]()\n\t\t在左边中新建JUnit，Default->JUnit\n\t\t- 测试代码\n\t\t- 中间出现问题\n\t\t\t- Android SDK目前只支持到22，5.1\n- 单元测试的目标函数主要有三种：\n\t1. 有明确的返回值，如上图的dosomething(Boolean param)，做单元测试时，只需调用这个函数，然后验证函数的返回值是否符合预期结果。\n\t2. 这个函数只改变其对象内部的一些属性或者状态，函数本身没有返回值，就验证它所改变的属性和状态。\n\t3. \t一些函数没有返回值，也没有直接改变哪个值的状态，这就需要验证其行为，比如点击事件。 \n\t\n\t- 既没有返回值，也没有改变状态，又没有触发行为的函数是不可测试的，在项目中不应该存在。当存在同时具备上述多种特性时，本文建议采用多个case来真对每一种特性逐一验证，或者采用一个case，逐一执行目标函数并验证其影响。\n\t- 构造用例的原则是测试用例与函数一对一，实现条件覆盖与路径覆盖。Java单元测试中，良好的单元测试是需要保证所有函数执行正确的，即所有边界条件都验证过，一个用例只测一个函数，便于维护。在Android单元测试中，并不要求对所有函数都覆盖到，像Android SDK中的函数回调则不用测试。\n- 测试用例\n\t- 组件\n\t\t- Activity测试\n\t\t\n\t\t````\n\t\t@Test\n    public void testLifecycle() {\n        ActivityController<MainActivity> activityController = Robolectric.buildActivity(MainActivity.class).create().start();\n        Activity activity = activityController.get();\n        Button action_next = (Button) activity.findViewById(R.id.next);\n        Assert.assertEquals(\"next\", action_next.getText().toString());\n//        error\n//        Assert.assertEquals(\"testLifecycle\", action_next.getText().toString());\n    }\n\n\t\t````  \n\t\t- Service\n\t\t- BroadcastReceiver\n\t\t- Fragment \n\t- 控件行为\n\t\t- 跳转\n\t- 界面元素\n\t\t- Toast\n\t\t\n\t\t````\n\t\t@Test\n    public void testToast() {\n        Button action_toast = (Button) mActivity.findViewById(R.id.action_toast);\n        action_toast.performClick();\n        Assert.assertEquals(\"hello\", ShadowToast.getTextOfLatestToast());\n    }\n\t\t````\n\t\t- Dialog\n\t\t- UI控件\n\t\t\n\t\t````\n\t\t @Test\n    public void testStartEndActivity() {\n        Button action_next = (Button) mActivity.findViewById(R.id.next);\n        action_next.performClick();\n\n        Intent intent = new Intent(mActivity, EndActivity.class);\n\n        Intent actionIntent = ShadowApplication.getInstance().getNextStartedActivity();\n        Assert.assertEquals(intent, actionIntent);\n    }\n\t\t````\n\t- 自定义函数\n\t- 网络请求\n- assertJ-android断言库\n- 资料\n\t- [参考1](https://hkliya.gitbooks.io/unit-test-android-with-robolectric/content/0-introduction.html)\n\t- [美团Android单元测试](http://tech.meituan.com/Android_unit_test.html)\n\t- [测试用例](http://www.jianshu.com/p/9d988a2f8ff7)\n\t","slug":"Android单元测试框架","published":1,"updated":"2021-09-10T07:04:21.936Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cktfeap3h000fc2xxqky80v90","content":"<ul>\n<li>Android单元测试<ul>\n<li>在Android项目中，单元测试的对象是组件状态、控件行为、界面元素和自定义函数。不推荐对每个函数进行一对一的测试，像onStart()、onDestroy()这些周期函数并不需要全部覆盖到。  </li>\n</ul>\n</li>\n<li>框架比较<ul>\n<li>JUnit<ul>\n<li>原生单元测试</li>\n<li>不能让Activity执行到resume的状态</li>\n<li>@王进已讲</li>\n</ul>\n</li>\n<li>AndroidTest<ul>\n<li>运行在Android环境</li>\n</ul>\n</li>\n<li>Instrumentation<ul>\n<li>运行在模拟器上</li>\n</ul>\n</li>\n<li>Robotium<ul>\n<li>类似于Selenium的测试框架</li>\n<li>运行在模拟器上</li>\n<li>通过对模拟器的操作或者mock，来触发函数调用，进而对其结果进行验证</li>\n</ul>\n</li>\n<li>Robolectric+Mock(Mockito)<ul>\n<li>运行在JVM上速度快</li>\n<li>Jenkins周期性执行</li>\n<li>无需准备Android环境</li>\n<li>实现了Android中对XML的解析，模拟了View，Layout，以及资源的加载</li>\n<li>一些测试对象依赖度较高而需要解除依赖的场景(如网络)使用Mock框架</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><a href=\"http://robolectric.org/getting-started/\" target=\"_blank\" rel=\"noopener\">Robolectric</a></p>\n<ul>\n<li><p>Android Studio配置</p>\n<ul>\n<li><p>build.gradle添加库</p>\n<pre><code>testCompile &quot;org.robolectric:robolectric:3.0&quot;\n</code></pre></li>\n<li>Build Variants设置<br><img src=\"http://robolectric.org/images/android-studio-enable-unit-tests-f15bd816.png\" alt=\"Unit Tests\"></li>\n<li>Linux和Mac平台的需要配置下才能运行:在Android Studio中run边上有一个app选择，这里选择”Edit Configurations” 出现编辑界面<br><img src alt=\"Run/Debug Configurations\"><br>在左边中新建JUnit，Default-&gt;JUnit</li>\n<li>测试代码</li>\n<li>中间出现问题<ul>\n<li>Android SDK目前只支持到22，5.1</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>单元测试的目标函数主要有三种：</p>\n<ol>\n<li>有明确的返回值，如上图的dosomething(Boolean param)，做单元测试时，只需调用这个函数，然后验证函数的返回值是否符合预期结果。</li>\n<li>这个函数只改变其对象内部的一些属性或者状态，函数本身没有返回值，就验证它所改变的属性和状态。</li>\n<li>一些函数没有返回值，也没有直接改变哪个值的状态，这就需要验证其行为，比如点击事件。 </li>\n</ol>\n<ul>\n<li>既没有返回值，也没有改变状态，又没有触发行为的函数是不可测试的，在项目中不应该存在。当存在同时具备上述多种特性时，本文建议采用多个case来真对每一种特性逐一验证，或者采用一个case，逐一执行目标函数并验证其影响。</li>\n<li>构造用例的原则是测试用例与函数一对一，实现条件覆盖与路径覆盖。Java单元测试中，良好的单元测试是需要保证所有函数执行正确的，即所有边界条件都验证过，一个用例只测一个函数，便于维护。在Android单元测试中，并不要求对所有函数都覆盖到，像Android SDK中的函数回调则不用测试。</li>\n</ul>\n</li>\n<li><p>测试用例</p>\n<ul>\n<li><p>组件</p>\n<ul>\n<li><p>Activity测试</p>\n<pre><code>@Test\npublic void testLifecycle() {\nActivityController&lt;MainActivity&gt; activityController = Robolectric.buildActivity(MainActivity.class).create().start();\nActivity activity = activityController.get();\nButton action_next = (Button) activity.findViewById(R.id.next);\nAssert.assertEquals(&quot;next&quot;, action_next.getText().toString());\n//        error\n//        Assert.assertEquals(&quot;testLifecycle&quot;, action_next.getText().toString());\n}\n</code></pre></li>\n<li>Service</li>\n<li>BroadcastReceiver</li>\n<li>Fragment </li>\n</ul>\n</li>\n<li>控件行为<ul>\n<li>跳转</li>\n</ul>\n</li>\n<li><p>界面元素</p>\n<ul>\n<li><p>Toast</p>\n<pre><code>@Test\npublic void testToast() {\nButton action_toast = (Button) mActivity.findViewById(R.id.action_toast);\naction_toast.performClick();\nAssert.assertEquals(&quot;hello&quot;, ShadowToast.getTextOfLatestToast());\n}\n</code></pre></li>\n<li>Dialog</li>\n<li><p>UI控件</p>\n<pre><code>@Test\npublic void testStartEndActivity() {\nButton action_next = (Button) mActivity.findViewById(R.id.next);\naction_next.performClick();\n\nIntent intent = new Intent(mActivity, EndActivity.class);\n\nIntent actionIntent = ShadowApplication.getInstance().getNextStartedActivity();\nAssert.assertEquals(intent, actionIntent);\n}\n</code></pre></li>\n</ul>\n</li>\n<li>自定义函数</li>\n<li>网络请求</li>\n</ul>\n</li>\n<li>assertJ-android断言库</li>\n<li>资料<ul>\n<li><a href=\"https://hkliya.gitbooks.io/unit-test-android-with-robolectric/content/0-introduction.html\" target=\"_blank\" rel=\"noopener\">参考1</a></li>\n<li><a href=\"http://tech.meituan.com/Android_unit_test.html\" target=\"_blank\" rel=\"noopener\">美团Android单元测试</a></li>\n<li><a href=\"http://www.jianshu.com/p/9d988a2f8ff7\" target=\"_blank\" rel=\"noopener\">测试用例</a></li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>Android单元测试<ul>\n<li>在Android项目中，单元测试的对象是组件状态、控件行为、界面元素和自定义函数。不推荐对每个函数进行一对一的测试，像onStart()、onDestroy()这些周期函数并不需要全部覆盖到。  </li>\n</ul>\n</li>\n<li>框架比较<ul>\n<li>JUnit<ul>\n<li>原生单元测试</li>\n<li>不能让Activity执行到resume的状态</li>\n<li>@王进已讲</li>\n</ul>\n</li>\n<li>AndroidTest<ul>\n<li>运行在Android环境</li>\n</ul>\n</li>\n<li>Instrumentation<ul>\n<li>运行在模拟器上</li>\n</ul>\n</li>\n<li>Robotium<ul>\n<li>类似于Selenium的测试框架</li>\n<li>运行在模拟器上</li>\n<li>通过对模拟器的操作或者mock，来触发函数调用，进而对其结果进行验证</li>\n</ul>\n</li>\n<li>Robolectric+Mock(Mockito)<ul>\n<li>运行在JVM上速度快</li>\n<li>Jenkins周期性执行</li>\n<li>无需准备Android环境</li>\n<li>实现了Android中对XML的解析，模拟了View，Layout，以及资源的加载</li>\n<li>一些测试对象依赖度较高而需要解除依赖的场景(如网络)使用Mock框架</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><a href=\"http://robolectric.org/getting-started/\" target=\"_blank\" rel=\"noopener\">Robolectric</a></p>\n<ul>\n<li><p>Android Studio配置</p>\n<ul>\n<li><p>build.gradle添加库</p>\n<pre><code>testCompile &quot;org.robolectric:robolectric:3.0&quot;\n</code></pre></li>\n<li>Build Variants设置<br><img src=\"http://robolectric.org/images/android-studio-enable-unit-tests-f15bd816.png\" alt=\"Unit Tests\"></li>\n<li>Linux和Mac平台的需要配置下才能运行:在Android Studio中run边上有一个app选择，这里选择”Edit Configurations” 出现编辑界面<br><img src alt=\"Run/Debug Configurations\"><br>在左边中新建JUnit，Default-&gt;JUnit</li>\n<li>测试代码</li>\n<li>中间出现问题<ul>\n<li>Android SDK目前只支持到22，5.1</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>单元测试的目标函数主要有三种：</p>\n<ol>\n<li>有明确的返回值，如上图的dosomething(Boolean param)，做单元测试时，只需调用这个函数，然后验证函数的返回值是否符合预期结果。</li>\n<li>这个函数只改变其对象内部的一些属性或者状态，函数本身没有返回值，就验证它所改变的属性和状态。</li>\n<li>一些函数没有返回值，也没有直接改变哪个值的状态，这就需要验证其行为，比如点击事件。 </li>\n</ol>\n<ul>\n<li>既没有返回值，也没有改变状态，又没有触发行为的函数是不可测试的，在项目中不应该存在。当存在同时具备上述多种特性时，本文建议采用多个case来真对每一种特性逐一验证，或者采用一个case，逐一执行目标函数并验证其影响。</li>\n<li>构造用例的原则是测试用例与函数一对一，实现条件覆盖与路径覆盖。Java单元测试中，良好的单元测试是需要保证所有函数执行正确的，即所有边界条件都验证过，一个用例只测一个函数，便于维护。在Android单元测试中，并不要求对所有函数都覆盖到，像Android SDK中的函数回调则不用测试。</li>\n</ul>\n</li>\n<li><p>测试用例</p>\n<ul>\n<li><p>组件</p>\n<ul>\n<li><p>Activity测试</p>\n<pre><code>@Test\npublic void testLifecycle() {\nActivityController&lt;MainActivity&gt; activityController = Robolectric.buildActivity(MainActivity.class).create().start();\nActivity activity = activityController.get();\nButton action_next = (Button) activity.findViewById(R.id.next);\nAssert.assertEquals(&quot;next&quot;, action_next.getText().toString());\n//        error\n//        Assert.assertEquals(&quot;testLifecycle&quot;, action_next.getText().toString());\n}\n</code></pre></li>\n<li>Service</li>\n<li>BroadcastReceiver</li>\n<li>Fragment </li>\n</ul>\n</li>\n<li>控件行为<ul>\n<li>跳转</li>\n</ul>\n</li>\n<li><p>界面元素</p>\n<ul>\n<li><p>Toast</p>\n<pre><code>@Test\npublic void testToast() {\nButton action_toast = (Button) mActivity.findViewById(R.id.action_toast);\naction_toast.performClick();\nAssert.assertEquals(&quot;hello&quot;, ShadowToast.getTextOfLatestToast());\n}\n</code></pre></li>\n<li>Dialog</li>\n<li><p>UI控件</p>\n<pre><code>@Test\npublic void testStartEndActivity() {\nButton action_next = (Button) mActivity.findViewById(R.id.next);\naction_next.performClick();\n\nIntent intent = new Intent(mActivity, EndActivity.class);\n\nIntent actionIntent = ShadowApplication.getInstance().getNextStartedActivity();\nAssert.assertEquals(intent, actionIntent);\n}\n</code></pre></li>\n</ul>\n</li>\n<li>自定义函数</li>\n<li>网络请求</li>\n</ul>\n</li>\n<li>assertJ-android断言库</li>\n<li>资料<ul>\n<li><a href=\"https://hkliya.gitbooks.io/unit-test-android-with-robolectric/content/0-introduction.html\" target=\"_blank\" rel=\"noopener\">参考1</a></li>\n<li><a href=\"http://tech.meituan.com/Android_unit_test.html\" target=\"_blank\" rel=\"noopener\">美团Android单元测试</a></li>\n<li><a href=\"http://www.jianshu.com/p/9d988a2f8ff7\" target=\"_blank\" rel=\"noopener\">测试用例</a></li>\n</ul>\n</li>\n</ul>\n"},{"title":"Android各个版本新特性","date":"2018-06-06T14:58:29.000Z","_content":"\n\n目前主流的Android适配版本最低版本4.0或5.0，这里主要总结一下Android 4.0以后各个版本特性，方便适配和面试。加粗标注为面试中问到的重点特性，其他为重要适配特性。（倒序）\n- [Android 8.0](https://developer.android.google.cn/about/versions/oreo/android-8.0.html)\n  - 优化通知\n    - 通知渠道\n    - 通知标志\n    - 休眠\n    - 通知超时\n    - 通知设置\n    - 通知清除\n  - 自动填充框架\n  - 画中画模式：清单中Activity设置android:supportsPictureInPicture\n  - **可下载字体**：[FontRequest](https://developer.android.google.cn/reference/android/provider/FontsContract.html)\n  - [XML 中的字体](https://developer.android.google.cn/guide/topics/ui/look-and-feel/fonts-in-xml.html)\n  - **自动调整 TextView 的大小**\n  - [自适应图标](https://developer.android.google.cn/guide/practices/ui_guidelines/icon_design_adaptive.html)\n  - 颜色管理\n  - [WebView API](https://developer.android.google.cn/guide/webapps/managing-webview.html)\n  - 多显示器支持\n  - **统一的布局外边距和内边距**\n![image.png](http://upload-images.jianshu.io/upload_images/1534431-b4ba4d688a817290.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n  - 指针捕获\n  - 应用类别\n  - Android TV 启动器\n  - AnimatorSet\n  - **新的 StrictMode 检测程序**\n![image.png](http://upload-images.jianshu.io/upload_images/1534431-e33af7003dde9550.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n  - 缓存数据\n  - **findViewById() 签名变更**\n![image.png](http://upload-images.jianshu.io/upload_images/1534431-89c0141aa910db0c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n  - **权限**\n![image.png](http://upload-images.jianshu.io/upload_images/1534431-f4c146ef0be3c03f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n  - **更新的 Java 支持**\n![image.png](http://upload-images.jianshu.io/upload_images/1534431-0464c897b3051935.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n- [Android 7.1](https://developer.android.google.cn/about/versions/nougat/android-7.1.html)\n\t- 加入重启按钮\n\t- App圆形图标\n\t- 添加新的Emoji\n- [Android 7.0](https://developer.android.google.cn/about/versions/nougat/android-7.0-changes.html)\n\t- 电池和内存\n\t\t- 低电耗模式\n\t\t- Project Svelte：后台优化\n\t- **权限更改**\n\t\t- 系统权限更改\n\t- **在应用间文件共享权限控制**\n\t- **多窗口支持**\n\t- **通知栏快捷回复**\n\t- **支持VR**\n\t- 引入JIT编译器\n\t- **画中画**\n\t- **App快捷菜单**\n- [Android 6.0](https://developer.android.google.cn/about/versions/marshmallow/android-6.0-changes.html)\n\t- **运行时请求权限**\n\t- 低电耗模式和应用待机模式\n\t- **取消支持 Apache HTTP 客户端**\n\t- BoringSSL\n\t- 硬件标识符访问权\n\t- 通知\n\t- 音频管理器变更\n\t- **支持文本选择**\n\t- Android 密钥库不再支持 DSA。但仍支持 ECDSA\n\t- WLAN 和网络连接变更\n\t- 相机服务变更\n\t- APK 验证\n\t- USB 连接\n- [Android 5.0](https://developer.android.google.cn/about/versions/android-5.0-changes.html#managed_profiles)\n  - **Android Runtime (ART)默认运行平台设置**\n  - **通知**\n  \t\t- Material Design 样式\n  \t\t- 声音和振动\n  \t\t- 锁定屏幕可见性\n  \t\t- 媒体播放\n\t  \t- 浮动通知\n  - **引入Material Design设计**\n  - 支持OpenGL ES3.1 \n  - 媒体控件和 RemoteControlClient\n  - getRecentTasks()\n  - **支持Android NDK中的64位**\n  - **只能显示绑定到服务，取消隐藏绑定服务**\n  - WebView API修改\n  - 自定义权限唯一性要求\n  - **TLS/SSL 默认配置变更**\n\t  \t- 服务器不支持任何已启用的加密套件\n\t  \t- 应用对用于连接服务器的加密套件做出错误的假设\n\t  \t- 服务器不支持 TLSv1.1、TLSv1.2 或新的 TLS 扩展\n  - 支持托管配置文件\n- [Android 4.4](https://developer.android.google.cn/about/versions/kitkat.html)\n\t- **支持Android Beam**\n\t- **添加打印框架**\n\t- 存储访问框架\n\t- 低功耗传感器\n\t- 添加短信提供程序\n\t- **添加全屏沉浸模式**\n        - [Android 沉浸式状态栏的三种实现方式](http://www.jianshu.com/p/be2b7be418d7#)\n        - [兼容库SystemBarTint](https://github.com/jgilfelt/SystemBarTint)\n\t- **添加透明系统 UI 样式**\n\t- 添加新的媒体功能\n\t- RenderScript Compute\n\t\t- 持续性能提升\n\t\t- **GPU 加速**\n\t\t- Android NDK 中的 RenderScript\n\t- 图形\n\t\t- GLES2.0 SurfaceFlinge\n\t\t- 新的硬件合成器支持虚拟显示\n\t- 支持新的连接类型\n\t\t- 新的蓝牙配置文件\n\t\t- 红外发射器\n\t\t- Wi-Fi TDLS 支持\n\t- 无障碍功能\n\t- 安全增强功能\n\t- 内存使用率分析工具\n\t\t- Procstats \n- [Android 4.0,4.1,4.2,4.3](https://developer.android.google.cn/about/versions/jelly-bean.html)\n\t- 支持OpenGL ES 3.0\n\t- 增强蓝牙连接\n\t- 优化位置和传感器\n\t- **添加转场动画**\n\t- 支持Daydream\n\t- **人脸识别解锁**\n\t- **Photo Sphere 全景相片**\n\n\n\t\n\n\n","source":"_posts/Android各个版本新特性.md","raw":"title: Android各个版本新特性\ndate: 2018-06-06 14:58:29\ntags:\ncategories: Android\n---\n\n\n目前主流的Android适配版本最低版本4.0或5.0，这里主要总结一下Android 4.0以后各个版本特性，方便适配和面试。加粗标注为面试中问到的重点特性，其他为重要适配特性。（倒序）\n- [Android 8.0](https://developer.android.google.cn/about/versions/oreo/android-8.0.html)\n  - 优化通知\n    - 通知渠道\n    - 通知标志\n    - 休眠\n    - 通知超时\n    - 通知设置\n    - 通知清除\n  - 自动填充框架\n  - 画中画模式：清单中Activity设置android:supportsPictureInPicture\n  - **可下载字体**：[FontRequest](https://developer.android.google.cn/reference/android/provider/FontsContract.html)\n  - [XML 中的字体](https://developer.android.google.cn/guide/topics/ui/look-and-feel/fonts-in-xml.html)\n  - **自动调整 TextView 的大小**\n  - [自适应图标](https://developer.android.google.cn/guide/practices/ui_guidelines/icon_design_adaptive.html)\n  - 颜色管理\n  - [WebView API](https://developer.android.google.cn/guide/webapps/managing-webview.html)\n  - 多显示器支持\n  - **统一的布局外边距和内边距**\n![image.png](http://upload-images.jianshu.io/upload_images/1534431-b4ba4d688a817290.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n  - 指针捕获\n  - 应用类别\n  - Android TV 启动器\n  - AnimatorSet\n  - **新的 StrictMode 检测程序**\n![image.png](http://upload-images.jianshu.io/upload_images/1534431-e33af7003dde9550.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n  - 缓存数据\n  - **findViewById() 签名变更**\n![image.png](http://upload-images.jianshu.io/upload_images/1534431-89c0141aa910db0c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n  - **权限**\n![image.png](http://upload-images.jianshu.io/upload_images/1534431-f4c146ef0be3c03f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n  - **更新的 Java 支持**\n![image.png](http://upload-images.jianshu.io/upload_images/1534431-0464c897b3051935.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n- [Android 7.1](https://developer.android.google.cn/about/versions/nougat/android-7.1.html)\n\t- 加入重启按钮\n\t- App圆形图标\n\t- 添加新的Emoji\n- [Android 7.0](https://developer.android.google.cn/about/versions/nougat/android-7.0-changes.html)\n\t- 电池和内存\n\t\t- 低电耗模式\n\t\t- Project Svelte：后台优化\n\t- **权限更改**\n\t\t- 系统权限更改\n\t- **在应用间文件共享权限控制**\n\t- **多窗口支持**\n\t- **通知栏快捷回复**\n\t- **支持VR**\n\t- 引入JIT编译器\n\t- **画中画**\n\t- **App快捷菜单**\n- [Android 6.0](https://developer.android.google.cn/about/versions/marshmallow/android-6.0-changes.html)\n\t- **运行时请求权限**\n\t- 低电耗模式和应用待机模式\n\t- **取消支持 Apache HTTP 客户端**\n\t- BoringSSL\n\t- 硬件标识符访问权\n\t- 通知\n\t- 音频管理器变更\n\t- **支持文本选择**\n\t- Android 密钥库不再支持 DSA。但仍支持 ECDSA\n\t- WLAN 和网络连接变更\n\t- 相机服务变更\n\t- APK 验证\n\t- USB 连接\n- [Android 5.0](https://developer.android.google.cn/about/versions/android-5.0-changes.html#managed_profiles)\n  - **Android Runtime (ART)默认运行平台设置**\n  - **通知**\n  \t\t- Material Design 样式\n  \t\t- 声音和振动\n  \t\t- 锁定屏幕可见性\n  \t\t- 媒体播放\n\t  \t- 浮动通知\n  - **引入Material Design设计**\n  - 支持OpenGL ES3.1 \n  - 媒体控件和 RemoteControlClient\n  - getRecentTasks()\n  - **支持Android NDK中的64位**\n  - **只能显示绑定到服务，取消隐藏绑定服务**\n  - WebView API修改\n  - 自定义权限唯一性要求\n  - **TLS/SSL 默认配置变更**\n\t  \t- 服务器不支持任何已启用的加密套件\n\t  \t- 应用对用于连接服务器的加密套件做出错误的假设\n\t  \t- 服务器不支持 TLSv1.1、TLSv1.2 或新的 TLS 扩展\n  - 支持托管配置文件\n- [Android 4.4](https://developer.android.google.cn/about/versions/kitkat.html)\n\t- **支持Android Beam**\n\t- **添加打印框架**\n\t- 存储访问框架\n\t- 低功耗传感器\n\t- 添加短信提供程序\n\t- **添加全屏沉浸模式**\n        - [Android 沉浸式状态栏的三种实现方式](http://www.jianshu.com/p/be2b7be418d7#)\n        - [兼容库SystemBarTint](https://github.com/jgilfelt/SystemBarTint)\n\t- **添加透明系统 UI 样式**\n\t- 添加新的媒体功能\n\t- RenderScript Compute\n\t\t- 持续性能提升\n\t\t- **GPU 加速**\n\t\t- Android NDK 中的 RenderScript\n\t- 图形\n\t\t- GLES2.0 SurfaceFlinge\n\t\t- 新的硬件合成器支持虚拟显示\n\t- 支持新的连接类型\n\t\t- 新的蓝牙配置文件\n\t\t- 红外发射器\n\t\t- Wi-Fi TDLS 支持\n\t- 无障碍功能\n\t- 安全增强功能\n\t- 内存使用率分析工具\n\t\t- Procstats \n- [Android 4.0,4.1,4.2,4.3](https://developer.android.google.cn/about/versions/jelly-bean.html)\n\t- 支持OpenGL ES 3.0\n\t- 增强蓝牙连接\n\t- 优化位置和传感器\n\t- **添加转场动画**\n\t- 支持Daydream\n\t- **人脸识别解锁**\n\t- **Photo Sphere 全景相片**\n\n\n\t\n\n\n","slug":"Android各个版本新特性","published":1,"updated":"2021-09-10T07:04:21.936Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cktfeap3i000ic2xxpjn17y2v","content":"<p>目前主流的Android适配版本最低版本4.0或5.0，这里主要总结一下Android 4.0以后各个版本特性，方便适配和面试。加粗标注为面试中问到的重点特性，其他为重要适配特性。（倒序）</p>\n<ul>\n<li><a href=\"https://developer.android.google.cn/about/versions/oreo/android-8.0.html\" target=\"_blank\" rel=\"noopener\">Android 8.0</a><ul>\n<li>优化通知<ul>\n<li>通知渠道</li>\n<li>通知标志</li>\n<li>休眠</li>\n<li>通知超时</li>\n<li>通知设置</li>\n<li>通知清除</li>\n</ul>\n</li>\n<li>自动填充框架</li>\n<li>画中画模式：清单中Activity设置android:supportsPictureInPicture</li>\n<li><strong>可下载字体</strong>：<a href=\"https://developer.android.google.cn/reference/android/provider/FontsContract.html\" target=\"_blank\" rel=\"noopener\">FontRequest</a></li>\n<li><a href=\"https://developer.android.google.cn/guide/topics/ui/look-and-feel/fonts-in-xml.html\" target=\"_blank\" rel=\"noopener\">XML 中的字体</a></li>\n<li><strong>自动调整 TextView 的大小</strong></li>\n<li><a href=\"https://developer.android.google.cn/guide/practices/ui_guidelines/icon_design_adaptive.html\" target=\"_blank\" rel=\"noopener\">自适应图标</a></li>\n<li>颜色管理</li>\n<li><a href=\"https://developer.android.google.cn/guide/webapps/managing-webview.html\" target=\"_blank\" rel=\"noopener\">WebView API</a></li>\n<li>多显示器支持</li>\n<li><strong>统一的布局外边距和内边距</strong><br><img src=\"http://upload-images.jianshu.io/upload_images/1534431-b4ba4d688a817290.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></li>\n<li>指针捕获</li>\n<li>应用类别</li>\n<li>Android TV 启动器</li>\n<li>AnimatorSet</li>\n<li><strong>新的 StrictMode 检测程序</strong><br><img src=\"http://upload-images.jianshu.io/upload_images/1534431-e33af7003dde9550.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></li>\n<li>缓存数据</li>\n<li><strong>findViewById() 签名变更</strong><br><img src=\"http://upload-images.jianshu.io/upload_images/1534431-89c0141aa910db0c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></li>\n<li><strong>权限</strong><br><img src=\"http://upload-images.jianshu.io/upload_images/1534431-f4c146ef0be3c03f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></li>\n<li><strong>更新的 Java 支持</strong><br><img src=\"http://upload-images.jianshu.io/upload_images/1534431-0464c897b3051935.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><a href=\"https://developer.android.google.cn/about/versions/nougat/android-7.1.html\" target=\"_blank\" rel=\"noopener\">Android 7.1</a><ul>\n<li>加入重启按钮</li>\n<li>App圆形图标</li>\n<li>添加新的Emoji</li>\n</ul>\n</li>\n<li><a href=\"https://developer.android.google.cn/about/versions/nougat/android-7.0-changes.html\" target=\"_blank\" rel=\"noopener\">Android 7.0</a><ul>\n<li>电池和内存<ul>\n<li>低电耗模式</li>\n<li>Project Svelte：后台优化</li>\n</ul>\n</li>\n<li><strong>权限更改</strong><ul>\n<li>系统权限更改</li>\n</ul>\n</li>\n<li><strong>在应用间文件共享权限控制</strong></li>\n<li><strong>多窗口支持</strong></li>\n<li><strong>通知栏快捷回复</strong></li>\n<li><strong>支持VR</strong></li>\n<li>引入JIT编译器</li>\n<li><strong>画中画</strong></li>\n<li><strong>App快捷菜单</strong></li>\n</ul>\n</li>\n<li><a href=\"https://developer.android.google.cn/about/versions/marshmallow/android-6.0-changes.html\" target=\"_blank\" rel=\"noopener\">Android 6.0</a><ul>\n<li><strong>运行时请求权限</strong></li>\n<li>低电耗模式和应用待机模式</li>\n<li><strong>取消支持 Apache HTTP 客户端</strong></li>\n<li>BoringSSL</li>\n<li>硬件标识符访问权</li>\n<li>通知</li>\n<li>音频管理器变更</li>\n<li><strong>支持文本选择</strong></li>\n<li>Android 密钥库不再支持 DSA。但仍支持 ECDSA</li>\n<li>WLAN 和网络连接变更</li>\n<li>相机服务变更</li>\n<li>APK 验证</li>\n<li>USB 连接</li>\n</ul>\n</li>\n<li><a href=\"https://developer.android.google.cn/about/versions/android-5.0-changes.html#managed_profiles\" target=\"_blank\" rel=\"noopener\">Android 5.0</a><ul>\n<li><strong>Android Runtime (ART)默认运行平台设置</strong></li>\n<li><strong>通知</strong><pre><code>  - Material Design 样式\n  - 声音和振动\n  - 锁定屏幕可见性\n  - 媒体播放\n  - 浮动通知\n</code></pre></li>\n<li><strong>引入Material Design设计</strong></li>\n<li>支持OpenGL ES3.1 </li>\n<li>媒体控件和 RemoteControlClient</li>\n<li>getRecentTasks()</li>\n<li><strong>支持Android NDK中的64位</strong></li>\n<li><strong>只能显示绑定到服务，取消隐藏绑定服务</strong></li>\n<li>WebView API修改</li>\n<li>自定义权限唯一性要求</li>\n<li><strong>TLS/SSL 默认配置变更</strong><pre><code>  - 服务器不支持任何已启用的加密套件\n  - 应用对用于连接服务器的加密套件做出错误的假设\n  - 服务器不支持 TLSv1.1、TLSv1.2 或新的 TLS 扩展\n</code></pre></li>\n<li>支持托管配置文件</li>\n</ul>\n</li>\n<li><a href=\"https://developer.android.google.cn/about/versions/kitkat.html\" target=\"_blank\" rel=\"noopener\">Android 4.4</a><ul>\n<li><strong>支持Android Beam</strong></li>\n<li><strong>添加打印框架</strong></li>\n<li>存储访问框架</li>\n<li>低功耗传感器</li>\n<li>添加短信提供程序</li>\n<li><strong>添加全屏沉浸模式</strong><ul>\n<li><a href=\"http://www.jianshu.com/p/be2b7be418d7#\" target=\"_blank\" rel=\"noopener\">Android 沉浸式状态栏的三种实现方式</a></li>\n<li><a href=\"https://github.com/jgilfelt/SystemBarTint\" target=\"_blank\" rel=\"noopener\">兼容库SystemBarTint</a></li>\n</ul>\n</li>\n<li><strong>添加透明系统 UI 样式</strong></li>\n<li>添加新的媒体功能</li>\n<li>RenderScript Compute<ul>\n<li>持续性能提升</li>\n<li><strong>GPU 加速</strong></li>\n<li>Android NDK 中的 RenderScript</li>\n</ul>\n</li>\n<li>图形<ul>\n<li>GLES2.0 SurfaceFlinge</li>\n<li>新的硬件合成器支持虚拟显示</li>\n</ul>\n</li>\n<li>支持新的连接类型<ul>\n<li>新的蓝牙配置文件</li>\n<li>红外发射器</li>\n<li>Wi-Fi TDLS 支持</li>\n</ul>\n</li>\n<li>无障碍功能</li>\n<li>安全增强功能</li>\n<li>内存使用率分析工具<ul>\n<li>Procstats </li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"https://developer.android.google.cn/about/versions/jelly-bean.html\" target=\"_blank\" rel=\"noopener\">Android 4.0,4.1,4.2,4.3</a><ul>\n<li>支持OpenGL ES 3.0</li>\n<li>增强蓝牙连接</li>\n<li>优化位置和传感器</li>\n<li><strong>添加转场动画</strong></li>\n<li>支持Daydream</li>\n<li><strong>人脸识别解锁</strong></li>\n<li><strong>Photo Sphere 全景相片</strong></li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>目前主流的Android适配版本最低版本4.0或5.0，这里主要总结一下Android 4.0以后各个版本特性，方便适配和面试。加粗标注为面试中问到的重点特性，其他为重要适配特性。（倒序）</p>\n<ul>\n<li><a href=\"https://developer.android.google.cn/about/versions/oreo/android-8.0.html\" target=\"_blank\" rel=\"noopener\">Android 8.0</a><ul>\n<li>优化通知<ul>\n<li>通知渠道</li>\n<li>通知标志</li>\n<li>休眠</li>\n<li>通知超时</li>\n<li>通知设置</li>\n<li>通知清除</li>\n</ul>\n</li>\n<li>自动填充框架</li>\n<li>画中画模式：清单中Activity设置android:supportsPictureInPicture</li>\n<li><strong>可下载字体</strong>：<a href=\"https://developer.android.google.cn/reference/android/provider/FontsContract.html\" target=\"_blank\" rel=\"noopener\">FontRequest</a></li>\n<li><a href=\"https://developer.android.google.cn/guide/topics/ui/look-and-feel/fonts-in-xml.html\" target=\"_blank\" rel=\"noopener\">XML 中的字体</a></li>\n<li><strong>自动调整 TextView 的大小</strong></li>\n<li><a href=\"https://developer.android.google.cn/guide/practices/ui_guidelines/icon_design_adaptive.html\" target=\"_blank\" rel=\"noopener\">自适应图标</a></li>\n<li>颜色管理</li>\n<li><a href=\"https://developer.android.google.cn/guide/webapps/managing-webview.html\" target=\"_blank\" rel=\"noopener\">WebView API</a></li>\n<li>多显示器支持</li>\n<li><strong>统一的布局外边距和内边距</strong><br><img src=\"http://upload-images.jianshu.io/upload_images/1534431-b4ba4d688a817290.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></li>\n<li>指针捕获</li>\n<li>应用类别</li>\n<li>Android TV 启动器</li>\n<li>AnimatorSet</li>\n<li><strong>新的 StrictMode 检测程序</strong><br><img src=\"http://upload-images.jianshu.io/upload_images/1534431-e33af7003dde9550.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></li>\n<li>缓存数据</li>\n<li><strong>findViewById() 签名变更</strong><br><img src=\"http://upload-images.jianshu.io/upload_images/1534431-89c0141aa910db0c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></li>\n<li><strong>权限</strong><br><img src=\"http://upload-images.jianshu.io/upload_images/1534431-f4c146ef0be3c03f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></li>\n<li><strong>更新的 Java 支持</strong><br><img src=\"http://upload-images.jianshu.io/upload_images/1534431-0464c897b3051935.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><a href=\"https://developer.android.google.cn/about/versions/nougat/android-7.1.html\" target=\"_blank\" rel=\"noopener\">Android 7.1</a><ul>\n<li>加入重启按钮</li>\n<li>App圆形图标</li>\n<li>添加新的Emoji</li>\n</ul>\n</li>\n<li><a href=\"https://developer.android.google.cn/about/versions/nougat/android-7.0-changes.html\" target=\"_blank\" rel=\"noopener\">Android 7.0</a><ul>\n<li>电池和内存<ul>\n<li>低电耗模式</li>\n<li>Project Svelte：后台优化</li>\n</ul>\n</li>\n<li><strong>权限更改</strong><ul>\n<li>系统权限更改</li>\n</ul>\n</li>\n<li><strong>在应用间文件共享权限控制</strong></li>\n<li><strong>多窗口支持</strong></li>\n<li><strong>通知栏快捷回复</strong></li>\n<li><strong>支持VR</strong></li>\n<li>引入JIT编译器</li>\n<li><strong>画中画</strong></li>\n<li><strong>App快捷菜单</strong></li>\n</ul>\n</li>\n<li><a href=\"https://developer.android.google.cn/about/versions/marshmallow/android-6.0-changes.html\" target=\"_blank\" rel=\"noopener\">Android 6.0</a><ul>\n<li><strong>运行时请求权限</strong></li>\n<li>低电耗模式和应用待机模式</li>\n<li><strong>取消支持 Apache HTTP 客户端</strong></li>\n<li>BoringSSL</li>\n<li>硬件标识符访问权</li>\n<li>通知</li>\n<li>音频管理器变更</li>\n<li><strong>支持文本选择</strong></li>\n<li>Android 密钥库不再支持 DSA。但仍支持 ECDSA</li>\n<li>WLAN 和网络连接变更</li>\n<li>相机服务变更</li>\n<li>APK 验证</li>\n<li>USB 连接</li>\n</ul>\n</li>\n<li><a href=\"https://developer.android.google.cn/about/versions/android-5.0-changes.html#managed_profiles\" target=\"_blank\" rel=\"noopener\">Android 5.0</a><ul>\n<li><strong>Android Runtime (ART)默认运行平台设置</strong></li>\n<li><strong>通知</strong><pre><code>  - Material Design 样式\n  - 声音和振动\n  - 锁定屏幕可见性\n  - 媒体播放\n  - 浮动通知\n</code></pre></li>\n<li><strong>引入Material Design设计</strong></li>\n<li>支持OpenGL ES3.1 </li>\n<li>媒体控件和 RemoteControlClient</li>\n<li>getRecentTasks()</li>\n<li><strong>支持Android NDK中的64位</strong></li>\n<li><strong>只能显示绑定到服务，取消隐藏绑定服务</strong></li>\n<li>WebView API修改</li>\n<li>自定义权限唯一性要求</li>\n<li><strong>TLS/SSL 默认配置变更</strong><pre><code>  - 服务器不支持任何已启用的加密套件\n  - 应用对用于连接服务器的加密套件做出错误的假设\n  - 服务器不支持 TLSv1.1、TLSv1.2 或新的 TLS 扩展\n</code></pre></li>\n<li>支持托管配置文件</li>\n</ul>\n</li>\n<li><a href=\"https://developer.android.google.cn/about/versions/kitkat.html\" target=\"_blank\" rel=\"noopener\">Android 4.4</a><ul>\n<li><strong>支持Android Beam</strong></li>\n<li><strong>添加打印框架</strong></li>\n<li>存储访问框架</li>\n<li>低功耗传感器</li>\n<li>添加短信提供程序</li>\n<li><strong>添加全屏沉浸模式</strong><ul>\n<li><a href=\"http://www.jianshu.com/p/be2b7be418d7#\" target=\"_blank\" rel=\"noopener\">Android 沉浸式状态栏的三种实现方式</a></li>\n<li><a href=\"https://github.com/jgilfelt/SystemBarTint\" target=\"_blank\" rel=\"noopener\">兼容库SystemBarTint</a></li>\n</ul>\n</li>\n<li><strong>添加透明系统 UI 样式</strong></li>\n<li>添加新的媒体功能</li>\n<li>RenderScript Compute<ul>\n<li>持续性能提升</li>\n<li><strong>GPU 加速</strong></li>\n<li>Android NDK 中的 RenderScript</li>\n</ul>\n</li>\n<li>图形<ul>\n<li>GLES2.0 SurfaceFlinge</li>\n<li>新的硬件合成器支持虚拟显示</li>\n</ul>\n</li>\n<li>支持新的连接类型<ul>\n<li>新的蓝牙配置文件</li>\n<li>红外发射器</li>\n<li>Wi-Fi TDLS 支持</li>\n</ul>\n</li>\n<li>无障碍功能</li>\n<li>安全增强功能</li>\n<li>内存使用率分析工具<ul>\n<li>Procstats </li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"https://developer.android.google.cn/about/versions/jelly-bean.html\" target=\"_blank\" rel=\"noopener\">Android 4.0,4.1,4.2,4.3</a><ul>\n<li>支持OpenGL ES 3.0</li>\n<li>增强蓝牙连接</li>\n<li>优化位置和传感器</li>\n<li><strong>添加转场动画</strong></li>\n<li>支持Daydream</li>\n<li><strong>人脸识别解锁</strong></li>\n<li><strong>Photo Sphere 全景相片</strong></li>\n</ul>\n</li>\n</ul>\n"},{"title":"Android多国语言适配","date":"2015-04-17T23:04:29.000Z","_content":"\n## [Android多国语言适配](http://blog.csdn.net/dyllove98/article/details/8831908)\n - android语言信息都是读取strings.xml(项目/res/values/strings.xml)文件指定key的索引值。\n\n - android语言适配需要在-项目/res下新建不同的语言目录(文件命名规范:values-zh(国家)-rTW(r+区域))如:\n       默认:项目/res/values\n       中国台湾:项目/res/values-zh-rTW\n       中国简体:项目/resvalues-zh-rCN\n\n - 用户启动APP默认读取跟android系统一样的语言文件，如没有配置各国语言则默认读取系统默认语言文件(项目/res/vlues/strings.xml)\n\n - 正在使用app怎么切换语言？\n    <ol>\n    <li>sharePreferences存入设置语言：</li>\n    \n\tSharences sharedPreferences = getActivity().getSharedPrefeivity().getPackageName(), 0);\n\tsharedPreferences.edit().putString(\"language\", lanAtr).commit();\n\t\n    <li>语言更新后，对于之前出现且目前仍旧存活的activity，语言设置是不生效的。可以通过重启对应的activity，让语言及时生效。\n    </li>\n\n     private void restart() {\n              Intent it = new Intent(getActivity(), MainActivity.class); //MainActivity是你想要重启的activity\n              it.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\n             it.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n             getActivity().startActivity(it);\n\t   }\n    \n      </ol>\n","source":"_posts/Android多国语言适配.md","raw":"title: Android多国语言适配\ndate: 2015-04-17 23:04:29\ntags:\ncategories: Android\n---\n\n## [Android多国语言适配](http://blog.csdn.net/dyllove98/article/details/8831908)\n - android语言信息都是读取strings.xml(项目/res/values/strings.xml)文件指定key的索引值。\n\n - android语言适配需要在-项目/res下新建不同的语言目录(文件命名规范:values-zh(国家)-rTW(r+区域))如:\n       默认:项目/res/values\n       中国台湾:项目/res/values-zh-rTW\n       中国简体:项目/resvalues-zh-rCN\n\n - 用户启动APP默认读取跟android系统一样的语言文件，如没有配置各国语言则默认读取系统默认语言文件(项目/res/vlues/strings.xml)\n\n - 正在使用app怎么切换语言？\n    <ol>\n    <li>sharePreferences存入设置语言：</li>\n    \n\tSharences sharedPreferences = getActivity().getSharedPrefeivity().getPackageName(), 0);\n\tsharedPreferences.edit().putString(\"language\", lanAtr).commit();\n\t\n    <li>语言更新后，对于之前出现且目前仍旧存活的activity，语言设置是不生效的。可以通过重启对应的activity，让语言及时生效。\n    </li>\n\n     private void restart() {\n              Intent it = new Intent(getActivity(), MainActivity.class); //MainActivity是你想要重启的activity\n              it.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\n             it.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n             getActivity().startActivity(it);\n\t   }\n    \n      </ol>\n","slug":"Android多国语言适配","published":1,"updated":"2021-09-10T07:04:21.936Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cktfeap3k000kc2xx467ns9fp","content":"<h2 id=\"Android多国语言适配\"><a href=\"#Android多国语言适配\" class=\"headerlink\" title=\"Android多国语言适配\"></a><a href=\"http://blog.csdn.net/dyllove98/article/details/8831908\" target=\"_blank\" rel=\"noopener\">Android多国语言适配</a></h2><ul>\n<li><p>android语言信息都是读取strings.xml(项目/res/values/strings.xml)文件指定key的索引值。</p>\n</li>\n<li><p>android语言适配需要在-项目/res下新建不同的语言目录(文件命名规范:values-zh(国家)-rTW(r+区域))如:</p>\n<pre><code>默认:项目/res/values\n中国台湾:项目/res/values-zh-rTW\n中国简体:项目/resvalues-zh-rCN\n</code></pre></li>\n<li><p>用户启动APP默认读取跟android系统一样的语言文件，如没有配置各国语言则默认读取系统默认语言文件(项目/res/vlues/strings.xml)</p>\n</li>\n<li><p>正在使用app怎么切换语言？</p>\n <ol><br> <li>sharePreferences存入设置语言：</li><br><br> Sharences sharedPreferences = getActivity().getSharedPrefeivity().getPackageName(), 0);<br> sharedPreferences.edit().putString(“language”, lanAtr).commit();<br><br> <li>语言更新后，对于之前出现且目前仍旧存活的activity，语言设置是不生效的。可以通过重启对应的activity，让语言及时生效。<br> </li><br><br>  private void restart() {<br>           Intent it = new Intent(getActivity(), MainActivity.class); //MainActivity是你想要重启的activity<br>           it.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);<br>          it.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);<br>          getActivity().startActivity(it);<br>    }<br><br>   </ol>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Android多国语言适配\"><a href=\"#Android多国语言适配\" class=\"headerlink\" title=\"Android多国语言适配\"></a><a href=\"http://blog.csdn.net/dyllove98/article/details/8831908\" target=\"_blank\" rel=\"noopener\">Android多国语言适配</a></h2><ul>\n<li><p>android语言信息都是读取strings.xml(项目/res/values/strings.xml)文件指定key的索引值。</p>\n</li>\n<li><p>android语言适配需要在-项目/res下新建不同的语言目录(文件命名规范:values-zh(国家)-rTW(r+区域))如:</p>\n<pre><code>默认:项目/res/values\n中国台湾:项目/res/values-zh-rTW\n中国简体:项目/resvalues-zh-rCN\n</code></pre></li>\n<li><p>用户启动APP默认读取跟android系统一样的语言文件，如没有配置各国语言则默认读取系统默认语言文件(项目/res/vlues/strings.xml)</p>\n</li>\n<li><p>正在使用app怎么切换语言？</p>\n <ol><br> <li>sharePreferences存入设置语言：</li><br><br> Sharences sharedPreferences = getActivity().getSharedPrefeivity().getPackageName(), 0);<br> sharedPreferences.edit().putString(“language”, lanAtr).commit();<br><br> <li>语言更新后，对于之前出现且目前仍旧存活的activity，语言设置是不生效的。可以通过重启对应的activity，让语言及时生效。<br> </li><br><br>  private void restart() {<br>           Intent it = new Intent(getActivity(), MainActivity.class); //MainActivity是你想要重启的activity<br>           it.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);<br>          it.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);<br>          getActivity().startActivity(it);<br>    }<br><br>   </ol>\n</li>\n</ul>\n"},{"title":"Android面试","date":"2016-08-24T15:47:29.000Z","_content":"\n\n面试问题总结\n## Android\n#### Handler机制\n- [Handler机制详解](http://www.jianshu.com/p/a04cbabaec83)\n- [Android-异步通信Handler机制](http://www.jianshu.com/p/041fff5acdcf)画图更清晰\n- [Android异步消息处理机制完全解析，带你从源码的角度彻底理解](http://blog.csdn.net/guolin_blog/article/details/9991569)\n\n#### 自定义View\n先总的分类:自绘控件、组合控件、继承控件\n- [Android自定义View的实现方法，带你一步步深入了解View(四)](http://blog.csdn.net/guolin_blog/article/details/17357967)\n\n在回头看View绘制源码\n- [Android LayoutInflater原理分析，带你一步步深入了解View(一)](http://blog.csdn.net/guolin_blog/article/details/12921889)\n- [Android视图绘制流程完全解析，带你一步步深入了解View(二)](http://blog.csdn.net/guolin_blog/article/details/16330267)\n- [Android视图状态及重绘流程分析，带你一步步深入了解View(三)](http://blog.csdn.net/guolin_blog/article/details/17045157)\n注：除了自绘控件需要搞清楚三个方法(onMeasure, onLayout, onDraw)外其他两个自定义相对比较简单。\n\n#### 事件分发机制\n- [Android事件分发机制完全解析，带你从源码的角度彻底理解(上)](http://blog.csdn.net/guolin_blog/article/details/9097463)\n- [Android事件分发机制完全解析，带你从源码的角度彻底理解(下)](http://blog.csdn.net/guolin_blog/article/details/9153747)\n- [图解 Android 事件分发机制](http://www.jianshu.com/p/e99b5e8bd67b)\n注:三个重要方法:\n    - dispatchTouchEvent事件分发\n    - onInterceptTouchEvent 事件拦截\n    - onTouchEvent() 事件处理\n\n#### 跨进程通信IPC\n- 序列化\n  - Serializable：对象序列化到存储设备或者将对象序列化通过网络传输优先选择\n  - Parcelable:Android首选\n- Bindler\n- IPC方式\n  - Bundle\n  - 文件共享\n  - Messenger(不是handler的Message)\n\n- AIDL\n  - [Android Service完全解析，关于服务你所需知道的一切(上)](http://blog.csdn.net/guolin_blog/article/details/11952435)\n  - [Android Service完全解析，关于服务你所需知道的一切(下)](http://blog.csdn.net/guolin_blog/article/details/9797169)\n\n#### Android适配\n- [Android开发：最全面、最易懂的Android屏幕适配解决方案](http://www.jianshu.com/p/ec5a1a30694b)\n- [Android切图](http://www.ui.cn/detail/79573.html)\n    - 1套标注dp图\n    - 三套切图(hdpi,xhpi,xxhdpi)\n\n#### Android动画\n - Frame Animation(帧动画)：按顺序播放事先做好的图像\n - Tween Animation(补间动画):只能对View进行平移，缩放，渐变，旋转\n - Property Animation(属性动画):API11开始引入，基于Object进行属性改变而\n达到动画效果\n - 使用动画场景\n    - 转场动画\n    - 加载动画\n    - 其他动画\n\n## Java基础\n- [\"==\"和equals区别](http://www.cnblogs.com/zhxhdean/archive/2011/03/25/1995431.html)\n  \"==\"是比较的内存地址，equals比较的是值。\n- [Java内存](http://wiki.jikexueyuan.com/project/java-vm/storage.html)\n    ![Java内存区域](http://upload-images.jianshu.io/upload_images/1534431-14bf0620b5705bf7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n  - 程序计数器\n  - Java 虚拟机栈\n      1. 局部变量表\n      > 局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量，其中存放的数据的类型是编译期可知的各种基本数据类型、对象引用（reference）和 returnAddress 类型（它指向了一条字节码指令的地址）.\n      \n      2. 操作数栈\n      > 操作数栈又常被称为操作栈，操作数栈的最大深度也是在编译的时候就确定了。\n      3. 动态连接\n        > 每个栈帧都包含一个指向运行时常量池（在方法区中，后面介绍）中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。\n      4. 方法返回地址\n      > 当一个方法被执行后，有两种方式退出该方法：执行引擎遇到了任意一个方法返回的字节码指令或遇到了异常，并且该异常没有在方法体内得到处理。无论采用何种退出方式，在方法退出之后，都需要返回到方法被调用的位置，程序才能继续执行。\n- 本地方法栈\n该区域与虚拟机栈所发挥的作用非常相似，只是虚拟机栈为虚拟机执行 Java 方法服务，而本地方法栈则为使用到的本地操作系统（Native）方法服务。\n- Java 堆\nJava Heap 是 Java 虚拟机所管理的内存中最大的一块，它是所有线程共享的一块内存区域。几乎所有的对象实例和数组都在这类分配内存。Java Heap 是垃圾收集器管理的主要区域，因此很多时候也被称为“GC堆”。\n- 方法区\n方法区也是各个线程共享的内存区域，它用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据\n- 直接内存\n   不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范定义的内存区域(Fresco图片加载库，就是运行这块内存超越虚拟机内存使用)。\n> 在 JDK1.4 中新引入了 NIO 机制，它是一种基于通道与缓冲区的新 I/O 方式，可以使用Native函数库直接分配堆外内存，然后通过存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。\n- 参考文章\n  - [Java类生命周期](http://blog.csdn.net/zhengzhb/article/details/7517213)\n  - [单例模式讨论篇：单例模式与垃圾回收](http://blog.csdn.net/zhengzhb/article/details/7331354)\n\n- int-char-long各占多少字节数\n\n| 类型 | 位数 | 字节 |\n| :------  | :------ | :------ |\n| byte    | 8       | 1       |\n| char    | 16     | 2     |\n| short   | 16     | 2       |\n| int       | 32     | 4       |\n| long    | 64     | 8      |\n| float    | 32     | 4       |\n| double| 64     | 8      |\n\n  - [Java 23种设计模式](http://wiki.jikexueyuan.com/project/java-design-pattern/factory-pattern.html)\n    - 单例模式\n    - [工厂模式](http://wiki.jikexueyuan.com/project/java-design-pattern/factory-pattern.html)\n       1. [静态工厂模式](http://www.cnblogs.com/lcw/p/3802790.html)\n       2. [工厂方法模式](http://wiki.jikexueyuan.com/project/java-design-pattern/factory-pattern.html)\n       3. [抽象工厂模式](http://wiki.jikexueyuan.com/project/java-design-pattern/abstract-factory-pattern.html)\n       4. 区别：\n          > 静态工厂模式:用静态方法获取指定产品\n             工厂方法模式:定义工厂接口,一个方法,让不同的子类工厂生产指定产品\n             抽象工厂模式:同工厂方法模式类似,只是工厂接口有多个方法\n    - 建造者模式\n    - 代理模式\n    - 策略模式\n    - 模板模式\n    - 观察者模式\n\n#### 网络\n- [HTTP,TCP,Socket关系](http://blog.csdn.net/bjyfb/article/details/6682913)\n - [TCP和UDP区别？TCP几次握手，几次断开？](http://mp.weixin.qq.com/s?__biz=MzA4MzQxMzg5MA==&mid=2649830415&idx=2&sn=760da2138f07c96ef25d451d745c4c72&scene=0#wechat_redirect)\n\n#### 参考资料\n- [Android 开发工程师面试指南](http://www.diycode.cc/wiki/androidinterview)","source":"_posts/Android面试.md","raw":"title: Android面试\ndate: 2016-08-24 15:47:29\ntags:\ncategories: Android\n---\n\n\n面试问题总结\n## Android\n#### Handler机制\n- [Handler机制详解](http://www.jianshu.com/p/a04cbabaec83)\n- [Android-异步通信Handler机制](http://www.jianshu.com/p/041fff5acdcf)画图更清晰\n- [Android异步消息处理机制完全解析，带你从源码的角度彻底理解](http://blog.csdn.net/guolin_blog/article/details/9991569)\n\n#### 自定义View\n先总的分类:自绘控件、组合控件、继承控件\n- [Android自定义View的实现方法，带你一步步深入了解View(四)](http://blog.csdn.net/guolin_blog/article/details/17357967)\n\n在回头看View绘制源码\n- [Android LayoutInflater原理分析，带你一步步深入了解View(一)](http://blog.csdn.net/guolin_blog/article/details/12921889)\n- [Android视图绘制流程完全解析，带你一步步深入了解View(二)](http://blog.csdn.net/guolin_blog/article/details/16330267)\n- [Android视图状态及重绘流程分析，带你一步步深入了解View(三)](http://blog.csdn.net/guolin_blog/article/details/17045157)\n注：除了自绘控件需要搞清楚三个方法(onMeasure, onLayout, onDraw)外其他两个自定义相对比较简单。\n\n#### 事件分发机制\n- [Android事件分发机制完全解析，带你从源码的角度彻底理解(上)](http://blog.csdn.net/guolin_blog/article/details/9097463)\n- [Android事件分发机制完全解析，带你从源码的角度彻底理解(下)](http://blog.csdn.net/guolin_blog/article/details/9153747)\n- [图解 Android 事件分发机制](http://www.jianshu.com/p/e99b5e8bd67b)\n注:三个重要方法:\n    - dispatchTouchEvent事件分发\n    - onInterceptTouchEvent 事件拦截\n    - onTouchEvent() 事件处理\n\n#### 跨进程通信IPC\n- 序列化\n  - Serializable：对象序列化到存储设备或者将对象序列化通过网络传输优先选择\n  - Parcelable:Android首选\n- Bindler\n- IPC方式\n  - Bundle\n  - 文件共享\n  - Messenger(不是handler的Message)\n\n- AIDL\n  - [Android Service完全解析，关于服务你所需知道的一切(上)](http://blog.csdn.net/guolin_blog/article/details/11952435)\n  - [Android Service完全解析，关于服务你所需知道的一切(下)](http://blog.csdn.net/guolin_blog/article/details/9797169)\n\n#### Android适配\n- [Android开发：最全面、最易懂的Android屏幕适配解决方案](http://www.jianshu.com/p/ec5a1a30694b)\n- [Android切图](http://www.ui.cn/detail/79573.html)\n    - 1套标注dp图\n    - 三套切图(hdpi,xhpi,xxhdpi)\n\n#### Android动画\n - Frame Animation(帧动画)：按顺序播放事先做好的图像\n - Tween Animation(补间动画):只能对View进行平移，缩放，渐变，旋转\n - Property Animation(属性动画):API11开始引入，基于Object进行属性改变而\n达到动画效果\n - 使用动画场景\n    - 转场动画\n    - 加载动画\n    - 其他动画\n\n## Java基础\n- [\"==\"和equals区别](http://www.cnblogs.com/zhxhdean/archive/2011/03/25/1995431.html)\n  \"==\"是比较的内存地址，equals比较的是值。\n- [Java内存](http://wiki.jikexueyuan.com/project/java-vm/storage.html)\n    ![Java内存区域](http://upload-images.jianshu.io/upload_images/1534431-14bf0620b5705bf7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n  - 程序计数器\n  - Java 虚拟机栈\n      1. 局部变量表\n      > 局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量，其中存放的数据的类型是编译期可知的各种基本数据类型、对象引用（reference）和 returnAddress 类型（它指向了一条字节码指令的地址）.\n      \n      2. 操作数栈\n      > 操作数栈又常被称为操作栈，操作数栈的最大深度也是在编译的时候就确定了。\n      3. 动态连接\n        > 每个栈帧都包含一个指向运行时常量池（在方法区中，后面介绍）中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。\n      4. 方法返回地址\n      > 当一个方法被执行后，有两种方式退出该方法：执行引擎遇到了任意一个方法返回的字节码指令或遇到了异常，并且该异常没有在方法体内得到处理。无论采用何种退出方式，在方法退出之后，都需要返回到方法被调用的位置，程序才能继续执行。\n- 本地方法栈\n该区域与虚拟机栈所发挥的作用非常相似，只是虚拟机栈为虚拟机执行 Java 方法服务，而本地方法栈则为使用到的本地操作系统（Native）方法服务。\n- Java 堆\nJava Heap 是 Java 虚拟机所管理的内存中最大的一块，它是所有线程共享的一块内存区域。几乎所有的对象实例和数组都在这类分配内存。Java Heap 是垃圾收集器管理的主要区域，因此很多时候也被称为“GC堆”。\n- 方法区\n方法区也是各个线程共享的内存区域，它用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据\n- 直接内存\n   不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范定义的内存区域(Fresco图片加载库，就是运行这块内存超越虚拟机内存使用)。\n> 在 JDK1.4 中新引入了 NIO 机制，它是一种基于通道与缓冲区的新 I/O 方式，可以使用Native函数库直接分配堆外内存，然后通过存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。\n- 参考文章\n  - [Java类生命周期](http://blog.csdn.net/zhengzhb/article/details/7517213)\n  - [单例模式讨论篇：单例模式与垃圾回收](http://blog.csdn.net/zhengzhb/article/details/7331354)\n\n- int-char-long各占多少字节数\n\n| 类型 | 位数 | 字节 |\n| :------  | :------ | :------ |\n| byte    | 8       | 1       |\n| char    | 16     | 2     |\n| short   | 16     | 2       |\n| int       | 32     | 4       |\n| long    | 64     | 8      |\n| float    | 32     | 4       |\n| double| 64     | 8      |\n\n  - [Java 23种设计模式](http://wiki.jikexueyuan.com/project/java-design-pattern/factory-pattern.html)\n    - 单例模式\n    - [工厂模式](http://wiki.jikexueyuan.com/project/java-design-pattern/factory-pattern.html)\n       1. [静态工厂模式](http://www.cnblogs.com/lcw/p/3802790.html)\n       2. [工厂方法模式](http://wiki.jikexueyuan.com/project/java-design-pattern/factory-pattern.html)\n       3. [抽象工厂模式](http://wiki.jikexueyuan.com/project/java-design-pattern/abstract-factory-pattern.html)\n       4. 区别：\n          > 静态工厂模式:用静态方法获取指定产品\n             工厂方法模式:定义工厂接口,一个方法,让不同的子类工厂生产指定产品\n             抽象工厂模式:同工厂方法模式类似,只是工厂接口有多个方法\n    - 建造者模式\n    - 代理模式\n    - 策略模式\n    - 模板模式\n    - 观察者模式\n\n#### 网络\n- [HTTP,TCP,Socket关系](http://blog.csdn.net/bjyfb/article/details/6682913)\n - [TCP和UDP区别？TCP几次握手，几次断开？](http://mp.weixin.qq.com/s?__biz=MzA4MzQxMzg5MA==&mid=2649830415&idx=2&sn=760da2138f07c96ef25d451d745c4c72&scene=0#wechat_redirect)\n\n#### 参考资料\n- [Android 开发工程师面试指南](http://www.diycode.cc/wiki/androidinterview)","slug":"Android面试","published":1,"updated":"2021-09-10T07:04:21.940Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cktfeap3m000mc2xxis7g9wsa","content":"<p>面试问题总结</p>\n<h2 id=\"Android\"><a href=\"#Android\" class=\"headerlink\" title=\"Android\"></a>Android</h2><h4 id=\"Handler机制\"><a href=\"#Handler机制\" class=\"headerlink\" title=\"Handler机制\"></a>Handler机制</h4><ul>\n<li><a href=\"http://www.jianshu.com/p/a04cbabaec83\" target=\"_blank\" rel=\"noopener\">Handler机制详解</a></li>\n<li><a href=\"http://www.jianshu.com/p/041fff5acdcf\" target=\"_blank\" rel=\"noopener\">Android-异步通信Handler机制</a>画图更清晰</li>\n<li><a href=\"http://blog.csdn.net/guolin_blog/article/details/9991569\" target=\"_blank\" rel=\"noopener\">Android异步消息处理机制完全解析，带你从源码的角度彻底理解</a></li>\n</ul>\n<h4 id=\"自定义View\"><a href=\"#自定义View\" class=\"headerlink\" title=\"自定义View\"></a>自定义View</h4><p>先总的分类:自绘控件、组合控件、继承控件</p>\n<ul>\n<li><a href=\"http://blog.csdn.net/guolin_blog/article/details/17357967\" target=\"_blank\" rel=\"noopener\">Android自定义View的实现方法，带你一步步深入了解View(四)</a></li>\n</ul>\n<p>在回头看View绘制源码</p>\n<ul>\n<li><a href=\"http://blog.csdn.net/guolin_blog/article/details/12921889\" target=\"_blank\" rel=\"noopener\">Android LayoutInflater原理分析，带你一步步深入了解View(一)</a></li>\n<li><a href=\"http://blog.csdn.net/guolin_blog/article/details/16330267\" target=\"_blank\" rel=\"noopener\">Android视图绘制流程完全解析，带你一步步深入了解View(二)</a></li>\n<li><a href=\"http://blog.csdn.net/guolin_blog/article/details/17045157\" target=\"_blank\" rel=\"noopener\">Android视图状态及重绘流程分析，带你一步步深入了解View(三)</a><br>注：除了自绘控件需要搞清楚三个方法(onMeasure, onLayout, onDraw)外其他两个自定义相对比较简单。</li>\n</ul>\n<h4 id=\"事件分发机制\"><a href=\"#事件分发机制\" class=\"headerlink\" title=\"事件分发机制\"></a>事件分发机制</h4><ul>\n<li><a href=\"http://blog.csdn.net/guolin_blog/article/details/9097463\" target=\"_blank\" rel=\"noopener\">Android事件分发机制完全解析，带你从源码的角度彻底理解(上)</a></li>\n<li><a href=\"http://blog.csdn.net/guolin_blog/article/details/9153747\" target=\"_blank\" rel=\"noopener\">Android事件分发机制完全解析，带你从源码的角度彻底理解(下)</a></li>\n<li><a href=\"http://www.jianshu.com/p/e99b5e8bd67b\" target=\"_blank\" rel=\"noopener\">图解 Android 事件分发机制</a><br>注:三个重要方法:<ul>\n<li>dispatchTouchEvent事件分发</li>\n<li>onInterceptTouchEvent 事件拦截</li>\n<li>onTouchEvent() 事件处理</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"跨进程通信IPC\"><a href=\"#跨进程通信IPC\" class=\"headerlink\" title=\"跨进程通信IPC\"></a>跨进程通信IPC</h4><ul>\n<li>序列化<ul>\n<li>Serializable：对象序列化到存储设备或者将对象序列化通过网络传输优先选择</li>\n<li>Parcelable:Android首选</li>\n</ul>\n</li>\n<li>Bindler</li>\n<li><p>IPC方式</p>\n<ul>\n<li>Bundle</li>\n<li>文件共享</li>\n<li>Messenger(不是handler的Message)</li>\n</ul>\n</li>\n<li><p>AIDL</p>\n<ul>\n<li><a href=\"http://blog.csdn.net/guolin_blog/article/details/11952435\" target=\"_blank\" rel=\"noopener\">Android Service完全解析，关于服务你所需知道的一切(上)</a></li>\n<li><a href=\"http://blog.csdn.net/guolin_blog/article/details/9797169\" target=\"_blank\" rel=\"noopener\">Android Service完全解析，关于服务你所需知道的一切(下)</a></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Android适配\"><a href=\"#Android适配\" class=\"headerlink\" title=\"Android适配\"></a>Android适配</h4><ul>\n<li><a href=\"http://www.jianshu.com/p/ec5a1a30694b\" target=\"_blank\" rel=\"noopener\">Android开发：最全面、最易懂的Android屏幕适配解决方案</a></li>\n<li><a href=\"http://www.ui.cn/detail/79573.html\" target=\"_blank\" rel=\"noopener\">Android切图</a><ul>\n<li>1套标注dp图</li>\n<li>三套切图(hdpi,xhpi,xxhdpi)</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Android动画\"><a href=\"#Android动画\" class=\"headerlink\" title=\"Android动画\"></a>Android动画</h4><ul>\n<li>Frame Animation(帧动画)：按顺序播放事先做好的图像</li>\n<li>Tween Animation(补间动画):只能对View进行平移，缩放，渐变，旋转</li>\n<li>Property Animation(属性动画):API11开始引入，基于Object进行属性改变而<br>达到动画效果</li>\n<li>使用动画场景<ul>\n<li>转场动画</li>\n<li>加载动画</li>\n<li>其他动画</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Java基础\"><a href=\"#Java基础\" class=\"headerlink\" title=\"Java基础\"></a>Java基础</h2><ul>\n<li><a href=\"http://www.cnblogs.com/zhxhdean/archive/2011/03/25/1995431.html\" target=\"_blank\" rel=\"noopener\">“==”和equals区别</a><br>“==”是比较的内存地址，equals比较的是值。</li>\n<li><p><a href=\"http://wiki.jikexueyuan.com/project/java-vm/storage.html\" target=\"_blank\" rel=\"noopener\">Java内存</a><br>  <img src=\"http://upload-images.jianshu.io/upload_images/1534431-14bf0620b5705bf7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Java内存区域\"></p>\n<ul>\n<li>程序计数器</li>\n<li><p>Java 虚拟机栈</p>\n<ol>\n<li><p>局部变量表</p>\n<blockquote>\n<p>局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量，其中存放的数据的类型是编译期可知的各种基本数据类型、对象引用（reference）和 returnAddress 类型（它指向了一条字节码指令的地址）.</p>\n</blockquote>\n</li>\n<li><p>操作数栈</p>\n<blockquote>\n<p>操作数栈又常被称为操作栈，操作数栈的最大深度也是在编译的时候就确定了。</p>\n</blockquote>\n</li>\n<li>动态连接<blockquote>\n<p>每个栈帧都包含一个指向运行时常量池（在方法区中，后面介绍）中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。</p>\n</blockquote>\n</li>\n<li>方法返回地址<blockquote>\n<p>当一个方法被执行后，有两种方式退出该方法：执行引擎遇到了任意一个方法返回的字节码指令或遇到了异常，并且该异常没有在方法体内得到处理。无论采用何种退出方式，在方法退出之后，都需要返回到方法被调用的位置，程序才能继续执行。</p>\n</blockquote>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>本地方法栈<br>该区域与虚拟机栈所发挥的作用非常相似，只是虚拟机栈为虚拟机执行 Java 方法服务，而本地方法栈则为使用到的本地操作系统（Native）方法服务。</li>\n<li>Java 堆<br>Java Heap 是 Java 虚拟机所管理的内存中最大的一块，它是所有线程共享的一块内存区域。几乎所有的对象实例和数组都在这类分配内存。Java Heap 是垃圾收集器管理的主要区域，因此很多时候也被称为“GC堆”。</li>\n<li>方法区<br>方法区也是各个线程共享的内存区域，它用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</li>\n<li>直接内存<br> 不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范定义的内存区域(Fresco图片加载库，就是运行这块内存超越虚拟机内存使用)。<blockquote>\n<p>在 JDK1.4 中新引入了 NIO 机制，它是一种基于通道与缓冲区的新 I/O 方式，可以使用Native函数库直接分配堆外内存，然后通过存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。</p>\n</blockquote>\n</li>\n<li><p>参考文章</p>\n<ul>\n<li><a href=\"http://blog.csdn.net/zhengzhb/article/details/7517213\" target=\"_blank\" rel=\"noopener\">Java类生命周期</a></li>\n<li><a href=\"http://blog.csdn.net/zhengzhb/article/details/7331354\" target=\"_blank\" rel=\"noopener\">单例模式讨论篇：单例模式与垃圾回收</a></li>\n</ul>\n</li>\n<li><p>int-char-long各占多少字节数</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">类型</th>\n<th style=\"text-align:left\">位数</th>\n<th style=\"text-align:left\">字节</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">byte</td>\n<td style=\"text-align:left\">8</td>\n<td style=\"text-align:left\">1</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">char</td>\n<td style=\"text-align:left\">16</td>\n<td style=\"text-align:left\">2</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">short</td>\n<td style=\"text-align:left\">16</td>\n<td style=\"text-align:left\">2</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">int</td>\n<td style=\"text-align:left\">32</td>\n<td style=\"text-align:left\">4</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">long</td>\n<td style=\"text-align:left\">64</td>\n<td style=\"text-align:left\">8</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">float</td>\n<td style=\"text-align:left\">32</td>\n<td style=\"text-align:left\">4</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">double</td>\n<td style=\"text-align:left\">64</td>\n<td style=\"text-align:left\">8</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><a href=\"http://wiki.jikexueyuan.com/project/java-design-pattern/factory-pattern.html\" target=\"_blank\" rel=\"noopener\">Java 23种设计模式</a><ul>\n<li>单例模式</li>\n<li><a href=\"http://wiki.jikexueyuan.com/project/java-design-pattern/factory-pattern.html\" target=\"_blank\" rel=\"noopener\">工厂模式</a><ol>\n<li><a href=\"http://www.cnblogs.com/lcw/p/3802790.html\" target=\"_blank\" rel=\"noopener\">静态工厂模式</a></li>\n<li><a href=\"http://wiki.jikexueyuan.com/project/java-design-pattern/factory-pattern.html\" target=\"_blank\" rel=\"noopener\">工厂方法模式</a></li>\n<li><a href=\"http://wiki.jikexueyuan.com/project/java-design-pattern/abstract-factory-pattern.html\" target=\"_blank\" rel=\"noopener\">抽象工厂模式</a></li>\n<li>区别：<blockquote>\n<p>静态工厂模式:用静态方法获取指定产品<br>   工厂方法模式:定义工厂接口,一个方法,让不同的子类工厂生产指定产品<br>   抽象工厂模式:同工厂方法模式类似,只是工厂接口有多个方法</p>\n</blockquote>\n</li>\n</ol>\n</li>\n<li>建造者模式</li>\n<li>代理模式</li>\n<li>策略模式</li>\n<li>模板模式</li>\n<li>观察者模式</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"网络\"><a href=\"#网络\" class=\"headerlink\" title=\"网络\"></a>网络</h4><ul>\n<li><a href=\"http://blog.csdn.net/bjyfb/article/details/6682913\" target=\"_blank\" rel=\"noopener\">HTTP,TCP,Socket关系</a><ul>\n<li><a href=\"http://mp.weixin.qq.com/s?__biz=MzA4MzQxMzg5MA==&amp;mid=2649830415&amp;idx=2&amp;sn=760da2138f07c96ef25d451d745c4c72&amp;scene=0#wechat_redirect\" target=\"_blank\" rel=\"noopener\">TCP和UDP区别？TCP几次握手，几次断开？</a></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h4><ul>\n<li><a href=\"http://www.diycode.cc/wiki/androidinterview\" target=\"_blank\" rel=\"noopener\">Android 开发工程师面试指南</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>面试问题总结</p>\n<h2 id=\"Android\"><a href=\"#Android\" class=\"headerlink\" title=\"Android\"></a>Android</h2><h4 id=\"Handler机制\"><a href=\"#Handler机制\" class=\"headerlink\" title=\"Handler机制\"></a>Handler机制</h4><ul>\n<li><a href=\"http://www.jianshu.com/p/a04cbabaec83\" target=\"_blank\" rel=\"noopener\">Handler机制详解</a></li>\n<li><a href=\"http://www.jianshu.com/p/041fff5acdcf\" target=\"_blank\" rel=\"noopener\">Android-异步通信Handler机制</a>画图更清晰</li>\n<li><a href=\"http://blog.csdn.net/guolin_blog/article/details/9991569\" target=\"_blank\" rel=\"noopener\">Android异步消息处理机制完全解析，带你从源码的角度彻底理解</a></li>\n</ul>\n<h4 id=\"自定义View\"><a href=\"#自定义View\" class=\"headerlink\" title=\"自定义View\"></a>自定义View</h4><p>先总的分类:自绘控件、组合控件、继承控件</p>\n<ul>\n<li><a href=\"http://blog.csdn.net/guolin_blog/article/details/17357967\" target=\"_blank\" rel=\"noopener\">Android自定义View的实现方法，带你一步步深入了解View(四)</a></li>\n</ul>\n<p>在回头看View绘制源码</p>\n<ul>\n<li><a href=\"http://blog.csdn.net/guolin_blog/article/details/12921889\" target=\"_blank\" rel=\"noopener\">Android LayoutInflater原理分析，带你一步步深入了解View(一)</a></li>\n<li><a href=\"http://blog.csdn.net/guolin_blog/article/details/16330267\" target=\"_blank\" rel=\"noopener\">Android视图绘制流程完全解析，带你一步步深入了解View(二)</a></li>\n<li><a href=\"http://blog.csdn.net/guolin_blog/article/details/17045157\" target=\"_blank\" rel=\"noopener\">Android视图状态及重绘流程分析，带你一步步深入了解View(三)</a><br>注：除了自绘控件需要搞清楚三个方法(onMeasure, onLayout, onDraw)外其他两个自定义相对比较简单。</li>\n</ul>\n<h4 id=\"事件分发机制\"><a href=\"#事件分发机制\" class=\"headerlink\" title=\"事件分发机制\"></a>事件分发机制</h4><ul>\n<li><a href=\"http://blog.csdn.net/guolin_blog/article/details/9097463\" target=\"_blank\" rel=\"noopener\">Android事件分发机制完全解析，带你从源码的角度彻底理解(上)</a></li>\n<li><a href=\"http://blog.csdn.net/guolin_blog/article/details/9153747\" target=\"_blank\" rel=\"noopener\">Android事件分发机制完全解析，带你从源码的角度彻底理解(下)</a></li>\n<li><a href=\"http://www.jianshu.com/p/e99b5e8bd67b\" target=\"_blank\" rel=\"noopener\">图解 Android 事件分发机制</a><br>注:三个重要方法:<ul>\n<li>dispatchTouchEvent事件分发</li>\n<li>onInterceptTouchEvent 事件拦截</li>\n<li>onTouchEvent() 事件处理</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"跨进程通信IPC\"><a href=\"#跨进程通信IPC\" class=\"headerlink\" title=\"跨进程通信IPC\"></a>跨进程通信IPC</h4><ul>\n<li>序列化<ul>\n<li>Serializable：对象序列化到存储设备或者将对象序列化通过网络传输优先选择</li>\n<li>Parcelable:Android首选</li>\n</ul>\n</li>\n<li>Bindler</li>\n<li><p>IPC方式</p>\n<ul>\n<li>Bundle</li>\n<li>文件共享</li>\n<li>Messenger(不是handler的Message)</li>\n</ul>\n</li>\n<li><p>AIDL</p>\n<ul>\n<li><a href=\"http://blog.csdn.net/guolin_blog/article/details/11952435\" target=\"_blank\" rel=\"noopener\">Android Service完全解析，关于服务你所需知道的一切(上)</a></li>\n<li><a href=\"http://blog.csdn.net/guolin_blog/article/details/9797169\" target=\"_blank\" rel=\"noopener\">Android Service完全解析，关于服务你所需知道的一切(下)</a></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Android适配\"><a href=\"#Android适配\" class=\"headerlink\" title=\"Android适配\"></a>Android适配</h4><ul>\n<li><a href=\"http://www.jianshu.com/p/ec5a1a30694b\" target=\"_blank\" rel=\"noopener\">Android开发：最全面、最易懂的Android屏幕适配解决方案</a></li>\n<li><a href=\"http://www.ui.cn/detail/79573.html\" target=\"_blank\" rel=\"noopener\">Android切图</a><ul>\n<li>1套标注dp图</li>\n<li>三套切图(hdpi,xhpi,xxhdpi)</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Android动画\"><a href=\"#Android动画\" class=\"headerlink\" title=\"Android动画\"></a>Android动画</h4><ul>\n<li>Frame Animation(帧动画)：按顺序播放事先做好的图像</li>\n<li>Tween Animation(补间动画):只能对View进行平移，缩放，渐变，旋转</li>\n<li>Property Animation(属性动画):API11开始引入，基于Object进行属性改变而<br>达到动画效果</li>\n<li>使用动画场景<ul>\n<li>转场动画</li>\n<li>加载动画</li>\n<li>其他动画</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Java基础\"><a href=\"#Java基础\" class=\"headerlink\" title=\"Java基础\"></a>Java基础</h2><ul>\n<li><a href=\"http://www.cnblogs.com/zhxhdean/archive/2011/03/25/1995431.html\" target=\"_blank\" rel=\"noopener\">“==”和equals区别</a><br>“==”是比较的内存地址，equals比较的是值。</li>\n<li><p><a href=\"http://wiki.jikexueyuan.com/project/java-vm/storage.html\" target=\"_blank\" rel=\"noopener\">Java内存</a><br>  <img src=\"http://upload-images.jianshu.io/upload_images/1534431-14bf0620b5705bf7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Java内存区域\"></p>\n<ul>\n<li>程序计数器</li>\n<li><p>Java 虚拟机栈</p>\n<ol>\n<li><p>局部变量表</p>\n<blockquote>\n<p>局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量，其中存放的数据的类型是编译期可知的各种基本数据类型、对象引用（reference）和 returnAddress 类型（它指向了一条字节码指令的地址）.</p>\n</blockquote>\n</li>\n<li><p>操作数栈</p>\n<blockquote>\n<p>操作数栈又常被称为操作栈，操作数栈的最大深度也是在编译的时候就确定了。</p>\n</blockquote>\n</li>\n<li>动态连接<blockquote>\n<p>每个栈帧都包含一个指向运行时常量池（在方法区中，后面介绍）中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。</p>\n</blockquote>\n</li>\n<li>方法返回地址<blockquote>\n<p>当一个方法被执行后，有两种方式退出该方法：执行引擎遇到了任意一个方法返回的字节码指令或遇到了异常，并且该异常没有在方法体内得到处理。无论采用何种退出方式，在方法退出之后，都需要返回到方法被调用的位置，程序才能继续执行。</p>\n</blockquote>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>本地方法栈<br>该区域与虚拟机栈所发挥的作用非常相似，只是虚拟机栈为虚拟机执行 Java 方法服务，而本地方法栈则为使用到的本地操作系统（Native）方法服务。</li>\n<li>Java 堆<br>Java Heap 是 Java 虚拟机所管理的内存中最大的一块，它是所有线程共享的一块内存区域。几乎所有的对象实例和数组都在这类分配内存。Java Heap 是垃圾收集器管理的主要区域，因此很多时候也被称为“GC堆”。</li>\n<li>方法区<br>方法区也是各个线程共享的内存区域，它用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</li>\n<li>直接内存<br> 不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范定义的内存区域(Fresco图片加载库，就是运行这块内存超越虚拟机内存使用)。<blockquote>\n<p>在 JDK1.4 中新引入了 NIO 机制，它是一种基于通道与缓冲区的新 I/O 方式，可以使用Native函数库直接分配堆外内存，然后通过存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。</p>\n</blockquote>\n</li>\n<li><p>参考文章</p>\n<ul>\n<li><a href=\"http://blog.csdn.net/zhengzhb/article/details/7517213\" target=\"_blank\" rel=\"noopener\">Java类生命周期</a></li>\n<li><a href=\"http://blog.csdn.net/zhengzhb/article/details/7331354\" target=\"_blank\" rel=\"noopener\">单例模式讨论篇：单例模式与垃圾回收</a></li>\n</ul>\n</li>\n<li><p>int-char-long各占多少字节数</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">类型</th>\n<th style=\"text-align:left\">位数</th>\n<th style=\"text-align:left\">字节</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">byte</td>\n<td style=\"text-align:left\">8</td>\n<td style=\"text-align:left\">1</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">char</td>\n<td style=\"text-align:left\">16</td>\n<td style=\"text-align:left\">2</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">short</td>\n<td style=\"text-align:left\">16</td>\n<td style=\"text-align:left\">2</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">int</td>\n<td style=\"text-align:left\">32</td>\n<td style=\"text-align:left\">4</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">long</td>\n<td style=\"text-align:left\">64</td>\n<td style=\"text-align:left\">8</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">float</td>\n<td style=\"text-align:left\">32</td>\n<td style=\"text-align:left\">4</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">double</td>\n<td style=\"text-align:left\">64</td>\n<td style=\"text-align:left\">8</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><a href=\"http://wiki.jikexueyuan.com/project/java-design-pattern/factory-pattern.html\" target=\"_blank\" rel=\"noopener\">Java 23种设计模式</a><ul>\n<li>单例模式</li>\n<li><a href=\"http://wiki.jikexueyuan.com/project/java-design-pattern/factory-pattern.html\" target=\"_blank\" rel=\"noopener\">工厂模式</a><ol>\n<li><a href=\"http://www.cnblogs.com/lcw/p/3802790.html\" target=\"_blank\" rel=\"noopener\">静态工厂模式</a></li>\n<li><a href=\"http://wiki.jikexueyuan.com/project/java-design-pattern/factory-pattern.html\" target=\"_blank\" rel=\"noopener\">工厂方法模式</a></li>\n<li><a href=\"http://wiki.jikexueyuan.com/project/java-design-pattern/abstract-factory-pattern.html\" target=\"_blank\" rel=\"noopener\">抽象工厂模式</a></li>\n<li>区别：<blockquote>\n<p>静态工厂模式:用静态方法获取指定产品<br>   工厂方法模式:定义工厂接口,一个方法,让不同的子类工厂生产指定产品<br>   抽象工厂模式:同工厂方法模式类似,只是工厂接口有多个方法</p>\n</blockquote>\n</li>\n</ol>\n</li>\n<li>建造者模式</li>\n<li>代理模式</li>\n<li>策略模式</li>\n<li>模板模式</li>\n<li>观察者模式</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"网络\"><a href=\"#网络\" class=\"headerlink\" title=\"网络\"></a>网络</h4><ul>\n<li><a href=\"http://blog.csdn.net/bjyfb/article/details/6682913\" target=\"_blank\" rel=\"noopener\">HTTP,TCP,Socket关系</a><ul>\n<li><a href=\"http://mp.weixin.qq.com/s?__biz=MzA4MzQxMzg5MA==&amp;mid=2649830415&amp;idx=2&amp;sn=760da2138f07c96ef25d451d745c4c72&amp;scene=0#wechat_redirect\" target=\"_blank\" rel=\"noopener\">TCP和UDP区别？TCP几次握手，几次断开？</a></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h4><ul>\n<li><a href=\"http://www.diycode.cc/wiki/androidinterview\" target=\"_blank\" rel=\"noopener\">Android 开发工程师面试指南</a></li>\n</ul>\n"},{"title":"App共享文件Uri不能为file://","date":"2016-06-17T10:30:00.000Z","_content":"\n\n- 先看异常信息:\n\n````\nE/StrictMode: null\n              java.lang.Throwable: file:// Uri exposed through Intent.getData()\n                  at android.os.StrictMode.onFileUriExposed(StrictMode.java:1757)\n                  at android.net.Uri.checkFileUriExposed(Uri.java:2346)\n                  at android.content.Intent.prepareToLeaveProcess(Intent.java:8045)\n                  at android.app.Instrumentation.execStartActivity(Instrumentation.java:1506)\n                  at android.app.Activity.startActivityForResult(Activity.java:3930)\n                  at android.app.Activity.startActivityForResult(Activity.java:3890)\n                  at android.support.v4.app.FragmentActivity.startActivityForResult(FragmentActivity.java:843)\n                  at android.app.Activity.startActivity(Activity.java:4213)\n                  at android.support.v4.app.ActivityCompatJB.startActivity(ActivityCompatJB.java:26)\n                  at android.support.v4.app.ActivityCompat.startActivity(ActivityCompat.java:133)\n                  at com.horizon.offer.mail.maildetail.impl.ImageAnnexWrapper.openFile(ImageAnnexWrapper.java:26)\n                  at com.horizon.offer.mail.maildetail.MailDetailActivity.openAnnexFile(MailDetailActivity.java:184)\n                  at com.horizon.offer.mail.maildetail.adapter.MailAnnexAdapter$MailAnnexViewHolder$1.onClick(MailAnnexAdapter.java:75)\n                  at android.view.View.performClick(View.java:5204)\n                  at android.view.View$PerformClick.run(View.java:21153)\n                  at android.os.Handler.handleCallback(Handler.java:739)\n                  at android.os.Handler.dispatchMessage(Handler.java:95)\n                  at android.os.Looper.loop(Looper.java:148)\n                  at android.app.ActivityThread.main(ActivityThread.java:5417)\n                  at java.lang.reflect.Method.invoke(Native Method)\n                  at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:726)\n                  at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:616)\n````\n在StrictMode(严格)模式下，App之间共享资源报的异常。\n\n- 出现这个异常的代码\n\n````\npublic void openFile(@NonNull Activity activity, @NonNull File file) {\n        Intent intent = new Intent(Intent.ACTION_VIEW);\n        intent.addCategory(Intent.CATEGORY_DEFAULT);\n        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        /**异常这行代码**/\n        intent.setDataAndType(Uri.fromFile(file), \"image/*\");\n        ActivityCompat.startActivity(activity, intent, null);\n    }\n````\n打印\n\n````\nUri.fromFile(file)\n````\n输出信息\n\n````\nUri uri=file:///storage/emulated/0/download/9text.jpg\n````\n- 各方说明\n\t- [Android N中说明Uri不能以file://的原因](https://developer.android.com/preview/behavior-changes.html#sharing-files)\n\t\t- 传递软件包网域外的 file:// URI 可能给接收器留下无法访问的路径。\n\t\t- 访问权限控制 \n- [解决办法](https://developer.android.com/preview/behavior-changes.html#sharing-files)\n\t- [FileProvider](https://developer.android.com/reference/android/support/v4/content/FileProvider.html)\n- 总结\n\t-  开始搜索Uri.fromFile(file)并分析源码\n\t  \n\t\t````\n\t\t /**\n     * Creates a Uri from a file. The URI has the form\n     * \"file://<absolute path>\". Encodes path characters with the exception of\n     * '/'.\n     *\n     * <p>Example: \"file:///tmp/android.txt\"\n     *\n     * @throws NullPointerException if file is null\n     * @return a Uri for the given file\n     */\n    public static Uri fromFile(File file) {\n        if (file == null) {\n            throw new NullPointerException(\"file\");\n        }\n\n        PathPart path = PathPart.fromDecoded(file.getAbsolutePath());\n        return new HierarchicalUri(\n                \"file\", Part.EMPTY, path, Part.NULL, Part.NULL);\n    }\n\t\t````\n\t\t没有找到相关解决方案。\n\t-  [StrictMode的FileUriExposedException异常检测](https://developer.android.com/reference/android/os/StrictMode.VmPolicy.Builder.html#detectFileUriExposure())中有提到FileProvider的使用\n\t-  我写的一个[demo](https://github.com/milin411/FileIntentDemo.git)\n\t-  给以后提醒app之间共享数据传Uri不能传file://\n\t\n-  参考资料\n\t- [StrictMode](https://developer.android.com/reference/android/os/StrictMode.html) \n\t- [Android Uri和Java URI的区别](http://www.jianshu.com/p/5572b42fc63f)\n\t- [Android的Uri](http://blog.csdn.net/dlutbrucezhang/article/details/8917303) \n\t- [Uri详解之——Uri结构与代码提取](http://blog.csdn.net/harvic880925/article/details/44679239)\n\t- [根据 Android Training课程写的FileProvider小例子](http://blog.csdn.net/zhangyingli/article/details/37902367)\n\t- [FileUriExposedException 异常](https://developer.android.com/preview/behavior-changes.html#sharing-files)\n\t- [FileProvider](https://developer.android.com/reference/android/support/v4/content/FileProvider.html)\n\t- [FileProvider使用](http://blog.csdn.net/zhangyingli/article/details/37902367)\n \n","source":"_posts/App共享文件权限.md","raw":"title: App共享文件Uri不能为file://\ndate: 2016-06-17  10:30:00\ntags:\ncategories: Android\n\n---\n\n\n- 先看异常信息:\n\n````\nE/StrictMode: null\n              java.lang.Throwable: file:// Uri exposed through Intent.getData()\n                  at android.os.StrictMode.onFileUriExposed(StrictMode.java:1757)\n                  at android.net.Uri.checkFileUriExposed(Uri.java:2346)\n                  at android.content.Intent.prepareToLeaveProcess(Intent.java:8045)\n                  at android.app.Instrumentation.execStartActivity(Instrumentation.java:1506)\n                  at android.app.Activity.startActivityForResult(Activity.java:3930)\n                  at android.app.Activity.startActivityForResult(Activity.java:3890)\n                  at android.support.v4.app.FragmentActivity.startActivityForResult(FragmentActivity.java:843)\n                  at android.app.Activity.startActivity(Activity.java:4213)\n                  at android.support.v4.app.ActivityCompatJB.startActivity(ActivityCompatJB.java:26)\n                  at android.support.v4.app.ActivityCompat.startActivity(ActivityCompat.java:133)\n                  at com.horizon.offer.mail.maildetail.impl.ImageAnnexWrapper.openFile(ImageAnnexWrapper.java:26)\n                  at com.horizon.offer.mail.maildetail.MailDetailActivity.openAnnexFile(MailDetailActivity.java:184)\n                  at com.horizon.offer.mail.maildetail.adapter.MailAnnexAdapter$MailAnnexViewHolder$1.onClick(MailAnnexAdapter.java:75)\n                  at android.view.View.performClick(View.java:5204)\n                  at android.view.View$PerformClick.run(View.java:21153)\n                  at android.os.Handler.handleCallback(Handler.java:739)\n                  at android.os.Handler.dispatchMessage(Handler.java:95)\n                  at android.os.Looper.loop(Looper.java:148)\n                  at android.app.ActivityThread.main(ActivityThread.java:5417)\n                  at java.lang.reflect.Method.invoke(Native Method)\n                  at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:726)\n                  at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:616)\n````\n在StrictMode(严格)模式下，App之间共享资源报的异常。\n\n- 出现这个异常的代码\n\n````\npublic void openFile(@NonNull Activity activity, @NonNull File file) {\n        Intent intent = new Intent(Intent.ACTION_VIEW);\n        intent.addCategory(Intent.CATEGORY_DEFAULT);\n        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        /**异常这行代码**/\n        intent.setDataAndType(Uri.fromFile(file), \"image/*\");\n        ActivityCompat.startActivity(activity, intent, null);\n    }\n````\n打印\n\n````\nUri.fromFile(file)\n````\n输出信息\n\n````\nUri uri=file:///storage/emulated/0/download/9text.jpg\n````\n- 各方说明\n\t- [Android N中说明Uri不能以file://的原因](https://developer.android.com/preview/behavior-changes.html#sharing-files)\n\t\t- 传递软件包网域外的 file:// URI 可能给接收器留下无法访问的路径。\n\t\t- 访问权限控制 \n- [解决办法](https://developer.android.com/preview/behavior-changes.html#sharing-files)\n\t- [FileProvider](https://developer.android.com/reference/android/support/v4/content/FileProvider.html)\n- 总结\n\t-  开始搜索Uri.fromFile(file)并分析源码\n\t  \n\t\t````\n\t\t /**\n     * Creates a Uri from a file. The URI has the form\n     * \"file://<absolute path>\". Encodes path characters with the exception of\n     * '/'.\n     *\n     * <p>Example: \"file:///tmp/android.txt\"\n     *\n     * @throws NullPointerException if file is null\n     * @return a Uri for the given file\n     */\n    public static Uri fromFile(File file) {\n        if (file == null) {\n            throw new NullPointerException(\"file\");\n        }\n\n        PathPart path = PathPart.fromDecoded(file.getAbsolutePath());\n        return new HierarchicalUri(\n                \"file\", Part.EMPTY, path, Part.NULL, Part.NULL);\n    }\n\t\t````\n\t\t没有找到相关解决方案。\n\t-  [StrictMode的FileUriExposedException异常检测](https://developer.android.com/reference/android/os/StrictMode.VmPolicy.Builder.html#detectFileUriExposure())中有提到FileProvider的使用\n\t-  我写的一个[demo](https://github.com/milin411/FileIntentDemo.git)\n\t-  给以后提醒app之间共享数据传Uri不能传file://\n\t\n-  参考资料\n\t- [StrictMode](https://developer.android.com/reference/android/os/StrictMode.html) \n\t- [Android Uri和Java URI的区别](http://www.jianshu.com/p/5572b42fc63f)\n\t- [Android的Uri](http://blog.csdn.net/dlutbrucezhang/article/details/8917303) \n\t- [Uri详解之——Uri结构与代码提取](http://blog.csdn.net/harvic880925/article/details/44679239)\n\t- [根据 Android Training课程写的FileProvider小例子](http://blog.csdn.net/zhangyingli/article/details/37902367)\n\t- [FileUriExposedException 异常](https://developer.android.com/preview/behavior-changes.html#sharing-files)\n\t- [FileProvider](https://developer.android.com/reference/android/support/v4/content/FileProvider.html)\n\t- [FileProvider使用](http://blog.csdn.net/zhangyingli/article/details/37902367)\n \n","slug":"App共享文件权限","published":1,"updated":"2021-09-10T07:04:21.941Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cktfeap3n000pc2xxd90ygf4q","content":"<ul>\n<li>先看异常信息:</li>\n</ul>\n<pre><code>E/StrictMode: null\n              java.lang.Throwable: file:// Uri exposed through Intent.getData()\n                  at android.os.StrictMode.onFileUriExposed(StrictMode.java:1757)\n                  at android.net.Uri.checkFileUriExposed(Uri.java:2346)\n                  at android.content.Intent.prepareToLeaveProcess(Intent.java:8045)\n                  at android.app.Instrumentation.execStartActivity(Instrumentation.java:1506)\n                  at android.app.Activity.startActivityForResult(Activity.java:3930)\n                  at android.app.Activity.startActivityForResult(Activity.java:3890)\n                  at android.support.v4.app.FragmentActivity.startActivityForResult(FragmentActivity.java:843)\n                  at android.app.Activity.startActivity(Activity.java:4213)\n                  at android.support.v4.app.ActivityCompatJB.startActivity(ActivityCompatJB.java:26)\n                  at android.support.v4.app.ActivityCompat.startActivity(ActivityCompat.java:133)\n                  at com.horizon.offer.mail.maildetail.impl.ImageAnnexWrapper.openFile(ImageAnnexWrapper.java:26)\n                  at com.horizon.offer.mail.maildetail.MailDetailActivity.openAnnexFile(MailDetailActivity.java:184)\n                  at com.horizon.offer.mail.maildetail.adapter.MailAnnexAdapter$MailAnnexViewHolder$1.onClick(MailAnnexAdapter.java:75)\n                  at android.view.View.performClick(View.java:5204)\n                  at android.view.View$PerformClick.run(View.java:21153)\n                  at android.os.Handler.handleCallback(Handler.java:739)\n                  at android.os.Handler.dispatchMessage(Handler.java:95)\n                  at android.os.Looper.loop(Looper.java:148)\n                  at android.app.ActivityThread.main(ActivityThread.java:5417)\n                  at java.lang.reflect.Method.invoke(Native Method)\n                  at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:726)\n                  at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:616)\n</code></pre><p>在StrictMode(严格)模式下，App之间共享资源报的异常。</p>\n<ul>\n<li>出现这个异常的代码</li>\n</ul>\n<pre><code>public void openFile(@NonNull Activity activity, @NonNull File file) {\n        Intent intent = new Intent(Intent.ACTION_VIEW);\n        intent.addCategory(Intent.CATEGORY_DEFAULT);\n        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        /**异常这行代码**/\n        intent.setDataAndType(Uri.fromFile(file), &quot;image/*&quot;);\n        ActivityCompat.startActivity(activity, intent, null);\n    }\n</code></pre><p>打印</p>\n<pre><code>Uri.fromFile(file)\n</code></pre><p>输出信息</p>\n<pre><code>Uri uri=file:///storage/emulated/0/download/9text.jpg\n</code></pre><ul>\n<li>各方说明<ul>\n<li><a href=\"https://developer.android.com/preview/behavior-changes.html#sharing-files\" target=\"_blank\" rel=\"noopener\">Android N中说明Uri不能以file://的原因</a><ul>\n<li>传递软件包网域外的 file:// URI 可能给接收器留下无法访问的路径。</li>\n<li>访问权限控制 </li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"https://developer.android.com/preview/behavior-changes.html#sharing-files\" target=\"_blank\" rel=\"noopener\">解决办法</a><ul>\n<li><a href=\"https://developer.android.com/reference/android/support/v4/content/FileProvider.html\" target=\"_blank\" rel=\"noopener\">FileProvider</a></li>\n</ul>\n</li>\n<li><p>总结</p>\n<ul>\n<li><p>开始搜索Uri.fromFile(file)并分析源码</p>\n<pre><code>  /**\n* Creates a Uri from a file. The URI has the form\n* &quot;file://&lt;absolute path&gt;&quot;. Encodes path characters with the exception of\n* &#39;/&#39;.\n*\n* &lt;p&gt;Example: &quot;file:///tmp/android.txt&quot;\n*\n* @throws NullPointerException if file is null\n* @return a Uri for the given file\n*/\npublic static Uri fromFile(File file) {\n if (file == null) {\n     throw new NullPointerException(&quot;file&quot;);\n }\n\n PathPart path = PathPart.fromDecoded(file.getAbsolutePath());\n return new HierarchicalUri(\n         &quot;file&quot;, Part.EMPTY, path, Part.NULL, Part.NULL);\n}\n</code></pre><p> 没有找到相关解决方案。</p>\n</li>\n<li><a href=\"https://developer.android.com/reference/android/os/StrictMode.VmPolicy.Builder.html#detectFileUriExposure(\" target=\"_blank\" rel=\"noopener\">StrictMode的FileUriExposedException异常检测</a>)中有提到FileProvider的使用</li>\n<li>我写的一个<a href=\"https://github.com/milin411/FileIntentDemo.git\" target=\"_blank\" rel=\"noopener\">demo</a></li>\n<li>给以后提醒app之间共享数据传Uri不能传file://</li>\n</ul>\n</li>\n<li><p>参考资料</p>\n<ul>\n<li><a href=\"https://developer.android.com/reference/android/os/StrictMode.html\" target=\"_blank\" rel=\"noopener\">StrictMode</a> </li>\n<li><a href=\"http://www.jianshu.com/p/5572b42fc63f\" target=\"_blank\" rel=\"noopener\">Android Uri和Java URI的区别</a></li>\n<li><a href=\"http://blog.csdn.net/dlutbrucezhang/article/details/8917303\" target=\"_blank\" rel=\"noopener\">Android的Uri</a> </li>\n<li><a href=\"http://blog.csdn.net/harvic880925/article/details/44679239\" target=\"_blank\" rel=\"noopener\">Uri详解之——Uri结构与代码提取</a></li>\n<li><a href=\"http://blog.csdn.net/zhangyingli/article/details/37902367\" target=\"_blank\" rel=\"noopener\">根据 Android Training课程写的FileProvider小例子</a></li>\n<li><a href=\"https://developer.android.com/preview/behavior-changes.html#sharing-files\" target=\"_blank\" rel=\"noopener\">FileUriExposedException 异常</a></li>\n<li><a href=\"https://developer.android.com/reference/android/support/v4/content/FileProvider.html\" target=\"_blank\" rel=\"noopener\">FileProvider</a></li>\n<li><a href=\"http://blog.csdn.net/zhangyingli/article/details/37902367\" target=\"_blank\" rel=\"noopener\">FileProvider使用</a></li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>先看异常信息:</li>\n</ul>\n<pre><code>E/StrictMode: null\n              java.lang.Throwable: file:// Uri exposed through Intent.getData()\n                  at android.os.StrictMode.onFileUriExposed(StrictMode.java:1757)\n                  at android.net.Uri.checkFileUriExposed(Uri.java:2346)\n                  at android.content.Intent.prepareToLeaveProcess(Intent.java:8045)\n                  at android.app.Instrumentation.execStartActivity(Instrumentation.java:1506)\n                  at android.app.Activity.startActivityForResult(Activity.java:3930)\n                  at android.app.Activity.startActivityForResult(Activity.java:3890)\n                  at android.support.v4.app.FragmentActivity.startActivityForResult(FragmentActivity.java:843)\n                  at android.app.Activity.startActivity(Activity.java:4213)\n                  at android.support.v4.app.ActivityCompatJB.startActivity(ActivityCompatJB.java:26)\n                  at android.support.v4.app.ActivityCompat.startActivity(ActivityCompat.java:133)\n                  at com.horizon.offer.mail.maildetail.impl.ImageAnnexWrapper.openFile(ImageAnnexWrapper.java:26)\n                  at com.horizon.offer.mail.maildetail.MailDetailActivity.openAnnexFile(MailDetailActivity.java:184)\n                  at com.horizon.offer.mail.maildetail.adapter.MailAnnexAdapter$MailAnnexViewHolder$1.onClick(MailAnnexAdapter.java:75)\n                  at android.view.View.performClick(View.java:5204)\n                  at android.view.View$PerformClick.run(View.java:21153)\n                  at android.os.Handler.handleCallback(Handler.java:739)\n                  at android.os.Handler.dispatchMessage(Handler.java:95)\n                  at android.os.Looper.loop(Looper.java:148)\n                  at android.app.ActivityThread.main(ActivityThread.java:5417)\n                  at java.lang.reflect.Method.invoke(Native Method)\n                  at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:726)\n                  at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:616)\n</code></pre><p>在StrictMode(严格)模式下，App之间共享资源报的异常。</p>\n<ul>\n<li>出现这个异常的代码</li>\n</ul>\n<pre><code>public void openFile(@NonNull Activity activity, @NonNull File file) {\n        Intent intent = new Intent(Intent.ACTION_VIEW);\n        intent.addCategory(Intent.CATEGORY_DEFAULT);\n        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        /**异常这行代码**/\n        intent.setDataAndType(Uri.fromFile(file), &quot;image/*&quot;);\n        ActivityCompat.startActivity(activity, intent, null);\n    }\n</code></pre><p>打印</p>\n<pre><code>Uri.fromFile(file)\n</code></pre><p>输出信息</p>\n<pre><code>Uri uri=file:///storage/emulated/0/download/9text.jpg\n</code></pre><ul>\n<li>各方说明<ul>\n<li><a href=\"https://developer.android.com/preview/behavior-changes.html#sharing-files\" target=\"_blank\" rel=\"noopener\">Android N中说明Uri不能以file://的原因</a><ul>\n<li>传递软件包网域外的 file:// URI 可能给接收器留下无法访问的路径。</li>\n<li>访问权限控制 </li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"https://developer.android.com/preview/behavior-changes.html#sharing-files\" target=\"_blank\" rel=\"noopener\">解决办法</a><ul>\n<li><a href=\"https://developer.android.com/reference/android/support/v4/content/FileProvider.html\" target=\"_blank\" rel=\"noopener\">FileProvider</a></li>\n</ul>\n</li>\n<li><p>总结</p>\n<ul>\n<li><p>开始搜索Uri.fromFile(file)并分析源码</p>\n<pre><code>  /**\n* Creates a Uri from a file. The URI has the form\n* &quot;file://&lt;absolute path&gt;&quot;. Encodes path characters with the exception of\n* &#39;/&#39;.\n*\n* &lt;p&gt;Example: &quot;file:///tmp/android.txt&quot;\n*\n* @throws NullPointerException if file is null\n* @return a Uri for the given file\n*/\npublic static Uri fromFile(File file) {\n if (file == null) {\n     throw new NullPointerException(&quot;file&quot;);\n }\n\n PathPart path = PathPart.fromDecoded(file.getAbsolutePath());\n return new HierarchicalUri(\n         &quot;file&quot;, Part.EMPTY, path, Part.NULL, Part.NULL);\n}\n</code></pre><p> 没有找到相关解决方案。</p>\n</li>\n<li><a href=\"https://developer.android.com/reference/android/os/StrictMode.VmPolicy.Builder.html#detectFileUriExposure(\" target=\"_blank\" rel=\"noopener\">StrictMode的FileUriExposedException异常检测</a>)中有提到FileProvider的使用</li>\n<li>我写的一个<a href=\"https://github.com/milin411/FileIntentDemo.git\" target=\"_blank\" rel=\"noopener\">demo</a></li>\n<li>给以后提醒app之间共享数据传Uri不能传file://</li>\n</ul>\n</li>\n<li><p>参考资料</p>\n<ul>\n<li><a href=\"https://developer.android.com/reference/android/os/StrictMode.html\" target=\"_blank\" rel=\"noopener\">StrictMode</a> </li>\n<li><a href=\"http://www.jianshu.com/p/5572b42fc63f\" target=\"_blank\" rel=\"noopener\">Android Uri和Java URI的区别</a></li>\n<li><a href=\"http://blog.csdn.net/dlutbrucezhang/article/details/8917303\" target=\"_blank\" rel=\"noopener\">Android的Uri</a> </li>\n<li><a href=\"http://blog.csdn.net/harvic880925/article/details/44679239\" target=\"_blank\" rel=\"noopener\">Uri详解之——Uri结构与代码提取</a></li>\n<li><a href=\"http://blog.csdn.net/zhangyingli/article/details/37902367\" target=\"_blank\" rel=\"noopener\">根据 Android Training课程写的FileProvider小例子</a></li>\n<li><a href=\"https://developer.android.com/preview/behavior-changes.html#sharing-files\" target=\"_blank\" rel=\"noopener\">FileUriExposedException 异常</a></li>\n<li><a href=\"https://developer.android.com/reference/android/support/v4/content/FileProvider.html\" target=\"_blank\" rel=\"noopener\">FileProvider</a></li>\n<li><a href=\"http://blog.csdn.net/zhangyingli/article/details/37902367\" target=\"_blank\" rel=\"noopener\">FileProvider使用</a></li>\n</ul>\n</li>\n</ul>\n"},{"title":"Android 微信抢红包","date":"2016-01-15T10:30:00.000Z","_content":"\n\n\n- 主要原理：监听微信APP,如果发送[微信红包]相关通知,则通过Android辅助类服务AccessibilityService实现抢红包点击一系列动作\n\n- 通过AccessibilityService服务监听微信\n- 主要监听配置如下:\n\n```\n监听动作类型\nandroid:accessibilityEventTypes=\"typeNotificationStateChanged|typeWindowStateChanged|typeViewScrolled\"\n完成反馈动作类型\nandroid:accessibilityFeedbackType=\"feedbackGeneric\"\n标识\nandroid:accessibilityFlags=\"\"\n是否可以屏幕内容\nandroid:canRetrieveWindowContent=\"true\"\n服务描述\nandroid:description=\"@string/server_description\"\n通知反应时间\nandroid:notificationTimeout=\"0\"\n监听应用包名\nandroid:packageNames=\"com.tencent.mm\" \n```\n\t\t\n- AccessibilityService实现方法：\n\t-  onAccessibilityEvent()时间监听回调方法\n\t-  onServiceConnected启动服务\n\t-  onUnbind服务器解绑\n\t-  onInterrupt中断服务\n-  事件\n\t- AccessibilityEvent.TYPE_NOTIFICATION_STATE_CHANGED:通知消息事件\n\t-   AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED:屏幕window变化时间\n\t-   AccessibilityEvent.TYPE_VIEW_SCROLLED屏幕滚动监听事件\n\n- 1.微信后台抢红包：\n\t- 后台TYPE_NOTIFICATION_STATE_CHANGED事件监听有[微信红包]通知则点击通知，TYPE_WINDOW_STATE_CHANGED事件点击‘抢红包’，TYPE_WINDOW_STATE_CHANGED点击‘拆红包’，TYPE_WINDOW_STATE_CHANGED跳转红包查看详情\n- 2.微信当前聊天页面抢红包\n\t-  当前聊天页面，不能接受通知\n\t- AccessibilityEvent.TYPE_VIEW_SCROLLED监听屏幕view有新消息，则查看屏幕是否有'抢红包'view，有则点击‘抢红包’view,点击抢红包后则同上通过TYPE_WINDOW_STATE_CHANGED事件完成抢红包一系列动作\n- [代码地址](https://github.com/milin411/RedWallet.git)","source":"_posts/Android微信抢红包.md","raw":"title: Android 微信抢红包\ndate: 2016-01-15  10:30:00\ntags:\ncategories: Android\n\n---\n\n\n\n- 主要原理：监听微信APP,如果发送[微信红包]相关通知,则通过Android辅助类服务AccessibilityService实现抢红包点击一系列动作\n\n- 通过AccessibilityService服务监听微信\n- 主要监听配置如下:\n\n```\n监听动作类型\nandroid:accessibilityEventTypes=\"typeNotificationStateChanged|typeWindowStateChanged|typeViewScrolled\"\n完成反馈动作类型\nandroid:accessibilityFeedbackType=\"feedbackGeneric\"\n标识\nandroid:accessibilityFlags=\"\"\n是否可以屏幕内容\nandroid:canRetrieveWindowContent=\"true\"\n服务描述\nandroid:description=\"@string/server_description\"\n通知反应时间\nandroid:notificationTimeout=\"0\"\n监听应用包名\nandroid:packageNames=\"com.tencent.mm\" \n```\n\t\t\n- AccessibilityService实现方法：\n\t-  onAccessibilityEvent()时间监听回调方法\n\t-  onServiceConnected启动服务\n\t-  onUnbind服务器解绑\n\t-  onInterrupt中断服务\n-  事件\n\t- AccessibilityEvent.TYPE_NOTIFICATION_STATE_CHANGED:通知消息事件\n\t-   AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED:屏幕window变化时间\n\t-   AccessibilityEvent.TYPE_VIEW_SCROLLED屏幕滚动监听事件\n\n- 1.微信后台抢红包：\n\t- 后台TYPE_NOTIFICATION_STATE_CHANGED事件监听有[微信红包]通知则点击通知，TYPE_WINDOW_STATE_CHANGED事件点击‘抢红包’，TYPE_WINDOW_STATE_CHANGED点击‘拆红包’，TYPE_WINDOW_STATE_CHANGED跳转红包查看详情\n- 2.微信当前聊天页面抢红包\n\t-  当前聊天页面，不能接受通知\n\t- AccessibilityEvent.TYPE_VIEW_SCROLLED监听屏幕view有新消息，则查看屏幕是否有'抢红包'view，有则点击‘抢红包’view,点击抢红包后则同上通过TYPE_WINDOW_STATE_CHANGED事件完成抢红包一系列动作\n- [代码地址](https://github.com/milin411/RedWallet.git)","slug":"Android微信抢红包","published":1,"updated":"2021-09-10T07:04:21.936Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cktfeap3o000rc2xx1y8rniww","content":"<ul>\n<li><p>主要原理：监听微信APP,如果发送[微信红包]相关通知,则通过Android辅助类服务AccessibilityService实现抢红包点击一系列动作</p>\n</li>\n<li><p>通过AccessibilityService服务监听微信</p>\n</li>\n<li>主要监听配置如下:</li>\n</ul>\n<pre><code>监听动作类型\nandroid:accessibilityEventTypes=&quot;typeNotificationStateChanged|typeWindowStateChanged|typeViewScrolled&quot;\n完成反馈动作类型\nandroid:accessibilityFeedbackType=&quot;feedbackGeneric&quot;\n标识\nandroid:accessibilityFlags=&quot;&quot;\n是否可以屏幕内容\nandroid:canRetrieveWindowContent=&quot;true&quot;\n服务描述\nandroid:description=&quot;@string/server_description&quot;\n通知反应时间\nandroid:notificationTimeout=&quot;0&quot;\n监听应用包名\nandroid:packageNames=&quot;com.tencent.mm&quot;\n</code></pre><ul>\n<li>AccessibilityService实现方法：<ul>\n<li>onAccessibilityEvent()时间监听回调方法</li>\n<li>onServiceConnected启动服务</li>\n<li>onUnbind服务器解绑</li>\n<li>onInterrupt中断服务</li>\n</ul>\n</li>\n<li><p>事件</p>\n<ul>\n<li>AccessibilityEvent.TYPE_NOTIFICATION_STATE_CHANGED:通知消息事件</li>\n<li>AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED:屏幕window变化时间</li>\n<li>AccessibilityEvent.TYPE_VIEW_SCROLLED屏幕滚动监听事件</li>\n</ul>\n</li>\n<li><p>1.微信后台抢红包：</p>\n<ul>\n<li>后台TYPE_NOTIFICATION_STATE_CHANGED事件监听有[微信红包]通知则点击通知，TYPE_WINDOW_STATE_CHANGED事件点击‘抢红包’，TYPE_WINDOW_STATE_CHANGED点击‘拆红包’，TYPE_WINDOW_STATE_CHANGED跳转红包查看详情</li>\n</ul>\n</li>\n<li>2.微信当前聊天页面抢红包<ul>\n<li>当前聊天页面，不能接受通知</li>\n<li>AccessibilityEvent.TYPE_VIEW_SCROLLED监听屏幕view有新消息，则查看屏幕是否有’抢红包’view，有则点击‘抢红包’view,点击抢红包后则同上通过TYPE_WINDOW_STATE_CHANGED事件完成抢红包一系列动作</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/milin411/RedWallet.git\" target=\"_blank\" rel=\"noopener\">代码地址</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li><p>主要原理：监听微信APP,如果发送[微信红包]相关通知,则通过Android辅助类服务AccessibilityService实现抢红包点击一系列动作</p>\n</li>\n<li><p>通过AccessibilityService服务监听微信</p>\n</li>\n<li>主要监听配置如下:</li>\n</ul>\n<pre><code>监听动作类型\nandroid:accessibilityEventTypes=&quot;typeNotificationStateChanged|typeWindowStateChanged|typeViewScrolled&quot;\n完成反馈动作类型\nandroid:accessibilityFeedbackType=&quot;feedbackGeneric&quot;\n标识\nandroid:accessibilityFlags=&quot;&quot;\n是否可以屏幕内容\nandroid:canRetrieveWindowContent=&quot;true&quot;\n服务描述\nandroid:description=&quot;@string/server_description&quot;\n通知反应时间\nandroid:notificationTimeout=&quot;0&quot;\n监听应用包名\nandroid:packageNames=&quot;com.tencent.mm&quot;\n</code></pre><ul>\n<li>AccessibilityService实现方法：<ul>\n<li>onAccessibilityEvent()时间监听回调方法</li>\n<li>onServiceConnected启动服务</li>\n<li>onUnbind服务器解绑</li>\n<li>onInterrupt中断服务</li>\n</ul>\n</li>\n<li><p>事件</p>\n<ul>\n<li>AccessibilityEvent.TYPE_NOTIFICATION_STATE_CHANGED:通知消息事件</li>\n<li>AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED:屏幕window变化时间</li>\n<li>AccessibilityEvent.TYPE_VIEW_SCROLLED屏幕滚动监听事件</li>\n</ul>\n</li>\n<li><p>1.微信后台抢红包：</p>\n<ul>\n<li>后台TYPE_NOTIFICATION_STATE_CHANGED事件监听有[微信红包]通知则点击通知，TYPE_WINDOW_STATE_CHANGED事件点击‘抢红包’，TYPE_WINDOW_STATE_CHANGED点击‘拆红包’，TYPE_WINDOW_STATE_CHANGED跳转红包查看详情</li>\n</ul>\n</li>\n<li>2.微信当前聊天页面抢红包<ul>\n<li>当前聊天页面，不能接受通知</li>\n<li>AccessibilityEvent.TYPE_VIEW_SCROLLED监听屏幕view有新消息，则查看屏幕是否有’抢红包’view，有则点击‘抢红包’view,点击抢红包后则同上通过TYPE_WINDOW_STATE_CHANGED事件完成抢红包一系列动作</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/milin411/RedWallet.git\" target=\"_blank\" rel=\"noopener\">代码地址</a></li>\n</ul>\n"},{"title":"Axure工具分享","date":"2015-05-08T23:04:29.000Z","_content":"## Axure工具分享\n\n\n####  [Axure工具分享](http://www.webppd.com/thread-8161-1-1.html) - 吴明\n\n- Axure是什么？\n\t- Axure界面原型设计工具，无须懂得控制人机交互的事件处理，设计好后可以导出html格式跨平台开发使用。\n- 原型工具对比：\n  - 使用网页制作软件创建：可以直接操作HTML文件，更接近真实。缺点，你需要掌握HTML语法，掌握复杂的网页制作工具。操作复杂性高。\n  - visio，可以快速的创建单个页面，也可以用创建，缺点：最多只能做到页面直接的关联，按钮，链接上无法创建事件，死板。无法作出接近真实的效果，无法生成HTML文件。\n  - Axure，Axure可以以所见即所得的方式创建界面原型，优点：操作者无须懂的HTML语法，无须懂得控制人机交互的事件处理，例如页面跳转时、命令按钮按下时系统响应 程序脚本（JAVA Script）。因此很适合业务需求分析人员使用。生成的页面，串接在一起，可以进行操作，模拟场景，让系统“动”起来。\n\n- 怎么下载安装Axure\n  - 网上下载axure RP7.0安装(如果有需要的的话下中文包)\n- Axure的使用：\n   - [axure工具界面介绍](http://www.luexiao.com/group/blog/111495)\n   - 组件\n   - [导入第三方组件](http://jingyan.baidu.com/article/bea41d437015bcb4c51be615.html),下载IOS8的组件，android的组件\n   - 常用组件使用:\n       - [Dynamic Pane(动态面板)](http://blog.163.com/summer_wang/blog/static/21470903220132675433741/):\n\n####  [ARC Welder](https://chrome.google.com/webstore/detail/arc-welder/emfinbmielocnlhgmfkkmkngdoccbadn) -王胜\n\n- ARC Welder是一个Chrome插件，可以直接运行原生的安卓APP应用程序\n- 该插件需要Chrome的版本在40.x以上\n- 目前还处于不断完善阶段，所以一些特大游戏类型的App可能跑不起来\n\n","source":"_posts/Axure工具分享.md","raw":"title: Axure工具分享\ndate: 2015-05-08 23:04:29\ntags:\ncategories: 移动组周分享\n---\n## Axure工具分享\n\n\n####  [Axure工具分享](http://www.webppd.com/thread-8161-1-1.html) - 吴明\n\n- Axure是什么？\n\t- Axure界面原型设计工具，无须懂得控制人机交互的事件处理，设计好后可以导出html格式跨平台开发使用。\n- 原型工具对比：\n  - 使用网页制作软件创建：可以直接操作HTML文件，更接近真实。缺点，你需要掌握HTML语法，掌握复杂的网页制作工具。操作复杂性高。\n  - visio，可以快速的创建单个页面，也可以用创建，缺点：最多只能做到页面直接的关联，按钮，链接上无法创建事件，死板。无法作出接近真实的效果，无法生成HTML文件。\n  - Axure，Axure可以以所见即所得的方式创建界面原型，优点：操作者无须懂的HTML语法，无须懂得控制人机交互的事件处理，例如页面跳转时、命令按钮按下时系统响应 程序脚本（JAVA Script）。因此很适合业务需求分析人员使用。生成的页面，串接在一起，可以进行操作，模拟场景，让系统“动”起来。\n\n- 怎么下载安装Axure\n  - 网上下载axure RP7.0安装(如果有需要的的话下中文包)\n- Axure的使用：\n   - [axure工具界面介绍](http://www.luexiao.com/group/blog/111495)\n   - 组件\n   - [导入第三方组件](http://jingyan.baidu.com/article/bea41d437015bcb4c51be615.html),下载IOS8的组件，android的组件\n   - 常用组件使用:\n       - [Dynamic Pane(动态面板)](http://blog.163.com/summer_wang/blog/static/21470903220132675433741/):\n\n####  [ARC Welder](https://chrome.google.com/webstore/detail/arc-welder/emfinbmielocnlhgmfkkmkngdoccbadn) -王胜\n\n- ARC Welder是一个Chrome插件，可以直接运行原生的安卓APP应用程序\n- 该插件需要Chrome的版本在40.x以上\n- 目前还处于不断完善阶段，所以一些特大游戏类型的App可能跑不起来\n\n","slug":"Axure工具分享","published":1,"updated":"2021-09-10T07:04:21.941Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cktfeap3p000tc2xxc13bvjih","content":"<h2 id=\"Axure工具分享\"><a href=\"#Axure工具分享\" class=\"headerlink\" title=\"Axure工具分享\"></a>Axure工具分享</h2><h4 id=\"Axure工具分享-吴明\"><a href=\"#Axure工具分享-吴明\" class=\"headerlink\" title=\"Axure工具分享 - 吴明\"></a><a href=\"http://www.webppd.com/thread-8161-1-1.html\" target=\"_blank\" rel=\"noopener\">Axure工具分享</a> - 吴明</h4><ul>\n<li>Axure是什么？<ul>\n<li>Axure界面原型设计工具，无须懂得控制人机交互的事件处理，设计好后可以导出html格式跨平台开发使用。</li>\n</ul>\n</li>\n<li><p>原型工具对比：</p>\n<ul>\n<li>使用网页制作软件创建：可以直接操作HTML文件，更接近真实。缺点，你需要掌握HTML语法，掌握复杂的网页制作工具。操作复杂性高。</li>\n<li>visio，可以快速的创建单个页面，也可以用创建，缺点：最多只能做到页面直接的关联，按钮，链接上无法创建事件，死板。无法作出接近真实的效果，无法生成HTML文件。</li>\n<li>Axure，Axure可以以所见即所得的方式创建界面原型，优点：操作者无须懂的HTML语法，无须懂得控制人机交互的事件处理，例如页面跳转时、命令按钮按下时系统响应 程序脚本（JAVA Script）。因此很适合业务需求分析人员使用。生成的页面，串接在一起，可以进行操作，模拟场景，让系统“动”起来。</li>\n</ul>\n</li>\n<li><p>怎么下载安装Axure</p>\n<ul>\n<li>网上下载axure RP7.0安装(如果有需要的的话下中文包)</li>\n</ul>\n</li>\n<li>Axure的使用：<ul>\n<li><a href=\"http://www.luexiao.com/group/blog/111495\" target=\"_blank\" rel=\"noopener\">axure工具界面介绍</a></li>\n<li>组件</li>\n<li><a href=\"http://jingyan.baidu.com/article/bea41d437015bcb4c51be615.html\" target=\"_blank\" rel=\"noopener\">导入第三方组件</a>,下载IOS8的组件，android的组件</li>\n<li>常用组件使用:<ul>\n<li><a href=\"http://blog.163.com/summer_wang/blog/static/21470903220132675433741/\" target=\"_blank\" rel=\"noopener\">Dynamic Pane(动态面板)</a>:</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"ARC-Welder-王胜\"><a href=\"#ARC-Welder-王胜\" class=\"headerlink\" title=\"ARC Welder -王胜\"></a><a href=\"https://chrome.google.com/webstore/detail/arc-welder/emfinbmielocnlhgmfkkmkngdoccbadn\" target=\"_blank\" rel=\"noopener\">ARC Welder</a> -王胜</h4><ul>\n<li>ARC Welder是一个Chrome插件，可以直接运行原生的安卓APP应用程序</li>\n<li>该插件需要Chrome的版本在40.x以上</li>\n<li>目前还处于不断完善阶段，所以一些特大游戏类型的App可能跑不起来</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Axure工具分享\"><a href=\"#Axure工具分享\" class=\"headerlink\" title=\"Axure工具分享\"></a>Axure工具分享</h2><h4 id=\"Axure工具分享-吴明\"><a href=\"#Axure工具分享-吴明\" class=\"headerlink\" title=\"Axure工具分享 - 吴明\"></a><a href=\"http://www.webppd.com/thread-8161-1-1.html\" target=\"_blank\" rel=\"noopener\">Axure工具分享</a> - 吴明</h4><ul>\n<li>Axure是什么？<ul>\n<li>Axure界面原型设计工具，无须懂得控制人机交互的事件处理，设计好后可以导出html格式跨平台开发使用。</li>\n</ul>\n</li>\n<li><p>原型工具对比：</p>\n<ul>\n<li>使用网页制作软件创建：可以直接操作HTML文件，更接近真实。缺点，你需要掌握HTML语法，掌握复杂的网页制作工具。操作复杂性高。</li>\n<li>visio，可以快速的创建单个页面，也可以用创建，缺点：最多只能做到页面直接的关联，按钮，链接上无法创建事件，死板。无法作出接近真实的效果，无法生成HTML文件。</li>\n<li>Axure，Axure可以以所见即所得的方式创建界面原型，优点：操作者无须懂的HTML语法，无须懂得控制人机交互的事件处理，例如页面跳转时、命令按钮按下时系统响应 程序脚本（JAVA Script）。因此很适合业务需求分析人员使用。生成的页面，串接在一起，可以进行操作，模拟场景，让系统“动”起来。</li>\n</ul>\n</li>\n<li><p>怎么下载安装Axure</p>\n<ul>\n<li>网上下载axure RP7.0安装(如果有需要的的话下中文包)</li>\n</ul>\n</li>\n<li>Axure的使用：<ul>\n<li><a href=\"http://www.luexiao.com/group/blog/111495\" target=\"_blank\" rel=\"noopener\">axure工具界面介绍</a></li>\n<li>组件</li>\n<li><a href=\"http://jingyan.baidu.com/article/bea41d437015bcb4c51be615.html\" target=\"_blank\" rel=\"noopener\">导入第三方组件</a>,下载IOS8的组件，android的组件</li>\n<li>常用组件使用:<ul>\n<li><a href=\"http://blog.163.com/summer_wang/blog/static/21470903220132675433741/\" target=\"_blank\" rel=\"noopener\">Dynamic Pane(动态面板)</a>:</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"ARC-Welder-王胜\"><a href=\"#ARC-Welder-王胜\" class=\"headerlink\" title=\"ARC Welder -王胜\"></a><a href=\"https://chrome.google.com/webstore/detail/arc-welder/emfinbmielocnlhgmfkkmkngdoccbadn\" target=\"_blank\" rel=\"noopener\">ARC Welder</a> -王胜</h4><ul>\n<li>ARC Welder是一个Chrome插件，可以直接运行原生的安卓APP应用程序</li>\n<li>该插件需要Chrome的版本在40.x以上</li>\n<li>目前还处于不断完善阶段，所以一些特大游戏类型的App可能跑不起来</li>\n</ul>\n"},{"title":"Excption与Error包结构","date":"2016-07-31T14:50:29.000Z","_content":"\n\n- [原文来自](https://github.com/GeniusVJR/LearningNotes/blob/master/Part2/JavaSE/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.md)\n- [Excption与Error包结构。OOM你遇到过哪些情况，SOF你遇到过哪些情况](http://www.cnblogs.com/yumo/p/4909617.html)\n\t- Java异常架构图\n\t![Java异常架构图](https://camo.githubusercontent.com/2248cdf95b8f2569ee0e58aac3d8ed179c89f190/687474703a2f2f696d61676573323031352e636e626c6f67732e636f6d2f626c6f672f3637393930342f3230313531302f3637393930342d32303135313032353231303831333938392d3932313932373931362e6a7067) \n\t\n\t1. Throwable Throwable是 Java 语言中所有错误或异常的超类。 Throwable包含两个子类: Error 和 Exception 。它们通常用于指示发生了异常情况。 Throwable包含了其线程创建时线程执行堆栈的快照，它提供了printStackTrace()等接口用于获取堆栈跟踪数据等信息。\n\t2. Exception Exception及其子类是 Throwable 的一种形式，它指出了合理的应用程序想要捕获的条件。\n\t3. RuntimeException RuntimeException是那些可能在 Java 虚拟机正常运行期间抛出的异常的超类。 编译器不会检查RuntimeException异常。 例如，除数为零时，抛出ArithmeticException异常。RuntimeException是ArithmeticException的超类。当代码发生除数为零的情况时，倘若既\"没有通过throws声明抛出ArithmeticException异常\"，也\"没有通过try...catch...处理该异常\"，也能通过编译。这就是我们所说的\"编译器不会检查RuntimeException异常\"！ 如果代码会产生RuntimeException异常，则需要通过修改代码进行避免。 例如，若会发生除数为零的情况，则需要通过代码避免该情况的发生\n\t4. Error 和Exception一样， Error也是Throwable的子类。 它用于指示合理的应用程序不应该试图捕获的严重问题，大多数这样的错误都是异常条件。 和RuntimeException一样， 编译器也不会检查Error。\n\n\tJava将可抛出(Throwable)的结构分为三种类型： 被检查的异常(Checked Exception)，运行时异常(RuntimeException)和错误(Error)。\n\n\t- (01) 运行时异常 定义 : RuntimeException及其子类都被称为运行时异常。 特点 : Java编译器不会检查它。 也就是说，当程序中可能出现这类异常时，倘若既\"没有通过throws声明抛出它\"，也\"没有用try-catch语句捕获它\"，还是会编译通过。例如，除数为零时产生的ArithmeticException异常，数组越界时产生的IndexOutOfBoundsException异常，fail-fail机制产生的ConcurrentModificationException异常等，都属于运行时异常。 虽然Java编译器不会检查运行时异常，但是我们也可以通过throws进行声明抛出，也可以通过try-catch对它进行捕获处理。 如果产生运行时异常，则需要通过修改代码来进行避免。 例如，若会发生除数为零的情况，则需要通过代码避免该情况的发生！\n\n\t- (02) 被检查的异常 定义 : Exception类本身，以及Exception的子类中除了\"运行时异常\"之外的其它子类都属于被检查异常。 特点 : Java编译器会检查它。 此类异常，要么通过throws进行声明抛出，要么通过try-catch进行捕获处理，否则不能通过编译。例如，CloneNotSupportedException就属于被检查异常。当通过clone()接口去克隆一个对象，而该对象对应的类没有实现Cloneable接口，就会抛出CloneNotSupportedException异常。 被检查异常通常都是可以恢复的。\n\n\t- (03) 错误 定义 : Error类及其子类。 特点 : 和运行时异常一样，编译器也不会对错误进行检查。 当资源不足、约束失败、或是其它程序无法继续运行的条件发生时，就产生错误。程序本身无法修复这些错误的。例如，VirtualMachineError就属于错误。 按照Java惯例，我们是不应该是实现任何新的Error子类的！\n\n\t对于上面的3种结构，我们在抛出异常或错误时，到底该哪一种？《Effective Java》中给出的建议是： 对于可以恢复的条件使用被检查异常，对于程序错误使用运行时异常。","source":"_posts/Excption与Error包结构.md","raw":"title: Excption与Error包结构\ndate: 2016-07-31 14:50:29\ntags:\ncategories: Java\n---\n\n\n- [原文来自](https://github.com/GeniusVJR/LearningNotes/blob/master/Part2/JavaSE/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.md)\n- [Excption与Error包结构。OOM你遇到过哪些情况，SOF你遇到过哪些情况](http://www.cnblogs.com/yumo/p/4909617.html)\n\t- Java异常架构图\n\t![Java异常架构图](https://camo.githubusercontent.com/2248cdf95b8f2569ee0e58aac3d8ed179c89f190/687474703a2f2f696d61676573323031352e636e626c6f67732e636f6d2f626c6f672f3637393930342f3230313531302f3637393930342d32303135313032353231303831333938392d3932313932373931362e6a7067) \n\t\n\t1. Throwable Throwable是 Java 语言中所有错误或异常的超类。 Throwable包含两个子类: Error 和 Exception 。它们通常用于指示发生了异常情况。 Throwable包含了其线程创建时线程执行堆栈的快照，它提供了printStackTrace()等接口用于获取堆栈跟踪数据等信息。\n\t2. Exception Exception及其子类是 Throwable 的一种形式，它指出了合理的应用程序想要捕获的条件。\n\t3. RuntimeException RuntimeException是那些可能在 Java 虚拟机正常运行期间抛出的异常的超类。 编译器不会检查RuntimeException异常。 例如，除数为零时，抛出ArithmeticException异常。RuntimeException是ArithmeticException的超类。当代码发生除数为零的情况时，倘若既\"没有通过throws声明抛出ArithmeticException异常\"，也\"没有通过try...catch...处理该异常\"，也能通过编译。这就是我们所说的\"编译器不会检查RuntimeException异常\"！ 如果代码会产生RuntimeException异常，则需要通过修改代码进行避免。 例如，若会发生除数为零的情况，则需要通过代码避免该情况的发生\n\t4. Error 和Exception一样， Error也是Throwable的子类。 它用于指示合理的应用程序不应该试图捕获的严重问题，大多数这样的错误都是异常条件。 和RuntimeException一样， 编译器也不会检查Error。\n\n\tJava将可抛出(Throwable)的结构分为三种类型： 被检查的异常(Checked Exception)，运行时异常(RuntimeException)和错误(Error)。\n\n\t- (01) 运行时异常 定义 : RuntimeException及其子类都被称为运行时异常。 特点 : Java编译器不会检查它。 也就是说，当程序中可能出现这类异常时，倘若既\"没有通过throws声明抛出它\"，也\"没有用try-catch语句捕获它\"，还是会编译通过。例如，除数为零时产生的ArithmeticException异常，数组越界时产生的IndexOutOfBoundsException异常，fail-fail机制产生的ConcurrentModificationException异常等，都属于运行时异常。 虽然Java编译器不会检查运行时异常，但是我们也可以通过throws进行声明抛出，也可以通过try-catch对它进行捕获处理。 如果产生运行时异常，则需要通过修改代码来进行避免。 例如，若会发生除数为零的情况，则需要通过代码避免该情况的发生！\n\n\t- (02) 被检查的异常 定义 : Exception类本身，以及Exception的子类中除了\"运行时异常\"之外的其它子类都属于被检查异常。 特点 : Java编译器会检查它。 此类异常，要么通过throws进行声明抛出，要么通过try-catch进行捕获处理，否则不能通过编译。例如，CloneNotSupportedException就属于被检查异常。当通过clone()接口去克隆一个对象，而该对象对应的类没有实现Cloneable接口，就会抛出CloneNotSupportedException异常。 被检查异常通常都是可以恢复的。\n\n\t- (03) 错误 定义 : Error类及其子类。 特点 : 和运行时异常一样，编译器也不会对错误进行检查。 当资源不足、约束失败、或是其它程序无法继续运行的条件发生时，就产生错误。程序本身无法修复这些错误的。例如，VirtualMachineError就属于错误。 按照Java惯例，我们是不应该是实现任何新的Error子类的！\n\n\t对于上面的3种结构，我们在抛出异常或错误时，到底该哪一种？《Effective Java》中给出的建议是： 对于可以恢复的条件使用被检查异常，对于程序错误使用运行时异常。","slug":"Excption与Error包结构","published":1,"updated":"2021-09-10T07:04:21.941Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cktfeap3q000vc2xxcscy29ea","content":"<ul>\n<li><a href=\"https://github.com/GeniusVJR/LearningNotes/blob/master/Part2/JavaSE/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.md\" target=\"_blank\" rel=\"noopener\">原文来自</a></li>\n<li><p><a href=\"http://www.cnblogs.com/yumo/p/4909617.html\" target=\"_blank\" rel=\"noopener\">Excption与Error包结构。OOM你遇到过哪些情况，SOF你遇到过哪些情况</a></p>\n<ul>\n<li>Java异常架构图<br><img src=\"https://camo.githubusercontent.com/2248cdf95b8f2569ee0e58aac3d8ed179c89f190/687474703a2f2f696d61676573323031352e636e626c6f67732e636f6d2f626c6f672f3637393930342f3230313531302f3637393930342d32303135313032353231303831333938392d3932313932373931362e6a7067\" alt=\"Java异常架构图\"> </li>\n</ul>\n<ol>\n<li>Throwable Throwable是 Java 语言中所有错误或异常的超类。 Throwable包含两个子类: Error 和 Exception 。它们通常用于指示发生了异常情况。 Throwable包含了其线程创建时线程执行堆栈的快照，它提供了printStackTrace()等接口用于获取堆栈跟踪数据等信息。</li>\n<li>Exception Exception及其子类是 Throwable 的一种形式，它指出了合理的应用程序想要捕获的条件。</li>\n<li>RuntimeException RuntimeException是那些可能在 Java 虚拟机正常运行期间抛出的异常的超类。 编译器不会检查RuntimeException异常。 例如，除数为零时，抛出ArithmeticException异常。RuntimeException是ArithmeticException的超类。当代码发生除数为零的情况时，倘若既”没有通过throws声明抛出ArithmeticException异常”，也”没有通过try…catch…处理该异常”，也能通过编译。这就是我们所说的”编译器不会检查RuntimeException异常”！ 如果代码会产生RuntimeException异常，则需要通过修改代码进行避免。 例如，若会发生除数为零的情况，则需要通过代码避免该情况的发生</li>\n<li><p>Error 和Exception一样， Error也是Throwable的子类。 它用于指示合理的应用程序不应该试图捕获的严重问题，大多数这样的错误都是异常条件。 和RuntimeException一样， 编译器也不会检查Error。</p>\n<p>Java将可抛出(Throwable)的结构分为三种类型： 被检查的异常(Checked Exception)，运行时异常(RuntimeException)和错误(Error)。</p>\n</li>\n</ol>\n<ul>\n<li><p>(01) 运行时异常 定义 : RuntimeException及其子类都被称为运行时异常。 特点 : Java编译器不会检查它。 也就是说，当程序中可能出现这类异常时，倘若既”没有通过throws声明抛出它”，也”没有用try-catch语句捕获它”，还是会编译通过。例如，除数为零时产生的ArithmeticException异常，数组越界时产生的IndexOutOfBoundsException异常，fail-fail机制产生的ConcurrentModificationException异常等，都属于运行时异常。 虽然Java编译器不会检查运行时异常，但是我们也可以通过throws进行声明抛出，也可以通过try-catch对它进行捕获处理。 如果产生运行时异常，则需要通过修改代码来进行避免。 例如，若会发生除数为零的情况，则需要通过代码避免该情况的发生！</p>\n</li>\n<li><p>(02) 被检查的异常 定义 : Exception类本身，以及Exception的子类中除了”运行时异常”之外的其它子类都属于被检查异常。 特点 : Java编译器会检查它。 此类异常，要么通过throws进行声明抛出，要么通过try-catch进行捕获处理，否则不能通过编译。例如，CloneNotSupportedException就属于被检查异常。当通过clone()接口去克隆一个对象，而该对象对应的类没有实现Cloneable接口，就会抛出CloneNotSupportedException异常。 被检查异常通常都是可以恢复的。</p>\n</li>\n<li><p>(03) 错误 定义 : Error类及其子类。 特点 : 和运行时异常一样，编译器也不会对错误进行检查。 当资源不足、约束失败、或是其它程序无法继续运行的条件发生时，就产生错误。程序本身无法修复这些错误的。例如，VirtualMachineError就属于错误。 按照Java惯例，我们是不应该是实现任何新的Error子类的！</p>\n<p>对于上面的3种结构，我们在抛出异常或错误时，到底该哪一种？《Effective Java》中给出的建议是： 对于可以恢复的条件使用被检查异常，对于程序错误使用运行时异常。</p>\n</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li><a href=\"https://github.com/GeniusVJR/LearningNotes/blob/master/Part2/JavaSE/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.md\" target=\"_blank\" rel=\"noopener\">原文来自</a></li>\n<li><p><a href=\"http://www.cnblogs.com/yumo/p/4909617.html\" target=\"_blank\" rel=\"noopener\">Excption与Error包结构。OOM你遇到过哪些情况，SOF你遇到过哪些情况</a></p>\n<ul>\n<li>Java异常架构图<br><img src=\"https://camo.githubusercontent.com/2248cdf95b8f2569ee0e58aac3d8ed179c89f190/687474703a2f2f696d61676573323031352e636e626c6f67732e636f6d2f626c6f672f3637393930342f3230313531302f3637393930342d32303135313032353231303831333938392d3932313932373931362e6a7067\" alt=\"Java异常架构图\"> </li>\n</ul>\n<ol>\n<li>Throwable Throwable是 Java 语言中所有错误或异常的超类。 Throwable包含两个子类: Error 和 Exception 。它们通常用于指示发生了异常情况。 Throwable包含了其线程创建时线程执行堆栈的快照，它提供了printStackTrace()等接口用于获取堆栈跟踪数据等信息。</li>\n<li>Exception Exception及其子类是 Throwable 的一种形式，它指出了合理的应用程序想要捕获的条件。</li>\n<li>RuntimeException RuntimeException是那些可能在 Java 虚拟机正常运行期间抛出的异常的超类。 编译器不会检查RuntimeException异常。 例如，除数为零时，抛出ArithmeticException异常。RuntimeException是ArithmeticException的超类。当代码发生除数为零的情况时，倘若既”没有通过throws声明抛出ArithmeticException异常”，也”没有通过try…catch…处理该异常”，也能通过编译。这就是我们所说的”编译器不会检查RuntimeException异常”！ 如果代码会产生RuntimeException异常，则需要通过修改代码进行避免。 例如，若会发生除数为零的情况，则需要通过代码避免该情况的发生</li>\n<li><p>Error 和Exception一样， Error也是Throwable的子类。 它用于指示合理的应用程序不应该试图捕获的严重问题，大多数这样的错误都是异常条件。 和RuntimeException一样， 编译器也不会检查Error。</p>\n<p>Java将可抛出(Throwable)的结构分为三种类型： 被检查的异常(Checked Exception)，运行时异常(RuntimeException)和错误(Error)。</p>\n</li>\n</ol>\n<ul>\n<li><p>(01) 运行时异常 定义 : RuntimeException及其子类都被称为运行时异常。 特点 : Java编译器不会检查它。 也就是说，当程序中可能出现这类异常时，倘若既”没有通过throws声明抛出它”，也”没有用try-catch语句捕获它”，还是会编译通过。例如，除数为零时产生的ArithmeticException异常，数组越界时产生的IndexOutOfBoundsException异常，fail-fail机制产生的ConcurrentModificationException异常等，都属于运行时异常。 虽然Java编译器不会检查运行时异常，但是我们也可以通过throws进行声明抛出，也可以通过try-catch对它进行捕获处理。 如果产生运行时异常，则需要通过修改代码来进行避免。 例如，若会发生除数为零的情况，则需要通过代码避免该情况的发生！</p>\n</li>\n<li><p>(02) 被检查的异常 定义 : Exception类本身，以及Exception的子类中除了”运行时异常”之外的其它子类都属于被检查异常。 特点 : Java编译器会检查它。 此类异常，要么通过throws进行声明抛出，要么通过try-catch进行捕获处理，否则不能通过编译。例如，CloneNotSupportedException就属于被检查异常。当通过clone()接口去克隆一个对象，而该对象对应的类没有实现Cloneable接口，就会抛出CloneNotSupportedException异常。 被检查异常通常都是可以恢复的。</p>\n</li>\n<li><p>(03) 错误 定义 : Error类及其子类。 特点 : 和运行时异常一样，编译器也不会对错误进行检查。 当资源不足、约束失败、或是其它程序无法继续运行的条件发生时，就产生错误。程序本身无法修复这些错误的。例如，VirtualMachineError就属于错误。 按照Java惯例，我们是不应该是实现任何新的Error子类的！</p>\n<p>对于上面的3种结构，我们在抛出异常或错误时，到底该哪一种？《Effective Java》中给出的建议是： 对于可以恢复的条件使用被检查异常，对于程序错误使用运行时异常。</p>\n</li>\n</ul>\n</li>\n</ul>\n"},{"title":"Java7 switch String","date":"2017-01-25T14:16:29.000Z","_content":"\n\n- Switch string\n\t- Java 7新特性，原来switch只能支持int，byte。short，char,枚举\n- 那具体性能如何了？看下code\n\n````\npackage com.wilson.test;\npublic class SwitchTest {\n    public static final String NUM_ONE = \"1\";\n    public static final String NUM_TWO = \"2\";\n    public static final String NUM_THREE = \"3\";\n    public static final String NUM_FOUR = \"4\";\n    public static final String NUM_FIVE = \"5\";\n    public static final String NUM_SIX = \"6\";\n    public static final String NUM_SEVEN = \"7\";\n    public static final String NUM_EIGHT = \"8\";\n\n    public static void main(String[] args) {\n        System.out.println(\"1->switchTime:\"+switchOutput(\"1\")+\",ifElse:\"+ifElseOutput(\"1\"));\n        System.out.println(\"2->switchTime:\"+switchOutput(\"2\")+\",ifElse:\"+ifElseOutput(\"2\"));\n        System.out.println(\"3->switchTime:\"+switchOutput(\"3\")+\",ifElse:\"+ifElseOutput(\"3\"));\n        System.out.println(\"4->switchTime:\"+switchOutput(\"4\")+\",ifElse:\"+ifElseOutput(\"4\"));\n        System.out.println(\"5->switchTime:\"+switchOutput(\"5\")+\",ifElse:\"+ifElseOutput(\"5\"));\n        System.out.println(\"6->switchTime:\"+switchOutput(\"6\")+\",ifElse:\"+ifElseOutput(\"6\"));\n        System.out.println(\"7->switchTime:\"+switchOutput(\"7\")+\",ifElse:\"+ifElseOutput(\"7\"));\n        System.out.println(\"8->switchTime:\"+switchOutput(\"8\")+\",ifElse:\"+ifElseOutput(\"8\"));\n    }\n\n    public static long switchOutput(String num) {\n        long start = System.currentTimeMillis();\n        if (num == null || num.equals(\"\")) {\n            return 0;\n        }\n        for (int i = 0; i < 1000000000; i++) {\n            switch (num) {\n                case NUM_ONE:\n                    break;\n                case NUM_TWO:\n                    break;\n                case NUM_THREE:\n                    break;\n                case NUM_FOUR:\n                    break;\n                case NUM_FIVE:\n                    break;\n                case NUM_SIX:\n                    break;\n                case NUM_SEVEN:\n                    break;\n                case NUM_EIGHT:\n                    break;\n            }\n        }\n\n        long end = System.currentTimeMillis();\n        return end - start;\n    }\n\n    public static long ifElseOutput(String num) {\n        long start = System.currentTimeMillis();\n        for (int i = 0; i < 1000000000; i++) {\n            if (num.equals(NUM_ONE)) {\n                break;\n            } else if (num.equals(NUM_TWO)) {\n                break;\n            } else if (num.equals(NUM_THREE)) {\n                break;\n            } else if (num.equals(NUM_FOUR)) {\n                break;\n            } else if (num.equals(NUM_FIVE)) {\n                break;\n            } else if (num.equals(NUM_SIX)) {\n                break;\n            } else if (num.equals(NUM_SEVEN)) {\n                break;\n            } else if (num.equals(NUM_EIGHT)) {\n                break;\n            }\n        }\n\n        long end = System.currentTimeMillis();\n        return end - start;\n    }\n}\n\n````\n开始想当然switch速度更快，那实际输出了?\n\n````\n1->switchTime:1868,ifElse:0\n2->switchTime:2381,ifElse:0\n3->switchTime:985,ifElse:0\n4->switchTime:1002,ifElse:0\n5->switchTime:486,ifElse:0\n6->switchTime:662,ifElse:0\n7->switchTime:652,ifElse:0\n8->switchTime:661,ifElse:0\n````\n结果大出我所希望的。用\"if-if-else\"几乎完胜switch String，那为什么了？\n[可以看下这篇文章](http://it.deepinmind.com/java/2014/05/08/how-string-in-switch-works-in-java-7.html),主要switch string，是通过equal和hashcode实现的。String先通过hashcode转换为int，在通过switch int，然后子case里面在if equal String。\n- 看来还是回来老路，只是添加一个新的支持特性而效率没有提高。对应String还是用if-if-else吧","source":"_posts/Java7_Switch_String.md","raw":"title: Java7 switch String\ndate: 2017-01-25 14:16:29\ntags:\ncategories: Java\n---\n\n\n- Switch string\n\t- Java 7新特性，原来switch只能支持int，byte。short，char,枚举\n- 那具体性能如何了？看下code\n\n````\npackage com.wilson.test;\npublic class SwitchTest {\n    public static final String NUM_ONE = \"1\";\n    public static final String NUM_TWO = \"2\";\n    public static final String NUM_THREE = \"3\";\n    public static final String NUM_FOUR = \"4\";\n    public static final String NUM_FIVE = \"5\";\n    public static final String NUM_SIX = \"6\";\n    public static final String NUM_SEVEN = \"7\";\n    public static final String NUM_EIGHT = \"8\";\n\n    public static void main(String[] args) {\n        System.out.println(\"1->switchTime:\"+switchOutput(\"1\")+\",ifElse:\"+ifElseOutput(\"1\"));\n        System.out.println(\"2->switchTime:\"+switchOutput(\"2\")+\",ifElse:\"+ifElseOutput(\"2\"));\n        System.out.println(\"3->switchTime:\"+switchOutput(\"3\")+\",ifElse:\"+ifElseOutput(\"3\"));\n        System.out.println(\"4->switchTime:\"+switchOutput(\"4\")+\",ifElse:\"+ifElseOutput(\"4\"));\n        System.out.println(\"5->switchTime:\"+switchOutput(\"5\")+\",ifElse:\"+ifElseOutput(\"5\"));\n        System.out.println(\"6->switchTime:\"+switchOutput(\"6\")+\",ifElse:\"+ifElseOutput(\"6\"));\n        System.out.println(\"7->switchTime:\"+switchOutput(\"7\")+\",ifElse:\"+ifElseOutput(\"7\"));\n        System.out.println(\"8->switchTime:\"+switchOutput(\"8\")+\",ifElse:\"+ifElseOutput(\"8\"));\n    }\n\n    public static long switchOutput(String num) {\n        long start = System.currentTimeMillis();\n        if (num == null || num.equals(\"\")) {\n            return 0;\n        }\n        for (int i = 0; i < 1000000000; i++) {\n            switch (num) {\n                case NUM_ONE:\n                    break;\n                case NUM_TWO:\n                    break;\n                case NUM_THREE:\n                    break;\n                case NUM_FOUR:\n                    break;\n                case NUM_FIVE:\n                    break;\n                case NUM_SIX:\n                    break;\n                case NUM_SEVEN:\n                    break;\n                case NUM_EIGHT:\n                    break;\n            }\n        }\n\n        long end = System.currentTimeMillis();\n        return end - start;\n    }\n\n    public static long ifElseOutput(String num) {\n        long start = System.currentTimeMillis();\n        for (int i = 0; i < 1000000000; i++) {\n            if (num.equals(NUM_ONE)) {\n                break;\n            } else if (num.equals(NUM_TWO)) {\n                break;\n            } else if (num.equals(NUM_THREE)) {\n                break;\n            } else if (num.equals(NUM_FOUR)) {\n                break;\n            } else if (num.equals(NUM_FIVE)) {\n                break;\n            } else if (num.equals(NUM_SIX)) {\n                break;\n            } else if (num.equals(NUM_SEVEN)) {\n                break;\n            } else if (num.equals(NUM_EIGHT)) {\n                break;\n            }\n        }\n\n        long end = System.currentTimeMillis();\n        return end - start;\n    }\n}\n\n````\n开始想当然switch速度更快，那实际输出了?\n\n````\n1->switchTime:1868,ifElse:0\n2->switchTime:2381,ifElse:0\n3->switchTime:985,ifElse:0\n4->switchTime:1002,ifElse:0\n5->switchTime:486,ifElse:0\n6->switchTime:662,ifElse:0\n7->switchTime:652,ifElse:0\n8->switchTime:661,ifElse:0\n````\n结果大出我所希望的。用\"if-if-else\"几乎完胜switch String，那为什么了？\n[可以看下这篇文章](http://it.deepinmind.com/java/2014/05/08/how-string-in-switch-works-in-java-7.html),主要switch string，是通过equal和hashcode实现的。String先通过hashcode转换为int，在通过switch int，然后子case里面在if equal String。\n- 看来还是回来老路，只是添加一个新的支持特性而效率没有提高。对应String还是用if-if-else吧","slug":"Java7-Switch-String","published":1,"updated":"2021-09-10T07:04:21.941Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cktfeap3r000xc2xx1q56j5vv","content":"<ul>\n<li>Switch string<ul>\n<li>Java 7新特性，原来switch只能支持int，byte。short，char,枚举</li>\n</ul>\n</li>\n<li>那具体性能如何了？看下code</li>\n</ul>\n<pre><code>package com.wilson.test;\npublic class SwitchTest {\n    public static final String NUM_ONE = &quot;1&quot;;\n    public static final String NUM_TWO = &quot;2&quot;;\n    public static final String NUM_THREE = &quot;3&quot;;\n    public static final String NUM_FOUR = &quot;4&quot;;\n    public static final String NUM_FIVE = &quot;5&quot;;\n    public static final String NUM_SIX = &quot;6&quot;;\n    public static final String NUM_SEVEN = &quot;7&quot;;\n    public static final String NUM_EIGHT = &quot;8&quot;;\n\n    public static void main(String[] args) {\n        System.out.println(&quot;1-&gt;switchTime:&quot;+switchOutput(&quot;1&quot;)+&quot;,ifElse:&quot;+ifElseOutput(&quot;1&quot;));\n        System.out.println(&quot;2-&gt;switchTime:&quot;+switchOutput(&quot;2&quot;)+&quot;,ifElse:&quot;+ifElseOutput(&quot;2&quot;));\n        System.out.println(&quot;3-&gt;switchTime:&quot;+switchOutput(&quot;3&quot;)+&quot;,ifElse:&quot;+ifElseOutput(&quot;3&quot;));\n        System.out.println(&quot;4-&gt;switchTime:&quot;+switchOutput(&quot;4&quot;)+&quot;,ifElse:&quot;+ifElseOutput(&quot;4&quot;));\n        System.out.println(&quot;5-&gt;switchTime:&quot;+switchOutput(&quot;5&quot;)+&quot;,ifElse:&quot;+ifElseOutput(&quot;5&quot;));\n        System.out.println(&quot;6-&gt;switchTime:&quot;+switchOutput(&quot;6&quot;)+&quot;,ifElse:&quot;+ifElseOutput(&quot;6&quot;));\n        System.out.println(&quot;7-&gt;switchTime:&quot;+switchOutput(&quot;7&quot;)+&quot;,ifElse:&quot;+ifElseOutput(&quot;7&quot;));\n        System.out.println(&quot;8-&gt;switchTime:&quot;+switchOutput(&quot;8&quot;)+&quot;,ifElse:&quot;+ifElseOutput(&quot;8&quot;));\n    }\n\n    public static long switchOutput(String num) {\n        long start = System.currentTimeMillis();\n        if (num == null || num.equals(&quot;&quot;)) {\n            return 0;\n        }\n        for (int i = 0; i &lt; 1000000000; i++) {\n            switch (num) {\n                case NUM_ONE:\n                    break;\n                case NUM_TWO:\n                    break;\n                case NUM_THREE:\n                    break;\n                case NUM_FOUR:\n                    break;\n                case NUM_FIVE:\n                    break;\n                case NUM_SIX:\n                    break;\n                case NUM_SEVEN:\n                    break;\n                case NUM_EIGHT:\n                    break;\n            }\n        }\n\n        long end = System.currentTimeMillis();\n        return end - start;\n    }\n\n    public static long ifElseOutput(String num) {\n        long start = System.currentTimeMillis();\n        for (int i = 0; i &lt; 1000000000; i++) {\n            if (num.equals(NUM_ONE)) {\n                break;\n            } else if (num.equals(NUM_TWO)) {\n                break;\n            } else if (num.equals(NUM_THREE)) {\n                break;\n            } else if (num.equals(NUM_FOUR)) {\n                break;\n            } else if (num.equals(NUM_FIVE)) {\n                break;\n            } else if (num.equals(NUM_SIX)) {\n                break;\n            } else if (num.equals(NUM_SEVEN)) {\n                break;\n            } else if (num.equals(NUM_EIGHT)) {\n                break;\n            }\n        }\n\n        long end = System.currentTimeMillis();\n        return end - start;\n    }\n}\n</code></pre><p>开始想当然switch速度更快，那实际输出了?</p>\n<pre><code>1-&gt;switchTime:1868,ifElse:0\n2-&gt;switchTime:2381,ifElse:0\n3-&gt;switchTime:985,ifElse:0\n4-&gt;switchTime:1002,ifElse:0\n5-&gt;switchTime:486,ifElse:0\n6-&gt;switchTime:662,ifElse:0\n7-&gt;switchTime:652,ifElse:0\n8-&gt;switchTime:661,ifElse:0\n</code></pre><p>结果大出我所希望的。用”if-if-else”几乎完胜switch String，那为什么了？<br><a href=\"http://it.deepinmind.com/java/2014/05/08/how-string-in-switch-works-in-java-7.html\" target=\"_blank\" rel=\"noopener\">可以看下这篇文章</a>,主要switch string，是通过equal和hashcode实现的。String先通过hashcode转换为int，在通过switch int，然后子case里面在if equal String。</p>\n<ul>\n<li>看来还是回来老路，只是添加一个新的支持特性而效率没有提高。对应String还是用if-if-else吧</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>Switch string<ul>\n<li>Java 7新特性，原来switch只能支持int，byte。short，char,枚举</li>\n</ul>\n</li>\n<li>那具体性能如何了？看下code</li>\n</ul>\n<pre><code>package com.wilson.test;\npublic class SwitchTest {\n    public static final String NUM_ONE = &quot;1&quot;;\n    public static final String NUM_TWO = &quot;2&quot;;\n    public static final String NUM_THREE = &quot;3&quot;;\n    public static final String NUM_FOUR = &quot;4&quot;;\n    public static final String NUM_FIVE = &quot;5&quot;;\n    public static final String NUM_SIX = &quot;6&quot;;\n    public static final String NUM_SEVEN = &quot;7&quot;;\n    public static final String NUM_EIGHT = &quot;8&quot;;\n\n    public static void main(String[] args) {\n        System.out.println(&quot;1-&gt;switchTime:&quot;+switchOutput(&quot;1&quot;)+&quot;,ifElse:&quot;+ifElseOutput(&quot;1&quot;));\n        System.out.println(&quot;2-&gt;switchTime:&quot;+switchOutput(&quot;2&quot;)+&quot;,ifElse:&quot;+ifElseOutput(&quot;2&quot;));\n        System.out.println(&quot;3-&gt;switchTime:&quot;+switchOutput(&quot;3&quot;)+&quot;,ifElse:&quot;+ifElseOutput(&quot;3&quot;));\n        System.out.println(&quot;4-&gt;switchTime:&quot;+switchOutput(&quot;4&quot;)+&quot;,ifElse:&quot;+ifElseOutput(&quot;4&quot;));\n        System.out.println(&quot;5-&gt;switchTime:&quot;+switchOutput(&quot;5&quot;)+&quot;,ifElse:&quot;+ifElseOutput(&quot;5&quot;));\n        System.out.println(&quot;6-&gt;switchTime:&quot;+switchOutput(&quot;6&quot;)+&quot;,ifElse:&quot;+ifElseOutput(&quot;6&quot;));\n        System.out.println(&quot;7-&gt;switchTime:&quot;+switchOutput(&quot;7&quot;)+&quot;,ifElse:&quot;+ifElseOutput(&quot;7&quot;));\n        System.out.println(&quot;8-&gt;switchTime:&quot;+switchOutput(&quot;8&quot;)+&quot;,ifElse:&quot;+ifElseOutput(&quot;8&quot;));\n    }\n\n    public static long switchOutput(String num) {\n        long start = System.currentTimeMillis();\n        if (num == null || num.equals(&quot;&quot;)) {\n            return 0;\n        }\n        for (int i = 0; i &lt; 1000000000; i++) {\n            switch (num) {\n                case NUM_ONE:\n                    break;\n                case NUM_TWO:\n                    break;\n                case NUM_THREE:\n                    break;\n                case NUM_FOUR:\n                    break;\n                case NUM_FIVE:\n                    break;\n                case NUM_SIX:\n                    break;\n                case NUM_SEVEN:\n                    break;\n                case NUM_EIGHT:\n                    break;\n            }\n        }\n\n        long end = System.currentTimeMillis();\n        return end - start;\n    }\n\n    public static long ifElseOutput(String num) {\n        long start = System.currentTimeMillis();\n        for (int i = 0; i &lt; 1000000000; i++) {\n            if (num.equals(NUM_ONE)) {\n                break;\n            } else if (num.equals(NUM_TWO)) {\n                break;\n            } else if (num.equals(NUM_THREE)) {\n                break;\n            } else if (num.equals(NUM_FOUR)) {\n                break;\n            } else if (num.equals(NUM_FIVE)) {\n                break;\n            } else if (num.equals(NUM_SIX)) {\n                break;\n            } else if (num.equals(NUM_SEVEN)) {\n                break;\n            } else if (num.equals(NUM_EIGHT)) {\n                break;\n            }\n        }\n\n        long end = System.currentTimeMillis();\n        return end - start;\n    }\n}\n</code></pre><p>开始想当然switch速度更快，那实际输出了?</p>\n<pre><code>1-&gt;switchTime:1868,ifElse:0\n2-&gt;switchTime:2381,ifElse:0\n3-&gt;switchTime:985,ifElse:0\n4-&gt;switchTime:1002,ifElse:0\n5-&gt;switchTime:486,ifElse:0\n6-&gt;switchTime:662,ifElse:0\n7-&gt;switchTime:652,ifElse:0\n8-&gt;switchTime:661,ifElse:0\n</code></pre><p>结果大出我所希望的。用”if-if-else”几乎完胜switch String，那为什么了？<br><a href=\"http://it.deepinmind.com/java/2014/05/08/how-string-in-switch-works-in-java-7.html\" target=\"_blank\" rel=\"noopener\">可以看下这篇文章</a>,主要switch string，是通过equal和hashcode实现的。String先通过hashcode转换为int，在通过switch int，然后子case里面在if equal String。</p>\n<ul>\n<li>看来还是回来老路，只是添加一个新的支持特性而效率没有提高。对应String还是用if-if-else吧</li>\n</ul>\n"},{"title":"(转载)Java 7之基础 - 强引用、弱引用、软引用、虚引用","date":"2016-05-28T14:50:29.000Z","_content":"\n\n### (转载)[Java 7之基础 - 强引用、弱引用、软引用、虚引用](http://blog.csdn.net/mazhimazh/article/details/19752475)\n\n1、强引用（StrongReference）\n\n强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。如下：\n\n````\nObject o=new Object();   //  强引用 \n````\n当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。如果不使用时，要通过如下方式来弱化引用，如下：\n\n````\no=null;     // 帮助垃圾收集器回收此对象\n````\n显式地设置o为null，或超出对象的生命周期范围，则gc认为该对象不存在引用，这时就可以回收这个对象。具体什么时候收集这要取决于gc的算法。\n举例：\n\n````\npublic void test(){  \n    Object o=new Object();  \n    // 省略其他操作  \n}  \n````\n在一个方法的内部有一个强引用，这个引用保存在栈中，而真正的引用内容（Object）保存在堆中。当这个方法运行完成后就会退出方法栈，则引用内容的引用不存在，这个Object会被回收。\n但是如果这个o是全局的变量时，就需要在不用这个对象时赋值为null，因为强引用不会被垃圾回收。\n强引用在实际中有非常重要的用处，举个ArrayList的实现源代码：\n\n````\nprivate transient Object[] elementData;  \npublic void clear() {  \n        modCount++;  \n        // Let gc do its work  \n        for (int i = 0; i < size; i++)  \n            elementData[i] = null;  \n        size = 0;  \n}  \n````\n在ArrayList类中定义了一个私有的变量elementData数组，在调用方法清空数组时可以看到为每个数组内容赋值为null。不同于elementData=null，强引用仍然存在，避免在后续调用 add()等方法添加元素时进行重新的内存分配。使用如clear()方法中释放内存的方法对数组中存放的引用类型特别适用，这样就可以及时释放内存。\n\n2、软引用（SoftReference）\n\n如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。 \n\n````\nString str=new String(\"abc\");                                     // 强引用  \nSoftReference<String> softRef=new SoftReference<String>(str);     // 软引用 \n````\n当内存不足时，等价于：\n\n````\nIf(JVM.内存不足()) {  \n   str = null;  // 转换为软引用  \n   System.gc(); // 垃圾回收器进行回收  \n}  \n````\n\n软引用在实际中有重要的应用，例如浏览器的后退按钮。按后退时，这个后退时显示的网页内容是重新进行请求还是从缓存中取出呢？这就要看具体的实现策略了。\n\n- 如果一个网页在浏览结束时就进行内容的回收，则按后退查看前面浏览过的页面时，需要重新构建\n- 如果将浏览过的网页存储到内存中会造成内存的大量浪费，甚至会造成内存溢出\n这时候就可以使用软引用\n\n````\nBrowser prev = new Browser();               // 获取页面进行浏览  \nSoftReference sr = new SoftReference(prev); // 浏览完毕后置为软引用         \n<br>if(sr.get()!=null) {<br>}<br>  \n    rev = (Browser) sr.get();           // 还没有被回收器回收，直接获取  \n}else{  \n    prev = new Browser();               // 由于内存吃紧，所以对软引用的对象回收了  \n    sr = new SoftReference(prev);       // 重新构建  \n}  \n````\n这样就很好的解决了实际的问题。\n       软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。\n\n\n3、弱引用（WeakReference）\n\n   弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。\n   \n ````\n String str=new String(\"abc\");      \nWeakReference<String> abcWeakRef = new WeakReference<String>(str);  \nstr=null;    \n ````\n 当垃圾回收器进行扫描回收时等价于：\n \n ````\n str = null;  \nSystem.gc();  \n ````\n 如果这个对象是偶尔的使用，并且希望在使用时随时就能获取到，但又不想影响此对象的垃圾收集，那么你应该用 Weak Reference 来记住此对象。   \n   下面的代码会让str再次变为一个强引用：\n   \n   ````\n   String  abc = abcWeakRef.get();\n   ````\n   弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。\n当你想引用一个对象，但是这个对象有自己的生命周期，你不想介入这个对象的生命周期，这时候你就是用弱引用。\n\n这个引用不会在对象的垃圾回收判断中产生任何附加的影响。\n\n````\n[java] view plain copy print?public class ReferenceTest {  \n  \n    private static ReferenceQueue<VeryBig> rq = new ReferenceQueue<VeryBig>();  \n  \n    public static void checkQueue() {  \n        Reference<? extends VeryBig> ref = null;  \n        while ((ref = rq.poll()) != null) {  \n            if (ref != null) {  \n                System.out.println(\"In queue: \" + ((VeryBigWeakReference) (ref)).id);  \n            }  \n        }  \n    }  \n  \n    public static void main(String args[]) {  \n        int size = 3;  \n        LinkedList<WeakReference<VeryBig>> weakList = new LinkedList<WeakReference<VeryBig>>();  \n        for (int i = 0; i < size; i++) {  \n            weakList.add(new VeryBigWeakReference(new VeryBig(\"Weak \" + i), rq));  \n            System.out.println(\"Just created weak: \" + weakList.getLast());  \n  \n        }  \n  \n        System.gc();   \n        try { // 下面休息几分钟，让上面的垃圾回收线程运行完成  \n            Thread.currentThread().sleep(6000);  \n        } catch (InterruptedException e) {  \n            e.printStackTrace();  \n        }  \n        checkQueue();  \n    }  \n}  \n  \nclass VeryBig {  \n    public String id;  \n    // 占用空间,让线程进行回收  \n    byte[] b = new byte[2 * 1024];  \n  \n    public VeryBig(String id) {  \n        this.id = id;  \n    }  \n  \n    protected void finalize() {  \n        System.out.println(\"Finalizing VeryBig \" + id);  \n    }  \n}  \n  \nclass VeryBigWeakReference extends WeakReference<VeryBig> {  \n    public String id;  \n  \n    public VeryBigWeakReference(VeryBig big, ReferenceQueue<VeryBig> rq) {  \n        super(big, rq);  \n        this.id = big.id;  \n    }  \n  \n    protected void finalize() {  \n        System.out.println(\"Finalizing VeryBigWeakReference \" + id);  \n    }  \n}  \n````\n最后的输出结果为：\n\n````\nJust created weak: com.javabase.reference.VeryBigWeakReference@1641c0  \nJust created weak: com.javabase.reference.VeryBigWeakReference@136ab79  \nJust created weak: com.javabase.reference.VeryBigWeakReference@33c1aa  \nFinalizing VeryBig Weak 2  \nFinalizing VeryBig Weak 1  \nFinalizing VeryBig Weak 0  \nIn queue: Weak 1  \nIn queue: Weak 2  \nIn queue: Weak 0  \n````\n\n4、虚引用（PhantomReference）\n\n “虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。\n\n  虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之 关联的引用队列中\n    \n5、总结\n\nJava4种引用的级别由高到低依次为：\n\n强引用  >  软引用  >  弱引用  >  虚引用\n\n通过图来看一下他们之间在垃圾回收时的区别：\n\n![垃圾回收关系图](http://upload-images.jianshu.io/upload_images/1534431-6fd93a3a77688946?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n当垃圾回收器回收时，某些对象会被回收，某些不会被回收。垃圾回收器会从根对象Object来标记存活的对象，然后将某些不可达的对象和一些引用的对象进行回收，如果对这方面不是很了解，可以参考如下的文章：[Java内存管理](http://blog.csdn.net/mazhimazh/article/category/1907599)\n\n通过表格来说明一下，如下：\n\n| 引用类型 | 被垃圾回收时间  |  用途 \t \t\t| 生存时间 |\n|:------- |:------------:| ------------:| -------------:|\n| 强引用   | 从来不会 \t\t  | 对象的一般状态 |  JVM停止运行时终止 |\n| 软引用   | 在内存不足时   |  对象缓存 \t\t|  内存不足时终止 |\n| 弱引用 \t| 在垃圾回收时   |  对象缓存 \t\t|  gc运行后终止 |\n| 虚引用 \t| Unknown      |  Unknown \t\t|  Unknown |","source":"_posts/Java7之强引用_弱引用_软引用_虚引用.md","raw":"title: (转载)Java 7之基础 - 强引用、弱引用、软引用、虚引用\ndate: 2016-05-28 14:50:29\ntags:\ncategories: Java\n---\n\n\n### (转载)[Java 7之基础 - 强引用、弱引用、软引用、虚引用](http://blog.csdn.net/mazhimazh/article/details/19752475)\n\n1、强引用（StrongReference）\n\n强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。如下：\n\n````\nObject o=new Object();   //  强引用 \n````\n当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。如果不使用时，要通过如下方式来弱化引用，如下：\n\n````\no=null;     // 帮助垃圾收集器回收此对象\n````\n显式地设置o为null，或超出对象的生命周期范围，则gc认为该对象不存在引用，这时就可以回收这个对象。具体什么时候收集这要取决于gc的算法。\n举例：\n\n````\npublic void test(){  \n    Object o=new Object();  \n    // 省略其他操作  \n}  \n````\n在一个方法的内部有一个强引用，这个引用保存在栈中，而真正的引用内容（Object）保存在堆中。当这个方法运行完成后就会退出方法栈，则引用内容的引用不存在，这个Object会被回收。\n但是如果这个o是全局的变量时，就需要在不用这个对象时赋值为null，因为强引用不会被垃圾回收。\n强引用在实际中有非常重要的用处，举个ArrayList的实现源代码：\n\n````\nprivate transient Object[] elementData;  \npublic void clear() {  \n        modCount++;  \n        // Let gc do its work  \n        for (int i = 0; i < size; i++)  \n            elementData[i] = null;  \n        size = 0;  \n}  \n````\n在ArrayList类中定义了一个私有的变量elementData数组，在调用方法清空数组时可以看到为每个数组内容赋值为null。不同于elementData=null，强引用仍然存在，避免在后续调用 add()等方法添加元素时进行重新的内存分配。使用如clear()方法中释放内存的方法对数组中存放的引用类型特别适用，这样就可以及时释放内存。\n\n2、软引用（SoftReference）\n\n如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。 \n\n````\nString str=new String(\"abc\");                                     // 强引用  \nSoftReference<String> softRef=new SoftReference<String>(str);     // 软引用 \n````\n当内存不足时，等价于：\n\n````\nIf(JVM.内存不足()) {  \n   str = null;  // 转换为软引用  \n   System.gc(); // 垃圾回收器进行回收  \n}  \n````\n\n软引用在实际中有重要的应用，例如浏览器的后退按钮。按后退时，这个后退时显示的网页内容是重新进行请求还是从缓存中取出呢？这就要看具体的实现策略了。\n\n- 如果一个网页在浏览结束时就进行内容的回收，则按后退查看前面浏览过的页面时，需要重新构建\n- 如果将浏览过的网页存储到内存中会造成内存的大量浪费，甚至会造成内存溢出\n这时候就可以使用软引用\n\n````\nBrowser prev = new Browser();               // 获取页面进行浏览  \nSoftReference sr = new SoftReference(prev); // 浏览完毕后置为软引用         \n<br>if(sr.get()!=null) {<br>}<br>  \n    rev = (Browser) sr.get();           // 还没有被回收器回收，直接获取  \n}else{  \n    prev = new Browser();               // 由于内存吃紧，所以对软引用的对象回收了  \n    sr = new SoftReference(prev);       // 重新构建  \n}  \n````\n这样就很好的解决了实际的问题。\n       软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。\n\n\n3、弱引用（WeakReference）\n\n   弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。\n   \n ````\n String str=new String(\"abc\");      \nWeakReference<String> abcWeakRef = new WeakReference<String>(str);  \nstr=null;    \n ````\n 当垃圾回收器进行扫描回收时等价于：\n \n ````\n str = null;  \nSystem.gc();  \n ````\n 如果这个对象是偶尔的使用，并且希望在使用时随时就能获取到，但又不想影响此对象的垃圾收集，那么你应该用 Weak Reference 来记住此对象。   \n   下面的代码会让str再次变为一个强引用：\n   \n   ````\n   String  abc = abcWeakRef.get();\n   ````\n   弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。\n当你想引用一个对象，但是这个对象有自己的生命周期，你不想介入这个对象的生命周期，这时候你就是用弱引用。\n\n这个引用不会在对象的垃圾回收判断中产生任何附加的影响。\n\n````\n[java] view plain copy print?public class ReferenceTest {  \n  \n    private static ReferenceQueue<VeryBig> rq = new ReferenceQueue<VeryBig>();  \n  \n    public static void checkQueue() {  \n        Reference<? extends VeryBig> ref = null;  \n        while ((ref = rq.poll()) != null) {  \n            if (ref != null) {  \n                System.out.println(\"In queue: \" + ((VeryBigWeakReference) (ref)).id);  \n            }  \n        }  \n    }  \n  \n    public static void main(String args[]) {  \n        int size = 3;  \n        LinkedList<WeakReference<VeryBig>> weakList = new LinkedList<WeakReference<VeryBig>>();  \n        for (int i = 0; i < size; i++) {  \n            weakList.add(new VeryBigWeakReference(new VeryBig(\"Weak \" + i), rq));  \n            System.out.println(\"Just created weak: \" + weakList.getLast());  \n  \n        }  \n  \n        System.gc();   \n        try { // 下面休息几分钟，让上面的垃圾回收线程运行完成  \n            Thread.currentThread().sleep(6000);  \n        } catch (InterruptedException e) {  \n            e.printStackTrace();  \n        }  \n        checkQueue();  \n    }  \n}  \n  \nclass VeryBig {  \n    public String id;  \n    // 占用空间,让线程进行回收  \n    byte[] b = new byte[2 * 1024];  \n  \n    public VeryBig(String id) {  \n        this.id = id;  \n    }  \n  \n    protected void finalize() {  \n        System.out.println(\"Finalizing VeryBig \" + id);  \n    }  \n}  \n  \nclass VeryBigWeakReference extends WeakReference<VeryBig> {  \n    public String id;  \n  \n    public VeryBigWeakReference(VeryBig big, ReferenceQueue<VeryBig> rq) {  \n        super(big, rq);  \n        this.id = big.id;  \n    }  \n  \n    protected void finalize() {  \n        System.out.println(\"Finalizing VeryBigWeakReference \" + id);  \n    }  \n}  \n````\n最后的输出结果为：\n\n````\nJust created weak: com.javabase.reference.VeryBigWeakReference@1641c0  \nJust created weak: com.javabase.reference.VeryBigWeakReference@136ab79  \nJust created weak: com.javabase.reference.VeryBigWeakReference@33c1aa  \nFinalizing VeryBig Weak 2  \nFinalizing VeryBig Weak 1  \nFinalizing VeryBig Weak 0  \nIn queue: Weak 1  \nIn queue: Weak 2  \nIn queue: Weak 0  \n````\n\n4、虚引用（PhantomReference）\n\n “虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。\n\n  虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之 关联的引用队列中\n    \n5、总结\n\nJava4种引用的级别由高到低依次为：\n\n强引用  >  软引用  >  弱引用  >  虚引用\n\n通过图来看一下他们之间在垃圾回收时的区别：\n\n![垃圾回收关系图](http://upload-images.jianshu.io/upload_images/1534431-6fd93a3a77688946?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n当垃圾回收器回收时，某些对象会被回收，某些不会被回收。垃圾回收器会从根对象Object来标记存活的对象，然后将某些不可达的对象和一些引用的对象进行回收，如果对这方面不是很了解，可以参考如下的文章：[Java内存管理](http://blog.csdn.net/mazhimazh/article/category/1907599)\n\n通过表格来说明一下，如下：\n\n| 引用类型 | 被垃圾回收时间  |  用途 \t \t\t| 生存时间 |\n|:------- |:------------:| ------------:| -------------:|\n| 强引用   | 从来不会 \t\t  | 对象的一般状态 |  JVM停止运行时终止 |\n| 软引用   | 在内存不足时   |  对象缓存 \t\t|  内存不足时终止 |\n| 弱引用 \t| 在垃圾回收时   |  对象缓存 \t\t|  gc运行后终止 |\n| 虚引用 \t| Unknown      |  Unknown \t\t|  Unknown |","slug":"Java7之强引用-弱引用-软引用-虚引用","published":1,"updated":"2021-09-10T07:04:21.942Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cktfeap3s0010c2xxmnhsn1l3","content":"<h3 id=\"转载-Java-7之基础-强引用、弱引用、软引用、虚引用\"><a href=\"#转载-Java-7之基础-强引用、弱引用、软引用、虚引用\" class=\"headerlink\" title=\"(转载)Java 7之基础 - 强引用、弱引用、软引用、虚引用\"></a>(转载)<a href=\"http://blog.csdn.net/mazhimazh/article/details/19752475\" target=\"_blank\" rel=\"noopener\">Java 7之基础 - 强引用、弱引用、软引用、虚引用</a></h3><p>1、强引用（StrongReference）</p>\n<p>强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。如下：</p>\n<pre><code>Object o=new Object();   //  强引用\n</code></pre><p>当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。如果不使用时，要通过如下方式来弱化引用，如下：</p>\n<pre><code>o=null;     // 帮助垃圾收集器回收此对象\n</code></pre><p>显式地设置o为null，或超出对象的生命周期范围，则gc认为该对象不存在引用，这时就可以回收这个对象。具体什么时候收集这要取决于gc的算法。<br>举例：</p>\n<pre><code>public void test(){  \n    Object o=new Object();  \n    // 省略其他操作  \n}\n</code></pre><p>在一个方法的内部有一个强引用，这个引用保存在栈中，而真正的引用内容（Object）保存在堆中。当这个方法运行完成后就会退出方法栈，则引用内容的引用不存在，这个Object会被回收。<br>但是如果这个o是全局的变量时，就需要在不用这个对象时赋值为null，因为强引用不会被垃圾回收。<br>强引用在实际中有非常重要的用处，举个ArrayList的实现源代码：</p>\n<pre><code>private transient Object[] elementData;  \npublic void clear() {  \n        modCount++;  \n        // Let gc do its work  \n        for (int i = 0; i &lt; size; i++)  \n            elementData[i] = null;  \n        size = 0;  \n}\n</code></pre><p>在ArrayList类中定义了一个私有的变量elementData数组，在调用方法清空数组时可以看到为每个数组内容赋值为null。不同于elementData=null，强引用仍然存在，避免在后续调用 add()等方法添加元素时进行重新的内存分配。使用如clear()方法中释放内存的方法对数组中存放的引用类型特别适用，这样就可以及时释放内存。</p>\n<p>2、软引用（SoftReference）</p>\n<p>如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。 </p>\n<pre><code>String str=new String(&quot;abc&quot;);                                     // 强引用  \nSoftReference&lt;String&gt; softRef=new SoftReference&lt;String&gt;(str);     // 软引用\n</code></pre><p>当内存不足时，等价于：</p>\n<pre><code>If(JVM.内存不足()) {  \n   str = null;  // 转换为软引用  \n   System.gc(); // 垃圾回收器进行回收  \n}\n</code></pre><p>软引用在实际中有重要的应用，例如浏览器的后退按钮。按后退时，这个后退时显示的网页内容是重新进行请求还是从缓存中取出呢？这就要看具体的实现策略了。</p>\n<ul>\n<li>如果一个网页在浏览结束时就进行内容的回收，则按后退查看前面浏览过的页面时，需要重新构建</li>\n<li>如果将浏览过的网页存储到内存中会造成内存的大量浪费，甚至会造成内存溢出<br>这时候就可以使用软引用</li>\n</ul>\n<pre><code>Browser prev = new Browser();               // 获取页面进行浏览  \nSoftReference sr = new SoftReference(prev); // 浏览完毕后置为软引用         \n&lt;br&gt;if(sr.get()!=null) {&lt;br&gt;}&lt;br&gt;  \n    rev = (Browser) sr.get();           // 还没有被回收器回收，直接获取  \n}else{  \n    prev = new Browser();               // 由于内存吃紧，所以对软引用的对象回收了  \n    sr = new SoftReference(prev);       // 重新构建  \n}\n</code></pre><p>这样就很好的解决了实际的问题。<br>       软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。</p>\n<p>3、弱引用（WeakReference）</p>\n<p>   弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。</p>\n<pre><code> String str=new String(&quot;abc&quot;);      \nWeakReference&lt;String&gt; abcWeakRef = new WeakReference&lt;String&gt;(str);  \nstr=null;\n</code></pre><p> 当垃圾回收器进行扫描回收时等价于：</p>\n<pre><code> str = null;  \nSystem.gc();\n</code></pre><p> 如果这个对象是偶尔的使用，并且希望在使用时随时就能获取到，但又不想影响此对象的垃圾收集，那么你应该用 Weak Reference 来记住此对象。<br>   下面的代码会让str再次变为一个强引用：</p>\n<pre><code>   String  abc = abcWeakRef.get();\n</code></pre><p>   弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。<br>当你想引用一个对象，但是这个对象有自己的生命周期，你不想介入这个对象的生命周期，这时候你就是用弱引用。</p>\n<p>这个引用不会在对象的垃圾回收判断中产生任何附加的影响。</p>\n<pre><code>[java] view plain copy print?public class ReferenceTest {  \n\n    private static ReferenceQueue&lt;VeryBig&gt; rq = new ReferenceQueue&lt;VeryBig&gt;();  \n\n    public static void checkQueue() {  \n        Reference&lt;? extends VeryBig&gt; ref = null;  \n        while ((ref = rq.poll()) != null) {  \n            if (ref != null) {  \n                System.out.println(&quot;In queue: &quot; + ((VeryBigWeakReference) (ref)).id);  \n            }  \n        }  \n    }  \n\n    public static void main(String args[]) {  \n        int size = 3;  \n        LinkedList&lt;WeakReference&lt;VeryBig&gt;&gt; weakList = new LinkedList&lt;WeakReference&lt;VeryBig&gt;&gt;();  \n        for (int i = 0; i &lt; size; i++) {  \n            weakList.add(new VeryBigWeakReference(new VeryBig(&quot;Weak &quot; + i), rq));  \n            System.out.println(&quot;Just created weak: &quot; + weakList.getLast());  \n\n        }  \n\n        System.gc();   \n        try { // 下面休息几分钟，让上面的垃圾回收线程运行完成  \n            Thread.currentThread().sleep(6000);  \n        } catch (InterruptedException e) {  \n            e.printStackTrace();  \n        }  \n        checkQueue();  \n    }  \n}  \n\nclass VeryBig {  \n    public String id;  \n    // 占用空间,让线程进行回收  \n    byte[] b = new byte[2 * 1024];  \n\n    public VeryBig(String id) {  \n        this.id = id;  \n    }  \n\n    protected void finalize() {  \n        System.out.println(&quot;Finalizing VeryBig &quot; + id);  \n    }  \n}  \n\nclass VeryBigWeakReference extends WeakReference&lt;VeryBig&gt; {  \n    public String id;  \n\n    public VeryBigWeakReference(VeryBig big, ReferenceQueue&lt;VeryBig&gt; rq) {  \n        super(big, rq);  \n        this.id = big.id;  \n    }  \n\n    protected void finalize() {  \n        System.out.println(&quot;Finalizing VeryBigWeakReference &quot; + id);  \n    }  \n}\n</code></pre><p>最后的输出结果为：</p>\n<pre><code>Just created weak: com.javabase.reference.VeryBigWeakReference@1641c0  \nJust created weak: com.javabase.reference.VeryBigWeakReference@136ab79  \nJust created weak: com.javabase.reference.VeryBigWeakReference@33c1aa  \nFinalizing VeryBig Weak 2  \nFinalizing VeryBig Weak 1  \nFinalizing VeryBig Weak 0  \nIn queue: Weak 1  \nIn queue: Weak 2  \nIn queue: Weak 0\n</code></pre><p>4、虚引用（PhantomReference）</p>\n<p> “虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。</p>\n<p>  虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之 关联的引用队列中</p>\n<p>5、总结</p>\n<p>Java4种引用的级别由高到低依次为：</p>\n<p>强引用  &gt;  软引用  &gt;  弱引用  &gt;  虚引用</p>\n<p>通过图来看一下他们之间在垃圾回收时的区别：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1534431-6fd93a3a77688946?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"垃圾回收关系图\"></p>\n<p>当垃圾回收器回收时，某些对象会被回收，某些不会被回收。垃圾回收器会从根对象Object来标记存活的对象，然后将某些不可达的对象和一些引用的对象进行回收，如果对这方面不是很了解，可以参考如下的文章：<a href=\"http://blog.csdn.net/mazhimazh/article/category/1907599\" target=\"_blank\" rel=\"noopener\">Java内存管理</a></p>\n<p>通过表格来说明一下，如下：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">引用类型</th>\n<th style=\"text-align:center\">被垃圾回收时间</th>\n<th style=\"text-align:right\">用途</th>\n<th style=\"text-align:right\">生存时间</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">强引用</td>\n<td style=\"text-align:center\">从来不会</td>\n<td style=\"text-align:right\">对象的一般状态</td>\n<td style=\"text-align:right\">JVM停止运行时终止</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">软引用</td>\n<td style=\"text-align:center\">在内存不足时</td>\n<td style=\"text-align:right\">对象缓存</td>\n<td style=\"text-align:right\">内存不足时终止</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">弱引用</td>\n<td style=\"text-align:center\">在垃圾回收时</td>\n<td style=\"text-align:right\">对象缓存</td>\n<td style=\"text-align:right\">gc运行后终止</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">虚引用</td>\n<td style=\"text-align:center\">Unknown</td>\n<td style=\"text-align:right\">Unknown</td>\n<td style=\"text-align:right\">Unknown</td>\n</tr>\n</tbody>\n</table>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"转载-Java-7之基础-强引用、弱引用、软引用、虚引用\"><a href=\"#转载-Java-7之基础-强引用、弱引用、软引用、虚引用\" class=\"headerlink\" title=\"(转载)Java 7之基础 - 强引用、弱引用、软引用、虚引用\"></a>(转载)<a href=\"http://blog.csdn.net/mazhimazh/article/details/19752475\" target=\"_blank\" rel=\"noopener\">Java 7之基础 - 强引用、弱引用、软引用、虚引用</a></h3><p>1、强引用（StrongReference）</p>\n<p>强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。如下：</p>\n<pre><code>Object o=new Object();   //  强引用\n</code></pre><p>当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。如果不使用时，要通过如下方式来弱化引用，如下：</p>\n<pre><code>o=null;     // 帮助垃圾收集器回收此对象\n</code></pre><p>显式地设置o为null，或超出对象的生命周期范围，则gc认为该对象不存在引用，这时就可以回收这个对象。具体什么时候收集这要取决于gc的算法。<br>举例：</p>\n<pre><code>public void test(){  \n    Object o=new Object();  \n    // 省略其他操作  \n}\n</code></pre><p>在一个方法的内部有一个强引用，这个引用保存在栈中，而真正的引用内容（Object）保存在堆中。当这个方法运行完成后就会退出方法栈，则引用内容的引用不存在，这个Object会被回收。<br>但是如果这个o是全局的变量时，就需要在不用这个对象时赋值为null，因为强引用不会被垃圾回收。<br>强引用在实际中有非常重要的用处，举个ArrayList的实现源代码：</p>\n<pre><code>private transient Object[] elementData;  \npublic void clear() {  \n        modCount++;  \n        // Let gc do its work  \n        for (int i = 0; i &lt; size; i++)  \n            elementData[i] = null;  \n        size = 0;  \n}\n</code></pre><p>在ArrayList类中定义了一个私有的变量elementData数组，在调用方法清空数组时可以看到为每个数组内容赋值为null。不同于elementData=null，强引用仍然存在，避免在后续调用 add()等方法添加元素时进行重新的内存分配。使用如clear()方法中释放内存的方法对数组中存放的引用类型特别适用，这样就可以及时释放内存。</p>\n<p>2、软引用（SoftReference）</p>\n<p>如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。 </p>\n<pre><code>String str=new String(&quot;abc&quot;);                                     // 强引用  \nSoftReference&lt;String&gt; softRef=new SoftReference&lt;String&gt;(str);     // 软引用\n</code></pre><p>当内存不足时，等价于：</p>\n<pre><code>If(JVM.内存不足()) {  \n   str = null;  // 转换为软引用  \n   System.gc(); // 垃圾回收器进行回收  \n}\n</code></pre><p>软引用在实际中有重要的应用，例如浏览器的后退按钮。按后退时，这个后退时显示的网页内容是重新进行请求还是从缓存中取出呢？这就要看具体的实现策略了。</p>\n<ul>\n<li>如果一个网页在浏览结束时就进行内容的回收，则按后退查看前面浏览过的页面时，需要重新构建</li>\n<li>如果将浏览过的网页存储到内存中会造成内存的大量浪费，甚至会造成内存溢出<br>这时候就可以使用软引用</li>\n</ul>\n<pre><code>Browser prev = new Browser();               // 获取页面进行浏览  \nSoftReference sr = new SoftReference(prev); // 浏览完毕后置为软引用         \n&lt;br&gt;if(sr.get()!=null) {&lt;br&gt;}&lt;br&gt;  \n    rev = (Browser) sr.get();           // 还没有被回收器回收，直接获取  \n}else{  \n    prev = new Browser();               // 由于内存吃紧，所以对软引用的对象回收了  \n    sr = new SoftReference(prev);       // 重新构建  \n}\n</code></pre><p>这样就很好的解决了实际的问题。<br>       软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。</p>\n<p>3、弱引用（WeakReference）</p>\n<p>   弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。</p>\n<pre><code> String str=new String(&quot;abc&quot;);      \nWeakReference&lt;String&gt; abcWeakRef = new WeakReference&lt;String&gt;(str);  \nstr=null;\n</code></pre><p> 当垃圾回收器进行扫描回收时等价于：</p>\n<pre><code> str = null;  \nSystem.gc();\n</code></pre><p> 如果这个对象是偶尔的使用，并且希望在使用时随时就能获取到，但又不想影响此对象的垃圾收集，那么你应该用 Weak Reference 来记住此对象。<br>   下面的代码会让str再次变为一个强引用：</p>\n<pre><code>   String  abc = abcWeakRef.get();\n</code></pre><p>   弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。<br>当你想引用一个对象，但是这个对象有自己的生命周期，你不想介入这个对象的生命周期，这时候你就是用弱引用。</p>\n<p>这个引用不会在对象的垃圾回收判断中产生任何附加的影响。</p>\n<pre><code>[java] view plain copy print?public class ReferenceTest {  \n\n    private static ReferenceQueue&lt;VeryBig&gt; rq = new ReferenceQueue&lt;VeryBig&gt;();  \n\n    public static void checkQueue() {  \n        Reference&lt;? extends VeryBig&gt; ref = null;  \n        while ((ref = rq.poll()) != null) {  \n            if (ref != null) {  \n                System.out.println(&quot;In queue: &quot; + ((VeryBigWeakReference) (ref)).id);  \n            }  \n        }  \n    }  \n\n    public static void main(String args[]) {  \n        int size = 3;  \n        LinkedList&lt;WeakReference&lt;VeryBig&gt;&gt; weakList = new LinkedList&lt;WeakReference&lt;VeryBig&gt;&gt;();  \n        for (int i = 0; i &lt; size; i++) {  \n            weakList.add(new VeryBigWeakReference(new VeryBig(&quot;Weak &quot; + i), rq));  \n            System.out.println(&quot;Just created weak: &quot; + weakList.getLast());  \n\n        }  \n\n        System.gc();   \n        try { // 下面休息几分钟，让上面的垃圾回收线程运行完成  \n            Thread.currentThread().sleep(6000);  \n        } catch (InterruptedException e) {  \n            e.printStackTrace();  \n        }  \n        checkQueue();  \n    }  \n}  \n\nclass VeryBig {  \n    public String id;  \n    // 占用空间,让线程进行回收  \n    byte[] b = new byte[2 * 1024];  \n\n    public VeryBig(String id) {  \n        this.id = id;  \n    }  \n\n    protected void finalize() {  \n        System.out.println(&quot;Finalizing VeryBig &quot; + id);  \n    }  \n}  \n\nclass VeryBigWeakReference extends WeakReference&lt;VeryBig&gt; {  \n    public String id;  \n\n    public VeryBigWeakReference(VeryBig big, ReferenceQueue&lt;VeryBig&gt; rq) {  \n        super(big, rq);  \n        this.id = big.id;  \n    }  \n\n    protected void finalize() {  \n        System.out.println(&quot;Finalizing VeryBigWeakReference &quot; + id);  \n    }  \n}\n</code></pre><p>最后的输出结果为：</p>\n<pre><code>Just created weak: com.javabase.reference.VeryBigWeakReference@1641c0  \nJust created weak: com.javabase.reference.VeryBigWeakReference@136ab79  \nJust created weak: com.javabase.reference.VeryBigWeakReference@33c1aa  \nFinalizing VeryBig Weak 2  \nFinalizing VeryBig Weak 1  \nFinalizing VeryBig Weak 0  \nIn queue: Weak 1  \nIn queue: Weak 2  \nIn queue: Weak 0\n</code></pre><p>4、虚引用（PhantomReference）</p>\n<p> “虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。</p>\n<p>  虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之 关联的引用队列中</p>\n<p>5、总结</p>\n<p>Java4种引用的级别由高到低依次为：</p>\n<p>强引用  &gt;  软引用  &gt;  弱引用  &gt;  虚引用</p>\n<p>通过图来看一下他们之间在垃圾回收时的区别：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1534431-6fd93a3a77688946?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"垃圾回收关系图\"></p>\n<p>当垃圾回收器回收时，某些对象会被回收，某些不会被回收。垃圾回收器会从根对象Object来标记存活的对象，然后将某些不可达的对象和一些引用的对象进行回收，如果对这方面不是很了解，可以参考如下的文章：<a href=\"http://blog.csdn.net/mazhimazh/article/category/1907599\" target=\"_blank\" rel=\"noopener\">Java内存管理</a></p>\n<p>通过表格来说明一下，如下：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">引用类型</th>\n<th style=\"text-align:center\">被垃圾回收时间</th>\n<th style=\"text-align:right\">用途</th>\n<th style=\"text-align:right\">生存时间</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">强引用</td>\n<td style=\"text-align:center\">从来不会</td>\n<td style=\"text-align:right\">对象的一般状态</td>\n<td style=\"text-align:right\">JVM停止运行时终止</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">软引用</td>\n<td style=\"text-align:center\">在内存不足时</td>\n<td style=\"text-align:right\">对象缓存</td>\n<td style=\"text-align:right\">内存不足时终止</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">弱引用</td>\n<td style=\"text-align:center\">在垃圾回收时</td>\n<td style=\"text-align:right\">对象缓存</td>\n<td style=\"text-align:right\">gc运行后终止</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">虚引用</td>\n<td style=\"text-align:center\">Unknown</td>\n<td style=\"text-align:right\">Unknown</td>\n<td style=\"text-align:right\">Unknown</td>\n</tr>\n</tbody>\n</table>\n"},{"title":"我所知道的-Java垃圾回收机制","date":"2018-07-12T11:11:00.000Z","_content":"\n\n\n![Java垃圾回收机制](https://upload-images.jianshu.io/upload_images/1534431-a4831eb7feafd902.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n本文章你能知道的内容：\n  - Java内存模型\n  - Java堆\n  - 对象什么时候回收\n  - 垃圾回收算法\n  - 垃圾回收器\n### Java内存模型\n要了解Java垃圾回收机制，首先知道Java内存模型是怎么样的。如下图\n![Java内存模型](https://upload-images.jianshu.io/upload_images/1534431-2c69d083add54ae6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n - 程序计数器\n- Java 虚拟机栈\n- 方法区：方法区也是各个线程共享的内存区域，它用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据\n  - 运行时常量池\n- Java 堆:一般new的对象实例和数组都是在堆中的，而GC主要回收的内存也是这块堆内存，后面单独领出来来讲。\n- 直接内存：不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范定义的内存区域(Fresco图片加载库，就是运行这块内存超越虚拟机内存使用)。\n- code cache等其他内存\n### Java 堆\nJava Heap 是 Java 虚拟机所管理的内存中最大的一块，它是所有线程共享的一块内存区域。几乎所有的对象实例和数组都在这类分配内存。\n>Java 堆内存由垃圾回收器的自动内存管理系统管理。\n堆内存分为两大部分：新生代和老年代，默认比例为1：2，可修改。\n老年代主要存放应用程序中生命周期长的存活对象。\n新生代又分为三个部分：一个Eden区和两个Survivor区，默认比例为8：1：1，可修改。\nEden区存放新生的对象。\nSurvivor存放每次垃圾回收后存活的对象。\n![堆内存](https://upload-images.jianshu.io/upload_images/1534431-062a3348d8286a11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 为什么？\n- 为什么要分新生代和老年代？\n- 新生代为什么分一个Eden区和两个Survivor区?\n\n带着这些疑问，我们就要先了解堆相关的垃圾回收算法和采用的垃圾回收器。在讲算法前先了解怎么判断对象是否回收。\n### 对象什么时候回收？\n判断对象是否回收主要有以下两种算法\n-  引用计数算法\n给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。\n![引用计数算法](https://upload-images.jianshu.io/upload_images/1534431-982627fe64dfa349.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n    - 优点：简单，高效，Objective-c用的就是这种算法。\n    - 缺点：很难处理循环引用，比如图中相互引用的两个对象则无法释放。但是也有解决办法，想知道自行搜索。\n- 可达性分析算法（根搜索算法）\n为了解决上面的循环引用问题，Java采用了一种新的算法：可达性分析算法。\n从GC Roots（每种具体实现对GC Roots有不同的定义）作为起点，向下搜索它们引用的对象，可以生成一棵引用树，树的节点视为可达对象，反之视为不可达。\n![可达性分析算法](https://upload-images.jianshu.io/upload_images/1534431-a9dda2d42cd749cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n>Java定义的GC Roots对象:\n  虚拟机栈（帧栈中的本地变量表）中引用的对象。\n  方法区中静态属性引用的对象。\n  方法区中常量引用的对象。\n  本地方法栈中JNI引用的对象。\n\n如果出现循环引用了，只要没有被GC Roots引用了就会被回收，完美解决！\n\n### 垃圾回收算法\n知道了什么时候回收对象，那我们再看具体怎么垃圾回收。\n- 标记清除法\n标记-清除法分为两个阶段：标记阶段和清除阶段。标记阶段的任务是标记出所有需要被回收的对象，清除阶段就是回收被标记的对象所占用的空间。\n![标记清除法](https://upload-images.jianshu.io/upload_images/1534431-43bc311c23427d67.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n  - 优点：是简单，容易实现。\n  - 缺点：容易产生内存碎片，碎片太多可能会导致后续过程中需要为大对象分配空间时无法找到足够的空间而提前触发新的一次垃圾收集动作。\n- 复制算法\n复制算法将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用的内存空间一次清理掉，这样一来就不容易出现内存碎片的问题。\n![复制算法](https://upload-images.jianshu.io/upload_images/1534431-9bf508a2e534d864.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n  - 优点：实现简单，运行高效且不容易产生内存碎片，适用于存活对象很少。回收对象多\n  - 缺点：内存空间的使用做出了高昂的代价，因为能够使用的内存缩减到原来的一半，如果存活对象很多，那么Copying算法的效率将会大大降低。\n- 标记整理算法\n该算法标记阶段和标记清除法一样，但是在完成标记之后，它不是直接清理可回收对象，而是将存活对象都向一端移动，然后清理掉端边界以外的内存。\n![标记整理算法](https://upload-images.jianshu.io/upload_images/1534431-4b6066a7e03fb403.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n    - 优点：不会出现内存碎片问题，适用于存活对象多，回收对象少的情况使用\n    - 缺点：整理时间长，容易导致卡顿。\n- 分代回收算法\n分代回收算法其实不算一种新的算法，而是根据复制算法和标记整理算法的使用场景综合使用。\n>复制算法：适用于存活对象很少。回收对象多\n标记整理算法: 适用用于存活对象多，回收对象少\n\n分代算法就是根据对象存活的生命周期将内存划分为若干个不同的区域。一般情况下将堆区划分为老年代（Old Generation）和新生代（Young Generation），老年代的特点是每次垃圾收集时只有少量对象需要被回收所以采用标记整理法。而新生代的特点是每次垃圾回收时都有大量的对象需要被回收所以采用复制算法（改良的复制算法，不是按1：1分配）。\n\n![分代回收算法](https://upload-images.jianshu.io/upload_images/1534431-df6da09763c72d95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n- Eden空间和两块Survivor空间的工作流程\n> // 分配了一个又一个对象\n放到Eden区\n// 不好，Eden区满了，只能GC(新生代GC：Minor GC)了\n把Eden区的存活对象copy到Survivor A区，然后清空Eden区（本来Survivor B区也需要清空的，不过本来就是空的）\n// 又分配了一个又一个对象\n放到Eden区\n// 不好，Eden区又满了，只能GC(新生代GC：Minor GC)了\n把Eden区和Survivor A区的存活对象copy到Survivor B区，然后清空Eden区和Survivor A区\n// 又分配了一个又一个对象\n放到Eden区\n// 不好，Eden区又满了，只能GC(新生代GC：Minor GC)了\n把Eden区和Survivor B区的存活对象copy到Survivor A区，然后清空Eden区和Survivor B区\n// ...\n// 有的对象来回在Survivor A区或者B区呆了比如15次，就被分配到老年代Old区\n// 有的对象太大，超过了Eden区，直接被分配在Old区\n// 有的存活对象，放不下Survivor区，也被分配到Old区\n// ...\n// 在某次Minor GC的过程中突然发现：\n// 不好，老年代Old区也满了，这是一次大GC(老年代GC：Major GC)\nOld区慢慢的整理一番，空间又够了\n// 继续Minor GC\n// ...\n// ...\n在回答上面提出的问题？\n>为什么要分新生代和老年代？\n综合使用算法，最优采用分代算法所以分为新生代和老年代两块区域。具体为什么1：2？应该是根据实践测试得出的结果，也可以调整。\n\n- 回答第二个问题[为什么新生代内存需要有两个Survivor区](https://blog.csdn.net/antony9118/article/details/51425581)，这里讲的比较详细\n\n- 什么时候触发GC？\n>GC_FOR_MALLOC: 表示是在堆上分配对象时内存不足触发的GC。\nGC_CONCURRENT: 当我们应用程序的堆内存达到一定量，或者可以理解为快要满的时候，系统会自动触发GC操作来释放内存。\nGC_EXPLICIT: 表示是应用程序调用System.gc、VMRuntime.gc接口或者收到SIGUSR1信号时触发的GC。\nGC_BEFORE_OOM: 表示是在准备抛OOM异常之前进行的最后努力而触发的GC。\n### 垃圾回收器\n在GC机制中，起重要作用的是垃圾收集器，垃圾收集器是GC的具体实现，Java虚拟机规范中对于垃圾收集器没有任何规定，所以不同厂商实现的垃圾 收集器各不相同，也有可能采用多个垃圾回收器并存方式，HotSpot 1.6版使用的垃圾收集器如下图（图来源于《深入理解Java虚拟机：JVM高级特效与最佳实现》，图中两个收集器之间有连线，说明它们可以配合使用）\n![垃圾回收器](https://upload-images.jianshu.io/upload_images/1534431-e50e3a7a84da379d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n- Serial收集器\n- ParNew收集器\n- Parallel Scavenge收集器\n- CMS收集器（应用非常广泛）\n- G1收集器（面向服务端应用）\n###ART与Dalvik虚拟机 \nART(Android Runtime)是Android 4.4发布的，用来替换Dalvik虚拟，Android 4.4默认采用的还是DVM，系统会提供一个选项来开启ART。在Android 5.0时，默认采用ART，DVM从此退出历史舞台。\n\nART与Dalvik的区别\n- Dalvik中的应用每次运行时，字节码都需要通过即时编译器（JIT，just in time）转换为机器码，这会使得应用的运行效率降低。而在ART中，系统在安装应用时会进行一次预编译（AOT，ahead of time）,将字节码预先编译成机器码并存储在本地，这样应用每次运行时就不需要执行编译了，运行效率也大大提升。\n- ART占用空间比Dalvik大（字节码变为机器码之后，可能会增加10%-20%），这就是“时间换空间大法”。\n- 改进CMS 垃圾回收，引入移动垃圾回收器。\n- ART把Java堆的主要组成包括Image Space、Zygote Space、Allocation Space和Large Object Space四个Space，Image Space用来存在一些预加载的类， Zygote Space和Allocation Space与Dalvik虚拟机垃圾收集机制中的Zygote堆和Active堆的作用是一样的，Large Object Space就是一些离散地址的集合，用来分配一些大对象从而提高了GC的管理效率和整体性能。如图\n![image.png](https://upload-images.jianshu.io/upload_images/1534431-56d1ba248844e594.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n### GC调优思路\n其中一个或者两个方面的目标，很少有情况可以兼顾三个不同的角度\n- 内存占用 \n- 延时\n- 吞吐量\n\n### 参考文章\n- [Android GC 那点事](https://juejin.im/post/5909c7ef570c3500583bf433)\n- [理解Java垃圾回收机制](http://jayfeng.com/2016/03/11/%E7%90%86%E8%A7%A3Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/?from=singlemessage&isappinstalled=0)\n - [Java类生命周期](http://blog.csdn.net/zhengzhb/article/details/7517213)\n - [单例模式讨论篇：单例模式与垃圾回收](http://blog.csdn.net/zhengzhb/article/details/7331354)\n- [JVM 垃圾回收算法及回收器详解](http://www.importnew.com/26383.html)\n- [为什么新生代内存需要有两个Survivor区](https://blog.csdn.net/antony9118/article/details/51425581)","source":"_posts/Java垃圾回收机制.md","raw":"title: 我所知道的-Java垃圾回收机制\ndate: 2018-07-12  11:11:00\ntags:\ncategories: Java\n---\n\n\n\n![Java垃圾回收机制](https://upload-images.jianshu.io/upload_images/1534431-a4831eb7feafd902.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n本文章你能知道的内容：\n  - Java内存模型\n  - Java堆\n  - 对象什么时候回收\n  - 垃圾回收算法\n  - 垃圾回收器\n### Java内存模型\n要了解Java垃圾回收机制，首先知道Java内存模型是怎么样的。如下图\n![Java内存模型](https://upload-images.jianshu.io/upload_images/1534431-2c69d083add54ae6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n - 程序计数器\n- Java 虚拟机栈\n- 方法区：方法区也是各个线程共享的内存区域，它用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据\n  - 运行时常量池\n- Java 堆:一般new的对象实例和数组都是在堆中的，而GC主要回收的内存也是这块堆内存，后面单独领出来来讲。\n- 直接内存：不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范定义的内存区域(Fresco图片加载库，就是运行这块内存超越虚拟机内存使用)。\n- code cache等其他内存\n### Java 堆\nJava Heap 是 Java 虚拟机所管理的内存中最大的一块，它是所有线程共享的一块内存区域。几乎所有的对象实例和数组都在这类分配内存。\n>Java 堆内存由垃圾回收器的自动内存管理系统管理。\n堆内存分为两大部分：新生代和老年代，默认比例为1：2，可修改。\n老年代主要存放应用程序中生命周期长的存活对象。\n新生代又分为三个部分：一个Eden区和两个Survivor区，默认比例为8：1：1，可修改。\nEden区存放新生的对象。\nSurvivor存放每次垃圾回收后存活的对象。\n![堆内存](https://upload-images.jianshu.io/upload_images/1534431-062a3348d8286a11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 为什么？\n- 为什么要分新生代和老年代？\n- 新生代为什么分一个Eden区和两个Survivor区?\n\n带着这些疑问，我们就要先了解堆相关的垃圾回收算法和采用的垃圾回收器。在讲算法前先了解怎么判断对象是否回收。\n### 对象什么时候回收？\n判断对象是否回收主要有以下两种算法\n-  引用计数算法\n给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。\n![引用计数算法](https://upload-images.jianshu.io/upload_images/1534431-982627fe64dfa349.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n    - 优点：简单，高效，Objective-c用的就是这种算法。\n    - 缺点：很难处理循环引用，比如图中相互引用的两个对象则无法释放。但是也有解决办法，想知道自行搜索。\n- 可达性分析算法（根搜索算法）\n为了解决上面的循环引用问题，Java采用了一种新的算法：可达性分析算法。\n从GC Roots（每种具体实现对GC Roots有不同的定义）作为起点，向下搜索它们引用的对象，可以生成一棵引用树，树的节点视为可达对象，反之视为不可达。\n![可达性分析算法](https://upload-images.jianshu.io/upload_images/1534431-a9dda2d42cd749cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n>Java定义的GC Roots对象:\n  虚拟机栈（帧栈中的本地变量表）中引用的对象。\n  方法区中静态属性引用的对象。\n  方法区中常量引用的对象。\n  本地方法栈中JNI引用的对象。\n\n如果出现循环引用了，只要没有被GC Roots引用了就会被回收，完美解决！\n\n### 垃圾回收算法\n知道了什么时候回收对象，那我们再看具体怎么垃圾回收。\n- 标记清除法\n标记-清除法分为两个阶段：标记阶段和清除阶段。标记阶段的任务是标记出所有需要被回收的对象，清除阶段就是回收被标记的对象所占用的空间。\n![标记清除法](https://upload-images.jianshu.io/upload_images/1534431-43bc311c23427d67.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n  - 优点：是简单，容易实现。\n  - 缺点：容易产生内存碎片，碎片太多可能会导致后续过程中需要为大对象分配空间时无法找到足够的空间而提前触发新的一次垃圾收集动作。\n- 复制算法\n复制算法将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用的内存空间一次清理掉，这样一来就不容易出现内存碎片的问题。\n![复制算法](https://upload-images.jianshu.io/upload_images/1534431-9bf508a2e534d864.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n  - 优点：实现简单，运行高效且不容易产生内存碎片，适用于存活对象很少。回收对象多\n  - 缺点：内存空间的使用做出了高昂的代价，因为能够使用的内存缩减到原来的一半，如果存活对象很多，那么Copying算法的效率将会大大降低。\n- 标记整理算法\n该算法标记阶段和标记清除法一样，但是在完成标记之后，它不是直接清理可回收对象，而是将存活对象都向一端移动，然后清理掉端边界以外的内存。\n![标记整理算法](https://upload-images.jianshu.io/upload_images/1534431-4b6066a7e03fb403.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n    - 优点：不会出现内存碎片问题，适用于存活对象多，回收对象少的情况使用\n    - 缺点：整理时间长，容易导致卡顿。\n- 分代回收算法\n分代回收算法其实不算一种新的算法，而是根据复制算法和标记整理算法的使用场景综合使用。\n>复制算法：适用于存活对象很少。回收对象多\n标记整理算法: 适用用于存活对象多，回收对象少\n\n分代算法就是根据对象存活的生命周期将内存划分为若干个不同的区域。一般情况下将堆区划分为老年代（Old Generation）和新生代（Young Generation），老年代的特点是每次垃圾收集时只有少量对象需要被回收所以采用标记整理法。而新生代的特点是每次垃圾回收时都有大量的对象需要被回收所以采用复制算法（改良的复制算法，不是按1：1分配）。\n\n![分代回收算法](https://upload-images.jianshu.io/upload_images/1534431-df6da09763c72d95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n- Eden空间和两块Survivor空间的工作流程\n> // 分配了一个又一个对象\n放到Eden区\n// 不好，Eden区满了，只能GC(新生代GC：Minor GC)了\n把Eden区的存活对象copy到Survivor A区，然后清空Eden区（本来Survivor B区也需要清空的，不过本来就是空的）\n// 又分配了一个又一个对象\n放到Eden区\n// 不好，Eden区又满了，只能GC(新生代GC：Minor GC)了\n把Eden区和Survivor A区的存活对象copy到Survivor B区，然后清空Eden区和Survivor A区\n// 又分配了一个又一个对象\n放到Eden区\n// 不好，Eden区又满了，只能GC(新生代GC：Minor GC)了\n把Eden区和Survivor B区的存活对象copy到Survivor A区，然后清空Eden区和Survivor B区\n// ...\n// 有的对象来回在Survivor A区或者B区呆了比如15次，就被分配到老年代Old区\n// 有的对象太大，超过了Eden区，直接被分配在Old区\n// 有的存活对象，放不下Survivor区，也被分配到Old区\n// ...\n// 在某次Minor GC的过程中突然发现：\n// 不好，老年代Old区也满了，这是一次大GC(老年代GC：Major GC)\nOld区慢慢的整理一番，空间又够了\n// 继续Minor GC\n// ...\n// ...\n在回答上面提出的问题？\n>为什么要分新生代和老年代？\n综合使用算法，最优采用分代算法所以分为新生代和老年代两块区域。具体为什么1：2？应该是根据实践测试得出的结果，也可以调整。\n\n- 回答第二个问题[为什么新生代内存需要有两个Survivor区](https://blog.csdn.net/antony9118/article/details/51425581)，这里讲的比较详细\n\n- 什么时候触发GC？\n>GC_FOR_MALLOC: 表示是在堆上分配对象时内存不足触发的GC。\nGC_CONCURRENT: 当我们应用程序的堆内存达到一定量，或者可以理解为快要满的时候，系统会自动触发GC操作来释放内存。\nGC_EXPLICIT: 表示是应用程序调用System.gc、VMRuntime.gc接口或者收到SIGUSR1信号时触发的GC。\nGC_BEFORE_OOM: 表示是在准备抛OOM异常之前进行的最后努力而触发的GC。\n### 垃圾回收器\n在GC机制中，起重要作用的是垃圾收集器，垃圾收集器是GC的具体实现，Java虚拟机规范中对于垃圾收集器没有任何规定，所以不同厂商实现的垃圾 收集器各不相同，也有可能采用多个垃圾回收器并存方式，HotSpot 1.6版使用的垃圾收集器如下图（图来源于《深入理解Java虚拟机：JVM高级特效与最佳实现》，图中两个收集器之间有连线，说明它们可以配合使用）\n![垃圾回收器](https://upload-images.jianshu.io/upload_images/1534431-e50e3a7a84da379d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n- Serial收集器\n- ParNew收集器\n- Parallel Scavenge收集器\n- CMS收集器（应用非常广泛）\n- G1收集器（面向服务端应用）\n###ART与Dalvik虚拟机 \nART(Android Runtime)是Android 4.4发布的，用来替换Dalvik虚拟，Android 4.4默认采用的还是DVM，系统会提供一个选项来开启ART。在Android 5.0时，默认采用ART，DVM从此退出历史舞台。\n\nART与Dalvik的区别\n- Dalvik中的应用每次运行时，字节码都需要通过即时编译器（JIT，just in time）转换为机器码，这会使得应用的运行效率降低。而在ART中，系统在安装应用时会进行一次预编译（AOT，ahead of time）,将字节码预先编译成机器码并存储在本地，这样应用每次运行时就不需要执行编译了，运行效率也大大提升。\n- ART占用空间比Dalvik大（字节码变为机器码之后，可能会增加10%-20%），这就是“时间换空间大法”。\n- 改进CMS 垃圾回收，引入移动垃圾回收器。\n- ART把Java堆的主要组成包括Image Space、Zygote Space、Allocation Space和Large Object Space四个Space，Image Space用来存在一些预加载的类， Zygote Space和Allocation Space与Dalvik虚拟机垃圾收集机制中的Zygote堆和Active堆的作用是一样的，Large Object Space就是一些离散地址的集合，用来分配一些大对象从而提高了GC的管理效率和整体性能。如图\n![image.png](https://upload-images.jianshu.io/upload_images/1534431-56d1ba248844e594.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n### GC调优思路\n其中一个或者两个方面的目标，很少有情况可以兼顾三个不同的角度\n- 内存占用 \n- 延时\n- 吞吐量\n\n### 参考文章\n- [Android GC 那点事](https://juejin.im/post/5909c7ef570c3500583bf433)\n- [理解Java垃圾回收机制](http://jayfeng.com/2016/03/11/%E7%90%86%E8%A7%A3Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/?from=singlemessage&isappinstalled=0)\n - [Java类生命周期](http://blog.csdn.net/zhengzhb/article/details/7517213)\n - [单例模式讨论篇：单例模式与垃圾回收](http://blog.csdn.net/zhengzhb/article/details/7331354)\n- [JVM 垃圾回收算法及回收器详解](http://www.importnew.com/26383.html)\n- [为什么新生代内存需要有两个Survivor区](https://blog.csdn.net/antony9118/article/details/51425581)","slug":"Java垃圾回收机制","published":1,"updated":"2021-09-10T07:04:21.942Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cktfeap3t0012c2xxkpnhf76p","content":"<p><img src=\"https://upload-images.jianshu.io/upload_images/1534431-a4831eb7feafd902.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Java垃圾回收机制\"></p>\n<p>本文章你能知道的内容：</p>\n<ul>\n<li>Java内存模型</li>\n<li>Java堆</li>\n<li>对象什么时候回收</li>\n<li>垃圾回收算法</li>\n<li>垃圾回收器<h3 id=\"Java内存模型\"><a href=\"#Java内存模型\" class=\"headerlink\" title=\"Java内存模型\"></a>Java内存模型</h3>要了解Java垃圾回收机制，首先知道Java内存模型是怎么样的。如下图<br><img src=\"https://upload-images.jianshu.io/upload_images/1534431-2c69d083add54ae6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Java内存模型\"><ul>\n<li>程序计数器</li>\n<li>Java 虚拟机栈</li>\n<li>方法区：方法区也是各个线程共享的内存区域，它用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</li>\n</ul>\n</li>\n<li>运行时常量池<ul>\n<li>Java 堆:一般new的对象实例和数组都是在堆中的，而GC主要回收的内存也是这块堆内存，后面单独领出来来讲。</li>\n<li>直接内存：不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范定义的内存区域(Fresco图片加载库，就是运行这块内存超越虚拟机内存使用)。</li>\n<li>code cache等其他内存<h3 id=\"Java-堆\"><a href=\"#Java-堆\" class=\"headerlink\" title=\"Java 堆\"></a>Java 堆</h3>Java Heap 是 Java 虚拟机所管理的内存中最大的一块，它是所有线程共享的一块内存区域。几乎所有的对象实例和数组都在这类分配内存。<blockquote>\n<p>Java 堆内存由垃圾回收器的自动内存管理系统管理。<br>堆内存分为两大部分：新生代和老年代，默认比例为1：2，可修改。<br>老年代主要存放应用程序中生命周期长的存活对象。<br>新生代又分为三个部分：一个Eden区和两个Survivor区，默认比例为8：1：1，可修改。<br>Eden区存放新生的对象。<br>Survivor存放每次垃圾回收后存活的对象。<br><img src=\"https://upload-images.jianshu.io/upload_images/1534431-062a3348d8286a11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"堆内存\"></p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"为什么？\"><a href=\"#为什么？\" class=\"headerlink\" title=\"为什么？\"></a>为什么？</h3><ul>\n<li>为什么要分新生代和老年代？</li>\n<li>新生代为什么分一个Eden区和两个Survivor区?</li>\n</ul>\n<p>带着这些疑问，我们就要先了解堆相关的垃圾回收算法和采用的垃圾回收器。在讲算法前先了解怎么判断对象是否回收。</p>\n<h3 id=\"对象什么时候回收？\"><a href=\"#对象什么时候回收？\" class=\"headerlink\" title=\"对象什么时候回收？\"></a>对象什么时候回收？</h3><p>判断对象是否回收主要有以下两种算法</p>\n<ul>\n<li>引用计数算法<br>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。<br><img src=\"https://upload-images.jianshu.io/upload_images/1534431-982627fe64dfa349.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"引用计数算法\"><ul>\n<li>优点：简单，高效，Objective-c用的就是这种算法。</li>\n<li>缺点：很难处理循环引用，比如图中相互引用的两个对象则无法释放。但是也有解决办法，想知道自行搜索。</li>\n</ul>\n</li>\n<li>可达性分析算法（根搜索算法）<br>为了解决上面的循环引用问题，Java采用了一种新的算法：可达性分析算法。<br>从GC Roots（每种具体实现对GC Roots有不同的定义）作为起点，向下搜索它们引用的对象，可以生成一棵引用树，树的节点视为可达对象，反之视为不可达。<br><img src=\"https://upload-images.jianshu.io/upload_images/1534431-a9dda2d42cd749cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"可达性分析算法\"><blockquote>\n<p>Java定义的GC Roots对象:<br>虚拟机栈（帧栈中的本地变量表）中引用的对象。<br>方法区中静态属性引用的对象。<br>方法区中常量引用的对象。<br>本地方法栈中JNI引用的对象。</p>\n</blockquote>\n</li>\n</ul>\n<p>如果出现循环引用了，只要没有被GC Roots引用了就会被回收，完美解决！</p>\n<h3 id=\"垃圾回收算法\"><a href=\"#垃圾回收算法\" class=\"headerlink\" title=\"垃圾回收算法\"></a>垃圾回收算法</h3><p>知道了什么时候回收对象，那我们再看具体怎么垃圾回收。</p>\n<ul>\n<li>标记清除法<br>标记-清除法分为两个阶段：标记阶段和清除阶段。标记阶段的任务是标记出所有需要被回收的对象，清除阶段就是回收被标记的对象所占用的空间。<br><img src=\"https://upload-images.jianshu.io/upload_images/1534431-43bc311c23427d67.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"标记清除法\"><ul>\n<li>优点：是简单，容易实现。</li>\n<li>缺点：容易产生内存碎片，碎片太多可能会导致后续过程中需要为大对象分配空间时无法找到足够的空间而提前触发新的一次垃圾收集动作。</li>\n</ul>\n</li>\n<li><p>复制算法<br>复制算法将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用的内存空间一次清理掉，这样一来就不容易出现内存碎片的问题。<br><img src=\"https://upload-images.jianshu.io/upload_images/1534431-9bf508a2e534d864.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"复制算法\"></p>\n<ul>\n<li>优点：实现简单，运行高效且不容易产生内存碎片，适用于存活对象很少。回收对象多</li>\n<li>缺点：内存空间的使用做出了高昂的代价，因为能够使用的内存缩减到原来的一半，如果存活对象很多，那么Copying算法的效率将会大大降低。</li>\n</ul>\n</li>\n<li>标记整理算法<br>该算法标记阶段和标记清除法一样，但是在完成标记之后，它不是直接清理可回收对象，而是将存活对象都向一端移动，然后清理掉端边界以外的内存。<br><img src=\"https://upload-images.jianshu.io/upload_images/1534431-4b6066a7e03fb403.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"标记整理算法\"><ul>\n<li>优点：不会出现内存碎片问题，适用于存活对象多，回收对象少的情况使用</li>\n<li>缺点：整理时间长，容易导致卡顿。</li>\n</ul>\n</li>\n<li>分代回收算法<br>分代回收算法其实不算一种新的算法，而是根据复制算法和标记整理算法的使用场景综合使用。<blockquote>\n<p>复制算法：适用于存活对象很少。回收对象多<br>标记整理算法: 适用用于存活对象多，回收对象少</p>\n</blockquote>\n</li>\n</ul>\n<p>分代算法就是根据对象存活的生命周期将内存划分为若干个不同的区域。一般情况下将堆区划分为老年代（Old Generation）和新生代（Young Generation），老年代的特点是每次垃圾收集时只有少量对象需要被回收所以采用标记整理法。而新生代的特点是每次垃圾回收时都有大量的对象需要被回收所以采用复制算法（改良的复制算法，不是按1：1分配）。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/1534431-df6da09763c72d95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"分代回收算法\"></p>\n<ul>\n<li><p>Eden空间和两块Survivor空间的工作流程</p>\n<blockquote>\n<p>// 分配了一个又一个对象<br>放到Eden区<br>// 不好，Eden区满了，只能GC(新生代GC：Minor GC)了<br>把Eden区的存活对象copy到Survivor A区，然后清空Eden区（本来Survivor B区也需要清空的，不过本来就是空的）<br>// 又分配了一个又一个对象<br>放到Eden区<br>// 不好，Eden区又满了，只能GC(新生代GC：Minor GC)了<br>把Eden区和Survivor A区的存活对象copy到Survivor B区，然后清空Eden区和Survivor A区<br>// 又分配了一个又一个对象<br>放到Eden区<br>// 不好，Eden区又满了，只能GC(新生代GC：Minor GC)了<br>把Eden区和Survivor B区的存活对象copy到Survivor A区，然后清空Eden区和Survivor B区<br>// …<br>// 有的对象来回在Survivor A区或者B区呆了比如15次，就被分配到老年代Old区<br>// 有的对象太大，超过了Eden区，直接被分配在Old区<br>// 有的存活对象，放不下Survivor区，也被分配到Old区<br>// …<br>// 在某次Minor GC的过程中突然发现：<br>// 不好，老年代Old区也满了，这是一次大GC(老年代GC：Major GC)<br>Old区慢慢的整理一番，空间又够了<br>// 继续Minor GC<br>// …<br>// …<br>在回答上面提出的问题？<br>为什么要分新生代和老年代？<br>综合使用算法，最优采用分代算法所以分为新生代和老年代两块区域。具体为什么1：2？应该是根据实践测试得出的结果，也可以调整。</p>\n</blockquote>\n</li>\n<li><p>回答第二个问题<a href=\"https://blog.csdn.net/antony9118/article/details/51425581\" target=\"_blank\" rel=\"noopener\">为什么新生代内存需要有两个Survivor区</a>，这里讲的比较详细</p>\n</li>\n<li><p>什么时候触发GC？</p>\n<blockquote>\n<p>GC_FOR_MALLOC: 表示是在堆上分配对象时内存不足触发的GC。<br>GC_CONCURRENT: 当我们应用程序的堆内存达到一定量，或者可以理解为快要满的时候，系统会自动触发GC操作来释放内存。<br>GC_EXPLICIT: 表示是应用程序调用System.gc、VMRuntime.gc接口或者收到SIGUSR1信号时触发的GC。<br>GC_BEFORE_OOM: 表示是在准备抛OOM异常之前进行的最后努力而触发的GC。</p>\n<h3 id=\"垃圾回收器\"><a href=\"#垃圾回收器\" class=\"headerlink\" title=\"垃圾回收器\"></a>垃圾回收器</h3><p>在GC机制中，起重要作用的是垃圾收集器，垃圾收集器是GC的具体实现，Java虚拟机规范中对于垃圾收集器没有任何规定，所以不同厂商实现的垃圾 收集器各不相同，也有可能采用多个垃圾回收器并存方式，HotSpot 1.6版使用的垃圾收集器如下图（图来源于《深入理解Java虚拟机：JVM高级特效与最佳实现》，图中两个收集器之间有连线，说明它们可以配合使用）<br><img src=\"https://upload-images.jianshu.io/upload_images/1534431-e50e3a7a84da379d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"垃圾回收器\"></p>\n</blockquote>\n</li>\n<li><p>Serial收集器</p>\n</li>\n<li>ParNew收集器</li>\n<li>Parallel Scavenge收集器</li>\n<li>CMS收集器（应用非常广泛）</li>\n<li>G1收集器（面向服务端应用）<br>###ART与Dalvik虚拟机<br>ART(Android Runtime)是Android 4.4发布的，用来替换Dalvik虚拟，Android 4.4默认采用的还是DVM，系统会提供一个选项来开启ART。在Android 5.0时，默认采用ART，DVM从此退出历史舞台。</li>\n</ul>\n<p>ART与Dalvik的区别</p>\n<ul>\n<li>Dalvik中的应用每次运行时，字节码都需要通过即时编译器（JIT，just in time）转换为机器码，这会使得应用的运行效率降低。而在ART中，系统在安装应用时会进行一次预编译（AOT，ahead of time）,将字节码预先编译成机器码并存储在本地，这样应用每次运行时就不需要执行编译了，运行效率也大大提升。</li>\n<li>ART占用空间比Dalvik大（字节码变为机器码之后，可能会增加10%-20%），这就是“时间换空间大法”。</li>\n<li>改进CMS 垃圾回收，引入移动垃圾回收器。</li>\n<li>ART把Java堆的主要组成包括Image Space、Zygote Space、Allocation Space和Large Object Space四个Space，Image Space用来存在一些预加载的类， Zygote Space和Allocation Space与Dalvik虚拟机垃圾收集机制中的Zygote堆和Active堆的作用是一样的，Large Object Space就是一些离散地址的集合，用来分配一些大对象从而提高了GC的管理效率和整体性能。如图<br><img src=\"https://upload-images.jianshu.io/upload_images/1534431-56d1ba248844e594.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><h3 id=\"GC调优思路\"><a href=\"#GC调优思路\" class=\"headerlink\" title=\"GC调优思路\"></a>GC调优思路</h3>其中一个或者两个方面的目标，很少有情况可以兼顾三个不同的角度</li>\n<li>内存占用 </li>\n<li>延时</li>\n<li>吞吐量</li>\n</ul>\n<h3 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h3><ul>\n<li><a href=\"https://juejin.im/post/5909c7ef570c3500583bf433\" target=\"_blank\" rel=\"noopener\">Android GC 那点事</a></li>\n<li><a href=\"http://jayfeng.com/2016/03/11/%E7%90%86%E8%A7%A3Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/?from=singlemessage&amp;isappinstalled=0\" target=\"_blank\" rel=\"noopener\">理解Java垃圾回收机制</a><ul>\n<li><a href=\"http://blog.csdn.net/zhengzhb/article/details/7517213\" target=\"_blank\" rel=\"noopener\">Java类生命周期</a></li>\n<li><a href=\"http://blog.csdn.net/zhengzhb/article/details/7331354\" target=\"_blank\" rel=\"noopener\">单例模式讨论篇：单例模式与垃圾回收</a></li>\n</ul>\n</li>\n<li><a href=\"http://www.importnew.com/26383.html\" target=\"_blank\" rel=\"noopener\">JVM 垃圾回收算法及回收器详解</a></li>\n<li><a href=\"https://blog.csdn.net/antony9118/article/details/51425581\" target=\"_blank\" rel=\"noopener\">为什么新生代内存需要有两个Survivor区</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"https://upload-images.jianshu.io/upload_images/1534431-a4831eb7feafd902.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Java垃圾回收机制\"></p>\n<p>本文章你能知道的内容：</p>\n<ul>\n<li>Java内存模型</li>\n<li>Java堆</li>\n<li>对象什么时候回收</li>\n<li>垃圾回收算法</li>\n<li>垃圾回收器<h3 id=\"Java内存模型\"><a href=\"#Java内存模型\" class=\"headerlink\" title=\"Java内存模型\"></a>Java内存模型</h3>要了解Java垃圾回收机制，首先知道Java内存模型是怎么样的。如下图<br><img src=\"https://upload-images.jianshu.io/upload_images/1534431-2c69d083add54ae6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Java内存模型\"><ul>\n<li>程序计数器</li>\n<li>Java 虚拟机栈</li>\n<li>方法区：方法区也是各个线程共享的内存区域，它用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</li>\n</ul>\n</li>\n<li>运行时常量池<ul>\n<li>Java 堆:一般new的对象实例和数组都是在堆中的，而GC主要回收的内存也是这块堆内存，后面单独领出来来讲。</li>\n<li>直接内存：不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范定义的内存区域(Fresco图片加载库，就是运行这块内存超越虚拟机内存使用)。</li>\n<li>code cache等其他内存<h3 id=\"Java-堆\"><a href=\"#Java-堆\" class=\"headerlink\" title=\"Java 堆\"></a>Java 堆</h3>Java Heap 是 Java 虚拟机所管理的内存中最大的一块，它是所有线程共享的一块内存区域。几乎所有的对象实例和数组都在这类分配内存。<blockquote>\n<p>Java 堆内存由垃圾回收器的自动内存管理系统管理。<br>堆内存分为两大部分：新生代和老年代，默认比例为1：2，可修改。<br>老年代主要存放应用程序中生命周期长的存活对象。<br>新生代又分为三个部分：一个Eden区和两个Survivor区，默认比例为8：1：1，可修改。<br>Eden区存放新生的对象。<br>Survivor存放每次垃圾回收后存活的对象。<br><img src=\"https://upload-images.jianshu.io/upload_images/1534431-062a3348d8286a11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"堆内存\"></p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"为什么？\"><a href=\"#为什么？\" class=\"headerlink\" title=\"为什么？\"></a>为什么？</h3><ul>\n<li>为什么要分新生代和老年代？</li>\n<li>新生代为什么分一个Eden区和两个Survivor区?</li>\n</ul>\n<p>带着这些疑问，我们就要先了解堆相关的垃圾回收算法和采用的垃圾回收器。在讲算法前先了解怎么判断对象是否回收。</p>\n<h3 id=\"对象什么时候回收？\"><a href=\"#对象什么时候回收？\" class=\"headerlink\" title=\"对象什么时候回收？\"></a>对象什么时候回收？</h3><p>判断对象是否回收主要有以下两种算法</p>\n<ul>\n<li>引用计数算法<br>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。<br><img src=\"https://upload-images.jianshu.io/upload_images/1534431-982627fe64dfa349.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"引用计数算法\"><ul>\n<li>优点：简单，高效，Objective-c用的就是这种算法。</li>\n<li>缺点：很难处理循环引用，比如图中相互引用的两个对象则无法释放。但是也有解决办法，想知道自行搜索。</li>\n</ul>\n</li>\n<li>可达性分析算法（根搜索算法）<br>为了解决上面的循环引用问题，Java采用了一种新的算法：可达性分析算法。<br>从GC Roots（每种具体实现对GC Roots有不同的定义）作为起点，向下搜索它们引用的对象，可以生成一棵引用树，树的节点视为可达对象，反之视为不可达。<br><img src=\"https://upload-images.jianshu.io/upload_images/1534431-a9dda2d42cd749cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"可达性分析算法\"><blockquote>\n<p>Java定义的GC Roots对象:<br>虚拟机栈（帧栈中的本地变量表）中引用的对象。<br>方法区中静态属性引用的对象。<br>方法区中常量引用的对象。<br>本地方法栈中JNI引用的对象。</p>\n</blockquote>\n</li>\n</ul>\n<p>如果出现循环引用了，只要没有被GC Roots引用了就会被回收，完美解决！</p>\n<h3 id=\"垃圾回收算法\"><a href=\"#垃圾回收算法\" class=\"headerlink\" title=\"垃圾回收算法\"></a>垃圾回收算法</h3><p>知道了什么时候回收对象，那我们再看具体怎么垃圾回收。</p>\n<ul>\n<li>标记清除法<br>标记-清除法分为两个阶段：标记阶段和清除阶段。标记阶段的任务是标记出所有需要被回收的对象，清除阶段就是回收被标记的对象所占用的空间。<br><img src=\"https://upload-images.jianshu.io/upload_images/1534431-43bc311c23427d67.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"标记清除法\"><ul>\n<li>优点：是简单，容易实现。</li>\n<li>缺点：容易产生内存碎片，碎片太多可能会导致后续过程中需要为大对象分配空间时无法找到足够的空间而提前触发新的一次垃圾收集动作。</li>\n</ul>\n</li>\n<li><p>复制算法<br>复制算法将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用的内存空间一次清理掉，这样一来就不容易出现内存碎片的问题。<br><img src=\"https://upload-images.jianshu.io/upload_images/1534431-9bf508a2e534d864.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"复制算法\"></p>\n<ul>\n<li>优点：实现简单，运行高效且不容易产生内存碎片，适用于存活对象很少。回收对象多</li>\n<li>缺点：内存空间的使用做出了高昂的代价，因为能够使用的内存缩减到原来的一半，如果存活对象很多，那么Copying算法的效率将会大大降低。</li>\n</ul>\n</li>\n<li>标记整理算法<br>该算法标记阶段和标记清除法一样，但是在完成标记之后，它不是直接清理可回收对象，而是将存活对象都向一端移动，然后清理掉端边界以外的内存。<br><img src=\"https://upload-images.jianshu.io/upload_images/1534431-4b6066a7e03fb403.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"标记整理算法\"><ul>\n<li>优点：不会出现内存碎片问题，适用于存活对象多，回收对象少的情况使用</li>\n<li>缺点：整理时间长，容易导致卡顿。</li>\n</ul>\n</li>\n<li>分代回收算法<br>分代回收算法其实不算一种新的算法，而是根据复制算法和标记整理算法的使用场景综合使用。<blockquote>\n<p>复制算法：适用于存活对象很少。回收对象多<br>标记整理算法: 适用用于存活对象多，回收对象少</p>\n</blockquote>\n</li>\n</ul>\n<p>分代算法就是根据对象存活的生命周期将内存划分为若干个不同的区域。一般情况下将堆区划分为老年代（Old Generation）和新生代（Young Generation），老年代的特点是每次垃圾收集时只有少量对象需要被回收所以采用标记整理法。而新生代的特点是每次垃圾回收时都有大量的对象需要被回收所以采用复制算法（改良的复制算法，不是按1：1分配）。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/1534431-df6da09763c72d95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"分代回收算法\"></p>\n<ul>\n<li><p>Eden空间和两块Survivor空间的工作流程</p>\n<blockquote>\n<p>// 分配了一个又一个对象<br>放到Eden区<br>// 不好，Eden区满了，只能GC(新生代GC：Minor GC)了<br>把Eden区的存活对象copy到Survivor A区，然后清空Eden区（本来Survivor B区也需要清空的，不过本来就是空的）<br>// 又分配了一个又一个对象<br>放到Eden区<br>// 不好，Eden区又满了，只能GC(新生代GC：Minor GC)了<br>把Eden区和Survivor A区的存活对象copy到Survivor B区，然后清空Eden区和Survivor A区<br>// 又分配了一个又一个对象<br>放到Eden区<br>// 不好，Eden区又满了，只能GC(新生代GC：Minor GC)了<br>把Eden区和Survivor B区的存活对象copy到Survivor A区，然后清空Eden区和Survivor B区<br>// …<br>// 有的对象来回在Survivor A区或者B区呆了比如15次，就被分配到老年代Old区<br>// 有的对象太大，超过了Eden区，直接被分配在Old区<br>// 有的存活对象，放不下Survivor区，也被分配到Old区<br>// …<br>// 在某次Minor GC的过程中突然发现：<br>// 不好，老年代Old区也满了，这是一次大GC(老年代GC：Major GC)<br>Old区慢慢的整理一番，空间又够了<br>// 继续Minor GC<br>// …<br>// …<br>在回答上面提出的问题？<br>为什么要分新生代和老年代？<br>综合使用算法，最优采用分代算法所以分为新生代和老年代两块区域。具体为什么1：2？应该是根据实践测试得出的结果，也可以调整。</p>\n</blockquote>\n</li>\n<li><p>回答第二个问题<a href=\"https://blog.csdn.net/antony9118/article/details/51425581\" target=\"_blank\" rel=\"noopener\">为什么新生代内存需要有两个Survivor区</a>，这里讲的比较详细</p>\n</li>\n<li><p>什么时候触发GC？</p>\n<blockquote>\n<p>GC_FOR_MALLOC: 表示是在堆上分配对象时内存不足触发的GC。<br>GC_CONCURRENT: 当我们应用程序的堆内存达到一定量，或者可以理解为快要满的时候，系统会自动触发GC操作来释放内存。<br>GC_EXPLICIT: 表示是应用程序调用System.gc、VMRuntime.gc接口或者收到SIGUSR1信号时触发的GC。<br>GC_BEFORE_OOM: 表示是在准备抛OOM异常之前进行的最后努力而触发的GC。</p>\n<h3 id=\"垃圾回收器\"><a href=\"#垃圾回收器\" class=\"headerlink\" title=\"垃圾回收器\"></a>垃圾回收器</h3><p>在GC机制中，起重要作用的是垃圾收集器，垃圾收集器是GC的具体实现，Java虚拟机规范中对于垃圾收集器没有任何规定，所以不同厂商实现的垃圾 收集器各不相同，也有可能采用多个垃圾回收器并存方式，HotSpot 1.6版使用的垃圾收集器如下图（图来源于《深入理解Java虚拟机：JVM高级特效与最佳实现》，图中两个收集器之间有连线，说明它们可以配合使用）<br><img src=\"https://upload-images.jianshu.io/upload_images/1534431-e50e3a7a84da379d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"垃圾回收器\"></p>\n</blockquote>\n</li>\n<li><p>Serial收集器</p>\n</li>\n<li>ParNew收集器</li>\n<li>Parallel Scavenge收集器</li>\n<li>CMS收集器（应用非常广泛）</li>\n<li>G1收集器（面向服务端应用）<br>###ART与Dalvik虚拟机<br>ART(Android Runtime)是Android 4.4发布的，用来替换Dalvik虚拟，Android 4.4默认采用的还是DVM，系统会提供一个选项来开启ART。在Android 5.0时，默认采用ART，DVM从此退出历史舞台。</li>\n</ul>\n<p>ART与Dalvik的区别</p>\n<ul>\n<li>Dalvik中的应用每次运行时，字节码都需要通过即时编译器（JIT，just in time）转换为机器码，这会使得应用的运行效率降低。而在ART中，系统在安装应用时会进行一次预编译（AOT，ahead of time）,将字节码预先编译成机器码并存储在本地，这样应用每次运行时就不需要执行编译了，运行效率也大大提升。</li>\n<li>ART占用空间比Dalvik大（字节码变为机器码之后，可能会增加10%-20%），这就是“时间换空间大法”。</li>\n<li>改进CMS 垃圾回收，引入移动垃圾回收器。</li>\n<li>ART把Java堆的主要组成包括Image Space、Zygote Space、Allocation Space和Large Object Space四个Space，Image Space用来存在一些预加载的类， Zygote Space和Allocation Space与Dalvik虚拟机垃圾收集机制中的Zygote堆和Active堆的作用是一样的，Large Object Space就是一些离散地址的集合，用来分配一些大对象从而提高了GC的管理效率和整体性能。如图<br><img src=\"https://upload-images.jianshu.io/upload_images/1534431-56d1ba248844e594.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><h3 id=\"GC调优思路\"><a href=\"#GC调优思路\" class=\"headerlink\" title=\"GC调优思路\"></a>GC调优思路</h3>其中一个或者两个方面的目标，很少有情况可以兼顾三个不同的角度</li>\n<li>内存占用 </li>\n<li>延时</li>\n<li>吞吐量</li>\n</ul>\n<h3 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h3><ul>\n<li><a href=\"https://juejin.im/post/5909c7ef570c3500583bf433\" target=\"_blank\" rel=\"noopener\">Android GC 那点事</a></li>\n<li><a href=\"http://jayfeng.com/2016/03/11/%E7%90%86%E8%A7%A3Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/?from=singlemessage&amp;isappinstalled=0\" target=\"_blank\" rel=\"noopener\">理解Java垃圾回收机制</a><ul>\n<li><a href=\"http://blog.csdn.net/zhengzhb/article/details/7517213\" target=\"_blank\" rel=\"noopener\">Java类生命周期</a></li>\n<li><a href=\"http://blog.csdn.net/zhengzhb/article/details/7331354\" target=\"_blank\" rel=\"noopener\">单例模式讨论篇：单例模式与垃圾回收</a></li>\n</ul>\n</li>\n<li><a href=\"http://www.importnew.com/26383.html\" target=\"_blank\" rel=\"noopener\">JVM 垃圾回收算法及回收器详解</a></li>\n<li><a href=\"https://blog.csdn.net/antony9118/article/details/51425581\" target=\"_blank\" rel=\"noopener\">为什么新生代内存需要有两个Survivor区</a></li>\n</ul>\n"},{"title":"Java单例模式，线程安全","date":"2016-05-28T14:50:29.000Z","_content":"\n- 懒汉式:线程安全，开销大\n\n````\npublic class Singleton{\n private static final Singleton singleton;\nprivate Singleton(){\n  }\n public static final synchronized Singleton getInstance(){\n \tif(singleton==null){\n \t singleton=new Singleton();\n \t}\n \treturn singleton;\n }\n}\n````\n- 双重检查锁：线程安全，根据需求使用\n\n````\npublic class Singleton{\n  private volatile static Singleton singleton;\n  private Singleton(){\n  }\n  public static final Singleton getInstance(){\n  \tif(singleton==null){\n  \t  synchronized(Singleton.class){\n  \t    if(singleton==null){\n  \t    singleton=new Singleton();\n  \t    }\n  \t  }\n  \t}\n   return singleton;\n  }\n}\n\n````\n- 静态内部类锁：线程安全，比较推荐\n\n````\npublic class Singleton{\nprivate Singleton(){\n  }\nprivate static class Holder{\npublic static final Singleton singleton=new Singleton();\n}\npublic static final Single getInstance(){\nreturn Holder.singleton;\n}\n}\n````\n- 饿汗式：线程安全，但没有实现懒加载\n\n````\npublic class Singleton{\n private static final Singleton singleton=new Singleton();\nprivate Singleton(){\n  }\n public static final Singleton getInstance(){\n return singleton;\n }\n}\n````\n- 枚举:线程安全，但比较少人用\n\n````\npublic class Singleton{\npublic enum EasySingleton{\n    INSTANCE;\n}\n}\n````\n\n- 参考文章\n\t- [具体JVM机制](http://www.infoq.com/cn/articles/double-checked-locking-with-delay-initialization)\n\t- [具体代码讲解](http://wuchong.me/blog/2014/08/28/how-to-correctly-write-singleton-pattern/)","source":"_posts/Java单例模式.md","raw":"title: Java单例模式，线程安全\ndate: 2016-05-28 14:50:29\ntags:\ncategories: Java\n---\n\n- 懒汉式:线程安全，开销大\n\n````\npublic class Singleton{\n private static final Singleton singleton;\nprivate Singleton(){\n  }\n public static final synchronized Singleton getInstance(){\n \tif(singleton==null){\n \t singleton=new Singleton();\n \t}\n \treturn singleton;\n }\n}\n````\n- 双重检查锁：线程安全，根据需求使用\n\n````\npublic class Singleton{\n  private volatile static Singleton singleton;\n  private Singleton(){\n  }\n  public static final Singleton getInstance(){\n  \tif(singleton==null){\n  \t  synchronized(Singleton.class){\n  \t    if(singleton==null){\n  \t    singleton=new Singleton();\n  \t    }\n  \t  }\n  \t}\n   return singleton;\n  }\n}\n\n````\n- 静态内部类锁：线程安全，比较推荐\n\n````\npublic class Singleton{\nprivate Singleton(){\n  }\nprivate static class Holder{\npublic static final Singleton singleton=new Singleton();\n}\npublic static final Single getInstance(){\nreturn Holder.singleton;\n}\n}\n````\n- 饿汗式：线程安全，但没有实现懒加载\n\n````\npublic class Singleton{\n private static final Singleton singleton=new Singleton();\nprivate Singleton(){\n  }\n public static final Singleton getInstance(){\n return singleton;\n }\n}\n````\n- 枚举:线程安全，但比较少人用\n\n````\npublic class Singleton{\npublic enum EasySingleton{\n    INSTANCE;\n}\n}\n````\n\n- 参考文章\n\t- [具体JVM机制](http://www.infoq.com/cn/articles/double-checked-locking-with-delay-initialization)\n\t- [具体代码讲解](http://wuchong.me/blog/2014/08/28/how-to-correctly-write-singleton-pattern/)","slug":"Java单例模式","published":1,"updated":"2021-09-10T07:04:21.942Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cktfeap3u0014c2xx1q76vg60","content":"<ul>\n<li>懒汉式:线程安全，开销大</li>\n</ul>\n<pre><code>public class Singleton{\n private static final Singleton singleton;\nprivate Singleton(){\n  }\n public static final synchronized Singleton getInstance(){\n     if(singleton==null){\n      singleton=new Singleton();\n     }\n     return singleton;\n }\n}\n</code></pre><ul>\n<li>双重检查锁：线程安全，根据需求使用</li>\n</ul>\n<pre><code>public class Singleton{\n  private volatile static Singleton singleton;\n  private Singleton(){\n  }\n  public static final Singleton getInstance(){\n      if(singleton==null){\n        synchronized(Singleton.class){\n          if(singleton==null){\n          singleton=new Singleton();\n          }\n        }\n      }\n   return singleton;\n  }\n}\n</code></pre><ul>\n<li>静态内部类锁：线程安全，比较推荐</li>\n</ul>\n<pre><code>public class Singleton{\nprivate Singleton(){\n  }\nprivate static class Holder{\npublic static final Singleton singleton=new Singleton();\n}\npublic static final Single getInstance(){\nreturn Holder.singleton;\n}\n}\n</code></pre><ul>\n<li>饿汗式：线程安全，但没有实现懒加载</li>\n</ul>\n<pre><code>public class Singleton{\n private static final Singleton singleton=new Singleton();\nprivate Singleton(){\n  }\n public static final Singleton getInstance(){\n return singleton;\n }\n}\n</code></pre><ul>\n<li>枚举:线程安全，但比较少人用</li>\n</ul>\n<pre><code>public class Singleton{\npublic enum EasySingleton{\n    INSTANCE;\n}\n}\n</code></pre><ul>\n<li>参考文章<ul>\n<li><a href=\"http://www.infoq.com/cn/articles/double-checked-locking-with-delay-initialization\" target=\"_blank\" rel=\"noopener\">具体JVM机制</a></li>\n<li><a href=\"http://wuchong.me/blog/2014/08/28/how-to-correctly-write-singleton-pattern/\" target=\"_blank\" rel=\"noopener\">具体代码讲解</a></li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>懒汉式:线程安全，开销大</li>\n</ul>\n<pre><code>public class Singleton{\n private static final Singleton singleton;\nprivate Singleton(){\n  }\n public static final synchronized Singleton getInstance(){\n     if(singleton==null){\n      singleton=new Singleton();\n     }\n     return singleton;\n }\n}\n</code></pre><ul>\n<li>双重检查锁：线程安全，根据需求使用</li>\n</ul>\n<pre><code>public class Singleton{\n  private volatile static Singleton singleton;\n  private Singleton(){\n  }\n  public static final Singleton getInstance(){\n      if(singleton==null){\n        synchronized(Singleton.class){\n          if(singleton==null){\n          singleton=new Singleton();\n          }\n        }\n      }\n   return singleton;\n  }\n}\n</code></pre><ul>\n<li>静态内部类锁：线程安全，比较推荐</li>\n</ul>\n<pre><code>public class Singleton{\nprivate Singleton(){\n  }\nprivate static class Holder{\npublic static final Singleton singleton=new Singleton();\n}\npublic static final Single getInstance(){\nreturn Holder.singleton;\n}\n}\n</code></pre><ul>\n<li>饿汗式：线程安全，但没有实现懒加载</li>\n</ul>\n<pre><code>public class Singleton{\n private static final Singleton singleton=new Singleton();\nprivate Singleton(){\n  }\n public static final Singleton getInstance(){\n return singleton;\n }\n}\n</code></pre><ul>\n<li>枚举:线程安全，但比较少人用</li>\n</ul>\n<pre><code>public class Singleton{\npublic enum EasySingleton{\n    INSTANCE;\n}\n}\n</code></pre><ul>\n<li>参考文章<ul>\n<li><a href=\"http://www.infoq.com/cn/articles/double-checked-locking-with-delay-initialization\" target=\"_blank\" rel=\"noopener\">具体JVM机制</a></li>\n<li><a href=\"http://wuchong.me/blog/2014/08/28/how-to-correctly-write-singleton-pattern/\" target=\"_blank\" rel=\"noopener\">具体代码讲解</a></li>\n</ul>\n</li>\n</ul>\n"},{"title":"Java异常","date":"2018-07-16T18:30:00.000Z","_content":"\n\n\n## Java异常\n\n![Java异常](https://upload-images.jianshu.io/upload_images/1534431-11903c56d9e318ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n- 对比Exception和Error \n- 运行异常与一般异常区别\n- ClassNotFoundException和NoClassDefFoundError有什么区别\n- throw和throws\n- 异常处理几点建议\n- 自定义异常\n\n### 对比Exception和Error。\n![Exception和Error](https://upload-images.jianshu.io/upload_images/1534431-ad557fa71b48a3ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\nException和Error都继承Throwable,\n- Exception是程序可以处理的异常，正常JVM运行外的异常。\n- Error一般是JVM相关异常错误，不可恢复状态，也不方便捕获。\n### 运行异常与一般异常区别\nEeception又分为可检测异常（Checked Exception）和运行异常（也可叫不可检查异常，Runtime Exception）。\n- 可检查异常（Checked Exception）在代码里必须显式地进行捕获处理，可以被处理的异常。如：IOException。\n- 运行异常,类似NullPointerException,ArrayIndexOutOfBoundsException,通常是可以编码避免的逻辑错误，具体根据需要来判断是否需要捕获，并不会在编译器强制要求。\n### ClassNotFoundException和NoClassDefFoundError有什么区别\n- ClassNotFoundException:Java动态加载类的时候，如果这个类在类路径中没有被找到或者当一个类已经某个类加载器加载到内存中了，此时另一个类加载器又尝试着动态地从同一个包中加载这个类就会抛出ClassNotFoundException异常。类加载中加载时从外存储器找不到需要的class。\n- NoClassDefFoudError，指要查找的类在编译的时候是存在的，运行的时候却找不到的异常错误。类加载中连接时从内存找不到需要的class。\n\n### throw和throws\n```\npublic void custormException()throws  CustomException{\nthrow new CustomException(\"抛出CustormException\");\n}\n```\n- throw作用域方法体内\n- throws方法名后面\n### 异常处理几点建议\n- 只针对不正常的情况才使用异常,不需要异常处理的不要专门处理以增加系统额外检查降低性能。\n```\ntry {\nint i=0;\nwhile (true) {\narr[i]=0;\ni++;\n}\n} catch (IndexOutOfBoundsException e) {\n}\n```\n- 抛出的异常要适合于相应的抽象\n```\npublic E get(int index) {\ntry {\nreturn listIterator(index).next();\n} catch (NoSuchElementException exc) {\nthrow new IndexOutOfBoundsException(\"Index: \"+index);\n}\n}\n```\n- 不要忽略异常，避免使用空的catch语句\n```\ntry {\n...\n} catch (SomeException e) {\n}\n```\n- 异常保证输出堆栈信息，在异常消息中加入导致异常发生的全部信息\n```\ntry {\n...\n} catch (SomeException e) {\nSystem.out.println(\"12344\");\n}\n```\n### 自定义异常\n一般根据项目需要自定义异常，特别是服务端处理业务的时候。一般自定义异常继承Exception，Throwable（因为Error一般用于JVM的异常错误，不常用自定义），因为异常已实现相关方法，只需重写构造方法就可以。代码如下：\n-  继承Exception\n```\npublic class CustomException extends Exception {\npublic CustomException() {\n}\n\npublic CustomException(String message) {\nsuper(message);\n}\n\npublic CustomException(String message, Throwable cause) {\nsuper(message, cause);\n}\n\npublic CustomException(Throwable cause) {\nsuper(cause);\n}\n\npublic CustomException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {\nsuper(message, cause, enableSuppression, writableStackTrace);\n}\n}\n```\n```\npublic class TestException {\npublic void testMethod(){\ntry {\ncustormException();\n} catch (CustomException e) {\ne.printStackTrace();\n}\n}\npublic void custormException()throws  CustomException{\nthrow new CustomException(\"抛出CustormException\");\n}\npublic static void main(String[] args) {\nTestException testException=new TestException();\ntestException.testMethod();\n}\n}\n```\n输出\n```\ncom.mysiga.learn.throwable.CustomException: 抛出CustormException\nat com.mysiga.learn.throwable.TestException.custormException(TestException.java:15)\nat com.mysiga.learn.throwable.TestException.testMethod(TestException.java:9)\nat com.mysiga.learn.throwable.TestException.main(TestException.java:19)\n\n```\n-  继承Throwable\n```\npublic class CustomThrowable extends Throwable {\npublic CustomThrowable() {\n}\n\npublic CustomThrowable(String message) {\nsuper(message);\n}\n\npublic CustomThrowable(String message, Throwable cause) {\nsuper(message, cause);\n}\n\npublic CustomThrowable(Throwable cause) {\nsuper(cause);\n}\n\npublic CustomThrowable(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {\nsuper(message, cause, enableSuppression, writableStackTrace);\n}\n}\n```\n```\npublic class TestThrowable {\npublic void testMethod(){\ntry {\ncustormException();\n} catch (CustomThrowable e) {\ne.printStackTrace();\n}\n}\npublic void custormException()throws  CustomThrowable{\nthrow new CustomThrowable(\"抛出CustomThrowable\");\n}\npublic static void main(String[] args) {\nTestThrowable testThrowable=new TestThrowable();\ntestThrowable.testMethod();\n}\n}\n```\n输出\n```\ncom.mysiga.learn.throwable.CustomThrowable: 抛出CustomThrowable\nat com.mysiga.learn.throwable.TestThrowable.custormException(TestThrowable.java:15)\nat com.mysiga.learn.throwable.TestThrowable.testMethod(TestThrowable.java:9)\nat com.mysiga.learn.throwable.TestThrowable.main(TestThrowable.java:19)\n\n```\n","source":"_posts/Java异常.md","raw":"title: Java异常\ndate: 2018-07-16  18:30:00\ntags:\ncategories: Java\n---\n\n\n\n## Java异常\n\n![Java异常](https://upload-images.jianshu.io/upload_images/1534431-11903c56d9e318ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n- 对比Exception和Error \n- 运行异常与一般异常区别\n- ClassNotFoundException和NoClassDefFoundError有什么区别\n- throw和throws\n- 异常处理几点建议\n- 自定义异常\n\n### 对比Exception和Error。\n![Exception和Error](https://upload-images.jianshu.io/upload_images/1534431-ad557fa71b48a3ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\nException和Error都继承Throwable,\n- Exception是程序可以处理的异常，正常JVM运行外的异常。\n- Error一般是JVM相关异常错误，不可恢复状态，也不方便捕获。\n### 运行异常与一般异常区别\nEeception又分为可检测异常（Checked Exception）和运行异常（也可叫不可检查异常，Runtime Exception）。\n- 可检查异常（Checked Exception）在代码里必须显式地进行捕获处理，可以被处理的异常。如：IOException。\n- 运行异常,类似NullPointerException,ArrayIndexOutOfBoundsException,通常是可以编码避免的逻辑错误，具体根据需要来判断是否需要捕获，并不会在编译器强制要求。\n### ClassNotFoundException和NoClassDefFoundError有什么区别\n- ClassNotFoundException:Java动态加载类的时候，如果这个类在类路径中没有被找到或者当一个类已经某个类加载器加载到内存中了，此时另一个类加载器又尝试着动态地从同一个包中加载这个类就会抛出ClassNotFoundException异常。类加载中加载时从外存储器找不到需要的class。\n- NoClassDefFoudError，指要查找的类在编译的时候是存在的，运行的时候却找不到的异常错误。类加载中连接时从内存找不到需要的class。\n\n### throw和throws\n```\npublic void custormException()throws  CustomException{\nthrow new CustomException(\"抛出CustormException\");\n}\n```\n- throw作用域方法体内\n- throws方法名后面\n### 异常处理几点建议\n- 只针对不正常的情况才使用异常,不需要异常处理的不要专门处理以增加系统额外检查降低性能。\n```\ntry {\nint i=0;\nwhile (true) {\narr[i]=0;\ni++;\n}\n} catch (IndexOutOfBoundsException e) {\n}\n```\n- 抛出的异常要适合于相应的抽象\n```\npublic E get(int index) {\ntry {\nreturn listIterator(index).next();\n} catch (NoSuchElementException exc) {\nthrow new IndexOutOfBoundsException(\"Index: \"+index);\n}\n}\n```\n- 不要忽略异常，避免使用空的catch语句\n```\ntry {\n...\n} catch (SomeException e) {\n}\n```\n- 异常保证输出堆栈信息，在异常消息中加入导致异常发生的全部信息\n```\ntry {\n...\n} catch (SomeException e) {\nSystem.out.println(\"12344\");\n}\n```\n### 自定义异常\n一般根据项目需要自定义异常，特别是服务端处理业务的时候。一般自定义异常继承Exception，Throwable（因为Error一般用于JVM的异常错误，不常用自定义），因为异常已实现相关方法，只需重写构造方法就可以。代码如下：\n-  继承Exception\n```\npublic class CustomException extends Exception {\npublic CustomException() {\n}\n\npublic CustomException(String message) {\nsuper(message);\n}\n\npublic CustomException(String message, Throwable cause) {\nsuper(message, cause);\n}\n\npublic CustomException(Throwable cause) {\nsuper(cause);\n}\n\npublic CustomException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {\nsuper(message, cause, enableSuppression, writableStackTrace);\n}\n}\n```\n```\npublic class TestException {\npublic void testMethod(){\ntry {\ncustormException();\n} catch (CustomException e) {\ne.printStackTrace();\n}\n}\npublic void custormException()throws  CustomException{\nthrow new CustomException(\"抛出CustormException\");\n}\npublic static void main(String[] args) {\nTestException testException=new TestException();\ntestException.testMethod();\n}\n}\n```\n输出\n```\ncom.mysiga.learn.throwable.CustomException: 抛出CustormException\nat com.mysiga.learn.throwable.TestException.custormException(TestException.java:15)\nat com.mysiga.learn.throwable.TestException.testMethod(TestException.java:9)\nat com.mysiga.learn.throwable.TestException.main(TestException.java:19)\n\n```\n-  继承Throwable\n```\npublic class CustomThrowable extends Throwable {\npublic CustomThrowable() {\n}\n\npublic CustomThrowable(String message) {\nsuper(message);\n}\n\npublic CustomThrowable(String message, Throwable cause) {\nsuper(message, cause);\n}\n\npublic CustomThrowable(Throwable cause) {\nsuper(cause);\n}\n\npublic CustomThrowable(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {\nsuper(message, cause, enableSuppression, writableStackTrace);\n}\n}\n```\n```\npublic class TestThrowable {\npublic void testMethod(){\ntry {\ncustormException();\n} catch (CustomThrowable e) {\ne.printStackTrace();\n}\n}\npublic void custormException()throws  CustomThrowable{\nthrow new CustomThrowable(\"抛出CustomThrowable\");\n}\npublic static void main(String[] args) {\nTestThrowable testThrowable=new TestThrowable();\ntestThrowable.testMethod();\n}\n}\n```\n输出\n```\ncom.mysiga.learn.throwable.CustomThrowable: 抛出CustomThrowable\nat com.mysiga.learn.throwable.TestThrowable.custormException(TestThrowable.java:15)\nat com.mysiga.learn.throwable.TestThrowable.testMethod(TestThrowable.java:9)\nat com.mysiga.learn.throwable.TestThrowable.main(TestThrowable.java:19)\n\n```\n","slug":"Java异常","published":1,"updated":"2021-09-10T07:04:21.943Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cktfeap3v0017c2xxqfubl8dt","content":"<h2 id=\"Java异常\"><a href=\"#Java异常\" class=\"headerlink\" title=\"Java异常\"></a>Java异常</h2><p><img src=\"https://upload-images.jianshu.io/upload_images/1534431-11903c56d9e318ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Java异常\"></p>\n<ul>\n<li>对比Exception和Error </li>\n<li>运行异常与一般异常区别</li>\n<li>ClassNotFoundException和NoClassDefFoundError有什么区别</li>\n<li>throw和throws</li>\n<li>异常处理几点建议</li>\n<li>自定义异常</li>\n</ul>\n<h3 id=\"对比Exception和Error。\"><a href=\"#对比Exception和Error。\" class=\"headerlink\" title=\"对比Exception和Error。\"></a>对比Exception和Error。</h3><p><img src=\"https://upload-images.jianshu.io/upload_images/1534431-ad557fa71b48a3ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Exception和Error\"><br>Exception和Error都继承Throwable,</p>\n<ul>\n<li>Exception是程序可以处理的异常，正常JVM运行外的异常。</li>\n<li>Error一般是JVM相关异常错误，不可恢复状态，也不方便捕获。<h3 id=\"运行异常与一般异常区别\"><a href=\"#运行异常与一般异常区别\" class=\"headerlink\" title=\"运行异常与一般异常区别\"></a>运行异常与一般异常区别</h3>Eeception又分为可检测异常（Checked Exception）和运行异常（也可叫不可检查异常，Runtime Exception）。</li>\n<li>可检查异常（Checked Exception）在代码里必须显式地进行捕获处理，可以被处理的异常。如：IOException。</li>\n<li>运行异常,类似NullPointerException,ArrayIndexOutOfBoundsException,通常是可以编码避免的逻辑错误，具体根据需要来判断是否需要捕获，并不会在编译器强制要求。<h3 id=\"ClassNotFoundException和NoClassDefFoundError有什么区别\"><a href=\"#ClassNotFoundException和NoClassDefFoundError有什么区别\" class=\"headerlink\" title=\"ClassNotFoundException和NoClassDefFoundError有什么区别\"></a>ClassNotFoundException和NoClassDefFoundError有什么区别</h3></li>\n<li>ClassNotFoundException:Java动态加载类的时候，如果这个类在类路径中没有被找到或者当一个类已经某个类加载器加载到内存中了，此时另一个类加载器又尝试着动态地从同一个包中加载这个类就会抛出ClassNotFoundException异常。类加载中加载时从外存储器找不到需要的class。</li>\n<li>NoClassDefFoudError，指要查找的类在编译的时候是存在的，运行的时候却找不到的异常错误。类加载中连接时从内存找不到需要的class。</li>\n</ul>\n<h3 id=\"throw和throws\"><a href=\"#throw和throws\" class=\"headerlink\" title=\"throw和throws\"></a>throw和throws</h3><pre><code>public void custormException()throws  CustomException{\nthrow new CustomException(&quot;抛出CustormException&quot;);\n}\n</code></pre><ul>\n<li>throw作用域方法体内</li>\n<li>throws方法名后面<h3 id=\"异常处理几点建议\"><a href=\"#异常处理几点建议\" class=\"headerlink\" title=\"异常处理几点建议\"></a>异常处理几点建议</h3></li>\n<li>只针对不正常的情况才使用异常,不需要异常处理的不要专门处理以增加系统额外检查降低性能。<pre><code>try {\nint i=0;\nwhile (true) {\narr[i]=0;\ni++;\n}\n} catch (IndexOutOfBoundsException e) {\n}\n</code></pre></li>\n<li>抛出的异常要适合于相应的抽象<pre><code>public E get(int index) {\ntry {\nreturn listIterator(index).next();\n} catch (NoSuchElementException exc) {\nthrow new IndexOutOfBoundsException(&quot;Index: &quot;+index);\n}\n}\n</code></pre></li>\n<li>不要忽略异常，避免使用空的catch语句<pre><code>try {\n...\n} catch (SomeException e) {\n}\n</code></pre></li>\n<li>异常保证输出堆栈信息，在异常消息中加入导致异常发生的全部信息<pre><code>try {\n...\n} catch (SomeException e) {\nSystem.out.println(&quot;12344&quot;);\n}\n</code></pre><h3 id=\"自定义异常\"><a href=\"#自定义异常\" class=\"headerlink\" title=\"自定义异常\"></a>自定义异常</h3>一般根据项目需要自定义异常，特别是服务端处理业务的时候。一般自定义异常继承Exception，Throwable（因为Error一般用于JVM的异常错误，不常用自定义），因为异常已实现相关方法，只需重写构造方法就可以。代码如下：</li>\n<li>继承Exception<br>```<br>public class CustomException extends Exception {<br>public CustomException() {<br>}</li>\n</ul>\n<p>public CustomException(String message) {<br>super(message);<br>}</p>\n<p>public CustomException(String message, Throwable cause) {<br>super(message, cause);<br>}</p>\n<p>public CustomException(Throwable cause) {<br>super(cause);<br>}</p>\n<p>public CustomException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {<br>super(message, cause, enableSuppression, writableStackTrace);<br>}<br>}</p>\n<pre><code>\n</code></pre><p>public class TestException {<br>public void testMethod(){<br>try {<br>custormException();<br>} catch (CustomException e) {<br>e.printStackTrace();<br>}<br>}<br>public void custormException()throws  CustomException{<br>throw new CustomException(“抛出CustormException”);<br>}<br>public static void main(String[] args) {<br>TestException testException=new TestException();<br>testException.testMethod();<br>}<br>}</p>\n<pre><code>输出\n</code></pre><p>com.mysiga.learn.throwable.CustomException: 抛出CustormException<br>at com.mysiga.learn.throwable.TestException.custormException(TestException.java:15)<br>at com.mysiga.learn.throwable.TestException.testMethod(TestException.java:9)<br>at com.mysiga.learn.throwable.TestException.main(TestException.java:19)</p>\n<pre><code>-  继承Throwable\n</code></pre><p>public class CustomThrowable extends Throwable {<br>public CustomThrowable() {<br>}</p>\n<p>public CustomThrowable(String message) {<br>super(message);<br>}</p>\n<p>public CustomThrowable(String message, Throwable cause) {<br>super(message, cause);<br>}</p>\n<p>public CustomThrowable(Throwable cause) {<br>super(cause);<br>}</p>\n<p>public CustomThrowable(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {<br>super(message, cause, enableSuppression, writableStackTrace);<br>}<br>}</p>\n<pre><code>\n</code></pre><p>public class TestThrowable {<br>public void testMethod(){<br>try {<br>custormException();<br>} catch (CustomThrowable e) {<br>e.printStackTrace();<br>}<br>}<br>public void custormException()throws  CustomThrowable{<br>throw new CustomThrowable(“抛出CustomThrowable”);<br>}<br>public static void main(String[] args) {<br>TestThrowable testThrowable=new TestThrowable();<br>testThrowable.testMethod();<br>}<br>}</p>\n<pre><code>输出\n</code></pre><p>com.mysiga.learn.throwable.CustomThrowable: 抛出CustomThrowable<br>at com.mysiga.learn.throwable.TestThrowable.custormException(TestThrowable.java:15)<br>at com.mysiga.learn.throwable.TestThrowable.testMethod(TestThrowable.java:9)<br>at com.mysiga.learn.throwable.TestThrowable.main(TestThrowable.java:19)</p>\n<p>```</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Java异常\"><a href=\"#Java异常\" class=\"headerlink\" title=\"Java异常\"></a>Java异常</h2><p><img src=\"https://upload-images.jianshu.io/upload_images/1534431-11903c56d9e318ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Java异常\"></p>\n<ul>\n<li>对比Exception和Error </li>\n<li>运行异常与一般异常区别</li>\n<li>ClassNotFoundException和NoClassDefFoundError有什么区别</li>\n<li>throw和throws</li>\n<li>异常处理几点建议</li>\n<li>自定义异常</li>\n</ul>\n<h3 id=\"对比Exception和Error。\"><a href=\"#对比Exception和Error。\" class=\"headerlink\" title=\"对比Exception和Error。\"></a>对比Exception和Error。</h3><p><img src=\"https://upload-images.jianshu.io/upload_images/1534431-ad557fa71b48a3ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Exception和Error\"><br>Exception和Error都继承Throwable,</p>\n<ul>\n<li>Exception是程序可以处理的异常，正常JVM运行外的异常。</li>\n<li>Error一般是JVM相关异常错误，不可恢复状态，也不方便捕获。<h3 id=\"运行异常与一般异常区别\"><a href=\"#运行异常与一般异常区别\" class=\"headerlink\" title=\"运行异常与一般异常区别\"></a>运行异常与一般异常区别</h3>Eeception又分为可检测异常（Checked Exception）和运行异常（也可叫不可检查异常，Runtime Exception）。</li>\n<li>可检查异常（Checked Exception）在代码里必须显式地进行捕获处理，可以被处理的异常。如：IOException。</li>\n<li>运行异常,类似NullPointerException,ArrayIndexOutOfBoundsException,通常是可以编码避免的逻辑错误，具体根据需要来判断是否需要捕获，并不会在编译器强制要求。<h3 id=\"ClassNotFoundException和NoClassDefFoundError有什么区别\"><a href=\"#ClassNotFoundException和NoClassDefFoundError有什么区别\" class=\"headerlink\" title=\"ClassNotFoundException和NoClassDefFoundError有什么区别\"></a>ClassNotFoundException和NoClassDefFoundError有什么区别</h3></li>\n<li>ClassNotFoundException:Java动态加载类的时候，如果这个类在类路径中没有被找到或者当一个类已经某个类加载器加载到内存中了，此时另一个类加载器又尝试着动态地从同一个包中加载这个类就会抛出ClassNotFoundException异常。类加载中加载时从外存储器找不到需要的class。</li>\n<li>NoClassDefFoudError，指要查找的类在编译的时候是存在的，运行的时候却找不到的异常错误。类加载中连接时从内存找不到需要的class。</li>\n</ul>\n<h3 id=\"throw和throws\"><a href=\"#throw和throws\" class=\"headerlink\" title=\"throw和throws\"></a>throw和throws</h3><pre><code>public void custormException()throws  CustomException{\nthrow new CustomException(&quot;抛出CustormException&quot;);\n}\n</code></pre><ul>\n<li>throw作用域方法体内</li>\n<li>throws方法名后面<h3 id=\"异常处理几点建议\"><a href=\"#异常处理几点建议\" class=\"headerlink\" title=\"异常处理几点建议\"></a>异常处理几点建议</h3></li>\n<li>只针对不正常的情况才使用异常,不需要异常处理的不要专门处理以增加系统额外检查降低性能。<pre><code>try {\nint i=0;\nwhile (true) {\narr[i]=0;\ni++;\n}\n} catch (IndexOutOfBoundsException e) {\n}\n</code></pre></li>\n<li>抛出的异常要适合于相应的抽象<pre><code>public E get(int index) {\ntry {\nreturn listIterator(index).next();\n} catch (NoSuchElementException exc) {\nthrow new IndexOutOfBoundsException(&quot;Index: &quot;+index);\n}\n}\n</code></pre></li>\n<li>不要忽略异常，避免使用空的catch语句<pre><code>try {\n...\n} catch (SomeException e) {\n}\n</code></pre></li>\n<li>异常保证输出堆栈信息，在异常消息中加入导致异常发生的全部信息<pre><code>try {\n...\n} catch (SomeException e) {\nSystem.out.println(&quot;12344&quot;);\n}\n</code></pre><h3 id=\"自定义异常\"><a href=\"#自定义异常\" class=\"headerlink\" title=\"自定义异常\"></a>自定义异常</h3>一般根据项目需要自定义异常，特别是服务端处理业务的时候。一般自定义异常继承Exception，Throwable（因为Error一般用于JVM的异常错误，不常用自定义），因为异常已实现相关方法，只需重写构造方法就可以。代码如下：</li>\n<li>继承Exception<br>```<br>public class CustomException extends Exception {<br>public CustomException() {<br>}</li>\n</ul>\n<p>public CustomException(String message) {<br>super(message);<br>}</p>\n<p>public CustomException(String message, Throwable cause) {<br>super(message, cause);<br>}</p>\n<p>public CustomException(Throwable cause) {<br>super(cause);<br>}</p>\n<p>public CustomException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {<br>super(message, cause, enableSuppression, writableStackTrace);<br>}<br>}</p>\n<pre><code>\n</code></pre><p>public class TestException {<br>public void testMethod(){<br>try {<br>custormException();<br>} catch (CustomException e) {<br>e.printStackTrace();<br>}<br>}<br>public void custormException()throws  CustomException{<br>throw new CustomException(“抛出CustormException”);<br>}<br>public static void main(String[] args) {<br>TestException testException=new TestException();<br>testException.testMethod();<br>}<br>}</p>\n<pre><code>输出\n</code></pre><p>com.mysiga.learn.throwable.CustomException: 抛出CustormException<br>at com.mysiga.learn.throwable.TestException.custormException(TestException.java:15)<br>at com.mysiga.learn.throwable.TestException.testMethod(TestException.java:9)<br>at com.mysiga.learn.throwable.TestException.main(TestException.java:19)</p>\n<pre><code>-  继承Throwable\n</code></pre><p>public class CustomThrowable extends Throwable {<br>public CustomThrowable() {<br>}</p>\n<p>public CustomThrowable(String message) {<br>super(message);<br>}</p>\n<p>public CustomThrowable(String message, Throwable cause) {<br>super(message, cause);<br>}</p>\n<p>public CustomThrowable(Throwable cause) {<br>super(cause);<br>}</p>\n<p>public CustomThrowable(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {<br>super(message, cause, enableSuppression, writableStackTrace);<br>}<br>}</p>\n<pre><code>\n</code></pre><p>public class TestThrowable {<br>public void testMethod(){<br>try {<br>custormException();<br>} catch (CustomThrowable e) {<br>e.printStackTrace();<br>}<br>}<br>public void custormException()throws  CustomThrowable{<br>throw new CustomThrowable(“抛出CustomThrowable”);<br>}<br>public static void main(String[] args) {<br>TestThrowable testThrowable=new TestThrowable();<br>testThrowable.testMethod();<br>}<br>}</p>\n<pre><code>输出\n</code></pre><p>com.mysiga.learn.throwable.CustomThrowable: 抛出CustomThrowable<br>at com.mysiga.learn.throwable.TestThrowable.custormException(TestThrowable.java:15)<br>at com.mysiga.learn.throwable.TestThrowable.testMethod(TestThrowable.java:9)<br>at com.mysiga.learn.throwable.TestThrowable.main(TestThrowable.java:19)</p>\n<p>```</p>\n"},{"title":"Java类初始化顺序","date":"2016-06-30T09:29:29.000Z","_content":"\n- Print.java\n````\npublic class Print {\n public Print (String print) {\n  System.out.println(print);\n }\n}\n````\n- Person.java\n````\npublic class Person {\n\n private static Print printLog = new Print(\"父类静态实例1-->\");\n private Print log = new Print(\"父类实例-->\");\n static {\n  Print printLog = new Print(\"父类静态块-->\");\n }\n private static Print print = new Print(\"父类静态实例2-->\");\n public Person(){\n  new Print(\"父类构造方法-->\");\n }\n \n public static void print() {\n  Print printLog = new Print(\"父类静态方法-->\");\n }\n private static Print printLog3 = new Print(\"父类静态实例3-->\");\n}\n````\n- Child.java\n````\npublic class Child extends Person {\n\n private static Print printLog = new Print(\"子类静态实例1-->\");\n private Print log = new Print(\"子类实例-->\");\n static {\n  Print printLog = new Print(\"子类静态块-->\");\n }\n private static Print print = new Print(\"子类静态实例2-->\");\n\n public Child() {\n  new Print(\"子类构造方法-->\");\n }\n\n public static void print() {\n  Print printLog = new Print(\"子类静态方法-->\");\n }\n\n private static Print printLog3 = new Print(\"子类静态实例3-->\");\n\n public static void main(String[] args) {\n  new Child();\n }\n}\n````\n- 输出结果\n````\n父类静态实例1-->\n父类静态块-->\n父类静态实例2-->\n父类静态实例3-->\n子类静态实例1-->\n子类静态块-->\n子类静态实例2-->\n子类静态实例3-->\n父类实例-->\n父类构造方法-->\n子类实例-->\n子类构造方法-->\n````\n->很显然，子类初始化的过程：\n  - 父类静态实例或者父类静态代码块，代码的放置先后顺序，决定它们执行先后\n - 子类静态实例或者子类静态代码块\n - 父类实例\n - 父类构造方法\n - 子类实例\n - 子类构造方法\n- 那为什么了？后面研究下再跟进","source":"_posts/Java类初始化顺序.md","raw":"title: Java类初始化顺序\ndate: 2016-06-30 09:29:29\ntags:\ncategories: Java\n---\n\n- Print.java\n````\npublic class Print {\n public Print (String print) {\n  System.out.println(print);\n }\n}\n````\n- Person.java\n````\npublic class Person {\n\n private static Print printLog = new Print(\"父类静态实例1-->\");\n private Print log = new Print(\"父类实例-->\");\n static {\n  Print printLog = new Print(\"父类静态块-->\");\n }\n private static Print print = new Print(\"父类静态实例2-->\");\n public Person(){\n  new Print(\"父类构造方法-->\");\n }\n \n public static void print() {\n  Print printLog = new Print(\"父类静态方法-->\");\n }\n private static Print printLog3 = new Print(\"父类静态实例3-->\");\n}\n````\n- Child.java\n````\npublic class Child extends Person {\n\n private static Print printLog = new Print(\"子类静态实例1-->\");\n private Print log = new Print(\"子类实例-->\");\n static {\n  Print printLog = new Print(\"子类静态块-->\");\n }\n private static Print print = new Print(\"子类静态实例2-->\");\n\n public Child() {\n  new Print(\"子类构造方法-->\");\n }\n\n public static void print() {\n  Print printLog = new Print(\"子类静态方法-->\");\n }\n\n private static Print printLog3 = new Print(\"子类静态实例3-->\");\n\n public static void main(String[] args) {\n  new Child();\n }\n}\n````\n- 输出结果\n````\n父类静态实例1-->\n父类静态块-->\n父类静态实例2-->\n父类静态实例3-->\n子类静态实例1-->\n子类静态块-->\n子类静态实例2-->\n子类静态实例3-->\n父类实例-->\n父类构造方法-->\n子类实例-->\n子类构造方法-->\n````\n->很显然，子类初始化的过程：\n  - 父类静态实例或者父类静态代码块，代码的放置先后顺序，决定它们执行先后\n - 子类静态实例或者子类静态代码块\n - 父类实例\n - 父类构造方法\n - 子类实例\n - 子类构造方法\n- 那为什么了？后面研究下再跟进","slug":"Java类初始化顺序","published":1,"updated":"2021-09-10T07:04:21.943Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cktfeap3w0019c2xxcs5i9c2s","content":"<ul>\n<li>Print.java<pre><code>public class Print {\npublic Print (String print) {\nSystem.out.println(print);\n}\n}\n</code></pre></li>\n<li><p>Person.java</p>\n<pre><code>public class Person {\n\nprivate static Print printLog = new Print(&quot;父类静态实例1--&gt;&quot;);\nprivate Print log = new Print(&quot;父类实例--&gt;&quot;);\nstatic {\nPrint printLog = new Print(&quot;父类静态块--&gt;&quot;);\n}\nprivate static Print print = new Print(&quot;父类静态实例2--&gt;&quot;);\npublic Person(){\nnew Print(&quot;父类构造方法--&gt;&quot;);\n}\n\npublic static void print() {\nPrint printLog = new Print(&quot;父类静态方法--&gt;&quot;);\n}\nprivate static Print printLog3 = new Print(&quot;父类静态实例3--&gt;&quot;);\n}\n</code></pre></li>\n<li><p>Child.java</p>\n<pre><code>public class Child extends Person {\n\nprivate static Print printLog = new Print(&quot;子类静态实例1--&gt;&quot;);\nprivate Print log = new Print(&quot;子类实例--&gt;&quot;);\nstatic {\nPrint printLog = new Print(&quot;子类静态块--&gt;&quot;);\n}\nprivate static Print print = new Print(&quot;子类静态实例2--&gt;&quot;);\n\npublic Child() {\nnew Print(&quot;子类构造方法--&gt;&quot;);\n}\n\npublic static void print() {\nPrint printLog = new Print(&quot;子类静态方法--&gt;&quot;);\n}\n\nprivate static Print printLog3 = new Print(&quot;子类静态实例3--&gt;&quot;);\n\npublic static void main(String[] args) {\nnew Child();\n}\n}\n</code></pre></li>\n<li>输出结果<pre><code>父类静态实例1--&gt;\n父类静态块--&gt;\n父类静态实例2--&gt;\n父类静态实例3--&gt;\n子类静态实例1--&gt;\n子类静态块--&gt;\n子类静态实例2--&gt;\n子类静态实例3--&gt;\n父类实例--&gt;\n父类构造方法--&gt;\n子类实例--&gt;\n子类构造方法--&gt;\n</code></pre>-&gt;很显然，子类初始化的过程：<ul>\n<li>父类静态实例或者父类静态代码块，代码的放置先后顺序，决定它们执行先后</li>\n<li>子类静态实例或者子类静态代码块</li>\n<li>父类实例</li>\n<li>父类构造方法</li>\n<li>子类实例</li>\n<li>子类构造方法</li>\n</ul>\n</li>\n<li>那为什么了？后面研究下再跟进</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>Print.java<pre><code>public class Print {\npublic Print (String print) {\nSystem.out.println(print);\n}\n}\n</code></pre></li>\n<li><p>Person.java</p>\n<pre><code>public class Person {\n\nprivate static Print printLog = new Print(&quot;父类静态实例1--&gt;&quot;);\nprivate Print log = new Print(&quot;父类实例--&gt;&quot;);\nstatic {\nPrint printLog = new Print(&quot;父类静态块--&gt;&quot;);\n}\nprivate static Print print = new Print(&quot;父类静态实例2--&gt;&quot;);\npublic Person(){\nnew Print(&quot;父类构造方法--&gt;&quot;);\n}\n\npublic static void print() {\nPrint printLog = new Print(&quot;父类静态方法--&gt;&quot;);\n}\nprivate static Print printLog3 = new Print(&quot;父类静态实例3--&gt;&quot;);\n}\n</code></pre></li>\n<li><p>Child.java</p>\n<pre><code>public class Child extends Person {\n\nprivate static Print printLog = new Print(&quot;子类静态实例1--&gt;&quot;);\nprivate Print log = new Print(&quot;子类实例--&gt;&quot;);\nstatic {\nPrint printLog = new Print(&quot;子类静态块--&gt;&quot;);\n}\nprivate static Print print = new Print(&quot;子类静态实例2--&gt;&quot;);\n\npublic Child() {\nnew Print(&quot;子类构造方法--&gt;&quot;);\n}\n\npublic static void print() {\nPrint printLog = new Print(&quot;子类静态方法--&gt;&quot;);\n}\n\nprivate static Print printLog3 = new Print(&quot;子类静态实例3--&gt;&quot;);\n\npublic static void main(String[] args) {\nnew Child();\n}\n}\n</code></pre></li>\n<li>输出结果<pre><code>父类静态实例1--&gt;\n父类静态块--&gt;\n父类静态实例2--&gt;\n父类静态实例3--&gt;\n子类静态实例1--&gt;\n子类静态块--&gt;\n子类静态实例2--&gt;\n子类静态实例3--&gt;\n父类实例--&gt;\n父类构造方法--&gt;\n子类实例--&gt;\n子类构造方法--&gt;\n</code></pre>-&gt;很显然，子类初始化的过程：<ul>\n<li>父类静态实例或者父类静态代码块，代码的放置先后顺序，决定它们执行先后</li>\n<li>子类静态实例或者子类静态代码块</li>\n<li>父类实例</li>\n<li>父类构造方法</li>\n<li>子类实例</li>\n<li>子类构造方法</li>\n</ul>\n</li>\n<li>那为什么了？后面研究下再跟进</li>\n</ul>\n"},{"title":"深入Java线程","date":"2018-08-02T18:30:00.000Z","_content":"\n\n线程是系统调度的最小单元，一个进程可以包含多个线程，作为任务的真正运作者，有自己的栈（Stack）、寄存器（Register）、本地存储（Thread Local）等，但是会和进程内其他线程共享文件描述符、虚拟地址空间等。在具体实现中，线程还分为内核线程、用户线程，Java 的线程实现其实是与虚拟机相关的。\n### 创建线程方式\n  - 继承Thread\n  \n```\npublic class ThreadImpl extends Thread {   \n}\n```\n  - 实现Runable\n  \n```\npublic class MyThread implements Runnable {\n    private int ticket;\n    private Lock lock = new ReentrantLock();\n\n    public MyThread(int ticket) {\n        this.ticket = ticket;\n    }\n\n    @Override\n    public void run() {\n        print();\n    }\n\n    public void print() {\n        lock.lock();\n        try {\n            while (ticket > 0) {\n                System.out.println(\"ticket==\" + ticket);\n                ticket--;\n            }\n        } catch (Exception e) {\n            System.out.println(\"Exception==\" + e);\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public static void main(String[] args) {\n        MyThread myThread = new MyThread(5);\n        new Thread(myThread).start();\n        new Thread(myThread).start();\n    }\n}\n```\n  - 实现Callable，运行完成后可返回值。\n  \n```\npublic class CallTask implements Callable {\n    private int upperBounds;\n\n    public CallTask(int upperBounds) {\n        this.upperBounds = upperBounds;\n    }\n\n    @Override\n    public Integer call() throws Exception {\n        int sum = 0;\n        for (int i = 1; i <= upperBounds; i++) {\n            sum += i;\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        ExecutorService service = Executors.newFixedThreadPool(10);\n        try {\n            int sum = (int) service.submit(new CallTask((int) (Math.random() * 100))).get();\n            System.out.println(\"sum==\" + sum);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } catch (ExecutionException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n### 常用锁处理\n  - [synchronized](https://www.jianshu.com/p/d53bf830fa09)  \n  \n```\npublic class LockThread implements Runnable {    \n  private Integer key = 0;      \n  @Override    \n  public void run() {       \n     synchronized (this) {    \n        key++;          \n     System.out.println(Thread.currentThread().getName() + \":\" + key);    \n    try {        \n        Thread.sleep(5);   \n       } catch (InterruptedException e) {        \n        e.printStackTrace();    }\n      }\n   }    \npublic static void main(String[] args) {       \n LockThread lockThread = new LockThread();       \n for (int i = 0; i < 100; i++) {\n        new Thread(lockThread, \"thread\" + i).start();        \n    }    \n   }\n}\n```\n  - lock\n  \n```\npublic class LockThread implements Runnable {    \n  private Integer key = 0;    \n  private Lock lock = new ReentrantLock();    \n  @Override    \n  public void run() {       \n     lock.lock();  //获取锁     \n       try {           \n           key++;                \n          System.out.println(Thread.currentThread().getName() + \":\" + key);            \n          Thread.sleep(5);       \n          } catch (Exception e) {        \n        } finally {            \n        lock.unlock();  //释放锁     \n       }    \n     }    \npublic static void main(String[] args) {       \n LockThread lockThread = new LockThread();       \n for (int i = 0; i < 100; i++) {            \n       new Thread(lockThread, \"thread\" + i).start();        \n      }    \n     }\n}\n```\n  - volatile\n  \n### volatile和synchronized的区别\n\n| | volatile | synchronized  | \n| ----- | ----- | ----- | \n| 作用域 | 变量 | 方法，代码块 | \n| 操作性| 仅保证可见性| 可以保证可见性和原子性  | \n| 线程堵塞状态| 不会造成线程的阻塞| 可能会造成线程的阻塞  | \n\n### Lock和synchronized的区别\n| | Lock | synchronized  | \n| ----- | ----- | ----- | \n| 使用区别 | 类 | 关键字  | \n| 作用域| 代码块| 代码块，方法 | \n| 释放锁| 需要finally()方法手动释放锁| 执行完自动释放锁  | \n| 锁类型| 可重入,可判断,可公平（两者皆可）|可重入,不可中断,非公平| \n| 依托实现| Java代码控制| JVM执行 | \n|性能|高竞争场景中表现可能优于synchronized|在低竞争场景中表现可能优于 ReentrantLock|\n### sleep()和wait()的区别\n| | sleep | wait  | \n| ----- | ----- | ----- | \n|| 睡眠时，保持对象锁，仍然占有该锁 | 睡眠时，释放对象锁  | \n| 作用域| 任何地方调用 | 只能在同步方法或同步块中使用| \n| 时间| 指定时间后唤醒 | 只有等notify()/notifyAll()通知有才能唤醒| \n\n### 并发高效类\n实际开发中Java封装了一些解决高并发的类包（java.util.concurrent包），常用的如下：\n\n- AtomicInteger：提供一种线程安全的加减操作\n- AtomicBoolean\n- AtomicLong\n- AtomicReference\n- AtomicIntegerArray\n- AtomicLongArray\n- AtomicReferenceArray\n\n### 线程生命周期\n![线程生命周期](https://upload-images.jianshu.io/upload_images/1534431-8837ea32b7cd19b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n关于线程生命周期的不同状态，在 Java 5 以后，线程状态被明确定义在其公共内部枚举类型 java.lang.Thread.State 中，分别是：\n\n- 新建（NEW），表示线程被创建出来还没真正启动的状态，可以认为它是个 Java 内部状态。\n- 就绪（RUNNABLE），表示该线程已经在 JVM 中执行，当然由于执行需要计算资源，它可能是正在运行，也可能还在等待系统分配给它 CPU 片段，在就绪队列里面排队。\n在其他一些分析中，会额外区分一种状态 RUNNING，但是从 Java API 的角度，并不能表示出来。\n- 阻塞（BLOCKED），这个状态和我们前面两讲介绍的同步非常相关，阻塞表示线程在等待 Monitor lock。比如，线程试图通过 synchronized 去获取某个锁，但是其他线程已经独占了，那么当前线程就会处于阻塞状态。如：sleep()\n- 等待（WAITING），表示正在等待其他线程采取某些操作。一个常见的场景是类似生产者消费者模式，发现任务条件尚未满足，就让当前消费者线程等待（wait），另外的生产者线程去准备任务数据，然后通过类似 notify 等动作，通知消费线程可以继续工作了。Thread.join() 也会令线程进入等待状态。\n- 计时等待（TIMED_WAIT），其进入条件和等待状态类似，但是调用的是存在超时条件的方法，比如 wait 或 join 等方法的指定超时版本，如下面示例：\n\n```\npublic final native void wait(long timeout) throws InterruptedException;\n```\n- 终止（TERMINATED），不管是意外退出还是正常执行结束，线程已经完成使命，终止运行，也有人把这个状态叫作死亡。\n在第二次调用 start() 方法的时候，线程可能处于终止或者其他（非 NEW）状态，但是不论如何，都是不可以再次启动的。\n\n### 线程安全基本特性\n  - 原子性：简单说就是相关操作不会中途被其他线程干扰，一般通过同步机制实现\n  - 可见性:是一个线程修改了某个共享变量，其状态能够立即被其他线程知晓，通常被解释为将线程本地状态反映到主内存上，volatile就是负责保证可见性的。\n - 有序性，是保证线程内串行语义，避免指令重排等\n\n### Monitor 实现的三种锁：\n所谓锁的升级、降级，就是 JVM 优化 synchronized 运行的机制，当 JVM 检测到不同的竞争状况时，会自动切换到适合的锁实现，这种切换就是锁的升级、降级。\n\n- 偏斜锁（Biased Locking）\n当没有竞争出现时，默认会使用偏斜锁。JVM 会利用 CAS 操作（compare and swap），在对象头上的 Mark Word 部分设置线程 ID，以表示这个对象偏向于当前线程，所以并不涉及真正的互斥锁。这样做的假设是基于在很多应用场景中，大部分对象生命周期中最多会被一个线程锁定，使用偏斜锁可以降低无竞争开销。\n- 轻量级锁\n如果有另外的线程试图锁定某个已经被偏斜过的对象，JVM 就需要撤销（revoke）偏斜锁，并切换到轻量级锁实现。\n- 重量级锁\n轻量级锁依赖 CAS 操作 Mark Word 来试图获取锁，如果重试成功，就使用普通的轻量级锁；否则，进一步升级为重量级锁。\n\n我注意到有的观点认为 Java 不会进行锁降级。实际上据我所知，锁降级确实是会发生的，当 JVM 进入安全点（SafePoint）的时候，会检查是否有闲置的 Monitor，然后试图进行降级\n![image.png](https://upload-images.jianshu.io/upload_images/1534431-1816e7d12c4ed6c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n- 可重入锁：它是表示当一个线程试图获取一个它已经获取的锁时,这个获取动作就自动成功。\nReentrantLock和synchronized，\n\n```\npublic class RepeLock implements Runnable {\n    private Lock lock = new ReentrantLock();\n    public void get() {\n        try {\n            lock.lock();\n            System.out.println(Thread.currentThread().getId());\n            set();\n        } finally {\n            lock.unlock();\n        }\n    }\n    public void set() {\n        try {\n            lock.lock();\n            System.out.println(Thread.currentThread().getId());\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    @Override\n    public void run() {\n        get();\n    }\n    public static void main(String[] args) {\n        RepeLock repeLock = new RepeLock();\n        new Thread(repeLock).start();\n        new Thread(repeLock).start();\n        new Thread(repeLock).start();\n    }\n}\n```\n- 锁膨胀：\n- 自旋锁：\n线程去拿锁时发现已经有线程拿了锁，然后让线程去执行一个无意义的循环，循环结束后再去重新竞争锁，如果竞争不到继续循环，循环过程中线程会一直处于running状态，但是基于JVM的线程调度，会出让时间片，所以其他线程依旧有申请锁和释放锁的机会。自旋锁省去了阻塞锁的时间空间（队列的维护等）开销，但是长时间自旋就变成了“忙式等待”，忙式等待显然还不如阻塞锁。所以自旋的次数一般控制在一个范围内，例如10,100等，在超出这个范围后，自旋锁会升级为阻塞锁。\n- [指令重排](https://www.cnblogs.com/chenyangyao/p/5269622.html)\n\n### [线程池](https://mp.weixin.qq.com/s/eyFVplFcZoN6-4WTMojtMw)\nExecutors 目前提供了 5 种不同的线程池创建配置：\n\n- newCachedThreadPool()，它是一种用来处理大量短时间工作任务的线程池，具有几个鲜明特点：它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程；如果线程闲置的时间超过 60 秒，则被终止并移出缓存；长时间闲置时，这种线程池，不会消耗什么资源。其内部使用 SynchronousQueue 作为工作队列。\n- newFixedThreadPool(int nThreads)，重用指定数目（nThreads）的线程，其背后使用的是无界的工作队列，任何时候最多有 nThreads 个工作线程是活动的。这意味着，如果任务数量超过了活动队列数目，将在工作队列中等待空闲线程出现；如果有工作线程退出，将会有新的工作线程被创建，以补足指定的数目 nThreads。\n- newSingleThreadExecutor()，它的特点在于工作线程数目被限制为 1，操作一个无界的工作队列，所以它保证了所有任务的都是被顺序执行，最多会有一个任务处于活动状态，并且不允许使用者改动线程池实例，因此可以避免其改变线程数目。\n- newSingleThreadScheduledExecutor() 和 newScheduledThreadPool(int corePoolSize)，创建的是个 ScheduledExecutorService，可以进行定时或周期性的工作调度，区别在于单一工作线程还是多个工作线程。\n- newWorkStealingPool(int parallelism)，这是一个经常被人忽略的线程池，Java 8 才加入这个创建方法，其内部会构建ForkJoinPool，利用Work-Stealing算法，并行地处理任务，不保证处理顺序。\n\n线程池构造方法几个参数\n\n```\npublic ThreadPoolExecutor(int corePoolSize,\n                              int maximumPoolSize,\n                              long keepAliveTime,\n                              TimeUnit unit,\n                              BlockingQueue<Runnable> workQueue,\n                              ThreadFactory threadFactory,\n                              RejectedExecutionHandler handler) {\n```\n1. corePoolSize : 该线程池中核心线程数最大值\n核心线程：线程池新建线程的时候，如果当前线程总数小于 corePoolSize ，则新建的是核心线程；如果超过corePoolSize，则新建的是非核心线程。核心线程默认情况下会一直存活在线程池中，即使这个核心线程啥也不干(闲置状态)。如果指定ThreadPoolExecutor的 allowCoreThreadTimeOut 这个属性为true，那么核心线程如果不干活(闲置状态)的话，超过一定时间( keepAliveTime)，就会被销毁掉.\n2. maximumPoolSize ：该线程池中线程总数的最大值\n线程总数计算公式 = 核心线程数 + 非核心线程数。\n3. keepAliveTime  ：该线程池中非核心线程闲置超时时长\n注意：一个非核心线程，如果不干活(闲置状态)的时长，超过这个参数所设定的时长，就会被销毁掉。但是，如果设置了  allowCoreThreadTimeOut = true，则会作用于核心线程。\n4. unit ：（时间单位）\n首先，TimeUnit是一个枚举类型，翻译过来就是时间单位，我们最常用的时间单位包括：\nMILLISECONDS ： 1毫秒 、SECONDS ： 秒、MINUTES ： 分、HOURS ： 小时、DAYS ： 天\n5. BlockingQueue<Runnable> workQueue ：( Blocking：阻塞的，queue：队列)，主要有四种队列\n   -  SynchronousQueue：（同步队列）这个队列接收到任务的时候，会直接提交给线程处理，而不保留它（名字定义为 同步队列），所有该队列跟设置的corePoolSize无效。但有一种情况，假设所有线程都在工作怎么办？这种情况下，SynchronousQueue就会新建一个线程来处理这个任务。所以为了保证不出现（线程数达到了maximumPoolSize而不能新建线程）的错误，使用这个类型队列的时候，maximumPoolSize一般指定成Integer.MAX_VALUE，即无限大，去规避这个使用风险。\n    - LinkedBlockingQueue（链表阻塞队列）：这个队列接收到任务的时候，如果当前线程数小于核心线程数，则新建线程(核心线程)处理任务；如果当前线程数等于核心线程数，则进入队列等待。由于这个队列没有最大值限制，即所有超过核心线程数的任务都将被添加到队列中，这也就导致了maximumPoolSize的设定失效，因为总线程数永远不会超过corePoolSize\n    - ArrayBlockingQueue（数组阻塞队列）：可以限定队列的长度（既然是数组，那么就限定了大小），接收到任务的时候，如果没有达到corePoolSize的值，则新建线程(核心线程)执行任务，如果达到了，则入队等候，如果队列已满，则新建线程(非核心线程)执行任务，又如果总线程数到了maximumPoolSize，并且队列也满了，则发生错误\n    - DelayQueue（延迟队列）：队列内元素必须实现Delayed接口，这就意味着你传进去的任务必须先实现Delayed接口。这个队列接收到任务时，首先先入队，只有达到了指定的延时时间，才会执行任务\n6. ThreadFactory threadFactory = > 创建线程的方式，这是一个接口，new它的时候需要实现他的Thread newThread(Runnable r)方法\n7. RejectedExecutionHandler handler = > 这个主要是用来抛异常的\n当线程无法执行新任务时（一般是由于线程池中的线程数量已经达到最大数或者线程池关闭导致的），默认情况下，当线程池无法处理新线程时，会抛出一个RejectedExecutionException。\n\n以 LinkedBlockingQueue、ArrayBlockingQueue 和 SynchronousQueue 为例，我们一起来分析一下，根据需求可以从很多方面考量：\n\n### ArrayBlockingQueue ,LinkedBlockingQueue ,SynchronousQueue \n- 从空间利用角度，数组结构的 ArrayBlockingQueue 要比 LinkedBlockingQueue 紧凑，因为其不需要创建所谓节点，但是其初始分配阶段就需要一段连续的空间，所以初始内存需求更大。\n- 通用场景中，LinkedBlockingQueue 的吞吐量一般优于 ArrayBlockingQueue，因为它实现了更加细粒度的锁操作。\n- ArrayBlockingQueue 实现比较简单，性能更好预测，属于表现稳定的“选手”。\n- 如果我们需要实现的是两个线程之间接力性（handoff）的场景，按照专栏上一讲的例子，你可能会选择 CountDownLatch，但是SynchronousQueue也是完美符合这种场景的，而且线程间协调和数据传输统一起来，代码更加规范。\n- 可能令人意外的是，很多时候 SynchronousQueue 的性能表现，往往大大超过其他实现，尤其是在队列元素较小的场景。\n\n### 重点源码分享\nokhttp\n\n```\n public synchronized ExecutorService executorService() {\n    if (executorService == null) {\n      executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,\n          new SynchronousQueue<Runnable>(), Util.threadFactory(\"OkHttp Dispatcher\", false));\n    }\n    return executorService;\n  }\n```\n```\n synchronized void enqueue(AsyncCall call) {\n    if (runningAsyncCalls.size() < maxRequests && runningCallsForHost(call) < maxRequestsPerHost) {\n      runningAsyncCalls.add(call);\n      executorService().execute(call);\n    } else {\n      readyAsyncCalls.add(call);\n    }\n  }\n```\nAsyncTask\n\n```\n private static final BlockingQueue<Runnable> sPoolWorkQueue =\n            new LinkedBlockingQueue<Runnable>(128);\n    /**\n     * An {@link Executor} that can be used to execute tasks in parallel.\n     */\n    public static final Executor THREAD_POOL_EXECUTOR;\n    static {\n        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(\n                CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS,\n                sPoolWorkQueue, sThreadFactory);\n        threadPoolExecutor.allowCoreThreadTimeOut(true);\n        THREAD_POOL_EXECUTOR = threadPoolExecutor;\n    }\n```\n\n```\nprivate static class SerialExecutor implements Executor {\n        final ArrayDeque<Runnable> mTasks = new ArrayDeque<Runnable>();\n        Runnable mActive;\n\n        public synchronized void execute(final Runnable r) {\n            mTasks.offer(new Runnable() {\n                public void run() {\n                    try {\n                        r.run();\n                    } finally {\n                        scheduleNext();\n                    }\n                }\n            });\n            if (mActive == null) {\n                scheduleNext();\n            }\n        }\n\n        protected synchronized void scheduleNext() {\n            if ((mActive = mTasks.poll()) != null) {\n                THREAD_POOL_EXECUTOR.execute(mActive);\n            }\n        }\n    }\n```\n\n\n\n\n\n\n","source":"_posts/Java线程.md","raw":"title: 深入Java线程\ndate: 2018-08-02  18:30:00\ntags:\ncategories: Java\n---\n\n\n线程是系统调度的最小单元，一个进程可以包含多个线程，作为任务的真正运作者，有自己的栈（Stack）、寄存器（Register）、本地存储（Thread Local）等，但是会和进程内其他线程共享文件描述符、虚拟地址空间等。在具体实现中，线程还分为内核线程、用户线程，Java 的线程实现其实是与虚拟机相关的。\n### 创建线程方式\n  - 继承Thread\n  \n```\npublic class ThreadImpl extends Thread {   \n}\n```\n  - 实现Runable\n  \n```\npublic class MyThread implements Runnable {\n    private int ticket;\n    private Lock lock = new ReentrantLock();\n\n    public MyThread(int ticket) {\n        this.ticket = ticket;\n    }\n\n    @Override\n    public void run() {\n        print();\n    }\n\n    public void print() {\n        lock.lock();\n        try {\n            while (ticket > 0) {\n                System.out.println(\"ticket==\" + ticket);\n                ticket--;\n            }\n        } catch (Exception e) {\n            System.out.println(\"Exception==\" + e);\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public static void main(String[] args) {\n        MyThread myThread = new MyThread(5);\n        new Thread(myThread).start();\n        new Thread(myThread).start();\n    }\n}\n```\n  - 实现Callable，运行完成后可返回值。\n  \n```\npublic class CallTask implements Callable {\n    private int upperBounds;\n\n    public CallTask(int upperBounds) {\n        this.upperBounds = upperBounds;\n    }\n\n    @Override\n    public Integer call() throws Exception {\n        int sum = 0;\n        for (int i = 1; i <= upperBounds; i++) {\n            sum += i;\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        ExecutorService service = Executors.newFixedThreadPool(10);\n        try {\n            int sum = (int) service.submit(new CallTask((int) (Math.random() * 100))).get();\n            System.out.println(\"sum==\" + sum);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } catch (ExecutionException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n### 常用锁处理\n  - [synchronized](https://www.jianshu.com/p/d53bf830fa09)  \n  \n```\npublic class LockThread implements Runnable {    \n  private Integer key = 0;      \n  @Override    \n  public void run() {       \n     synchronized (this) {    \n        key++;          \n     System.out.println(Thread.currentThread().getName() + \":\" + key);    \n    try {        \n        Thread.sleep(5);   \n       } catch (InterruptedException e) {        \n        e.printStackTrace();    }\n      }\n   }    \npublic static void main(String[] args) {       \n LockThread lockThread = new LockThread();       \n for (int i = 0; i < 100; i++) {\n        new Thread(lockThread, \"thread\" + i).start();        \n    }    \n   }\n}\n```\n  - lock\n  \n```\npublic class LockThread implements Runnable {    \n  private Integer key = 0;    \n  private Lock lock = new ReentrantLock();    \n  @Override    \n  public void run() {       \n     lock.lock();  //获取锁     \n       try {           \n           key++;                \n          System.out.println(Thread.currentThread().getName() + \":\" + key);            \n          Thread.sleep(5);       \n          } catch (Exception e) {        \n        } finally {            \n        lock.unlock();  //释放锁     \n       }    \n     }    \npublic static void main(String[] args) {       \n LockThread lockThread = new LockThread();       \n for (int i = 0; i < 100; i++) {            \n       new Thread(lockThread, \"thread\" + i).start();        \n      }    \n     }\n}\n```\n  - volatile\n  \n### volatile和synchronized的区别\n\n| | volatile | synchronized  | \n| ----- | ----- | ----- | \n| 作用域 | 变量 | 方法，代码块 | \n| 操作性| 仅保证可见性| 可以保证可见性和原子性  | \n| 线程堵塞状态| 不会造成线程的阻塞| 可能会造成线程的阻塞  | \n\n### Lock和synchronized的区别\n| | Lock | synchronized  | \n| ----- | ----- | ----- | \n| 使用区别 | 类 | 关键字  | \n| 作用域| 代码块| 代码块，方法 | \n| 释放锁| 需要finally()方法手动释放锁| 执行完自动释放锁  | \n| 锁类型| 可重入,可判断,可公平（两者皆可）|可重入,不可中断,非公平| \n| 依托实现| Java代码控制| JVM执行 | \n|性能|高竞争场景中表现可能优于synchronized|在低竞争场景中表现可能优于 ReentrantLock|\n### sleep()和wait()的区别\n| | sleep | wait  | \n| ----- | ----- | ----- | \n|| 睡眠时，保持对象锁，仍然占有该锁 | 睡眠时，释放对象锁  | \n| 作用域| 任何地方调用 | 只能在同步方法或同步块中使用| \n| 时间| 指定时间后唤醒 | 只有等notify()/notifyAll()通知有才能唤醒| \n\n### 并发高效类\n实际开发中Java封装了一些解决高并发的类包（java.util.concurrent包），常用的如下：\n\n- AtomicInteger：提供一种线程安全的加减操作\n- AtomicBoolean\n- AtomicLong\n- AtomicReference\n- AtomicIntegerArray\n- AtomicLongArray\n- AtomicReferenceArray\n\n### 线程生命周期\n![线程生命周期](https://upload-images.jianshu.io/upload_images/1534431-8837ea32b7cd19b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n关于线程生命周期的不同状态，在 Java 5 以后，线程状态被明确定义在其公共内部枚举类型 java.lang.Thread.State 中，分别是：\n\n- 新建（NEW），表示线程被创建出来还没真正启动的状态，可以认为它是个 Java 内部状态。\n- 就绪（RUNNABLE），表示该线程已经在 JVM 中执行，当然由于执行需要计算资源，它可能是正在运行，也可能还在等待系统分配给它 CPU 片段，在就绪队列里面排队。\n在其他一些分析中，会额外区分一种状态 RUNNING，但是从 Java API 的角度，并不能表示出来。\n- 阻塞（BLOCKED），这个状态和我们前面两讲介绍的同步非常相关，阻塞表示线程在等待 Monitor lock。比如，线程试图通过 synchronized 去获取某个锁，但是其他线程已经独占了，那么当前线程就会处于阻塞状态。如：sleep()\n- 等待（WAITING），表示正在等待其他线程采取某些操作。一个常见的场景是类似生产者消费者模式，发现任务条件尚未满足，就让当前消费者线程等待（wait），另外的生产者线程去准备任务数据，然后通过类似 notify 等动作，通知消费线程可以继续工作了。Thread.join() 也会令线程进入等待状态。\n- 计时等待（TIMED_WAIT），其进入条件和等待状态类似，但是调用的是存在超时条件的方法，比如 wait 或 join 等方法的指定超时版本，如下面示例：\n\n```\npublic final native void wait(long timeout) throws InterruptedException;\n```\n- 终止（TERMINATED），不管是意外退出还是正常执行结束，线程已经完成使命，终止运行，也有人把这个状态叫作死亡。\n在第二次调用 start() 方法的时候，线程可能处于终止或者其他（非 NEW）状态，但是不论如何，都是不可以再次启动的。\n\n### 线程安全基本特性\n  - 原子性：简单说就是相关操作不会中途被其他线程干扰，一般通过同步机制实现\n  - 可见性:是一个线程修改了某个共享变量，其状态能够立即被其他线程知晓，通常被解释为将线程本地状态反映到主内存上，volatile就是负责保证可见性的。\n - 有序性，是保证线程内串行语义，避免指令重排等\n\n### Monitor 实现的三种锁：\n所谓锁的升级、降级，就是 JVM 优化 synchronized 运行的机制，当 JVM 检测到不同的竞争状况时，会自动切换到适合的锁实现，这种切换就是锁的升级、降级。\n\n- 偏斜锁（Biased Locking）\n当没有竞争出现时，默认会使用偏斜锁。JVM 会利用 CAS 操作（compare and swap），在对象头上的 Mark Word 部分设置线程 ID，以表示这个对象偏向于当前线程，所以并不涉及真正的互斥锁。这样做的假设是基于在很多应用场景中，大部分对象生命周期中最多会被一个线程锁定，使用偏斜锁可以降低无竞争开销。\n- 轻量级锁\n如果有另外的线程试图锁定某个已经被偏斜过的对象，JVM 就需要撤销（revoke）偏斜锁，并切换到轻量级锁实现。\n- 重量级锁\n轻量级锁依赖 CAS 操作 Mark Word 来试图获取锁，如果重试成功，就使用普通的轻量级锁；否则，进一步升级为重量级锁。\n\n我注意到有的观点认为 Java 不会进行锁降级。实际上据我所知，锁降级确实是会发生的，当 JVM 进入安全点（SafePoint）的时候，会检查是否有闲置的 Monitor，然后试图进行降级\n![image.png](https://upload-images.jianshu.io/upload_images/1534431-1816e7d12c4ed6c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n- 可重入锁：它是表示当一个线程试图获取一个它已经获取的锁时,这个获取动作就自动成功。\nReentrantLock和synchronized，\n\n```\npublic class RepeLock implements Runnable {\n    private Lock lock = new ReentrantLock();\n    public void get() {\n        try {\n            lock.lock();\n            System.out.println(Thread.currentThread().getId());\n            set();\n        } finally {\n            lock.unlock();\n        }\n    }\n    public void set() {\n        try {\n            lock.lock();\n            System.out.println(Thread.currentThread().getId());\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    @Override\n    public void run() {\n        get();\n    }\n    public static void main(String[] args) {\n        RepeLock repeLock = new RepeLock();\n        new Thread(repeLock).start();\n        new Thread(repeLock).start();\n        new Thread(repeLock).start();\n    }\n}\n```\n- 锁膨胀：\n- 自旋锁：\n线程去拿锁时发现已经有线程拿了锁，然后让线程去执行一个无意义的循环，循环结束后再去重新竞争锁，如果竞争不到继续循环，循环过程中线程会一直处于running状态，但是基于JVM的线程调度，会出让时间片，所以其他线程依旧有申请锁和释放锁的机会。自旋锁省去了阻塞锁的时间空间（队列的维护等）开销，但是长时间自旋就变成了“忙式等待”，忙式等待显然还不如阻塞锁。所以自旋的次数一般控制在一个范围内，例如10,100等，在超出这个范围后，自旋锁会升级为阻塞锁。\n- [指令重排](https://www.cnblogs.com/chenyangyao/p/5269622.html)\n\n### [线程池](https://mp.weixin.qq.com/s/eyFVplFcZoN6-4WTMojtMw)\nExecutors 目前提供了 5 种不同的线程池创建配置：\n\n- newCachedThreadPool()，它是一种用来处理大量短时间工作任务的线程池，具有几个鲜明特点：它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程；如果线程闲置的时间超过 60 秒，则被终止并移出缓存；长时间闲置时，这种线程池，不会消耗什么资源。其内部使用 SynchronousQueue 作为工作队列。\n- newFixedThreadPool(int nThreads)，重用指定数目（nThreads）的线程，其背后使用的是无界的工作队列，任何时候最多有 nThreads 个工作线程是活动的。这意味着，如果任务数量超过了活动队列数目，将在工作队列中等待空闲线程出现；如果有工作线程退出，将会有新的工作线程被创建，以补足指定的数目 nThreads。\n- newSingleThreadExecutor()，它的特点在于工作线程数目被限制为 1，操作一个无界的工作队列，所以它保证了所有任务的都是被顺序执行，最多会有一个任务处于活动状态，并且不允许使用者改动线程池实例，因此可以避免其改变线程数目。\n- newSingleThreadScheduledExecutor() 和 newScheduledThreadPool(int corePoolSize)，创建的是个 ScheduledExecutorService，可以进行定时或周期性的工作调度，区别在于单一工作线程还是多个工作线程。\n- newWorkStealingPool(int parallelism)，这是一个经常被人忽略的线程池，Java 8 才加入这个创建方法，其内部会构建ForkJoinPool，利用Work-Stealing算法，并行地处理任务，不保证处理顺序。\n\n线程池构造方法几个参数\n\n```\npublic ThreadPoolExecutor(int corePoolSize,\n                              int maximumPoolSize,\n                              long keepAliveTime,\n                              TimeUnit unit,\n                              BlockingQueue<Runnable> workQueue,\n                              ThreadFactory threadFactory,\n                              RejectedExecutionHandler handler) {\n```\n1. corePoolSize : 该线程池中核心线程数最大值\n核心线程：线程池新建线程的时候，如果当前线程总数小于 corePoolSize ，则新建的是核心线程；如果超过corePoolSize，则新建的是非核心线程。核心线程默认情况下会一直存活在线程池中，即使这个核心线程啥也不干(闲置状态)。如果指定ThreadPoolExecutor的 allowCoreThreadTimeOut 这个属性为true，那么核心线程如果不干活(闲置状态)的话，超过一定时间( keepAliveTime)，就会被销毁掉.\n2. maximumPoolSize ：该线程池中线程总数的最大值\n线程总数计算公式 = 核心线程数 + 非核心线程数。\n3. keepAliveTime  ：该线程池中非核心线程闲置超时时长\n注意：一个非核心线程，如果不干活(闲置状态)的时长，超过这个参数所设定的时长，就会被销毁掉。但是，如果设置了  allowCoreThreadTimeOut = true，则会作用于核心线程。\n4. unit ：（时间单位）\n首先，TimeUnit是一个枚举类型，翻译过来就是时间单位，我们最常用的时间单位包括：\nMILLISECONDS ： 1毫秒 、SECONDS ： 秒、MINUTES ： 分、HOURS ： 小时、DAYS ： 天\n5. BlockingQueue<Runnable> workQueue ：( Blocking：阻塞的，queue：队列)，主要有四种队列\n   -  SynchronousQueue：（同步队列）这个队列接收到任务的时候，会直接提交给线程处理，而不保留它（名字定义为 同步队列），所有该队列跟设置的corePoolSize无效。但有一种情况，假设所有线程都在工作怎么办？这种情况下，SynchronousQueue就会新建一个线程来处理这个任务。所以为了保证不出现（线程数达到了maximumPoolSize而不能新建线程）的错误，使用这个类型队列的时候，maximumPoolSize一般指定成Integer.MAX_VALUE，即无限大，去规避这个使用风险。\n    - LinkedBlockingQueue（链表阻塞队列）：这个队列接收到任务的时候，如果当前线程数小于核心线程数，则新建线程(核心线程)处理任务；如果当前线程数等于核心线程数，则进入队列等待。由于这个队列没有最大值限制，即所有超过核心线程数的任务都将被添加到队列中，这也就导致了maximumPoolSize的设定失效，因为总线程数永远不会超过corePoolSize\n    - ArrayBlockingQueue（数组阻塞队列）：可以限定队列的长度（既然是数组，那么就限定了大小），接收到任务的时候，如果没有达到corePoolSize的值，则新建线程(核心线程)执行任务，如果达到了，则入队等候，如果队列已满，则新建线程(非核心线程)执行任务，又如果总线程数到了maximumPoolSize，并且队列也满了，则发生错误\n    - DelayQueue（延迟队列）：队列内元素必须实现Delayed接口，这就意味着你传进去的任务必须先实现Delayed接口。这个队列接收到任务时，首先先入队，只有达到了指定的延时时间，才会执行任务\n6. ThreadFactory threadFactory = > 创建线程的方式，这是一个接口，new它的时候需要实现他的Thread newThread(Runnable r)方法\n7. RejectedExecutionHandler handler = > 这个主要是用来抛异常的\n当线程无法执行新任务时（一般是由于线程池中的线程数量已经达到最大数或者线程池关闭导致的），默认情况下，当线程池无法处理新线程时，会抛出一个RejectedExecutionException。\n\n以 LinkedBlockingQueue、ArrayBlockingQueue 和 SynchronousQueue 为例，我们一起来分析一下，根据需求可以从很多方面考量：\n\n### ArrayBlockingQueue ,LinkedBlockingQueue ,SynchronousQueue \n- 从空间利用角度，数组结构的 ArrayBlockingQueue 要比 LinkedBlockingQueue 紧凑，因为其不需要创建所谓节点，但是其初始分配阶段就需要一段连续的空间，所以初始内存需求更大。\n- 通用场景中，LinkedBlockingQueue 的吞吐量一般优于 ArrayBlockingQueue，因为它实现了更加细粒度的锁操作。\n- ArrayBlockingQueue 实现比较简单，性能更好预测，属于表现稳定的“选手”。\n- 如果我们需要实现的是两个线程之间接力性（handoff）的场景，按照专栏上一讲的例子，你可能会选择 CountDownLatch，但是SynchronousQueue也是完美符合这种场景的，而且线程间协调和数据传输统一起来，代码更加规范。\n- 可能令人意外的是，很多时候 SynchronousQueue 的性能表现，往往大大超过其他实现，尤其是在队列元素较小的场景。\n\n### 重点源码分享\nokhttp\n\n```\n public synchronized ExecutorService executorService() {\n    if (executorService == null) {\n      executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,\n          new SynchronousQueue<Runnable>(), Util.threadFactory(\"OkHttp Dispatcher\", false));\n    }\n    return executorService;\n  }\n```\n```\n synchronized void enqueue(AsyncCall call) {\n    if (runningAsyncCalls.size() < maxRequests && runningCallsForHost(call) < maxRequestsPerHost) {\n      runningAsyncCalls.add(call);\n      executorService().execute(call);\n    } else {\n      readyAsyncCalls.add(call);\n    }\n  }\n```\nAsyncTask\n\n```\n private static final BlockingQueue<Runnable> sPoolWorkQueue =\n            new LinkedBlockingQueue<Runnable>(128);\n    /**\n     * An {@link Executor} that can be used to execute tasks in parallel.\n     */\n    public static final Executor THREAD_POOL_EXECUTOR;\n    static {\n        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(\n                CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS,\n                sPoolWorkQueue, sThreadFactory);\n        threadPoolExecutor.allowCoreThreadTimeOut(true);\n        THREAD_POOL_EXECUTOR = threadPoolExecutor;\n    }\n```\n\n```\nprivate static class SerialExecutor implements Executor {\n        final ArrayDeque<Runnable> mTasks = new ArrayDeque<Runnable>();\n        Runnable mActive;\n\n        public synchronized void execute(final Runnable r) {\n            mTasks.offer(new Runnable() {\n                public void run() {\n                    try {\n                        r.run();\n                    } finally {\n                        scheduleNext();\n                    }\n                }\n            });\n            if (mActive == null) {\n                scheduleNext();\n            }\n        }\n\n        protected synchronized void scheduleNext() {\n            if ((mActive = mTasks.poll()) != null) {\n                THREAD_POOL_EXECUTOR.execute(mActive);\n            }\n        }\n    }\n```\n\n\n\n\n\n\n","slug":"Java线程","published":1,"updated":"2021-09-10T07:04:21.943Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cktfeap3x001cc2xxj1cleyz4","content":"<p>线程是系统调度的最小单元，一个进程可以包含多个线程，作为任务的真正运作者，有自己的栈（Stack）、寄存器（Register）、本地存储（Thread Local）等，但是会和进程内其他线程共享文件描述符、虚拟地址空间等。在具体实现中，线程还分为内核线程、用户线程，Java 的线程实现其实是与虚拟机相关的。</p>\n<h3 id=\"创建线程方式\"><a href=\"#创建线程方式\" class=\"headerlink\" title=\"创建线程方式\"></a>创建线程方式</h3><ul>\n<li>继承Thread</li>\n</ul>\n<pre><code>public class ThreadImpl extends Thread {   \n}\n</code></pre><ul>\n<li>实现Runable</li>\n</ul>\n<pre><code>public class MyThread implements Runnable {\n    private int ticket;\n    private Lock lock = new ReentrantLock();\n\n    public MyThread(int ticket) {\n        this.ticket = ticket;\n    }\n\n    @Override\n    public void run() {\n        print();\n    }\n\n    public void print() {\n        lock.lock();\n        try {\n            while (ticket &gt; 0) {\n                System.out.println(&quot;ticket==&quot; + ticket);\n                ticket--;\n            }\n        } catch (Exception e) {\n            System.out.println(&quot;Exception==&quot; + e);\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public static void main(String[] args) {\n        MyThread myThread = new MyThread(5);\n        new Thread(myThread).start();\n        new Thread(myThread).start();\n    }\n}\n</code></pre><ul>\n<li>实现Callable，运行完成后可返回值。</li>\n</ul>\n<pre><code>public class CallTask implements Callable {\n    private int upperBounds;\n\n    public CallTask(int upperBounds) {\n        this.upperBounds = upperBounds;\n    }\n\n    @Override\n    public Integer call() throws Exception {\n        int sum = 0;\n        for (int i = 1; i &lt;= upperBounds; i++) {\n            sum += i;\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        ExecutorService service = Executors.newFixedThreadPool(10);\n        try {\n            int sum = (int) service.submit(new CallTask((int) (Math.random() * 100))).get();\n            System.out.println(&quot;sum==&quot; + sum);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } catch (ExecutionException e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre><h3 id=\"常用锁处理\"><a href=\"#常用锁处理\" class=\"headerlink\" title=\"常用锁处理\"></a>常用锁处理</h3><ul>\n<li><a href=\"https://www.jianshu.com/p/d53bf830fa09\" target=\"_blank\" rel=\"noopener\">synchronized</a>  </li>\n</ul>\n<pre><code>public class LockThread implements Runnable {    \n  private Integer key = 0;      \n  @Override    \n  public void run() {       \n     synchronized (this) {    \n        key++;          \n     System.out.println(Thread.currentThread().getName() + &quot;:&quot; + key);    \n    try {        \n        Thread.sleep(5);   \n       } catch (InterruptedException e) {        \n        e.printStackTrace();    }\n      }\n   }    \npublic static void main(String[] args) {       \n LockThread lockThread = new LockThread();       \n for (int i = 0; i &lt; 100; i++) {\n        new Thread(lockThread, &quot;thread&quot; + i).start();        \n    }    \n   }\n}\n</code></pre><ul>\n<li>lock</li>\n</ul>\n<pre><code>public class LockThread implements Runnable {    \n  private Integer key = 0;    \n  private Lock lock = new ReentrantLock();    \n  @Override    \n  public void run() {       \n     lock.lock();  //获取锁     \n       try {           \n           key++;                \n          System.out.println(Thread.currentThread().getName() + &quot;:&quot; + key);            \n          Thread.sleep(5);       \n          } catch (Exception e) {        \n        } finally {            \n        lock.unlock();  //释放锁     \n       }    \n     }    \npublic static void main(String[] args) {       \n LockThread lockThread = new LockThread();       \n for (int i = 0; i &lt; 100; i++) {            \n       new Thread(lockThread, &quot;thread&quot; + i).start();        \n      }    \n     }\n}\n</code></pre><ul>\n<li>volatile</li>\n</ul>\n<h3 id=\"volatile和synchronized的区别\"><a href=\"#volatile和synchronized的区别\" class=\"headerlink\" title=\"volatile和synchronized的区别\"></a>volatile和synchronized的区别</h3><table>\n<thead>\n<tr>\n<th></th>\n<th>volatile</th>\n<th>synchronized</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>作用域</td>\n<td>变量</td>\n<td>方法，代码块</td>\n</tr>\n<tr>\n<td>操作性</td>\n<td>仅保证可见性</td>\n<td>可以保证可见性和原子性</td>\n</tr>\n<tr>\n<td>线程堵塞状态</td>\n<td>不会造成线程的阻塞</td>\n<td>可能会造成线程的阻塞</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"Lock和synchronized的区别\"><a href=\"#Lock和synchronized的区别\" class=\"headerlink\" title=\"Lock和synchronized的区别\"></a>Lock和synchronized的区别</h3><table>\n<thead>\n<tr>\n<th></th>\n<th>Lock</th>\n<th>synchronized</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>使用区别</td>\n<td>类</td>\n<td>关键字</td>\n</tr>\n<tr>\n<td>作用域</td>\n<td>代码块</td>\n<td>代码块，方法</td>\n</tr>\n<tr>\n<td>释放锁</td>\n<td>需要finally()方法手动释放锁</td>\n<td>执行完自动释放锁</td>\n</tr>\n<tr>\n<td>锁类型</td>\n<td>可重入,可判断,可公平（两者皆可）</td>\n<td>可重入,不可中断,非公平</td>\n</tr>\n<tr>\n<td>依托实现</td>\n<td>Java代码控制</td>\n<td>JVM执行</td>\n</tr>\n<tr>\n<td>性能</td>\n<td>高竞争场景中表现可能优于synchronized</td>\n<td>在低竞争场景中表现可能优于 ReentrantLock</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"sleep-和wait-的区别\"><a href=\"#sleep-和wait-的区别\" class=\"headerlink\" title=\"sleep()和wait()的区别\"></a>sleep()和wait()的区别</h3><table>\n<thead>\n<tr>\n<th></th>\n<th>sleep</th>\n<th>wait</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td></td>\n<td>睡眠时，保持对象锁，仍然占有该锁</td>\n<td>睡眠时，释放对象锁</td>\n</tr>\n<tr>\n<td>作用域</td>\n<td>任何地方调用</td>\n<td>只能在同步方法或同步块中使用</td>\n</tr>\n<tr>\n<td>时间</td>\n<td>指定时间后唤醒</td>\n<td>只有等notify()/notifyAll()通知有才能唤醒</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"并发高效类\"><a href=\"#并发高效类\" class=\"headerlink\" title=\"并发高效类\"></a>并发高效类</h3><p>实际开发中Java封装了一些解决高并发的类包（java.util.concurrent包），常用的如下：</p>\n<ul>\n<li>AtomicInteger：提供一种线程安全的加减操作</li>\n<li>AtomicBoolean</li>\n<li>AtomicLong</li>\n<li>AtomicReference</li>\n<li>AtomicIntegerArray</li>\n<li>AtomicLongArray</li>\n<li>AtomicReferenceArray</li>\n</ul>\n<h3 id=\"线程生命周期\"><a href=\"#线程生命周期\" class=\"headerlink\" title=\"线程生命周期\"></a>线程生命周期</h3><p><img src=\"https://upload-images.jianshu.io/upload_images/1534431-8837ea32b7cd19b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"线程生命周期\"></p>\n<p>关于线程生命周期的不同状态，在 Java 5 以后，线程状态被明确定义在其公共内部枚举类型 java.lang.Thread.State 中，分别是：</p>\n<ul>\n<li>新建（NEW），表示线程被创建出来还没真正启动的状态，可以认为它是个 Java 内部状态。</li>\n<li>就绪（RUNNABLE），表示该线程已经在 JVM 中执行，当然由于执行需要计算资源，它可能是正在运行，也可能还在等待系统分配给它 CPU 片段，在就绪队列里面排队。<br>在其他一些分析中，会额外区分一种状态 RUNNING，但是从 Java API 的角度，并不能表示出来。</li>\n<li>阻塞（BLOCKED），这个状态和我们前面两讲介绍的同步非常相关，阻塞表示线程在等待 Monitor lock。比如，线程试图通过 synchronized 去获取某个锁，但是其他线程已经独占了，那么当前线程就会处于阻塞状态。如：sleep()</li>\n<li>等待（WAITING），表示正在等待其他线程采取某些操作。一个常见的场景是类似生产者消费者模式，发现任务条件尚未满足，就让当前消费者线程等待（wait），另外的生产者线程去准备任务数据，然后通过类似 notify 等动作，通知消费线程可以继续工作了。Thread.join() 也会令线程进入等待状态。</li>\n<li>计时等待（TIMED_WAIT），其进入条件和等待状态类似，但是调用的是存在超时条件的方法，比如 wait 或 join 等方法的指定超时版本，如下面示例：</li>\n</ul>\n<pre><code>public final native void wait(long timeout) throws InterruptedException;\n</code></pre><ul>\n<li>终止（TERMINATED），不管是意外退出还是正常执行结束，线程已经完成使命，终止运行，也有人把这个状态叫作死亡。<br>在第二次调用 start() 方法的时候，线程可能处于终止或者其他（非 NEW）状态，但是不论如何，都是不可以再次启动的。</li>\n</ul>\n<h3 id=\"线程安全基本特性\"><a href=\"#线程安全基本特性\" class=\"headerlink\" title=\"线程安全基本特性\"></a>线程安全基本特性</h3><ul>\n<li>原子性：简单说就是相关操作不会中途被其他线程干扰，一般通过同步机制实现</li>\n<li>可见性:是一个线程修改了某个共享变量，其状态能够立即被其他线程知晓，通常被解释为将线程本地状态反映到主内存上，volatile就是负责保证可见性的。<ul>\n<li>有序性，是保证线程内串行语义，避免指令重排等</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Monitor-实现的三种锁：\"><a href=\"#Monitor-实现的三种锁：\" class=\"headerlink\" title=\"Monitor 实现的三种锁：\"></a>Monitor 实现的三种锁：</h3><p>所谓锁的升级、降级，就是 JVM 优化 synchronized 运行的机制，当 JVM 检测到不同的竞争状况时，会自动切换到适合的锁实现，这种切换就是锁的升级、降级。</p>\n<ul>\n<li>偏斜锁（Biased Locking）<br>当没有竞争出现时，默认会使用偏斜锁。JVM 会利用 CAS 操作（compare and swap），在对象头上的 Mark Word 部分设置线程 ID，以表示这个对象偏向于当前线程，所以并不涉及真正的互斥锁。这样做的假设是基于在很多应用场景中，大部分对象生命周期中最多会被一个线程锁定，使用偏斜锁可以降低无竞争开销。</li>\n<li>轻量级锁<br>如果有另外的线程试图锁定某个已经被偏斜过的对象，JVM 就需要撤销（revoke）偏斜锁，并切换到轻量级锁实现。</li>\n<li>重量级锁<br>轻量级锁依赖 CAS 操作 Mark Word 来试图获取锁，如果重试成功，就使用普通的轻量级锁；否则，进一步升级为重量级锁。</li>\n</ul>\n<p>我注意到有的观点认为 Java 不会进行锁降级。实际上据我所知，锁降级确实是会发生的，当 JVM 进入安全点（SafePoint）的时候，会检查是否有闲置的 Monitor，然后试图进行降级<br><img src=\"https://upload-images.jianshu.io/upload_images/1534431-1816e7d12c4ed6c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<ul>\n<li>可重入锁：它是表示当一个线程试图获取一个它已经获取的锁时,这个获取动作就自动成功。<br>ReentrantLock和synchronized，</li>\n</ul>\n<pre><code>public class RepeLock implements Runnable {\n    private Lock lock = new ReentrantLock();\n    public void get() {\n        try {\n            lock.lock();\n            System.out.println(Thread.currentThread().getId());\n            set();\n        } finally {\n            lock.unlock();\n        }\n    }\n    public void set() {\n        try {\n            lock.lock();\n            System.out.println(Thread.currentThread().getId());\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    @Override\n    public void run() {\n        get();\n    }\n    public static void main(String[] args) {\n        RepeLock repeLock = new RepeLock();\n        new Thread(repeLock).start();\n        new Thread(repeLock).start();\n        new Thread(repeLock).start();\n    }\n}\n</code></pre><ul>\n<li>锁膨胀：</li>\n<li>自旋锁：<br>线程去拿锁时发现已经有线程拿了锁，然后让线程去执行一个无意义的循环，循环结束后再去重新竞争锁，如果竞争不到继续循环，循环过程中线程会一直处于running状态，但是基于JVM的线程调度，会出让时间片，所以其他线程依旧有申请锁和释放锁的机会。自旋锁省去了阻塞锁的时间空间（队列的维护等）开销，但是长时间自旋就变成了“忙式等待”，忙式等待显然还不如阻塞锁。所以自旋的次数一般控制在一个范围内，例如10,100等，在超出这个范围后，自旋锁会升级为阻塞锁。</li>\n<li><a href=\"https://www.cnblogs.com/chenyangyao/p/5269622.html\" target=\"_blank\" rel=\"noopener\">指令重排</a></li>\n</ul>\n<h3 id=\"线程池\"><a href=\"#线程池\" class=\"headerlink\" title=\"线程池\"></a><a href=\"https://mp.weixin.qq.com/s/eyFVplFcZoN6-4WTMojtMw\" target=\"_blank\" rel=\"noopener\">线程池</a></h3><p>Executors 目前提供了 5 种不同的线程池创建配置：</p>\n<ul>\n<li>newCachedThreadPool()，它是一种用来处理大量短时间工作任务的线程池，具有几个鲜明特点：它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程；如果线程闲置的时间超过 60 秒，则被终止并移出缓存；长时间闲置时，这种线程池，不会消耗什么资源。其内部使用 SynchronousQueue 作为工作队列。</li>\n<li>newFixedThreadPool(int nThreads)，重用指定数目（nThreads）的线程，其背后使用的是无界的工作队列，任何时候最多有 nThreads 个工作线程是活动的。这意味着，如果任务数量超过了活动队列数目，将在工作队列中等待空闲线程出现；如果有工作线程退出，将会有新的工作线程被创建，以补足指定的数目 nThreads。</li>\n<li>newSingleThreadExecutor()，它的特点在于工作线程数目被限制为 1，操作一个无界的工作队列，所以它保证了所有任务的都是被顺序执行，最多会有一个任务处于活动状态，并且不允许使用者改动线程池实例，因此可以避免其改变线程数目。</li>\n<li>newSingleThreadScheduledExecutor() 和 newScheduledThreadPool(int corePoolSize)，创建的是个 ScheduledExecutorService，可以进行定时或周期性的工作调度，区别在于单一工作线程还是多个工作线程。</li>\n<li>newWorkStealingPool(int parallelism)，这是一个经常被人忽略的线程池，Java 8 才加入这个创建方法，其内部会构建ForkJoinPool，利用Work-Stealing算法，并行地处理任务，不保证处理顺序。</li>\n</ul>\n<p>线程池构造方法几个参数</p>\n<pre><code>public ThreadPoolExecutor(int corePoolSize,\n                              int maximumPoolSize,\n                              long keepAliveTime,\n                              TimeUnit unit,\n                              BlockingQueue&lt;Runnable&gt; workQueue,\n                              ThreadFactory threadFactory,\n                              RejectedExecutionHandler handler) {\n</code></pre><ol>\n<li>corePoolSize : 该线程池中核心线程数最大值<br>核心线程：线程池新建线程的时候，如果当前线程总数小于 corePoolSize ，则新建的是核心线程；如果超过corePoolSize，则新建的是非核心线程。核心线程默认情况下会一直存活在线程池中，即使这个核心线程啥也不干(闲置状态)。如果指定ThreadPoolExecutor的 allowCoreThreadTimeOut 这个属性为true，那么核心线程如果不干活(闲置状态)的话，超过一定时间( keepAliveTime)，就会被销毁掉.</li>\n<li>maximumPoolSize ：该线程池中线程总数的最大值<br>线程总数计算公式 = 核心线程数 + 非核心线程数。</li>\n<li>keepAliveTime  ：该线程池中非核心线程闲置超时时长<br>注意：一个非核心线程，如果不干活(闲置状态)的时长，超过这个参数所设定的时长，就会被销毁掉。但是，如果设置了  allowCoreThreadTimeOut = true，则会作用于核心线程。</li>\n<li>unit ：（时间单位）<br>首先，TimeUnit是一个枚举类型，翻译过来就是时间单位，我们最常用的时间单位包括：<br>MILLISECONDS ： 1毫秒 、SECONDS ： 秒、MINUTES ： 分、HOURS ： 小时、DAYS ： 天</li>\n<li>BlockingQueue<runnable> workQueue ：( Blocking：阻塞的，queue：队列)，主要有四种队列<ul>\n<li>SynchronousQueue：（同步队列）这个队列接收到任务的时候，会直接提交给线程处理，而不保留它（名字定义为 同步队列），所有该队列跟设置的corePoolSize无效。但有一种情况，假设所有线程都在工作怎么办？这种情况下，SynchronousQueue就会新建一个线程来处理这个任务。所以为了保证不出现（线程数达到了maximumPoolSize而不能新建线程）的错误，使用这个类型队列的时候，maximumPoolSize一般指定成Integer.MAX_VALUE，即无限大，去规避这个使用风险。<ul>\n<li>LinkedBlockingQueue（链表阻塞队列）：这个队列接收到任务的时候，如果当前线程数小于核心线程数，则新建线程(核心线程)处理任务；如果当前线程数等于核心线程数，则进入队列等待。由于这个队列没有最大值限制，即所有超过核心线程数的任务都将被添加到队列中，这也就导致了maximumPoolSize的设定失效，因为总线程数永远不会超过corePoolSize</li>\n<li>ArrayBlockingQueue（数组阻塞队列）：可以限定队列的长度（既然是数组，那么就限定了大小），接收到任务的时候，如果没有达到corePoolSize的值，则新建线程(核心线程)执行任务，如果达到了，则入队等候，如果队列已满，则新建线程(非核心线程)执行任务，又如果总线程数到了maximumPoolSize，并且队列也满了，则发生错误</li>\n<li>DelayQueue（延迟队列）：队列内元素必须实现Delayed接口，这就意味着你传进去的任务必须先实现Delayed接口。这个队列接收到任务时，首先先入队，只有达到了指定的延时时间，才会执行任务</li>\n</ul>\n</li>\n</ul>\n</runnable></li>\n<li>ThreadFactory threadFactory = &gt; 创建线程的方式，这是一个接口，new它的时候需要实现他的Thread newThread(Runnable r)方法</li>\n<li>RejectedExecutionHandler handler = &gt; 这个主要是用来抛异常的<br>当线程无法执行新任务时（一般是由于线程池中的线程数量已经达到最大数或者线程池关闭导致的），默认情况下，当线程池无法处理新线程时，会抛出一个RejectedExecutionException。</li>\n</ol>\n<p>以 LinkedBlockingQueue、ArrayBlockingQueue 和 SynchronousQueue 为例，我们一起来分析一下，根据需求可以从很多方面考量：</p>\n<h3 id=\"ArrayBlockingQueue-LinkedBlockingQueue-SynchronousQueue\"><a href=\"#ArrayBlockingQueue-LinkedBlockingQueue-SynchronousQueue\" class=\"headerlink\" title=\"ArrayBlockingQueue ,LinkedBlockingQueue ,SynchronousQueue\"></a>ArrayBlockingQueue ,LinkedBlockingQueue ,SynchronousQueue</h3><ul>\n<li>从空间利用角度，数组结构的 ArrayBlockingQueue 要比 LinkedBlockingQueue 紧凑，因为其不需要创建所谓节点，但是其初始分配阶段就需要一段连续的空间，所以初始内存需求更大。</li>\n<li>通用场景中，LinkedBlockingQueue 的吞吐量一般优于 ArrayBlockingQueue，因为它实现了更加细粒度的锁操作。</li>\n<li>ArrayBlockingQueue 实现比较简单，性能更好预测，属于表现稳定的“选手”。</li>\n<li>如果我们需要实现的是两个线程之间接力性（handoff）的场景，按照专栏上一讲的例子，你可能会选择 CountDownLatch，但是SynchronousQueue也是完美符合这种场景的，而且线程间协调和数据传输统一起来，代码更加规范。</li>\n<li>可能令人意外的是，很多时候 SynchronousQueue 的性能表现，往往大大超过其他实现，尤其是在队列元素较小的场景。</li>\n</ul>\n<h3 id=\"重点源码分享\"><a href=\"#重点源码分享\" class=\"headerlink\" title=\"重点源码分享\"></a>重点源码分享</h3><p>okhttp</p>\n<pre><code> public synchronized ExecutorService executorService() {\n    if (executorService == null) {\n      executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,\n          new SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(&quot;OkHttp Dispatcher&quot;, false));\n    }\n    return executorService;\n  }\n</code></pre><pre><code> synchronized void enqueue(AsyncCall call) {\n    if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) {\n      runningAsyncCalls.add(call);\n      executorService().execute(call);\n    } else {\n      readyAsyncCalls.add(call);\n    }\n  }\n</code></pre><p>AsyncTask</p>\n<pre><code> private static final BlockingQueue&lt;Runnable&gt; sPoolWorkQueue =\n            new LinkedBlockingQueue&lt;Runnable&gt;(128);\n    /**\n     * An {@link Executor} that can be used to execute tasks in parallel.\n     */\n    public static final Executor THREAD_POOL_EXECUTOR;\n    static {\n        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(\n                CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS,\n                sPoolWorkQueue, sThreadFactory);\n        threadPoolExecutor.allowCoreThreadTimeOut(true);\n        THREAD_POOL_EXECUTOR = threadPoolExecutor;\n    }\n</code></pre><pre><code>private static class SerialExecutor implements Executor {\n        final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;();\n        Runnable mActive;\n\n        public synchronized void execute(final Runnable r) {\n            mTasks.offer(new Runnable() {\n                public void run() {\n                    try {\n                        r.run();\n                    } finally {\n                        scheduleNext();\n                    }\n                }\n            });\n            if (mActive == null) {\n                scheduleNext();\n            }\n        }\n\n        protected synchronized void scheduleNext() {\n            if ((mActive = mTasks.poll()) != null) {\n                THREAD_POOL_EXECUTOR.execute(mActive);\n            }\n        }\n    }\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>线程是系统调度的最小单元，一个进程可以包含多个线程，作为任务的真正运作者，有自己的栈（Stack）、寄存器（Register）、本地存储（Thread Local）等，但是会和进程内其他线程共享文件描述符、虚拟地址空间等。在具体实现中，线程还分为内核线程、用户线程，Java 的线程实现其实是与虚拟机相关的。</p>\n<h3 id=\"创建线程方式\"><a href=\"#创建线程方式\" class=\"headerlink\" title=\"创建线程方式\"></a>创建线程方式</h3><ul>\n<li>继承Thread</li>\n</ul>\n<pre><code>public class ThreadImpl extends Thread {   \n}\n</code></pre><ul>\n<li>实现Runable</li>\n</ul>\n<pre><code>public class MyThread implements Runnable {\n    private int ticket;\n    private Lock lock = new ReentrantLock();\n\n    public MyThread(int ticket) {\n        this.ticket = ticket;\n    }\n\n    @Override\n    public void run() {\n        print();\n    }\n\n    public void print() {\n        lock.lock();\n        try {\n            while (ticket &gt; 0) {\n                System.out.println(&quot;ticket==&quot; + ticket);\n                ticket--;\n            }\n        } catch (Exception e) {\n            System.out.println(&quot;Exception==&quot; + e);\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public static void main(String[] args) {\n        MyThread myThread = new MyThread(5);\n        new Thread(myThread).start();\n        new Thread(myThread).start();\n    }\n}\n</code></pre><ul>\n<li>实现Callable，运行完成后可返回值。</li>\n</ul>\n<pre><code>public class CallTask implements Callable {\n    private int upperBounds;\n\n    public CallTask(int upperBounds) {\n        this.upperBounds = upperBounds;\n    }\n\n    @Override\n    public Integer call() throws Exception {\n        int sum = 0;\n        for (int i = 1; i &lt;= upperBounds; i++) {\n            sum += i;\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        ExecutorService service = Executors.newFixedThreadPool(10);\n        try {\n            int sum = (int) service.submit(new CallTask((int) (Math.random() * 100))).get();\n            System.out.println(&quot;sum==&quot; + sum);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } catch (ExecutionException e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre><h3 id=\"常用锁处理\"><a href=\"#常用锁处理\" class=\"headerlink\" title=\"常用锁处理\"></a>常用锁处理</h3><ul>\n<li><a href=\"https://www.jianshu.com/p/d53bf830fa09\" target=\"_blank\" rel=\"noopener\">synchronized</a>  </li>\n</ul>\n<pre><code>public class LockThread implements Runnable {    \n  private Integer key = 0;      \n  @Override    \n  public void run() {       \n     synchronized (this) {    \n        key++;          \n     System.out.println(Thread.currentThread().getName() + &quot;:&quot; + key);    \n    try {        \n        Thread.sleep(5);   \n       } catch (InterruptedException e) {        \n        e.printStackTrace();    }\n      }\n   }    \npublic static void main(String[] args) {       \n LockThread lockThread = new LockThread();       \n for (int i = 0; i &lt; 100; i++) {\n        new Thread(lockThread, &quot;thread&quot; + i).start();        \n    }    \n   }\n}\n</code></pre><ul>\n<li>lock</li>\n</ul>\n<pre><code>public class LockThread implements Runnable {    \n  private Integer key = 0;    \n  private Lock lock = new ReentrantLock();    \n  @Override    \n  public void run() {       \n     lock.lock();  //获取锁     \n       try {           \n           key++;                \n          System.out.println(Thread.currentThread().getName() + &quot;:&quot; + key);            \n          Thread.sleep(5);       \n          } catch (Exception e) {        \n        } finally {            \n        lock.unlock();  //释放锁     \n       }    \n     }    \npublic static void main(String[] args) {       \n LockThread lockThread = new LockThread();       \n for (int i = 0; i &lt; 100; i++) {            \n       new Thread(lockThread, &quot;thread&quot; + i).start();        \n      }    \n     }\n}\n</code></pre><ul>\n<li>volatile</li>\n</ul>\n<h3 id=\"volatile和synchronized的区别\"><a href=\"#volatile和synchronized的区别\" class=\"headerlink\" title=\"volatile和synchronized的区别\"></a>volatile和synchronized的区别</h3><table>\n<thead>\n<tr>\n<th></th>\n<th>volatile</th>\n<th>synchronized</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>作用域</td>\n<td>变量</td>\n<td>方法，代码块</td>\n</tr>\n<tr>\n<td>操作性</td>\n<td>仅保证可见性</td>\n<td>可以保证可见性和原子性</td>\n</tr>\n<tr>\n<td>线程堵塞状态</td>\n<td>不会造成线程的阻塞</td>\n<td>可能会造成线程的阻塞</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"Lock和synchronized的区别\"><a href=\"#Lock和synchronized的区别\" class=\"headerlink\" title=\"Lock和synchronized的区别\"></a>Lock和synchronized的区别</h3><table>\n<thead>\n<tr>\n<th></th>\n<th>Lock</th>\n<th>synchronized</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>使用区别</td>\n<td>类</td>\n<td>关键字</td>\n</tr>\n<tr>\n<td>作用域</td>\n<td>代码块</td>\n<td>代码块，方法</td>\n</tr>\n<tr>\n<td>释放锁</td>\n<td>需要finally()方法手动释放锁</td>\n<td>执行完自动释放锁</td>\n</tr>\n<tr>\n<td>锁类型</td>\n<td>可重入,可判断,可公平（两者皆可）</td>\n<td>可重入,不可中断,非公平</td>\n</tr>\n<tr>\n<td>依托实现</td>\n<td>Java代码控制</td>\n<td>JVM执行</td>\n</tr>\n<tr>\n<td>性能</td>\n<td>高竞争场景中表现可能优于synchronized</td>\n<td>在低竞争场景中表现可能优于 ReentrantLock</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"sleep-和wait-的区别\"><a href=\"#sleep-和wait-的区别\" class=\"headerlink\" title=\"sleep()和wait()的区别\"></a>sleep()和wait()的区别</h3><table>\n<thead>\n<tr>\n<th></th>\n<th>sleep</th>\n<th>wait</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td></td>\n<td>睡眠时，保持对象锁，仍然占有该锁</td>\n<td>睡眠时，释放对象锁</td>\n</tr>\n<tr>\n<td>作用域</td>\n<td>任何地方调用</td>\n<td>只能在同步方法或同步块中使用</td>\n</tr>\n<tr>\n<td>时间</td>\n<td>指定时间后唤醒</td>\n<td>只有等notify()/notifyAll()通知有才能唤醒</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"并发高效类\"><a href=\"#并发高效类\" class=\"headerlink\" title=\"并发高效类\"></a>并发高效类</h3><p>实际开发中Java封装了一些解决高并发的类包（java.util.concurrent包），常用的如下：</p>\n<ul>\n<li>AtomicInteger：提供一种线程安全的加减操作</li>\n<li>AtomicBoolean</li>\n<li>AtomicLong</li>\n<li>AtomicReference</li>\n<li>AtomicIntegerArray</li>\n<li>AtomicLongArray</li>\n<li>AtomicReferenceArray</li>\n</ul>\n<h3 id=\"线程生命周期\"><a href=\"#线程生命周期\" class=\"headerlink\" title=\"线程生命周期\"></a>线程生命周期</h3><p><img src=\"https://upload-images.jianshu.io/upload_images/1534431-8837ea32b7cd19b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"线程生命周期\"></p>\n<p>关于线程生命周期的不同状态，在 Java 5 以后，线程状态被明确定义在其公共内部枚举类型 java.lang.Thread.State 中，分别是：</p>\n<ul>\n<li>新建（NEW），表示线程被创建出来还没真正启动的状态，可以认为它是个 Java 内部状态。</li>\n<li>就绪（RUNNABLE），表示该线程已经在 JVM 中执行，当然由于执行需要计算资源，它可能是正在运行，也可能还在等待系统分配给它 CPU 片段，在就绪队列里面排队。<br>在其他一些分析中，会额外区分一种状态 RUNNING，但是从 Java API 的角度，并不能表示出来。</li>\n<li>阻塞（BLOCKED），这个状态和我们前面两讲介绍的同步非常相关，阻塞表示线程在等待 Monitor lock。比如，线程试图通过 synchronized 去获取某个锁，但是其他线程已经独占了，那么当前线程就会处于阻塞状态。如：sleep()</li>\n<li>等待（WAITING），表示正在等待其他线程采取某些操作。一个常见的场景是类似生产者消费者模式，发现任务条件尚未满足，就让当前消费者线程等待（wait），另外的生产者线程去准备任务数据，然后通过类似 notify 等动作，通知消费线程可以继续工作了。Thread.join() 也会令线程进入等待状态。</li>\n<li>计时等待（TIMED_WAIT），其进入条件和等待状态类似，但是调用的是存在超时条件的方法，比如 wait 或 join 等方法的指定超时版本，如下面示例：</li>\n</ul>\n<pre><code>public final native void wait(long timeout) throws InterruptedException;\n</code></pre><ul>\n<li>终止（TERMINATED），不管是意外退出还是正常执行结束，线程已经完成使命，终止运行，也有人把这个状态叫作死亡。<br>在第二次调用 start() 方法的时候，线程可能处于终止或者其他（非 NEW）状态，但是不论如何，都是不可以再次启动的。</li>\n</ul>\n<h3 id=\"线程安全基本特性\"><a href=\"#线程安全基本特性\" class=\"headerlink\" title=\"线程安全基本特性\"></a>线程安全基本特性</h3><ul>\n<li>原子性：简单说就是相关操作不会中途被其他线程干扰，一般通过同步机制实现</li>\n<li>可见性:是一个线程修改了某个共享变量，其状态能够立即被其他线程知晓，通常被解释为将线程本地状态反映到主内存上，volatile就是负责保证可见性的。<ul>\n<li>有序性，是保证线程内串行语义，避免指令重排等</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Monitor-实现的三种锁：\"><a href=\"#Monitor-实现的三种锁：\" class=\"headerlink\" title=\"Monitor 实现的三种锁：\"></a>Monitor 实现的三种锁：</h3><p>所谓锁的升级、降级，就是 JVM 优化 synchronized 运行的机制，当 JVM 检测到不同的竞争状况时，会自动切换到适合的锁实现，这种切换就是锁的升级、降级。</p>\n<ul>\n<li>偏斜锁（Biased Locking）<br>当没有竞争出现时，默认会使用偏斜锁。JVM 会利用 CAS 操作（compare and swap），在对象头上的 Mark Word 部分设置线程 ID，以表示这个对象偏向于当前线程，所以并不涉及真正的互斥锁。这样做的假设是基于在很多应用场景中，大部分对象生命周期中最多会被一个线程锁定，使用偏斜锁可以降低无竞争开销。</li>\n<li>轻量级锁<br>如果有另外的线程试图锁定某个已经被偏斜过的对象，JVM 就需要撤销（revoke）偏斜锁，并切换到轻量级锁实现。</li>\n<li>重量级锁<br>轻量级锁依赖 CAS 操作 Mark Word 来试图获取锁，如果重试成功，就使用普通的轻量级锁；否则，进一步升级为重量级锁。</li>\n</ul>\n<p>我注意到有的观点认为 Java 不会进行锁降级。实际上据我所知，锁降级确实是会发生的，当 JVM 进入安全点（SafePoint）的时候，会检查是否有闲置的 Monitor，然后试图进行降级<br><img src=\"https://upload-images.jianshu.io/upload_images/1534431-1816e7d12c4ed6c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<ul>\n<li>可重入锁：它是表示当一个线程试图获取一个它已经获取的锁时,这个获取动作就自动成功。<br>ReentrantLock和synchronized，</li>\n</ul>\n<pre><code>public class RepeLock implements Runnable {\n    private Lock lock = new ReentrantLock();\n    public void get() {\n        try {\n            lock.lock();\n            System.out.println(Thread.currentThread().getId());\n            set();\n        } finally {\n            lock.unlock();\n        }\n    }\n    public void set() {\n        try {\n            lock.lock();\n            System.out.println(Thread.currentThread().getId());\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    @Override\n    public void run() {\n        get();\n    }\n    public static void main(String[] args) {\n        RepeLock repeLock = new RepeLock();\n        new Thread(repeLock).start();\n        new Thread(repeLock).start();\n        new Thread(repeLock).start();\n    }\n}\n</code></pre><ul>\n<li>锁膨胀：</li>\n<li>自旋锁：<br>线程去拿锁时发现已经有线程拿了锁，然后让线程去执行一个无意义的循环，循环结束后再去重新竞争锁，如果竞争不到继续循环，循环过程中线程会一直处于running状态，但是基于JVM的线程调度，会出让时间片，所以其他线程依旧有申请锁和释放锁的机会。自旋锁省去了阻塞锁的时间空间（队列的维护等）开销，但是长时间自旋就变成了“忙式等待”，忙式等待显然还不如阻塞锁。所以自旋的次数一般控制在一个范围内，例如10,100等，在超出这个范围后，自旋锁会升级为阻塞锁。</li>\n<li><a href=\"https://www.cnblogs.com/chenyangyao/p/5269622.html\" target=\"_blank\" rel=\"noopener\">指令重排</a></li>\n</ul>\n<h3 id=\"线程池\"><a href=\"#线程池\" class=\"headerlink\" title=\"线程池\"></a><a href=\"https://mp.weixin.qq.com/s/eyFVplFcZoN6-4WTMojtMw\" target=\"_blank\" rel=\"noopener\">线程池</a></h3><p>Executors 目前提供了 5 种不同的线程池创建配置：</p>\n<ul>\n<li>newCachedThreadPool()，它是一种用来处理大量短时间工作任务的线程池，具有几个鲜明特点：它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程；如果线程闲置的时间超过 60 秒，则被终止并移出缓存；长时间闲置时，这种线程池，不会消耗什么资源。其内部使用 SynchronousQueue 作为工作队列。</li>\n<li>newFixedThreadPool(int nThreads)，重用指定数目（nThreads）的线程，其背后使用的是无界的工作队列，任何时候最多有 nThreads 个工作线程是活动的。这意味着，如果任务数量超过了活动队列数目，将在工作队列中等待空闲线程出现；如果有工作线程退出，将会有新的工作线程被创建，以补足指定的数目 nThreads。</li>\n<li>newSingleThreadExecutor()，它的特点在于工作线程数目被限制为 1，操作一个无界的工作队列，所以它保证了所有任务的都是被顺序执行，最多会有一个任务处于活动状态，并且不允许使用者改动线程池实例，因此可以避免其改变线程数目。</li>\n<li>newSingleThreadScheduledExecutor() 和 newScheduledThreadPool(int corePoolSize)，创建的是个 ScheduledExecutorService，可以进行定时或周期性的工作调度，区别在于单一工作线程还是多个工作线程。</li>\n<li>newWorkStealingPool(int parallelism)，这是一个经常被人忽略的线程池，Java 8 才加入这个创建方法，其内部会构建ForkJoinPool，利用Work-Stealing算法，并行地处理任务，不保证处理顺序。</li>\n</ul>\n<p>线程池构造方法几个参数</p>\n<pre><code>public ThreadPoolExecutor(int corePoolSize,\n                              int maximumPoolSize,\n                              long keepAliveTime,\n                              TimeUnit unit,\n                              BlockingQueue&lt;Runnable&gt; workQueue,\n                              ThreadFactory threadFactory,\n                              RejectedExecutionHandler handler) {\n</code></pre><ol>\n<li>corePoolSize : 该线程池中核心线程数最大值<br>核心线程：线程池新建线程的时候，如果当前线程总数小于 corePoolSize ，则新建的是核心线程；如果超过corePoolSize，则新建的是非核心线程。核心线程默认情况下会一直存活在线程池中，即使这个核心线程啥也不干(闲置状态)。如果指定ThreadPoolExecutor的 allowCoreThreadTimeOut 这个属性为true，那么核心线程如果不干活(闲置状态)的话，超过一定时间( keepAliveTime)，就会被销毁掉.</li>\n<li>maximumPoolSize ：该线程池中线程总数的最大值<br>线程总数计算公式 = 核心线程数 + 非核心线程数。</li>\n<li>keepAliveTime  ：该线程池中非核心线程闲置超时时长<br>注意：一个非核心线程，如果不干活(闲置状态)的时长，超过这个参数所设定的时长，就会被销毁掉。但是，如果设置了  allowCoreThreadTimeOut = true，则会作用于核心线程。</li>\n<li>unit ：（时间单位）<br>首先，TimeUnit是一个枚举类型，翻译过来就是时间单位，我们最常用的时间单位包括：<br>MILLISECONDS ： 1毫秒 、SECONDS ： 秒、MINUTES ： 分、HOURS ： 小时、DAYS ： 天</li>\n<li>BlockingQueue<runnable> workQueue ：( Blocking：阻塞的，queue：队列)，主要有四种队列<ul>\n<li>SynchronousQueue：（同步队列）这个队列接收到任务的时候，会直接提交给线程处理，而不保留它（名字定义为 同步队列），所有该队列跟设置的corePoolSize无效。但有一种情况，假设所有线程都在工作怎么办？这种情况下，SynchronousQueue就会新建一个线程来处理这个任务。所以为了保证不出现（线程数达到了maximumPoolSize而不能新建线程）的错误，使用这个类型队列的时候，maximumPoolSize一般指定成Integer.MAX_VALUE，即无限大，去规避这个使用风险。<ul>\n<li>LinkedBlockingQueue（链表阻塞队列）：这个队列接收到任务的时候，如果当前线程数小于核心线程数，则新建线程(核心线程)处理任务；如果当前线程数等于核心线程数，则进入队列等待。由于这个队列没有最大值限制，即所有超过核心线程数的任务都将被添加到队列中，这也就导致了maximumPoolSize的设定失效，因为总线程数永远不会超过corePoolSize</li>\n<li>ArrayBlockingQueue（数组阻塞队列）：可以限定队列的长度（既然是数组，那么就限定了大小），接收到任务的时候，如果没有达到corePoolSize的值，则新建线程(核心线程)执行任务，如果达到了，则入队等候，如果队列已满，则新建线程(非核心线程)执行任务，又如果总线程数到了maximumPoolSize，并且队列也满了，则发生错误</li>\n<li>DelayQueue（延迟队列）：队列内元素必须实现Delayed接口，这就意味着你传进去的任务必须先实现Delayed接口。这个队列接收到任务时，首先先入队，只有达到了指定的延时时间，才会执行任务</li>\n</ul>\n</li>\n</ul>\n</runnable></li>\n<li>ThreadFactory threadFactory = &gt; 创建线程的方式，这是一个接口，new它的时候需要实现他的Thread newThread(Runnable r)方法</li>\n<li>RejectedExecutionHandler handler = &gt; 这个主要是用来抛异常的<br>当线程无法执行新任务时（一般是由于线程池中的线程数量已经达到最大数或者线程池关闭导致的），默认情况下，当线程池无法处理新线程时，会抛出一个RejectedExecutionException。</li>\n</ol>\n<p>以 LinkedBlockingQueue、ArrayBlockingQueue 和 SynchronousQueue 为例，我们一起来分析一下，根据需求可以从很多方面考量：</p>\n<h3 id=\"ArrayBlockingQueue-LinkedBlockingQueue-SynchronousQueue\"><a href=\"#ArrayBlockingQueue-LinkedBlockingQueue-SynchronousQueue\" class=\"headerlink\" title=\"ArrayBlockingQueue ,LinkedBlockingQueue ,SynchronousQueue\"></a>ArrayBlockingQueue ,LinkedBlockingQueue ,SynchronousQueue</h3><ul>\n<li>从空间利用角度，数组结构的 ArrayBlockingQueue 要比 LinkedBlockingQueue 紧凑，因为其不需要创建所谓节点，但是其初始分配阶段就需要一段连续的空间，所以初始内存需求更大。</li>\n<li>通用场景中，LinkedBlockingQueue 的吞吐量一般优于 ArrayBlockingQueue，因为它实现了更加细粒度的锁操作。</li>\n<li>ArrayBlockingQueue 实现比较简单，性能更好预测，属于表现稳定的“选手”。</li>\n<li>如果我们需要实现的是两个线程之间接力性（handoff）的场景，按照专栏上一讲的例子，你可能会选择 CountDownLatch，但是SynchronousQueue也是完美符合这种场景的，而且线程间协调和数据传输统一起来，代码更加规范。</li>\n<li>可能令人意外的是，很多时候 SynchronousQueue 的性能表现，往往大大超过其他实现，尤其是在队列元素较小的场景。</li>\n</ul>\n<h3 id=\"重点源码分享\"><a href=\"#重点源码分享\" class=\"headerlink\" title=\"重点源码分享\"></a>重点源码分享</h3><p>okhttp</p>\n<pre><code> public synchronized ExecutorService executorService() {\n    if (executorService == null) {\n      executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,\n          new SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(&quot;OkHttp Dispatcher&quot;, false));\n    }\n    return executorService;\n  }\n</code></pre><pre><code> synchronized void enqueue(AsyncCall call) {\n    if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) {\n      runningAsyncCalls.add(call);\n      executorService().execute(call);\n    } else {\n      readyAsyncCalls.add(call);\n    }\n  }\n</code></pre><p>AsyncTask</p>\n<pre><code> private static final BlockingQueue&lt;Runnable&gt; sPoolWorkQueue =\n            new LinkedBlockingQueue&lt;Runnable&gt;(128);\n    /**\n     * An {@link Executor} that can be used to execute tasks in parallel.\n     */\n    public static final Executor THREAD_POOL_EXECUTOR;\n    static {\n        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(\n                CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS,\n                sPoolWorkQueue, sThreadFactory);\n        threadPoolExecutor.allowCoreThreadTimeOut(true);\n        THREAD_POOL_EXECUTOR = threadPoolExecutor;\n    }\n</code></pre><pre><code>private static class SerialExecutor implements Executor {\n        final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;();\n        Runnable mActive;\n\n        public synchronized void execute(final Runnable r) {\n            mTasks.offer(new Runnable() {\n                public void run() {\n                    try {\n                        r.run();\n                    } finally {\n                        scheduleNext();\n                    }\n                }\n            });\n            if (mActive == null) {\n                scheduleNext();\n            }\n        }\n\n        protected synchronized void scheduleNext() {\n            if ((mActive = mTasks.poll()) != null) {\n                THREAD_POOL_EXECUTOR.execute(mActive);\n            }\n        }\n    }\n</code></pre>"},{"title":"Swift入门专题","date":"2015-11-13T10:30:00.000Z","_content":"\n## Swift初见 -- 张超耀\n\n### 宏 \n```\n// in objective-c, but in swift, #define can't be used any more  \n// use let keyword to define a macro, look up original document:  \n/*  \nSimple Macros  \nWhere you typically used the #define directive to define a primitive constant in C and Objective-C, in Swift you use a global constant instead. For example, the constant definition #define FADE_ANIMATION_DURATION 0.35 can be better expressed in Swift with let FADE_ANIMATION_DURATION = 0.35. Because simple constant-like macros map directly to Swift global variables, the compiler automatically imports simple macros defined in C and Objective-C source files.  \n*/  \n// in objective-c  \n// #define kCommonAPI @\"http://xxxxxxx\"  \n// but in swift, no #define, just use let to define  \nlet kCommonAPI = \"http://xxxxxxx\"\n```\n### 注释 & 分号\n- 在Swift中，注释跟C/OC语言中的注释很像，但最大的不同点就是在Swift中多行注释可以嵌套\n\n```\n// 这是单行注释  \n  \n/* 这也是注释，但是多行注释   \n  /*多行注释在swift中是可以嵌套的*/  \n  /*原官方指导教程上说嵌套多行注释可以快速、简单地把大的代码块分成多块来注释 */  \n*/ \n\n```\n\n- 与其它开发语言不同的时，swift是不要求写分号的，当然如果想写，也是可以的。当你想把多个语句写到同一行时，这种情况下就一定要使用分号来隔开不同的语句了\n\n``` \nlet dog = \"a gog\" // 可以不添加分号  \nlet cat = \"a cat\"; print(cat)// 除了最后一条语句可以不添加分号外，其它都需要添加分号来隔开  \nlet catTwo = \"two cats\"; let name = \"Jobs\"; print(\"\\(name) has \\(catTwos)\")  \n\n```\n\n### 类型转换\n- Swift不会像C、OC那样自动**隐式转换**类型，所以我们需要手动进行类型转换 \n\n\n```\nlet twoThousand: UInt16 = 2000   \n// one是UInt8类型  \nlet one: UInt8 = 1  \n// twoThousand是UInt16类型，one是UInt8类型，如果要执行相加，那么就需要进行类型转换   \n// 否则会报错的。  \nlet twoThousandAndOne = twoThousand + UInt16(one) \n\n** 浮点值转换成整型时，会截尾**\n```\n\n### 类型别名(Typealias)\n\n- 类型别名也就是给已经存在的类型起一个别名。定义类型别名是使用关键字typealias。 类型别名一般是为了让开发者更容易看出变量或者常量的类型或者是更好地归类某一个模块中需要使用到的类型，让开发者见名知意。\n\n```\n// 下面是给UInt16起一个别名，叫mySample  \n// 然后就可以在其它地方使用这个mySample声明变量或者常量  \ntypealias mySample = UInt16  \n  \n// 由于前面已经定义了类型别名，那么这里使用AudioSample也相当于使用UInt16  \n所以mySample.min = UInt16.min,也就是0 \nvar maxAmplitudeFound = mySample.min  \n```\n\n### \"?\" 和 \"!\" \n- Swift语言使用var定义变量，但和别的语言不同，Swift里不会自动给变量赋初始值， 也就是说变量不会有默认值，所以要求使用变量之前必须要对其初始化\n。如果在使用变量之前不进行初始化就会报错.\n\n```\nvar stringValue : String?\nstringValue = nil\nprint(\"\\(stringValue)\")\nlet hashValue = stringValue?.hashValue\n\n// 这就是optional, strValue自动得到默认值：nil\n// 这个nil跟Objective-C中的nil不同，不是指针，而是表示值不存在。\nvar strValue: String?\n\n// 判断optional是否有值\nif (strValue != nil) {\n    // do what you need to do here\n}\n```\n\n##下期预告\n### 深度理解Swift的\"?\"和\"!\"\n### Swift之断言\n### 浅谈Swift的closure\n\n## Dubbo 上手 -- 陈奎\n\n## 『图像和滤镜』 - 图像选择器\n\n`我们可以使用以下常规的图像获取方式`\n\n![Alt text](./Simulator Screen Shot Nov 12, 2015, 8.11.12 PM.png)\n\n`图库与相册`\n\n![Alt text](./Simulator Screen Shot Nov 12, 2015, 8.16.30 PM.png)\n\n\n#### 系统自带\n``` swift\noverride func touchesBegan(touches: Set<UITouch>, withEvent event: UIEvent?) {\n    \n    let sheet = UIAlertController(title: \"图片选择\", message: \"简单版的三种选择\", preferredStyle: .ActionSheet)\n    // 判断设备是否支持相机（iPod & Simulator）\n    if (UIImagePickerController.isSourceTypeAvailable(.Camera)) {\n        sheet.addAction(UIAlertAction.init(title: \"Camera\", style: .Default, handler: { _ in\n            self.showPhotoes(.Camera)\n        }))\n    }\n    sheet.addAction(UIAlertAction.init(title: \"PhotoLibrary\", style: .Default, handler: { _ in\n        self.showPhotoes(.PhotoLibrary)\n    }))\n    sheet.addAction(UIAlertAction.init(title: \"SavedPhotosAlbum\", style: .Default, handler: { _ in\n        self.showPhotoes(.SavedPhotosAlbum)\n    }))\n    sheet.addAction(UIAlertAction.init(title: \"Cancel\", style: .Cancel, handler: nil))\n    presentViewController(sheet, animated: true, completion: nil)\n}\n```\n```\nfunc showPhotoes(source: UIImagePickerControllerSourceType) {\n    let controller = UIImagePickerController()\n    controller.delegate = self\n    controller.sourceType = source\n    controller.allowsEditing = source == .SavedPhotosAlbum ? true:false\n\n    self.presentViewController(controller, animated: true, completion: nil)\n}\n```\n`UIImagePickerController的代理`\n```\nfunc imagePickerControllerDidCancel(picker: UIImagePickerController) {\n    dismissViewControllerAnimated(true, completion: nil)\n}\n// 非常坑，这个方法废弃了但代码提示只有它\n//\tfunc imagePickerController(picker: UIImagePickerController, didFinishPickingImage image: UIImage, editingInfo: [String : AnyObject]?) {\n//\t}\nfunc imagePickerController(picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [String : AnyObject]) {\n}\n```\n#####[info字典介绍](https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIImagePickerControllerDelegate_Protocol/#//apple_ref/doc/constant_group/Editing_Information_Keys)\n```\nUIImagePickerControllerMediaType: String\nUIImagePickerControllerOriginalImage: UIImage\nUIImagePickerControllerEditedImage: UIImage\nUIImagePickerControllerCropRect: NSValue -> CGRect\n// MediaURL只为视频提供\nUIImagePickerControllerMediaURL:  NSURL\n// LivePhoto是一张图片，保留那个moment的前后动作和声音\nUIImagePickerControllerLivePhoto: String\n// 摄像摄影时返回media的信息字典\nUIImagePickerControllerMediaMetadata: NSDictionary\n```\n```\n// SavedPhotosAlbum 的 info 示例\n\n▿ 5 elements\n  ▿ [0] : 2 elements\n    - .0 : \"UIImagePickerControllerCropRect\"\n  ▿ [1] : 2 elements\n    - .0 : \"UIImagePickerControllerOriginalImage\"\n  ▿ [2] : 2 elements\n    - .0 : \"UIImagePickerControllerReferenceURL\"\n    - .1 : assets-library://asset/asset.JPG?id=99D53A1F-FEEF-40E1-8BB3-7DD55A43C8B7&ext=JPG\n  ▿ [3] : 2 elements\n    - .0 : \"UIImagePickerControllerMediaType\"\n    - .1 : public.image\n  ▿ [4] : 2 elements\n    - .0 : \"UIImagePickerControllerEditedImage\"\n```\n### 自定义\n\n![Alt text](./1447343597718.png)\n\n遍历相册的所有图片\n``` swift\n// AssetsLibrary.framework\n// ALAssetsLibrary 的使用,但是它慢慢的被放弃了\n    func loadLocalPhotoes(){\n        var countOne = 0\n        //ALAssetsGroupSavedPhotos表示只读取相机胶卷（ALAssetsGroupAll则读取全部相簿）\n        assetsLibrary.enumerateGroupsWithTypes(ALAssetsGroupSavedPhotos, usingBlock: {\n            (group: ALAssetsGroup!, stop) in\n            print(\"is goin\")\n            if group != nil {\n                let assetBlock : ALAssetsGroupEnumerationResultsBlock = {\n                    (result: ALAsset!, index: Int, stop) in\n                    if result != nil {\n                        self.assets.append(result)\n                        countOne++\n                    }\n                }\n                group.enumerateAssetsUsingBlock(assetBlock)\n                print(\"assets:\\(countOne)\")\n                self.startChangeLocalImages(0)\n            }\n            }, failureBlock: { (fail) in\n                print(fail)\n        })\n    }\n    \n// 展现本地图片\nfunc startChangeLocalImages(var index: Int){\n        if index==assets.count {\n            index = 0\n        }\n        let myAsset = assets[index]\n        let image = UIImage(CGImage:myAsset.thumbnail().takeUnretainedValue())\n        self.backImageView.image = image\n        \n        let popTime = dispatch_time(DISPATCH_TIME_NOW, Int64(1 * Double(NSEC_PER_SEC)))\n        dispatch_after(popTime, dispatch_get_main_queue()) {\n            self.startChangeLocalImages(index+1)\n        }\n    }\n```\niOS9 开始使用新库\n[PHPhotoLibrary](https://developer.apple.com/library/prerelease/ios/documentation/Photos/Reference/PHPhotoLibrary_Class/index.html)\n","source":"_posts/Swift入门专题.md","raw":"title: Swift入门专题\n\ndate: 2015-11-13  10:30:00\n\ntags:\n\ncategories: 移动组周分享\n\n---\n\n## Swift初见 -- 张超耀\n\n### 宏 \n```\n// in objective-c, but in swift, #define can't be used any more  \n// use let keyword to define a macro, look up original document:  \n/*  \nSimple Macros  \nWhere you typically used the #define directive to define a primitive constant in C and Objective-C, in Swift you use a global constant instead. For example, the constant definition #define FADE_ANIMATION_DURATION 0.35 can be better expressed in Swift with let FADE_ANIMATION_DURATION = 0.35. Because simple constant-like macros map directly to Swift global variables, the compiler automatically imports simple macros defined in C and Objective-C source files.  \n*/  \n// in objective-c  \n// #define kCommonAPI @\"http://xxxxxxx\"  \n// but in swift, no #define, just use let to define  \nlet kCommonAPI = \"http://xxxxxxx\"\n```\n### 注释 & 分号\n- 在Swift中，注释跟C/OC语言中的注释很像，但最大的不同点就是在Swift中多行注释可以嵌套\n\n```\n// 这是单行注释  \n  \n/* 这也是注释，但是多行注释   \n  /*多行注释在swift中是可以嵌套的*/  \n  /*原官方指导教程上说嵌套多行注释可以快速、简单地把大的代码块分成多块来注释 */  \n*/ \n\n```\n\n- 与其它开发语言不同的时，swift是不要求写分号的，当然如果想写，也是可以的。当你想把多个语句写到同一行时，这种情况下就一定要使用分号来隔开不同的语句了\n\n``` \nlet dog = \"a gog\" // 可以不添加分号  \nlet cat = \"a cat\"; print(cat)// 除了最后一条语句可以不添加分号外，其它都需要添加分号来隔开  \nlet catTwo = \"two cats\"; let name = \"Jobs\"; print(\"\\(name) has \\(catTwos)\")  \n\n```\n\n### 类型转换\n- Swift不会像C、OC那样自动**隐式转换**类型，所以我们需要手动进行类型转换 \n\n\n```\nlet twoThousand: UInt16 = 2000   \n// one是UInt8类型  \nlet one: UInt8 = 1  \n// twoThousand是UInt16类型，one是UInt8类型，如果要执行相加，那么就需要进行类型转换   \n// 否则会报错的。  \nlet twoThousandAndOne = twoThousand + UInt16(one) \n\n** 浮点值转换成整型时，会截尾**\n```\n\n### 类型别名(Typealias)\n\n- 类型别名也就是给已经存在的类型起一个别名。定义类型别名是使用关键字typealias。 类型别名一般是为了让开发者更容易看出变量或者常量的类型或者是更好地归类某一个模块中需要使用到的类型，让开发者见名知意。\n\n```\n// 下面是给UInt16起一个别名，叫mySample  \n// 然后就可以在其它地方使用这个mySample声明变量或者常量  \ntypealias mySample = UInt16  \n  \n// 由于前面已经定义了类型别名，那么这里使用AudioSample也相当于使用UInt16  \n所以mySample.min = UInt16.min,也就是0 \nvar maxAmplitudeFound = mySample.min  \n```\n\n### \"?\" 和 \"!\" \n- Swift语言使用var定义变量，但和别的语言不同，Swift里不会自动给变量赋初始值， 也就是说变量不会有默认值，所以要求使用变量之前必须要对其初始化\n。如果在使用变量之前不进行初始化就会报错.\n\n```\nvar stringValue : String?\nstringValue = nil\nprint(\"\\(stringValue)\")\nlet hashValue = stringValue?.hashValue\n\n// 这就是optional, strValue自动得到默认值：nil\n// 这个nil跟Objective-C中的nil不同，不是指针，而是表示值不存在。\nvar strValue: String?\n\n// 判断optional是否有值\nif (strValue != nil) {\n    // do what you need to do here\n}\n```\n\n##下期预告\n### 深度理解Swift的\"?\"和\"!\"\n### Swift之断言\n### 浅谈Swift的closure\n\n## Dubbo 上手 -- 陈奎\n\n## 『图像和滤镜』 - 图像选择器\n\n`我们可以使用以下常规的图像获取方式`\n\n![Alt text](./Simulator Screen Shot Nov 12, 2015, 8.11.12 PM.png)\n\n`图库与相册`\n\n![Alt text](./Simulator Screen Shot Nov 12, 2015, 8.16.30 PM.png)\n\n\n#### 系统自带\n``` swift\noverride func touchesBegan(touches: Set<UITouch>, withEvent event: UIEvent?) {\n    \n    let sheet = UIAlertController(title: \"图片选择\", message: \"简单版的三种选择\", preferredStyle: .ActionSheet)\n    // 判断设备是否支持相机（iPod & Simulator）\n    if (UIImagePickerController.isSourceTypeAvailable(.Camera)) {\n        sheet.addAction(UIAlertAction.init(title: \"Camera\", style: .Default, handler: { _ in\n            self.showPhotoes(.Camera)\n        }))\n    }\n    sheet.addAction(UIAlertAction.init(title: \"PhotoLibrary\", style: .Default, handler: { _ in\n        self.showPhotoes(.PhotoLibrary)\n    }))\n    sheet.addAction(UIAlertAction.init(title: \"SavedPhotosAlbum\", style: .Default, handler: { _ in\n        self.showPhotoes(.SavedPhotosAlbum)\n    }))\n    sheet.addAction(UIAlertAction.init(title: \"Cancel\", style: .Cancel, handler: nil))\n    presentViewController(sheet, animated: true, completion: nil)\n}\n```\n```\nfunc showPhotoes(source: UIImagePickerControllerSourceType) {\n    let controller = UIImagePickerController()\n    controller.delegate = self\n    controller.sourceType = source\n    controller.allowsEditing = source == .SavedPhotosAlbum ? true:false\n\n    self.presentViewController(controller, animated: true, completion: nil)\n}\n```\n`UIImagePickerController的代理`\n```\nfunc imagePickerControllerDidCancel(picker: UIImagePickerController) {\n    dismissViewControllerAnimated(true, completion: nil)\n}\n// 非常坑，这个方法废弃了但代码提示只有它\n//\tfunc imagePickerController(picker: UIImagePickerController, didFinishPickingImage image: UIImage, editingInfo: [String : AnyObject]?) {\n//\t}\nfunc imagePickerController(picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [String : AnyObject]) {\n}\n```\n#####[info字典介绍](https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIImagePickerControllerDelegate_Protocol/#//apple_ref/doc/constant_group/Editing_Information_Keys)\n```\nUIImagePickerControllerMediaType: String\nUIImagePickerControllerOriginalImage: UIImage\nUIImagePickerControllerEditedImage: UIImage\nUIImagePickerControllerCropRect: NSValue -> CGRect\n// MediaURL只为视频提供\nUIImagePickerControllerMediaURL:  NSURL\n// LivePhoto是一张图片，保留那个moment的前后动作和声音\nUIImagePickerControllerLivePhoto: String\n// 摄像摄影时返回media的信息字典\nUIImagePickerControllerMediaMetadata: NSDictionary\n```\n```\n// SavedPhotosAlbum 的 info 示例\n\n▿ 5 elements\n  ▿ [0] : 2 elements\n    - .0 : \"UIImagePickerControllerCropRect\"\n  ▿ [1] : 2 elements\n    - .0 : \"UIImagePickerControllerOriginalImage\"\n  ▿ [2] : 2 elements\n    - .0 : \"UIImagePickerControllerReferenceURL\"\n    - .1 : assets-library://asset/asset.JPG?id=99D53A1F-FEEF-40E1-8BB3-7DD55A43C8B7&ext=JPG\n  ▿ [3] : 2 elements\n    - .0 : \"UIImagePickerControllerMediaType\"\n    - .1 : public.image\n  ▿ [4] : 2 elements\n    - .0 : \"UIImagePickerControllerEditedImage\"\n```\n### 自定义\n\n![Alt text](./1447343597718.png)\n\n遍历相册的所有图片\n``` swift\n// AssetsLibrary.framework\n// ALAssetsLibrary 的使用,但是它慢慢的被放弃了\n    func loadLocalPhotoes(){\n        var countOne = 0\n        //ALAssetsGroupSavedPhotos表示只读取相机胶卷（ALAssetsGroupAll则读取全部相簿）\n        assetsLibrary.enumerateGroupsWithTypes(ALAssetsGroupSavedPhotos, usingBlock: {\n            (group: ALAssetsGroup!, stop) in\n            print(\"is goin\")\n            if group != nil {\n                let assetBlock : ALAssetsGroupEnumerationResultsBlock = {\n                    (result: ALAsset!, index: Int, stop) in\n                    if result != nil {\n                        self.assets.append(result)\n                        countOne++\n                    }\n                }\n                group.enumerateAssetsUsingBlock(assetBlock)\n                print(\"assets:\\(countOne)\")\n                self.startChangeLocalImages(0)\n            }\n            }, failureBlock: { (fail) in\n                print(fail)\n        })\n    }\n    \n// 展现本地图片\nfunc startChangeLocalImages(var index: Int){\n        if index==assets.count {\n            index = 0\n        }\n        let myAsset = assets[index]\n        let image = UIImage(CGImage:myAsset.thumbnail().takeUnretainedValue())\n        self.backImageView.image = image\n        \n        let popTime = dispatch_time(DISPATCH_TIME_NOW, Int64(1 * Double(NSEC_PER_SEC)))\n        dispatch_after(popTime, dispatch_get_main_queue()) {\n            self.startChangeLocalImages(index+1)\n        }\n    }\n```\niOS9 开始使用新库\n[PHPhotoLibrary](https://developer.apple.com/library/prerelease/ios/documentation/Photos/Reference/PHPhotoLibrary_Class/index.html)\n","slug":"Swift入门专题","published":1,"updated":"2021-09-10T07:04:21.944Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cktfeap3y001ec2xxs2gm0pui","content":"<h2 id=\"Swift初见-–-张超耀\"><a href=\"#Swift初见-–-张超耀\" class=\"headerlink\" title=\"Swift初见 – 张超耀\"></a>Swift初见 – 张超耀</h2><h3 id=\"宏\"><a href=\"#宏\" class=\"headerlink\" title=\"宏\"></a>宏</h3><pre><code>// in objective-c, but in swift, #define can&#39;t be used any more  \n// use let keyword to define a macro, look up original document:  \n/*  \nSimple Macros  \nWhere you typically used the #define directive to define a primitive constant in C and Objective-C, in Swift you use a global constant instead. For example, the constant definition #define FADE_ANIMATION_DURATION 0.35 can be better expressed in Swift with let FADE_ANIMATION_DURATION = 0.35. Because simple constant-like macros map directly to Swift global variables, the compiler automatically imports simple macros defined in C and Objective-C source files.  \n*/  \n// in objective-c  \n// #define kCommonAPI @&quot;http://xxxxxxx&quot;  \n// but in swift, no #define, just use let to define  \nlet kCommonAPI = &quot;http://xxxxxxx&quot;\n</code></pre><h3 id=\"注释-amp-分号\"><a href=\"#注释-amp-分号\" class=\"headerlink\" title=\"注释 &amp; 分号\"></a>注释 &amp; 分号</h3><ul>\n<li>在Swift中，注释跟C/OC语言中的注释很像，但最大的不同点就是在Swift中多行注释可以嵌套</li>\n</ul>\n<pre><code>// 这是单行注释  \n\n/* 这也是注释，但是多行注释   \n  /*多行注释在swift中是可以嵌套的*/  \n  /*原官方指导教程上说嵌套多行注释可以快速、简单地把大的代码块分成多块来注释 */  \n*/\n</code></pre><ul>\n<li>与其它开发语言不同的时，swift是不要求写分号的，当然如果想写，也是可以的。当你想把多个语句写到同一行时，这种情况下就一定要使用分号来隔开不同的语句了</li>\n</ul>\n<pre><code>let dog = &quot;a gog&quot; // 可以不添加分号  \nlet cat = &quot;a cat&quot;; print(cat)// 除了最后一条语句可以不添加分号外，其它都需要添加分号来隔开  \nlet catTwo = &quot;two cats&quot;; let name = &quot;Jobs&quot;; print(&quot;\\(name) has \\(catTwos)&quot;)\n</code></pre><h3 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a>类型转换</h3><ul>\n<li>Swift不会像C、OC那样自动<strong>隐式转换</strong>类型，所以我们需要手动进行类型转换 </li>\n</ul>\n<pre><code>let twoThousand: UInt16 = 2000   \n// one是UInt8类型  \nlet one: UInt8 = 1  \n// twoThousand是UInt16类型，one是UInt8类型，如果要执行相加，那么就需要进行类型转换   \n// 否则会报错的。  \nlet twoThousandAndOne = twoThousand + UInt16(one) \n\n** 浮点值转换成整型时，会截尾**\n</code></pre><h3 id=\"类型别名-Typealias\"><a href=\"#类型别名-Typealias\" class=\"headerlink\" title=\"类型别名(Typealias)\"></a>类型别名(Typealias)</h3><ul>\n<li>类型别名也就是给已经存在的类型起一个别名。定义类型别名是使用关键字typealias。 类型别名一般是为了让开发者更容易看出变量或者常量的类型或者是更好地归类某一个模块中需要使用到的类型，让开发者见名知意。</li>\n</ul>\n<pre><code>// 下面是给UInt16起一个别名，叫mySample  \n// 然后就可以在其它地方使用这个mySample声明变量或者常量  \ntypealias mySample = UInt16  \n\n// 由于前面已经定义了类型别名，那么这里使用AudioSample也相当于使用UInt16  \n所以mySample.min = UInt16.min,也就是0 \nvar maxAmplitudeFound = mySample.min\n</code></pre><h3 id=\"“-”-和-“-”\"><a href=\"#“-”-和-“-”\" class=\"headerlink\" title=\"“?” 和 “!”\"></a>“?” 和 “!”</h3><ul>\n<li>Swift语言使用var定义变量，但和别的语言不同，Swift里不会自动给变量赋初始值， 也就是说变量不会有默认值，所以要求使用变量之前必须要对其初始化<br>。如果在使用变量之前不进行初始化就会报错.</li>\n</ul>\n<pre><code>var stringValue : String?\nstringValue = nil\nprint(&quot;\\(stringValue)&quot;)\nlet hashValue = stringValue?.hashValue\n\n// 这就是optional, strValue自动得到默认值：nil\n// 这个nil跟Objective-C中的nil不同，不是指针，而是表示值不存在。\nvar strValue: String?\n\n// 判断optional是否有值\nif (strValue != nil) {\n    // do what you need to do here\n}\n</code></pre><p>##下期预告</p>\n<h3 id=\"深度理解Swift的”-”和”-”\"><a href=\"#深度理解Swift的”-”和”-”\" class=\"headerlink\" title=\"深度理解Swift的”?”和”!”\"></a>深度理解Swift的”?”和”!”</h3><h3 id=\"Swift之断言\"><a href=\"#Swift之断言\" class=\"headerlink\" title=\"Swift之断言\"></a>Swift之断言</h3><h3 id=\"浅谈Swift的closure\"><a href=\"#浅谈Swift的closure\" class=\"headerlink\" title=\"浅谈Swift的closure\"></a>浅谈Swift的closure</h3><h2 id=\"Dubbo-上手-–-陈奎\"><a href=\"#Dubbo-上手-–-陈奎\" class=\"headerlink\" title=\"Dubbo 上手 – 陈奎\"></a>Dubbo 上手 – 陈奎</h2><h2 id=\"『图像和滤镜』-图像选择器\"><a href=\"#『图像和滤镜』-图像选择器\" class=\"headerlink\" title=\"『图像和滤镜』 - 图像选择器\"></a>『图像和滤镜』 - 图像选择器</h2><p><code>我们可以使用以下常规的图像获取方式</code></p>\n<p><img src=\"./Simulator Screen Shot Nov 12, 2015, 8.11.12 PM.png\" alt=\"Alt text\"></p>\n<p><code>图库与相册</code></p>\n<p><img src=\"./Simulator Screen Shot Nov 12, 2015, 8.16.30 PM.png\" alt=\"Alt text\"></p>\n<h4 id=\"系统自带\"><a href=\"#系统自带\" class=\"headerlink\" title=\"系统自带\"></a>系统自带</h4><pre><code class=\"swift\">override func touchesBegan(touches: Set&lt;UITouch&gt;, withEvent event: UIEvent?) {\n\n    let sheet = UIAlertController(title: &quot;图片选择&quot;, message: &quot;简单版的三种选择&quot;, preferredStyle: .ActionSheet)\n    // 判断设备是否支持相机（iPod &amp; Simulator）\n    if (UIImagePickerController.isSourceTypeAvailable(.Camera)) {\n        sheet.addAction(UIAlertAction.init(title: &quot;Camera&quot;, style: .Default, handler: { _ in\n            self.showPhotoes(.Camera)\n        }))\n    }\n    sheet.addAction(UIAlertAction.init(title: &quot;PhotoLibrary&quot;, style: .Default, handler: { _ in\n        self.showPhotoes(.PhotoLibrary)\n    }))\n    sheet.addAction(UIAlertAction.init(title: &quot;SavedPhotosAlbum&quot;, style: .Default, handler: { _ in\n        self.showPhotoes(.SavedPhotosAlbum)\n    }))\n    sheet.addAction(UIAlertAction.init(title: &quot;Cancel&quot;, style: .Cancel, handler: nil))\n    presentViewController(sheet, animated: true, completion: nil)\n}\n</code></pre>\n<pre><code>func showPhotoes(source: UIImagePickerControllerSourceType) {\n    let controller = UIImagePickerController()\n    controller.delegate = self\n    controller.sourceType = source\n    controller.allowsEditing = source == .SavedPhotosAlbum ? true:false\n\n    self.presentViewController(controller, animated: true, completion: nil)\n}\n</code></pre><p><code>UIImagePickerController的代理</code></p>\n<pre><code>func imagePickerControllerDidCancel(picker: UIImagePickerController) {\n    dismissViewControllerAnimated(true, completion: nil)\n}\n// 非常坑，这个方法废弃了但代码提示只有它\n//    func imagePickerController(picker: UIImagePickerController, didFinishPickingImage image: UIImage, editingInfo: [String : AnyObject]?) {\n//    }\nfunc imagePickerController(picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [String : AnyObject]) {\n}\n</code></pre><p>#####<a href=\"https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIImagePickerControllerDelegate_Protocol/#//apple_ref/doc/constant_group/Editing_Information_Keys\" target=\"_blank\" rel=\"noopener\">info字典介绍</a></p>\n<pre><code>UIImagePickerControllerMediaType: String\nUIImagePickerControllerOriginalImage: UIImage\nUIImagePickerControllerEditedImage: UIImage\nUIImagePickerControllerCropRect: NSValue -&gt; CGRect\n// MediaURL只为视频提供\nUIImagePickerControllerMediaURL:  NSURL\n// LivePhoto是一张图片，保留那个moment的前后动作和声音\nUIImagePickerControllerLivePhoto: String\n// 摄像摄影时返回media的信息字典\nUIImagePickerControllerMediaMetadata: NSDictionary\n</code></pre><pre><code>// SavedPhotosAlbum 的 info 示例\n\n▿ 5 elements\n  ▿ [0] : 2 elements\n    - .0 : &quot;UIImagePickerControllerCropRect&quot;\n  ▿ [1] : 2 elements\n    - .0 : &quot;UIImagePickerControllerOriginalImage&quot;\n  ▿ [2] : 2 elements\n    - .0 : &quot;UIImagePickerControllerReferenceURL&quot;\n    - .1 : assets-library://asset/asset.JPG?id=99D53A1F-FEEF-40E1-8BB3-7DD55A43C8B7&amp;ext=JPG\n  ▿ [3] : 2 elements\n    - .0 : &quot;UIImagePickerControllerMediaType&quot;\n    - .1 : public.image\n  ▿ [4] : 2 elements\n    - .0 : &quot;UIImagePickerControllerEditedImage&quot;\n</code></pre><h3 id=\"自定义\"><a href=\"#自定义\" class=\"headerlink\" title=\"自定义\"></a>自定义</h3><p><img src=\"./1447343597718.png\" alt=\"Alt text\"></p>\n<p>遍历相册的所有图片</p>\n<pre><code class=\"swift\">// AssetsLibrary.framework\n// ALAssetsLibrary 的使用,但是它慢慢的被放弃了\n    func loadLocalPhotoes(){\n        var countOne = 0\n        //ALAssetsGroupSavedPhotos表示只读取相机胶卷（ALAssetsGroupAll则读取全部相簿）\n        assetsLibrary.enumerateGroupsWithTypes(ALAssetsGroupSavedPhotos, usingBlock: {\n            (group: ALAssetsGroup!, stop) in\n            print(&quot;is goin&quot;)\n            if group != nil {\n                let assetBlock : ALAssetsGroupEnumerationResultsBlock = {\n                    (result: ALAsset!, index: Int, stop) in\n                    if result != nil {\n                        self.assets.append(result)\n                        countOne++\n                    }\n                }\n                group.enumerateAssetsUsingBlock(assetBlock)\n                print(&quot;assets:\\(countOne)&quot;)\n                self.startChangeLocalImages(0)\n            }\n            }, failureBlock: { (fail) in\n                print(fail)\n        })\n    }\n\n// 展现本地图片\nfunc startChangeLocalImages(var index: Int){\n        if index==assets.count {\n            index = 0\n        }\n        let myAsset = assets[index]\n        let image = UIImage(CGImage:myAsset.thumbnail().takeUnretainedValue())\n        self.backImageView.image = image\n\n        let popTime = dispatch_time(DISPATCH_TIME_NOW, Int64(1 * Double(NSEC_PER_SEC)))\n        dispatch_after(popTime, dispatch_get_main_queue()) {\n            self.startChangeLocalImages(index+1)\n        }\n    }\n</code></pre>\n<p>iOS9 开始使用新库<br><a href=\"https://developer.apple.com/library/prerelease/ios/documentation/Photos/Reference/PHPhotoLibrary_Class/index.html\" target=\"_blank\" rel=\"noopener\">PHPhotoLibrary</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Swift初见-–-张超耀\"><a href=\"#Swift初见-–-张超耀\" class=\"headerlink\" title=\"Swift初见 – 张超耀\"></a>Swift初见 – 张超耀</h2><h3 id=\"宏\"><a href=\"#宏\" class=\"headerlink\" title=\"宏\"></a>宏</h3><pre><code>// in objective-c, but in swift, #define can&#39;t be used any more  \n// use let keyword to define a macro, look up original document:  \n/*  \nSimple Macros  \nWhere you typically used the #define directive to define a primitive constant in C and Objective-C, in Swift you use a global constant instead. For example, the constant definition #define FADE_ANIMATION_DURATION 0.35 can be better expressed in Swift with let FADE_ANIMATION_DURATION = 0.35. Because simple constant-like macros map directly to Swift global variables, the compiler automatically imports simple macros defined in C and Objective-C source files.  \n*/  \n// in objective-c  \n// #define kCommonAPI @&quot;http://xxxxxxx&quot;  \n// but in swift, no #define, just use let to define  \nlet kCommonAPI = &quot;http://xxxxxxx&quot;\n</code></pre><h3 id=\"注释-amp-分号\"><a href=\"#注释-amp-分号\" class=\"headerlink\" title=\"注释 &amp; 分号\"></a>注释 &amp; 分号</h3><ul>\n<li>在Swift中，注释跟C/OC语言中的注释很像，但最大的不同点就是在Swift中多行注释可以嵌套</li>\n</ul>\n<pre><code>// 这是单行注释  \n\n/* 这也是注释，但是多行注释   \n  /*多行注释在swift中是可以嵌套的*/  \n  /*原官方指导教程上说嵌套多行注释可以快速、简单地把大的代码块分成多块来注释 */  \n*/\n</code></pre><ul>\n<li>与其它开发语言不同的时，swift是不要求写分号的，当然如果想写，也是可以的。当你想把多个语句写到同一行时，这种情况下就一定要使用分号来隔开不同的语句了</li>\n</ul>\n<pre><code>let dog = &quot;a gog&quot; // 可以不添加分号  \nlet cat = &quot;a cat&quot;; print(cat)// 除了最后一条语句可以不添加分号外，其它都需要添加分号来隔开  \nlet catTwo = &quot;two cats&quot;; let name = &quot;Jobs&quot;; print(&quot;\\(name) has \\(catTwos)&quot;)\n</code></pre><h3 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a>类型转换</h3><ul>\n<li>Swift不会像C、OC那样自动<strong>隐式转换</strong>类型，所以我们需要手动进行类型转换 </li>\n</ul>\n<pre><code>let twoThousand: UInt16 = 2000   \n// one是UInt8类型  \nlet one: UInt8 = 1  \n// twoThousand是UInt16类型，one是UInt8类型，如果要执行相加，那么就需要进行类型转换   \n// 否则会报错的。  \nlet twoThousandAndOne = twoThousand + UInt16(one) \n\n** 浮点值转换成整型时，会截尾**\n</code></pre><h3 id=\"类型别名-Typealias\"><a href=\"#类型别名-Typealias\" class=\"headerlink\" title=\"类型别名(Typealias)\"></a>类型别名(Typealias)</h3><ul>\n<li>类型别名也就是给已经存在的类型起一个别名。定义类型别名是使用关键字typealias。 类型别名一般是为了让开发者更容易看出变量或者常量的类型或者是更好地归类某一个模块中需要使用到的类型，让开发者见名知意。</li>\n</ul>\n<pre><code>// 下面是给UInt16起一个别名，叫mySample  \n// 然后就可以在其它地方使用这个mySample声明变量或者常量  \ntypealias mySample = UInt16  \n\n// 由于前面已经定义了类型别名，那么这里使用AudioSample也相当于使用UInt16  \n所以mySample.min = UInt16.min,也就是0 \nvar maxAmplitudeFound = mySample.min\n</code></pre><h3 id=\"“-”-和-“-”\"><a href=\"#“-”-和-“-”\" class=\"headerlink\" title=\"“?” 和 “!”\"></a>“?” 和 “!”</h3><ul>\n<li>Swift语言使用var定义变量，但和别的语言不同，Swift里不会自动给变量赋初始值， 也就是说变量不会有默认值，所以要求使用变量之前必须要对其初始化<br>。如果在使用变量之前不进行初始化就会报错.</li>\n</ul>\n<pre><code>var stringValue : String?\nstringValue = nil\nprint(&quot;\\(stringValue)&quot;)\nlet hashValue = stringValue?.hashValue\n\n// 这就是optional, strValue自动得到默认值：nil\n// 这个nil跟Objective-C中的nil不同，不是指针，而是表示值不存在。\nvar strValue: String?\n\n// 判断optional是否有值\nif (strValue != nil) {\n    // do what you need to do here\n}\n</code></pre><p>##下期预告</p>\n<h3 id=\"深度理解Swift的”-”和”-”\"><a href=\"#深度理解Swift的”-”和”-”\" class=\"headerlink\" title=\"深度理解Swift的”?”和”!”\"></a>深度理解Swift的”?”和”!”</h3><h3 id=\"Swift之断言\"><a href=\"#Swift之断言\" class=\"headerlink\" title=\"Swift之断言\"></a>Swift之断言</h3><h3 id=\"浅谈Swift的closure\"><a href=\"#浅谈Swift的closure\" class=\"headerlink\" title=\"浅谈Swift的closure\"></a>浅谈Swift的closure</h3><h2 id=\"Dubbo-上手-–-陈奎\"><a href=\"#Dubbo-上手-–-陈奎\" class=\"headerlink\" title=\"Dubbo 上手 – 陈奎\"></a>Dubbo 上手 – 陈奎</h2><h2 id=\"『图像和滤镜』-图像选择器\"><a href=\"#『图像和滤镜』-图像选择器\" class=\"headerlink\" title=\"『图像和滤镜』 - 图像选择器\"></a>『图像和滤镜』 - 图像选择器</h2><p><code>我们可以使用以下常规的图像获取方式</code></p>\n<p><img src=\"./Simulator Screen Shot Nov 12, 2015, 8.11.12 PM.png\" alt=\"Alt text\"></p>\n<p><code>图库与相册</code></p>\n<p><img src=\"./Simulator Screen Shot Nov 12, 2015, 8.16.30 PM.png\" alt=\"Alt text\"></p>\n<h4 id=\"系统自带\"><a href=\"#系统自带\" class=\"headerlink\" title=\"系统自带\"></a>系统自带</h4><pre><code class=\"swift\">override func touchesBegan(touches: Set&lt;UITouch&gt;, withEvent event: UIEvent?) {\n\n    let sheet = UIAlertController(title: &quot;图片选择&quot;, message: &quot;简单版的三种选择&quot;, preferredStyle: .ActionSheet)\n    // 判断设备是否支持相机（iPod &amp; Simulator）\n    if (UIImagePickerController.isSourceTypeAvailable(.Camera)) {\n        sheet.addAction(UIAlertAction.init(title: &quot;Camera&quot;, style: .Default, handler: { _ in\n            self.showPhotoes(.Camera)\n        }))\n    }\n    sheet.addAction(UIAlertAction.init(title: &quot;PhotoLibrary&quot;, style: .Default, handler: { _ in\n        self.showPhotoes(.PhotoLibrary)\n    }))\n    sheet.addAction(UIAlertAction.init(title: &quot;SavedPhotosAlbum&quot;, style: .Default, handler: { _ in\n        self.showPhotoes(.SavedPhotosAlbum)\n    }))\n    sheet.addAction(UIAlertAction.init(title: &quot;Cancel&quot;, style: .Cancel, handler: nil))\n    presentViewController(sheet, animated: true, completion: nil)\n}\n</code></pre>\n<pre><code>func showPhotoes(source: UIImagePickerControllerSourceType) {\n    let controller = UIImagePickerController()\n    controller.delegate = self\n    controller.sourceType = source\n    controller.allowsEditing = source == .SavedPhotosAlbum ? true:false\n\n    self.presentViewController(controller, animated: true, completion: nil)\n}\n</code></pre><p><code>UIImagePickerController的代理</code></p>\n<pre><code>func imagePickerControllerDidCancel(picker: UIImagePickerController) {\n    dismissViewControllerAnimated(true, completion: nil)\n}\n// 非常坑，这个方法废弃了但代码提示只有它\n//    func imagePickerController(picker: UIImagePickerController, didFinishPickingImage image: UIImage, editingInfo: [String : AnyObject]?) {\n//    }\nfunc imagePickerController(picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [String : AnyObject]) {\n}\n</code></pre><p>#####<a href=\"https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIImagePickerControllerDelegate_Protocol/#//apple_ref/doc/constant_group/Editing_Information_Keys\" target=\"_blank\" rel=\"noopener\">info字典介绍</a></p>\n<pre><code>UIImagePickerControllerMediaType: String\nUIImagePickerControllerOriginalImage: UIImage\nUIImagePickerControllerEditedImage: UIImage\nUIImagePickerControllerCropRect: NSValue -&gt; CGRect\n// MediaURL只为视频提供\nUIImagePickerControllerMediaURL:  NSURL\n// LivePhoto是一张图片，保留那个moment的前后动作和声音\nUIImagePickerControllerLivePhoto: String\n// 摄像摄影时返回media的信息字典\nUIImagePickerControllerMediaMetadata: NSDictionary\n</code></pre><pre><code>// SavedPhotosAlbum 的 info 示例\n\n▿ 5 elements\n  ▿ [0] : 2 elements\n    - .0 : &quot;UIImagePickerControllerCropRect&quot;\n  ▿ [1] : 2 elements\n    - .0 : &quot;UIImagePickerControllerOriginalImage&quot;\n  ▿ [2] : 2 elements\n    - .0 : &quot;UIImagePickerControllerReferenceURL&quot;\n    - .1 : assets-library://asset/asset.JPG?id=99D53A1F-FEEF-40E1-8BB3-7DD55A43C8B7&amp;ext=JPG\n  ▿ [3] : 2 elements\n    - .0 : &quot;UIImagePickerControllerMediaType&quot;\n    - .1 : public.image\n  ▿ [4] : 2 elements\n    - .0 : &quot;UIImagePickerControllerEditedImage&quot;\n</code></pre><h3 id=\"自定义\"><a href=\"#自定义\" class=\"headerlink\" title=\"自定义\"></a>自定义</h3><p><img src=\"./1447343597718.png\" alt=\"Alt text\"></p>\n<p>遍历相册的所有图片</p>\n<pre><code class=\"swift\">// AssetsLibrary.framework\n// ALAssetsLibrary 的使用,但是它慢慢的被放弃了\n    func loadLocalPhotoes(){\n        var countOne = 0\n        //ALAssetsGroupSavedPhotos表示只读取相机胶卷（ALAssetsGroupAll则读取全部相簿）\n        assetsLibrary.enumerateGroupsWithTypes(ALAssetsGroupSavedPhotos, usingBlock: {\n            (group: ALAssetsGroup!, stop) in\n            print(&quot;is goin&quot;)\n            if group != nil {\n                let assetBlock : ALAssetsGroupEnumerationResultsBlock = {\n                    (result: ALAsset!, index: Int, stop) in\n                    if result != nil {\n                        self.assets.append(result)\n                        countOne++\n                    }\n                }\n                group.enumerateAssetsUsingBlock(assetBlock)\n                print(&quot;assets:\\(countOne)&quot;)\n                self.startChangeLocalImages(0)\n            }\n            }, failureBlock: { (fail) in\n                print(fail)\n        })\n    }\n\n// 展现本地图片\nfunc startChangeLocalImages(var index: Int){\n        if index==assets.count {\n            index = 0\n        }\n        let myAsset = assets[index]\n        let image = UIImage(CGImage:myAsset.thumbnail().takeUnretainedValue())\n        self.backImageView.image = image\n\n        let popTime = dispatch_time(DISPATCH_TIME_NOW, Int64(1 * Double(NSEC_PER_SEC)))\n        dispatch_after(popTime, dispatch_get_main_queue()) {\n            self.startChangeLocalImages(index+1)\n        }\n    }\n</code></pre>\n<p>iOS9 开始使用新库<br><a href=\"https://developer.apple.com/library/prerelease/ios/documentation/Photos/Reference/PHPhotoLibrary_Class/index.html\" target=\"_blank\" rel=\"noopener\">PHPhotoLibrary</a></p>\n"},{"title":"Moto 360 Sport初体验","date":"2016-03-04T10:30:00.000Z","_content":"\n\n- 前奏\n\t- 美版\n\t- 第一连接需要连接Android手机\n\t- 需要翻墙\n- 应用\n\t- Android  Wear\n\t- WearADay\n- iPhone支持\n\t- 无需越狱，连接应用WearADay\n\t\t- ![如图1](http://pic.5577.com/up/2015-5/2015050417055266573.jpg)\n\t\t- ![如图2](http://pic.5577.com/up/2015-5/2015050417055336913.jpg)\n\t\t- ![如图3](http://pic.5577.com/up/2015-5/2015050417055318883.jpg)\n\t\t- ![如图4](http://pic.5577.com/up/2015-5/2015050417055318092.jpg)\n\t\t- ![如图5](http://pic.5577.com/up/2015-5/2015050417055331041.jpg)\n\t- 包括来电，信息以及各种应用的通知，包括 QQ，微信等等在 iPhone 和 Moto360 配对成功之后都可以在 Moto360 上显示\n\t\t- ![如图1](http://pic.5577.com/up/2015-5/2015050417055428219.jpg)\n\t\t- ![如图2](http://pic.5577.com/up/2015-5/2015050417055481895.jpg)\n\t\t- ![如图3](http://pic.5577.com/up/2015-5/2015050417055447453.jpg)\n\t\t- ![如图4](http://pic.5577.com/up/2015-5/2015050417055512184.jpg)\n\t\t- ![如图5](http://pic.5577.com/up/2015-5/2015050417055547831.jpg)\n\t\t- ![如图6](http://pic.5577.com/up/2015-5/2015050417055580691.jpg)\n- Android支持\n\t-  微信:表情回复，语音回复，文字回复\n\t-  QQ:未测\n- 缺陷\n\t- 分辨率不高\n\t- 目前测试没有好的输入法每次提示都是在连接手机输入但每次都是提示手机不在附近\n\t\n\n- 开发者模式安装应用\n\t1. 打开手机以及手表的开发者选项\n\t\t- 手机端：设置-关于手机，找到“版本号”，对着它连续点击7下即可开启，开机后进入“设置”-“开发者选项”，勾选“USB调试\n\t\t- ![手机开启develp](http://image.anruan.com/imglist/20141021/20141021863912.png)\n\t\t- 手表端：长按右侧按钮唤出设置界面-“About”，找到“Build number”，对着它连续点击7下即可开启，开启后进入设置-“Developer options”，按图所示开启“ADB debugging”和“Debug over Bluetooth”\n\t\t- ![Moto开启develp](http://image.anruan.com/imglist/20141021/20141021863360.png)\n\t2. 打开Android Wear软件，勾选设置菜单里的“Debugging over Bluetooth”。\n\t\t- 你可以发现“Host”是disconnected未连接状态，这是代表手表端;“Target”是手机端，connected已连接状态;怎么让手表端的显示已连接呢?请继续往下看\n\t\t- ![Android Wear打开蓝牙调试](http://image.anruan.com/imglist/20141021/20141021863594.png) \n\t3. 把手机连接上电脑，在adb工具的文件夹里调出命令行，依次输入以下命令\n\t\n\t````\n\tadb forward tcp:4444 localabstract:/adb-hub\n　　adb connect localhost:4444\n\t````\n\t分两次输入(电脑需支持adb命令，如果不支持请百度[Mac配置adb](http://blog.sina.com.cn/s/blog_6268f10201016s64.html)，[Window配置adb](http://blog.csdn.net/huangbiao86/article/details/6664779)两个链接是未测试)\n\t\n\t- 输完以上两条命令后，留意手机，会弹出允许USB调试的窗口，勾选总是允许，点击OK即可，这时你就发现代表手表端的“Host”就变成connected已连接状态了，嗯，这就代表可以再电脑执行adb命令来控制手表了\n\t- ![提示是否调试](http://image.anruan.com/imglist/20141021/20141021863363.png)\n\t4. 相关命令\n\t\t- adb devices (显示已连接的设备，如图所示，会显示出2个设备名，分别对应手机和手表)\n\t\t- ![如图](http://image.anruan.com/imglist/20141021/20141021863452.png)\n\t\t\n\t\t- adb -s 手机ID号 install xxx.apk(给手机安装软件，要注意加上手机ID号，比如我的就是 adb -s TA26901ZLK install xxx.apk )\n\t\t- adb -s localhost:4444 install xxx.apk(给手表安装软件，MOTO 360的软件apk可以通过Android Wear软件专题下载，这里是通过手机的蓝牙给手表安装的，所以传输速度稍慢，要耐心等待，安装成功后会有提示)\n\t\t- adb -s localhost:4444 unistall xxx(卸载手表端的某个软件，比如adb -s localhost:4444unistall com.whirlscape.minuum)\n\t\t- 查看Moto 360所有app的packages\n\t\t\n\t\t````\n\t\tadb -s localhost:4444 shell pm list packages\n\t\t````\n\t\t- 卸载指定包名的app\n\t\t\n\t\t````\n\t\tadb -s localhost:4444 uninstall [-k] <insert package name here>\n\t\t````\n\t\t\n- 参考文章\n\t- [链接1](http://m.anruan.com/view_5488.html)\n\t- [链接2](https://www.reddit.com/r/moto360/comments/3bkd5r/remove_wear_apps_without_uninstalling_app_from/) \n\t- [链接3](http://www.5577.com/wear/58563.html)\n \n\n\n","source":"_posts/Moto 360 Sport初体验.md","raw":"title: Moto 360 Sport初体验\ndate: 2016-03-04  10:30:00\ntags:\ncategories: Android\n\n---\n\n\n- 前奏\n\t- 美版\n\t- 第一连接需要连接Android手机\n\t- 需要翻墙\n- 应用\n\t- Android  Wear\n\t- WearADay\n- iPhone支持\n\t- 无需越狱，连接应用WearADay\n\t\t- ![如图1](http://pic.5577.com/up/2015-5/2015050417055266573.jpg)\n\t\t- ![如图2](http://pic.5577.com/up/2015-5/2015050417055336913.jpg)\n\t\t- ![如图3](http://pic.5577.com/up/2015-5/2015050417055318883.jpg)\n\t\t- ![如图4](http://pic.5577.com/up/2015-5/2015050417055318092.jpg)\n\t\t- ![如图5](http://pic.5577.com/up/2015-5/2015050417055331041.jpg)\n\t- 包括来电，信息以及各种应用的通知，包括 QQ，微信等等在 iPhone 和 Moto360 配对成功之后都可以在 Moto360 上显示\n\t\t- ![如图1](http://pic.5577.com/up/2015-5/2015050417055428219.jpg)\n\t\t- ![如图2](http://pic.5577.com/up/2015-5/2015050417055481895.jpg)\n\t\t- ![如图3](http://pic.5577.com/up/2015-5/2015050417055447453.jpg)\n\t\t- ![如图4](http://pic.5577.com/up/2015-5/2015050417055512184.jpg)\n\t\t- ![如图5](http://pic.5577.com/up/2015-5/2015050417055547831.jpg)\n\t\t- ![如图6](http://pic.5577.com/up/2015-5/2015050417055580691.jpg)\n- Android支持\n\t-  微信:表情回复，语音回复，文字回复\n\t-  QQ:未测\n- 缺陷\n\t- 分辨率不高\n\t- 目前测试没有好的输入法每次提示都是在连接手机输入但每次都是提示手机不在附近\n\t\n\n- 开发者模式安装应用\n\t1. 打开手机以及手表的开发者选项\n\t\t- 手机端：设置-关于手机，找到“版本号”，对着它连续点击7下即可开启，开机后进入“设置”-“开发者选项”，勾选“USB调试\n\t\t- ![手机开启develp](http://image.anruan.com/imglist/20141021/20141021863912.png)\n\t\t- 手表端：长按右侧按钮唤出设置界面-“About”，找到“Build number”，对着它连续点击7下即可开启，开启后进入设置-“Developer options”，按图所示开启“ADB debugging”和“Debug over Bluetooth”\n\t\t- ![Moto开启develp](http://image.anruan.com/imglist/20141021/20141021863360.png)\n\t2. 打开Android Wear软件，勾选设置菜单里的“Debugging over Bluetooth”。\n\t\t- 你可以发现“Host”是disconnected未连接状态，这是代表手表端;“Target”是手机端，connected已连接状态;怎么让手表端的显示已连接呢?请继续往下看\n\t\t- ![Android Wear打开蓝牙调试](http://image.anruan.com/imglist/20141021/20141021863594.png) \n\t3. 把手机连接上电脑，在adb工具的文件夹里调出命令行，依次输入以下命令\n\t\n\t````\n\tadb forward tcp:4444 localabstract:/adb-hub\n　　adb connect localhost:4444\n\t````\n\t分两次输入(电脑需支持adb命令，如果不支持请百度[Mac配置adb](http://blog.sina.com.cn/s/blog_6268f10201016s64.html)，[Window配置adb](http://blog.csdn.net/huangbiao86/article/details/6664779)两个链接是未测试)\n\t\n\t- 输完以上两条命令后，留意手机，会弹出允许USB调试的窗口，勾选总是允许，点击OK即可，这时你就发现代表手表端的“Host”就变成connected已连接状态了，嗯，这就代表可以再电脑执行adb命令来控制手表了\n\t- ![提示是否调试](http://image.anruan.com/imglist/20141021/20141021863363.png)\n\t4. 相关命令\n\t\t- adb devices (显示已连接的设备，如图所示，会显示出2个设备名，分别对应手机和手表)\n\t\t- ![如图](http://image.anruan.com/imglist/20141021/20141021863452.png)\n\t\t\n\t\t- adb -s 手机ID号 install xxx.apk(给手机安装软件，要注意加上手机ID号，比如我的就是 adb -s TA26901ZLK install xxx.apk )\n\t\t- adb -s localhost:4444 install xxx.apk(给手表安装软件，MOTO 360的软件apk可以通过Android Wear软件专题下载，这里是通过手机的蓝牙给手表安装的，所以传输速度稍慢，要耐心等待，安装成功后会有提示)\n\t\t- adb -s localhost:4444 unistall xxx(卸载手表端的某个软件，比如adb -s localhost:4444unistall com.whirlscape.minuum)\n\t\t- 查看Moto 360所有app的packages\n\t\t\n\t\t````\n\t\tadb -s localhost:4444 shell pm list packages\n\t\t````\n\t\t- 卸载指定包名的app\n\t\t\n\t\t````\n\t\tadb -s localhost:4444 uninstall [-k] <insert package name here>\n\t\t````\n\t\t\n- 参考文章\n\t- [链接1](http://m.anruan.com/view_5488.html)\n\t- [链接2](https://www.reddit.com/r/moto360/comments/3bkd5r/remove_wear_apps_without_uninstalling_app_from/) \n\t- [链接3](http://www.5577.com/wear/58563.html)\n \n\n\n","slug":"Moto-360-Sport初体验","published":1,"updated":"2021-09-10T07:04:21.944Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cktfeap3z001gc2xxkq0x1zqt","content":"<ul>\n<li>前奏<ul>\n<li>美版</li>\n<li>第一连接需要连接Android手机</li>\n<li>需要翻墙</li>\n</ul>\n</li>\n<li>应用<ul>\n<li>Android  Wear</li>\n<li>WearADay</li>\n</ul>\n</li>\n<li>iPhone支持<ul>\n<li>无需越狱，连接应用WearADay<ul>\n<li><img src=\"http://pic.5577.com/up/2015-5/2015050417055266573.jpg\" alt=\"如图1\"></li>\n<li><img src=\"http://pic.5577.com/up/2015-5/2015050417055336913.jpg\" alt=\"如图2\"></li>\n<li><img src=\"http://pic.5577.com/up/2015-5/2015050417055318883.jpg\" alt=\"如图3\"></li>\n<li><img src=\"http://pic.5577.com/up/2015-5/2015050417055318092.jpg\" alt=\"如图4\"></li>\n<li><img src=\"http://pic.5577.com/up/2015-5/2015050417055331041.jpg\" alt=\"如图5\"></li>\n</ul>\n</li>\n<li>包括来电，信息以及各种应用的通知，包括 QQ，微信等等在 iPhone 和 Moto360 配对成功之后都可以在 Moto360 上显示<ul>\n<li><img src=\"http://pic.5577.com/up/2015-5/2015050417055428219.jpg\" alt=\"如图1\"></li>\n<li><img src=\"http://pic.5577.com/up/2015-5/2015050417055481895.jpg\" alt=\"如图2\"></li>\n<li><img src=\"http://pic.5577.com/up/2015-5/2015050417055447453.jpg\" alt=\"如图3\"></li>\n<li><img src=\"http://pic.5577.com/up/2015-5/2015050417055512184.jpg\" alt=\"如图4\"></li>\n<li><img src=\"http://pic.5577.com/up/2015-5/2015050417055547831.jpg\" alt=\"如图5\"></li>\n<li><img src=\"http://pic.5577.com/up/2015-5/2015050417055580691.jpg\" alt=\"如图6\"></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Android支持<ul>\n<li>微信:表情回复，语音回复，文字回复</li>\n<li>QQ:未测</li>\n</ul>\n</li>\n<li>缺陷<ul>\n<li>分辨率不高</li>\n<li>目前测试没有好的输入法每次提示都是在连接手机输入但每次都是提示手机不在附近</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>开发者模式安装应用</p>\n<ol>\n<li>打开手机以及手表的开发者选项<ul>\n<li>手机端：设置-关于手机，找到“版本号”，对着它连续点击7下即可开启，开机后进入“设置”-“开发者选项”，勾选“USB调试</li>\n<li><img src=\"http://image.anruan.com/imglist/20141021/20141021863912.png\" alt=\"手机开启develp\"></li>\n<li>手表端：长按右侧按钮唤出设置界面-“About”，找到“Build number”，对着它连续点击7下即可开启，开启后进入设置-“Developer options”，按图所示开启“ADB debugging”和“Debug over Bluetooth”</li>\n<li><img src=\"http://image.anruan.com/imglist/20141021/20141021863360.png\" alt=\"Moto开启develp\"></li>\n</ul>\n</li>\n<li>打开Android Wear软件，勾选设置菜单里的“Debugging over Bluetooth”。<ul>\n<li>你可以发现“Host”是disconnected未连接状态，这是代表手表端;“Target”是手机端，connected已连接状态;怎么让手表端的显示已连接呢?请继续往下看</li>\n<li><img src=\"http://image.anruan.com/imglist/20141021/20141021863594.png\" alt=\"Android Wear打开蓝牙调试\"> </li>\n</ul>\n</li>\n<li><p>把手机连接上电脑，在adb工具的文件夹里调出命令行，依次输入以下命令</p>\n<pre><code>adb forward tcp:4444 localabstract:/adb-hub\n　　adb connect localhost:4444\n</code></pre><p>分两次输入(电脑需支持adb命令，如果不支持请百度<a href=\"http://blog.sina.com.cn/s/blog_6268f10201016s64.html\" target=\"_blank\" rel=\"noopener\">Mac配置adb</a>，<a href=\"http://blog.csdn.net/huangbiao86/article/details/6664779\" target=\"_blank\" rel=\"noopener\">Window配置adb</a>两个链接是未测试)</p>\n</li>\n</ol>\n<ul>\n<li>输完以上两条命令后，留意手机，会弹出允许USB调试的窗口，勾选总是允许，点击OK即可，这时你就发现代表手表端的“Host”就变成connected已连接状态了，嗯，这就代表可以再电脑执行adb命令来控制手表了</li>\n<li><img src=\"http://image.anruan.com/imglist/20141021/20141021863363.png\" alt=\"提示是否调试\"></li>\n</ul>\n<ol>\n<li><p>相关命令</p>\n<ul>\n<li>adb devices (显示已连接的设备，如图所示，会显示出2个设备名，分别对应手机和手表)</li>\n<li><p><img src=\"http://image.anruan.com/imglist/20141021/20141021863452.png\" alt=\"如图\"></p>\n</li>\n<li><p>adb -s 手机ID号 install xxx.apk(给手机安装软件，要注意加上手机ID号，比如我的就是 adb -s TA26901ZLK install xxx.apk )</p>\n</li>\n<li>adb -s localhost:4444 install xxx.apk(给手表安装软件，MOTO 360的软件apk可以通过Android Wear软件专题下载，这里是通过手机的蓝牙给手表安装的，所以传输速度稍慢，要耐心等待，安装成功后会有提示)</li>\n<li>adb -s localhost:4444 unistall xxx(卸载手表端的某个软件，比如adb -s localhost:4444unistall com.whirlscape.minuum)</li>\n<li><p>查看Moto 360所有app的packages</p>\n<pre><code>adb -s localhost:4444 shell pm list packages\n</code></pre></li>\n<li><p>卸载指定包名的app</p>\n<pre><code>adb -s localhost:4444 uninstall [-k] &lt;insert package name here&gt;\n</code></pre></li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>参考文章</p>\n<ul>\n<li><a href=\"http://m.anruan.com/view_5488.html\" target=\"_blank\" rel=\"noopener\">链接1</a></li>\n<li><a href=\"https://www.reddit.com/r/moto360/comments/3bkd5r/remove_wear_apps_without_uninstalling_app_from/\" target=\"_blank\" rel=\"noopener\">链接2</a> </li>\n<li><a href=\"http://www.5577.com/wear/58563.html\" target=\"_blank\" rel=\"noopener\">链接3</a></li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>前奏<ul>\n<li>美版</li>\n<li>第一连接需要连接Android手机</li>\n<li>需要翻墙</li>\n</ul>\n</li>\n<li>应用<ul>\n<li>Android  Wear</li>\n<li>WearADay</li>\n</ul>\n</li>\n<li>iPhone支持<ul>\n<li>无需越狱，连接应用WearADay<ul>\n<li><img src=\"http://pic.5577.com/up/2015-5/2015050417055266573.jpg\" alt=\"如图1\"></li>\n<li><img src=\"http://pic.5577.com/up/2015-5/2015050417055336913.jpg\" alt=\"如图2\"></li>\n<li><img src=\"http://pic.5577.com/up/2015-5/2015050417055318883.jpg\" alt=\"如图3\"></li>\n<li><img src=\"http://pic.5577.com/up/2015-5/2015050417055318092.jpg\" alt=\"如图4\"></li>\n<li><img src=\"http://pic.5577.com/up/2015-5/2015050417055331041.jpg\" alt=\"如图5\"></li>\n</ul>\n</li>\n<li>包括来电，信息以及各种应用的通知，包括 QQ，微信等等在 iPhone 和 Moto360 配对成功之后都可以在 Moto360 上显示<ul>\n<li><img src=\"http://pic.5577.com/up/2015-5/2015050417055428219.jpg\" alt=\"如图1\"></li>\n<li><img src=\"http://pic.5577.com/up/2015-5/2015050417055481895.jpg\" alt=\"如图2\"></li>\n<li><img src=\"http://pic.5577.com/up/2015-5/2015050417055447453.jpg\" alt=\"如图3\"></li>\n<li><img src=\"http://pic.5577.com/up/2015-5/2015050417055512184.jpg\" alt=\"如图4\"></li>\n<li><img src=\"http://pic.5577.com/up/2015-5/2015050417055547831.jpg\" alt=\"如图5\"></li>\n<li><img src=\"http://pic.5577.com/up/2015-5/2015050417055580691.jpg\" alt=\"如图6\"></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Android支持<ul>\n<li>微信:表情回复，语音回复，文字回复</li>\n<li>QQ:未测</li>\n</ul>\n</li>\n<li>缺陷<ul>\n<li>分辨率不高</li>\n<li>目前测试没有好的输入法每次提示都是在连接手机输入但每次都是提示手机不在附近</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>开发者模式安装应用</p>\n<ol>\n<li>打开手机以及手表的开发者选项<ul>\n<li>手机端：设置-关于手机，找到“版本号”，对着它连续点击7下即可开启，开机后进入“设置”-“开发者选项”，勾选“USB调试</li>\n<li><img src=\"http://image.anruan.com/imglist/20141021/20141021863912.png\" alt=\"手机开启develp\"></li>\n<li>手表端：长按右侧按钮唤出设置界面-“About”，找到“Build number”，对着它连续点击7下即可开启，开启后进入设置-“Developer options”，按图所示开启“ADB debugging”和“Debug over Bluetooth”</li>\n<li><img src=\"http://image.anruan.com/imglist/20141021/20141021863360.png\" alt=\"Moto开启develp\"></li>\n</ul>\n</li>\n<li>打开Android Wear软件，勾选设置菜单里的“Debugging over Bluetooth”。<ul>\n<li>你可以发现“Host”是disconnected未连接状态，这是代表手表端;“Target”是手机端，connected已连接状态;怎么让手表端的显示已连接呢?请继续往下看</li>\n<li><img src=\"http://image.anruan.com/imglist/20141021/20141021863594.png\" alt=\"Android Wear打开蓝牙调试\"> </li>\n</ul>\n</li>\n<li><p>把手机连接上电脑，在adb工具的文件夹里调出命令行，依次输入以下命令</p>\n<pre><code>adb forward tcp:4444 localabstract:/adb-hub\n　　adb connect localhost:4444\n</code></pre><p>分两次输入(电脑需支持adb命令，如果不支持请百度<a href=\"http://blog.sina.com.cn/s/blog_6268f10201016s64.html\" target=\"_blank\" rel=\"noopener\">Mac配置adb</a>，<a href=\"http://blog.csdn.net/huangbiao86/article/details/6664779\" target=\"_blank\" rel=\"noopener\">Window配置adb</a>两个链接是未测试)</p>\n</li>\n</ol>\n<ul>\n<li>输完以上两条命令后，留意手机，会弹出允许USB调试的窗口，勾选总是允许，点击OK即可，这时你就发现代表手表端的“Host”就变成connected已连接状态了，嗯，这就代表可以再电脑执行adb命令来控制手表了</li>\n<li><img src=\"http://image.anruan.com/imglist/20141021/20141021863363.png\" alt=\"提示是否调试\"></li>\n</ul>\n<ol>\n<li><p>相关命令</p>\n<ul>\n<li>adb devices (显示已连接的设备，如图所示，会显示出2个设备名，分别对应手机和手表)</li>\n<li><p><img src=\"http://image.anruan.com/imglist/20141021/20141021863452.png\" alt=\"如图\"></p>\n</li>\n<li><p>adb -s 手机ID号 install xxx.apk(给手机安装软件，要注意加上手机ID号，比如我的就是 adb -s TA26901ZLK install xxx.apk )</p>\n</li>\n<li>adb -s localhost:4444 install xxx.apk(给手表安装软件，MOTO 360的软件apk可以通过Android Wear软件专题下载，这里是通过手机的蓝牙给手表安装的，所以传输速度稍慢，要耐心等待，安装成功后会有提示)</li>\n<li>adb -s localhost:4444 unistall xxx(卸载手表端的某个软件，比如adb -s localhost:4444unistall com.whirlscape.minuum)</li>\n<li><p>查看Moto 360所有app的packages</p>\n<pre><code>adb -s localhost:4444 shell pm list packages\n</code></pre></li>\n<li><p>卸载指定包名的app</p>\n<pre><code>adb -s localhost:4444 uninstall [-k] &lt;insert package name here&gt;\n</code></pre></li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>参考文章</p>\n<ul>\n<li><a href=\"http://m.anruan.com/view_5488.html\" target=\"_blank\" rel=\"noopener\">链接1</a></li>\n<li><a href=\"https://www.reddit.com/r/moto360/comments/3bkd5r/remove_wear_apps_without_uninstalling_app_from/\" target=\"_blank\" rel=\"noopener\">链接2</a> </li>\n<li><a href=\"http://www.5577.com/wear/58563.html\" target=\"_blank\" rel=\"noopener\">链接3</a></li>\n</ul>\n</li>\n</ul>\n"},{"title":"Jenkins配置Android深坑","date":"2017-07-17T09:47:29.000Z","_content":"\n\n在Jenkins上配置Android的一些持续集成（自动打包上传，单元测试，集成测试等）应该是很普遍的事情了。Jenkins一般配置在一个通用的测试服务器上，原来都是拿一个mac当测试服务器，在上面想怎么玩怎么就怎么玩，想怎么配置就怎么配置。可是如果测试服务器是在虚拟机上而且测试服务器不是你能控制的，那就要在Jenkins上配置Android就不能想自己控制自己电脑那边方便了，在配置过程中也填了不少的坑。那就讲下填坑之路吧。\n\n#### Jenkins安装\n 这部分一般不用担心，在公司里会有专门的人员安装，你只管用就可以了。那如果是由你负责安装Jenkins的话那就要好好看Jenkins官网的安装方法了，[根据不同的平台下载不同的安装包安装](https://jenkins.io/download/)\n \n#### Jenkins上新建项目\n在打开的Jenkins页面左上方找到\"创建\"(create),\n![image.png](http://upload-images.jianshu.io/upload_images/1534431-cbd759e33b51c05c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n然后，写项目名和项目类型\n\n![image.png](http://upload-images.jianshu.io/upload_images/1534431-031ffec2a56338d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n(因为是Android项目，默认就选择第一个。)\n然后选择\"OK\"\n然后,一个新建的项目就好了。\n\n![image.png](http://upload-images.jianshu.io/upload_images/1534431-f3da863f34edd75e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n#### Jenkins配置项目\n配置前提条件就是你[jenkins要安装好几个插件](https://jenkins.io/doc/book/managing/plugins/): git插件，gradle插件，Android虚拟机插件\n![image.png](http://upload-images.jianshu.io/upload_images/1534431-d563fd7f6289c76a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n![image.png](http://upload-images.jianshu.io/upload_images/1534431-630008664ec0e4df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n![image.png](http://upload-images.jianshu.io/upload_images/1534431-096e22f8f71b8d9f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n然后就开始\n[Jenkins官网配置Androd环境](https://www.zuehlke.com/blog/en/configure-your-android-project-on-jenkins/)，\n- 选择JDK\n\n![image.png](http://upload-images.jianshu.io/upload_images/1534431-8dc9b1da00eb9751.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n- 源码\n\n![image.png](http://upload-images.jianshu.io/upload_images/1534431-5d5da1a0efcb3f73.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n- 构建环境\n\n![image.png](http://upload-images.jianshu.io/upload_images/1534431-0652ce7865dadf45.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)虚拟机配置后期关闭，配置虚拟机主要用来下载andoid-sdk。\n\n- 构建\n\n![image.png](http://upload-images.jianshu.io/upload_images/1534431-a430e352881caaaa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\nOK,好了，这就是正确的配置，那我们就运行下开始深坑之旅了。\n\n![image.png](http://upload-images.jianshu.io/upload_images/1534431-f199552ec5263663.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n看下输入log\n\n![image.png](http://upload-images.jianshu.io/upload_images/1534431-dcdc202bcd339294.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n####问题不分先后，按解决问题处理\n- 问题1\n\n![image.png](http://upload-images.jianshu.io/upload_images/1534431-fe1cf269790bc480.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n虚拟机没有找到相应的hardware配置，尝试更改各种配置方法最后都是失败结束（如果你有其他解决方法记得告诉我）。能走到这一步就说明你的andoid-sdk已经按照好了，只是打开虚拟机还有问题。想想本身主要用来gradle打包Android apk，还用不到打开虚拟机，能安装好Android-sdk就可以。然后在项目配置中![Alt text]\n![image.png](http://upload-images.jianshu.io/upload_images/1534431-1dee90179b1159f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n勾选掉虚拟机配置就可以了，不影响你gradle打包。\n\n- 问题2\n\n![image.png](http://upload-images.jianshu.io/upload_images/1534431-459d738485a45673.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\nAndroid环境变量没有配置，需要根据Android虚拟机配置下载来的android sdk位置配了，\n\n![image.png](http://upload-images.jianshu.io/upload_images/1534431-5c08d301ca0b3962.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n仔细看下android虚拟机下载sdk的位置，然后在jenkins的系统配置中配置相应的环境变量\n![image.png](http://upload-images.jianshu.io/upload_images/1534431-d1dcc03ef8d1b69c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n就可以了。\n\n- 问题3\n\n![image.png](http://upload-images.jianshu.io/upload_images/1534431-5e890bdc058bdc5e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n虚拟机的ABIs没有配置好,需要项目配置\n\n![image.png](http://upload-images.jianshu.io/upload_images/1534431-067d2f34dbe6ae82.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n就OK了。\n\n- 问题4\n![image.png](http://upload-images.jianshu.io/upload_images/1534431-42d5c68603b71397.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n这个是说你下载的android-sdk需要同意协议，可是我们这个是虚拟的服务器上没有办法点击同意啊，那就看提示解决方法地址\n\n![image.png](http://upload-images.jianshu.io/upload_images/1534431-385369d144163db1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n![image.png](http://upload-images.jianshu.io/upload_images/1534431-3d0e78dbf20fe800.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n有两种解决方案，一种在ui上点，一种是把你已经同意好的协议文件拷贝到当前页面。那我们只能把自己电脑的电脑拷贝进去了，可是又遇到问题，我没有权限访问这个服务器那怎么复制到这个jekins服务器上了，那只能把这个协议文件上传到[七牛](https://www.qiniu.com/)（或者其他托管服务器上），脚本如下\n```\n# 进入下载好的android-sdk路径\ncd /root/.jenkins/tools/android-sdk\n# 新建协议文件夹\nmkdir licenses\n# 进入协议文件夹内\ncd /root/.jenkins/tools/android-sdk/licenses\n# rm -rf android-sdk-license\n# 下载已经同意好的android协议文件\nwget http://7xn0ue.com1.z0.glb.clouddn.com/android-sdk-license\n```\n具体项目配置\n\n![image.png](http://upload-images.jianshu.io/upload_images/1534431-da840093cfec03e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\nOK,重新构建一下，不过记得先把“构建环境”的配置勾选掉，要不然“构建环境有问题执行不到这个脚本”\n\n- 问题5\n\n![image.png](http://upload-images.jianshu.io/upload_images/1534431-82183912bc907638.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n你运行的系统缺少libGL.so.1库，那就需要安装这个库，找了下可以用\n```\nyum install mesa-libGL -y\n```脚本解决,已经要记得加“-y ”要不然会出错提示\n\n![image.png](http://upload-images.jianshu.io/upload_images/1534431-23a8a172c18ff124.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n- 问题6\n\n![image.png](http://upload-images.jianshu.io/upload_images/1534431-570f151c6e7b1551.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n你运行的系统内核版本过低需要升级，这个也是我比较纠结的要是升级那会不会影响测试服务器的运行。（如果你现在是正式环境下你就需要跟领导沟通只是斟酌了）。\n通过以下脚本可以解决，同\n```\n# 下载glibc-2.15.tar.gz内核文件，根据不同版本在http://ftp.gnu.org/gnu/glibc/\n下载\nwget http://ftp.gnu.org/gnu/glibc/glibc-2.15.tar.gz\n# 解压文件\ntar -xvf glibc-2.15.tar.gz\n# 依赖库(glibc-ports-2.15.tar.gz)\nwget http://ftp.gnu.org/gnu/glibc/glibc-ports-2.15.tar.gz\n# 解压\ntar -xvf glibc-ports-2.15.tar.gz\n# 依赖库解压目录移到到主目录中\nmv glibc-ports-2.15 glibc-2.15/ports\n# 创建编译目录\nmkdir glibc-build\ncd glibc-build\n# 运行以下命令编译及安装\n../glibc-2.15/configure --prefix=/usr --disable-profile --enable-add-ons --with-headers=/usr/include --with-binutils=/usr/bin\nmake\nmake install\n```\n配置如下\n![image.png](http://upload-images.jianshu.io/upload_images/1534431-f5153e0d9295fde4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n以上是我遇到的所有问题，希望这些坑可以对你有帮助。\n那看下最后成功输出log和配置：\n\n![log](http://upload-images.jianshu.io/upload_images/1534431-5a7844d2a0ded788.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![JDK](http://upload-images.jianshu.io/upload_images/1534431-1e5e1234553f21e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![源码仓库](http://upload-images.jianshu.io/upload_images/1534431-adb38281522b4c42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![构建触发器和构建环境](http://upload-images.jianshu.io/upload_images/1534431-f59eff5b1878425c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![构建](http://upload-images.jianshu.io/upload_images/1534431-7705c3fbf55d287f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)","source":"_posts/Jenkins配置Android深坑.md","raw":"title: Jenkins配置Android深坑\ndate: 2017-07-17 09:47:29\ntags:\ncategories: 其他\n---\n\n\n在Jenkins上配置Android的一些持续集成（自动打包上传，单元测试，集成测试等）应该是很普遍的事情了。Jenkins一般配置在一个通用的测试服务器上，原来都是拿一个mac当测试服务器，在上面想怎么玩怎么就怎么玩，想怎么配置就怎么配置。可是如果测试服务器是在虚拟机上而且测试服务器不是你能控制的，那就要在Jenkins上配置Android就不能想自己控制自己电脑那边方便了，在配置过程中也填了不少的坑。那就讲下填坑之路吧。\n\n#### Jenkins安装\n 这部分一般不用担心，在公司里会有专门的人员安装，你只管用就可以了。那如果是由你负责安装Jenkins的话那就要好好看Jenkins官网的安装方法了，[根据不同的平台下载不同的安装包安装](https://jenkins.io/download/)\n \n#### Jenkins上新建项目\n在打开的Jenkins页面左上方找到\"创建\"(create),\n![image.png](http://upload-images.jianshu.io/upload_images/1534431-cbd759e33b51c05c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n然后，写项目名和项目类型\n\n![image.png](http://upload-images.jianshu.io/upload_images/1534431-031ffec2a56338d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n(因为是Android项目，默认就选择第一个。)\n然后选择\"OK\"\n然后,一个新建的项目就好了。\n\n![image.png](http://upload-images.jianshu.io/upload_images/1534431-f3da863f34edd75e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n#### Jenkins配置项目\n配置前提条件就是你[jenkins要安装好几个插件](https://jenkins.io/doc/book/managing/plugins/): git插件，gradle插件，Android虚拟机插件\n![image.png](http://upload-images.jianshu.io/upload_images/1534431-d563fd7f6289c76a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n![image.png](http://upload-images.jianshu.io/upload_images/1534431-630008664ec0e4df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n![image.png](http://upload-images.jianshu.io/upload_images/1534431-096e22f8f71b8d9f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n然后就开始\n[Jenkins官网配置Androd环境](https://www.zuehlke.com/blog/en/configure-your-android-project-on-jenkins/)，\n- 选择JDK\n\n![image.png](http://upload-images.jianshu.io/upload_images/1534431-8dc9b1da00eb9751.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n- 源码\n\n![image.png](http://upload-images.jianshu.io/upload_images/1534431-5d5da1a0efcb3f73.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n- 构建环境\n\n![image.png](http://upload-images.jianshu.io/upload_images/1534431-0652ce7865dadf45.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)虚拟机配置后期关闭，配置虚拟机主要用来下载andoid-sdk。\n\n- 构建\n\n![image.png](http://upload-images.jianshu.io/upload_images/1534431-a430e352881caaaa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\nOK,好了，这就是正确的配置，那我们就运行下开始深坑之旅了。\n\n![image.png](http://upload-images.jianshu.io/upload_images/1534431-f199552ec5263663.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n看下输入log\n\n![image.png](http://upload-images.jianshu.io/upload_images/1534431-dcdc202bcd339294.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n####问题不分先后，按解决问题处理\n- 问题1\n\n![image.png](http://upload-images.jianshu.io/upload_images/1534431-fe1cf269790bc480.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n虚拟机没有找到相应的hardware配置，尝试更改各种配置方法最后都是失败结束（如果你有其他解决方法记得告诉我）。能走到这一步就说明你的andoid-sdk已经按照好了，只是打开虚拟机还有问题。想想本身主要用来gradle打包Android apk，还用不到打开虚拟机，能安装好Android-sdk就可以。然后在项目配置中![Alt text]\n![image.png](http://upload-images.jianshu.io/upload_images/1534431-1dee90179b1159f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n勾选掉虚拟机配置就可以了，不影响你gradle打包。\n\n- 问题2\n\n![image.png](http://upload-images.jianshu.io/upload_images/1534431-459d738485a45673.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\nAndroid环境变量没有配置，需要根据Android虚拟机配置下载来的android sdk位置配了，\n\n![image.png](http://upload-images.jianshu.io/upload_images/1534431-5c08d301ca0b3962.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n仔细看下android虚拟机下载sdk的位置，然后在jenkins的系统配置中配置相应的环境变量\n![image.png](http://upload-images.jianshu.io/upload_images/1534431-d1dcc03ef8d1b69c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n就可以了。\n\n- 问题3\n\n![image.png](http://upload-images.jianshu.io/upload_images/1534431-5e890bdc058bdc5e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n虚拟机的ABIs没有配置好,需要项目配置\n\n![image.png](http://upload-images.jianshu.io/upload_images/1534431-067d2f34dbe6ae82.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n就OK了。\n\n- 问题4\n![image.png](http://upload-images.jianshu.io/upload_images/1534431-42d5c68603b71397.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n这个是说你下载的android-sdk需要同意协议，可是我们这个是虚拟的服务器上没有办法点击同意啊，那就看提示解决方法地址\n\n![image.png](http://upload-images.jianshu.io/upload_images/1534431-385369d144163db1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n![image.png](http://upload-images.jianshu.io/upload_images/1534431-3d0e78dbf20fe800.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n有两种解决方案，一种在ui上点，一种是把你已经同意好的协议文件拷贝到当前页面。那我们只能把自己电脑的电脑拷贝进去了，可是又遇到问题，我没有权限访问这个服务器那怎么复制到这个jekins服务器上了，那只能把这个协议文件上传到[七牛](https://www.qiniu.com/)（或者其他托管服务器上），脚本如下\n```\n# 进入下载好的android-sdk路径\ncd /root/.jenkins/tools/android-sdk\n# 新建协议文件夹\nmkdir licenses\n# 进入协议文件夹内\ncd /root/.jenkins/tools/android-sdk/licenses\n# rm -rf android-sdk-license\n# 下载已经同意好的android协议文件\nwget http://7xn0ue.com1.z0.glb.clouddn.com/android-sdk-license\n```\n具体项目配置\n\n![image.png](http://upload-images.jianshu.io/upload_images/1534431-da840093cfec03e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\nOK,重新构建一下，不过记得先把“构建环境”的配置勾选掉，要不然“构建环境有问题执行不到这个脚本”\n\n- 问题5\n\n![image.png](http://upload-images.jianshu.io/upload_images/1534431-82183912bc907638.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n你运行的系统缺少libGL.so.1库，那就需要安装这个库，找了下可以用\n```\nyum install mesa-libGL -y\n```脚本解决,已经要记得加“-y ”要不然会出错提示\n\n![image.png](http://upload-images.jianshu.io/upload_images/1534431-23a8a172c18ff124.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n- 问题6\n\n![image.png](http://upload-images.jianshu.io/upload_images/1534431-570f151c6e7b1551.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n你运行的系统内核版本过低需要升级，这个也是我比较纠结的要是升级那会不会影响测试服务器的运行。（如果你现在是正式环境下你就需要跟领导沟通只是斟酌了）。\n通过以下脚本可以解决，同\n```\n# 下载glibc-2.15.tar.gz内核文件，根据不同版本在http://ftp.gnu.org/gnu/glibc/\n下载\nwget http://ftp.gnu.org/gnu/glibc/glibc-2.15.tar.gz\n# 解压文件\ntar -xvf glibc-2.15.tar.gz\n# 依赖库(glibc-ports-2.15.tar.gz)\nwget http://ftp.gnu.org/gnu/glibc/glibc-ports-2.15.tar.gz\n# 解压\ntar -xvf glibc-ports-2.15.tar.gz\n# 依赖库解压目录移到到主目录中\nmv glibc-ports-2.15 glibc-2.15/ports\n# 创建编译目录\nmkdir glibc-build\ncd glibc-build\n# 运行以下命令编译及安装\n../glibc-2.15/configure --prefix=/usr --disable-profile --enable-add-ons --with-headers=/usr/include --with-binutils=/usr/bin\nmake\nmake install\n```\n配置如下\n![image.png](http://upload-images.jianshu.io/upload_images/1534431-f5153e0d9295fde4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n以上是我遇到的所有问题，希望这些坑可以对你有帮助。\n那看下最后成功输出log和配置：\n\n![log](http://upload-images.jianshu.io/upload_images/1534431-5a7844d2a0ded788.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![JDK](http://upload-images.jianshu.io/upload_images/1534431-1e5e1234553f21e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![源码仓库](http://upload-images.jianshu.io/upload_images/1534431-adb38281522b4c42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![构建触发器和构建环境](http://upload-images.jianshu.io/upload_images/1534431-f59eff5b1878425c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![构建](http://upload-images.jianshu.io/upload_images/1534431-7705c3fbf55d287f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)","slug":"Jenkins配置Android深坑","published":1,"updated":"2021-09-10T07:04:21.943Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cktfeap40001ic2xxzfe3riws","content":"<p>在Jenkins上配置Android的一些持续集成（自动打包上传，单元测试，集成测试等）应该是很普遍的事情了。Jenkins一般配置在一个通用的测试服务器上，原来都是拿一个mac当测试服务器，在上面想怎么玩怎么就怎么玩，想怎么配置就怎么配置。可是如果测试服务器是在虚拟机上而且测试服务器不是你能控制的，那就要在Jenkins上配置Android就不能想自己控制自己电脑那边方便了，在配置过程中也填了不少的坑。那就讲下填坑之路吧。</p>\n<h4 id=\"Jenkins安装\"><a href=\"#Jenkins安装\" class=\"headerlink\" title=\"Jenkins安装\"></a>Jenkins安装</h4><p> 这部分一般不用担心，在公司里会有专门的人员安装，你只管用就可以了。那如果是由你负责安装Jenkins的话那就要好好看Jenkins官网的安装方法了，<a href=\"https://jenkins.io/download/\" target=\"_blank\" rel=\"noopener\">根据不同的平台下载不同的安装包安装</a></p>\n<h4 id=\"Jenkins上新建项目\"><a href=\"#Jenkins上新建项目\" class=\"headerlink\" title=\"Jenkins上新建项目\"></a>Jenkins上新建项目</h4><p>在打开的Jenkins页面左上方找到”创建”(create),<br><img src=\"http://upload-images.jianshu.io/upload_images/1534431-cbd759e33b51c05c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>然后，写项目名和项目类型</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1534431-031ffec2a56338d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>(因为是Android项目，默认就选择第一个。)<br>然后选择”OK”<br>然后,一个新建的项目就好了。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1534431-f3da863f34edd75e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<h4 id=\"Jenkins配置项目\"><a href=\"#Jenkins配置项目\" class=\"headerlink\" title=\"Jenkins配置项目\"></a>Jenkins配置项目</h4><p>配置前提条件就是你<a href=\"https://jenkins.io/doc/book/managing/plugins/\" target=\"_blank\" rel=\"noopener\">jenkins要安装好几个插件</a>: git插件，gradle插件，Android虚拟机插件<br><img src=\"http://upload-images.jianshu.io/upload_images/1534431-d563fd7f6289c76a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><br><img src=\"http://upload-images.jianshu.io/upload_images/1534431-630008664ec0e4df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><br><img src=\"http://upload-images.jianshu.io/upload_images/1534431-096e22f8f71b8d9f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>然后就开始<br><a href=\"https://www.zuehlke.com/blog/en/configure-your-android-project-on-jenkins/\" target=\"_blank\" rel=\"noopener\">Jenkins官网配置Androd环境</a>，</p>\n<ul>\n<li>选择JDK</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1534431-8dc9b1da00eb9751.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<ul>\n<li>源码</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1534431-5d5da1a0efcb3f73.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<ul>\n<li>构建环境</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1534431-0652ce7865dadf45.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\">虚拟机配置后期关闭，配置虚拟机主要用来下载andoid-sdk。</p>\n<ul>\n<li>构建</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1534431-a430e352881caaaa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>OK,好了，这就是正确的配置，那我们就运行下开始深坑之旅了。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1534431-f199552ec5263663.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>看下输入log</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1534431-dcdc202bcd339294.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>####问题不分先后，按解决问题处理</p>\n<ul>\n<li>问题1</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1534431-fe1cf269790bc480.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>虚拟机没有找到相应的hardware配置，尝试更改各种配置方法最后都是失败结束（如果你有其他解决方法记得告诉我）。能走到这一步就说明你的andoid-sdk已经按照好了，只是打开虚拟机还有问题。想想本身主要用来gradle打包Android apk，还用不到打开虚拟机，能安装好Android-sdk就可以。然后在项目配置中![Alt text]<br><img src=\"http://upload-images.jianshu.io/upload_images/1534431-1dee90179b1159f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>勾选掉虚拟机配置就可以了，不影响你gradle打包。</p>\n<ul>\n<li>问题2</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1534431-459d738485a45673.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>Android环境变量没有配置，需要根据Android虚拟机配置下载来的android sdk位置配了，</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1534431-5c08d301ca0b3962.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>仔细看下android虚拟机下载sdk的位置，然后在jenkins的系统配置中配置相应的环境变量<br><img src=\"http://upload-images.jianshu.io/upload_images/1534431-d1dcc03ef8d1b69c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>就可以了。</p>\n<ul>\n<li>问题3</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1534431-5e890bdc058bdc5e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>虚拟机的ABIs没有配置好,需要项目配置</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1534431-067d2f34dbe6ae82.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>就OK了。</p>\n<ul>\n<li>问题4<br><img src=\"http://upload-images.jianshu.io/upload_images/1534431-42d5c68603b71397.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><br>这个是说你下载的android-sdk需要同意协议，可是我们这个是虚拟的服务器上没有办法点击同意啊，那就看提示解决方法地址</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1534431-385369d144163db1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1534431-3d0e78dbf20fe800.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>有两种解决方案，一种在ui上点，一种是把你已经同意好的协议文件拷贝到当前页面。那我们只能把自己电脑的电脑拷贝进去了，可是又遇到问题，我没有权限访问这个服务器那怎么复制到这个jekins服务器上了，那只能把这个协议文件上传到<a href=\"https://www.qiniu.com/\" target=\"_blank\" rel=\"noopener\">七牛</a>（或者其他托管服务器上），脚本如下</p>\n<pre><code># 进入下载好的android-sdk路径\ncd /root/.jenkins/tools/android-sdk\n# 新建协议文件夹\nmkdir licenses\n# 进入协议文件夹内\ncd /root/.jenkins/tools/android-sdk/licenses\n# rm -rf android-sdk-license\n# 下载已经同意好的android协议文件\nwget http://7xn0ue.com1.z0.glb.clouddn.com/android-sdk-license\n</code></pre><p>具体项目配置</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1534431-da840093cfec03e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>OK,重新构建一下，不过记得先把“构建环境”的配置勾选掉，要不然“构建环境有问题执行不到这个脚本”</p>\n<ul>\n<li>问题5</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1534431-82183912bc907638.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>你运行的系统缺少libGL.so.1库，那就需要安装这个库，找了下可以用</p>\n<pre><code>yum install mesa-libGL -y\n```脚本解决,已经要记得加“-y ”要不然会出错提示\n\n![image.png](http://upload-images.jianshu.io/upload_images/1534431-23a8a172c18ff124.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n- 问题6\n\n![image.png](http://upload-images.jianshu.io/upload_images/1534431-570f151c6e7b1551.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n你运行的系统内核版本过低需要升级，这个也是我比较纠结的要是升级那会不会影响测试服务器的运行。（如果你现在是正式环境下你就需要跟领导沟通只是斟酌了）。\n通过以下脚本可以解决，同\n</code></pre><h1 id=\"下载glibc-2-15-tar-gz内核文件，根据不同版本在http-ftp-gnu-org-gnu-glibc\"><a href=\"#下载glibc-2-15-tar-gz内核文件，根据不同版本在http-ftp-gnu-org-gnu-glibc\" class=\"headerlink\" title=\"下载glibc-2.15.tar.gz内核文件，根据不同版本在http://ftp.gnu.org/gnu/glibc/\"></a>下载glibc-2.15.tar.gz内核文件，根据不同版本在<a href=\"http://ftp.gnu.org/gnu/glibc/\" target=\"_blank\" rel=\"noopener\">http://ftp.gnu.org/gnu/glibc/</a></h1><p>下载<br>wget <a href=\"http://ftp.gnu.org/gnu/glibc/glibc-2.15.tar.gz\" target=\"_blank\" rel=\"noopener\">http://ftp.gnu.org/gnu/glibc/glibc-2.15.tar.gz</a></p>\n<h1 id=\"解压文件\"><a href=\"#解压文件\" class=\"headerlink\" title=\"解压文件\"></a>解压文件</h1><p>tar -xvf glibc-2.15.tar.gz</p>\n<h1 id=\"依赖库-glibc-ports-2-15-tar-gz\"><a href=\"#依赖库-glibc-ports-2-15-tar-gz\" class=\"headerlink\" title=\"依赖库(glibc-ports-2.15.tar.gz)\"></a>依赖库(glibc-ports-2.15.tar.gz)</h1><p>wget <a href=\"http://ftp.gnu.org/gnu/glibc/glibc-ports-2.15.tar.gz\" target=\"_blank\" rel=\"noopener\">http://ftp.gnu.org/gnu/glibc/glibc-ports-2.15.tar.gz</a></p>\n<h1 id=\"解压\"><a href=\"#解压\" class=\"headerlink\" title=\"解压\"></a>解压</h1><p>tar -xvf glibc-ports-2.15.tar.gz</p>\n<h1 id=\"依赖库解压目录移到到主目录中\"><a href=\"#依赖库解压目录移到到主目录中\" class=\"headerlink\" title=\"依赖库解压目录移到到主目录中\"></a>依赖库解压目录移到到主目录中</h1><p>mv glibc-ports-2.15 glibc-2.15/ports</p>\n<h1 id=\"创建编译目录\"><a href=\"#创建编译目录\" class=\"headerlink\" title=\"创建编译目录\"></a>创建编译目录</h1><p>mkdir glibc-build<br>cd glibc-build</p>\n<h1 id=\"运行以下命令编译及安装\"><a href=\"#运行以下命令编译及安装\" class=\"headerlink\" title=\"运行以下命令编译及安装\"></a>运行以下命令编译及安装</h1><p>../glibc-2.15/configure –prefix=/usr –disable-profile –enable-add-ons –with-headers=/usr/include –with-binutils=/usr/bin<br>make<br>make install<br>```<br>配置如下<br><img src=\"http://upload-images.jianshu.io/upload_images/1534431-f5153e0d9295fde4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>以上是我遇到的所有问题，希望这些坑可以对你有帮助。<br>那看下最后成功输出log和配置：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1534431-5a7844d2a0ded788.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"log\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1534431-1e5e1234553f21e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"JDK\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1534431-adb38281522b4c42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"源码仓库\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1534431-f59eff5b1878425c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"构建触发器和构建环境\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1534431-7705c3fbf55d287f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"构建\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>在Jenkins上配置Android的一些持续集成（自动打包上传，单元测试，集成测试等）应该是很普遍的事情了。Jenkins一般配置在一个通用的测试服务器上，原来都是拿一个mac当测试服务器，在上面想怎么玩怎么就怎么玩，想怎么配置就怎么配置。可是如果测试服务器是在虚拟机上而且测试服务器不是你能控制的，那就要在Jenkins上配置Android就不能想自己控制自己电脑那边方便了，在配置过程中也填了不少的坑。那就讲下填坑之路吧。</p>\n<h4 id=\"Jenkins安装\"><a href=\"#Jenkins安装\" class=\"headerlink\" title=\"Jenkins安装\"></a>Jenkins安装</h4><p> 这部分一般不用担心，在公司里会有专门的人员安装，你只管用就可以了。那如果是由你负责安装Jenkins的话那就要好好看Jenkins官网的安装方法了，<a href=\"https://jenkins.io/download/\" target=\"_blank\" rel=\"noopener\">根据不同的平台下载不同的安装包安装</a></p>\n<h4 id=\"Jenkins上新建项目\"><a href=\"#Jenkins上新建项目\" class=\"headerlink\" title=\"Jenkins上新建项目\"></a>Jenkins上新建项目</h4><p>在打开的Jenkins页面左上方找到”创建”(create),<br><img src=\"http://upload-images.jianshu.io/upload_images/1534431-cbd759e33b51c05c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>然后，写项目名和项目类型</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1534431-031ffec2a56338d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>(因为是Android项目，默认就选择第一个。)<br>然后选择”OK”<br>然后,一个新建的项目就好了。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1534431-f3da863f34edd75e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<h4 id=\"Jenkins配置项目\"><a href=\"#Jenkins配置项目\" class=\"headerlink\" title=\"Jenkins配置项目\"></a>Jenkins配置项目</h4><p>配置前提条件就是你<a href=\"https://jenkins.io/doc/book/managing/plugins/\" target=\"_blank\" rel=\"noopener\">jenkins要安装好几个插件</a>: git插件，gradle插件，Android虚拟机插件<br><img src=\"http://upload-images.jianshu.io/upload_images/1534431-d563fd7f6289c76a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><br><img src=\"http://upload-images.jianshu.io/upload_images/1534431-630008664ec0e4df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><br><img src=\"http://upload-images.jianshu.io/upload_images/1534431-096e22f8f71b8d9f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>然后就开始<br><a href=\"https://www.zuehlke.com/blog/en/configure-your-android-project-on-jenkins/\" target=\"_blank\" rel=\"noopener\">Jenkins官网配置Androd环境</a>，</p>\n<ul>\n<li>选择JDK</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1534431-8dc9b1da00eb9751.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<ul>\n<li>源码</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1534431-5d5da1a0efcb3f73.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<ul>\n<li>构建环境</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1534431-0652ce7865dadf45.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\">虚拟机配置后期关闭，配置虚拟机主要用来下载andoid-sdk。</p>\n<ul>\n<li>构建</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1534431-a430e352881caaaa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>OK,好了，这就是正确的配置，那我们就运行下开始深坑之旅了。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1534431-f199552ec5263663.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>看下输入log</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1534431-dcdc202bcd339294.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>####问题不分先后，按解决问题处理</p>\n<ul>\n<li>问题1</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1534431-fe1cf269790bc480.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>虚拟机没有找到相应的hardware配置，尝试更改各种配置方法最后都是失败结束（如果你有其他解决方法记得告诉我）。能走到这一步就说明你的andoid-sdk已经按照好了，只是打开虚拟机还有问题。想想本身主要用来gradle打包Android apk，还用不到打开虚拟机，能安装好Android-sdk就可以。然后在项目配置中![Alt text]<br><img src=\"http://upload-images.jianshu.io/upload_images/1534431-1dee90179b1159f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>勾选掉虚拟机配置就可以了，不影响你gradle打包。</p>\n<ul>\n<li>问题2</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1534431-459d738485a45673.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>Android环境变量没有配置，需要根据Android虚拟机配置下载来的android sdk位置配了，</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1534431-5c08d301ca0b3962.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>仔细看下android虚拟机下载sdk的位置，然后在jenkins的系统配置中配置相应的环境变量<br><img src=\"http://upload-images.jianshu.io/upload_images/1534431-d1dcc03ef8d1b69c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>就可以了。</p>\n<ul>\n<li>问题3</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1534431-5e890bdc058bdc5e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>虚拟机的ABIs没有配置好,需要项目配置</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1534431-067d2f34dbe6ae82.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>就OK了。</p>\n<ul>\n<li>问题4<br><img src=\"http://upload-images.jianshu.io/upload_images/1534431-42d5c68603b71397.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><br>这个是说你下载的android-sdk需要同意协议，可是我们这个是虚拟的服务器上没有办法点击同意啊，那就看提示解决方法地址</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1534431-385369d144163db1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1534431-3d0e78dbf20fe800.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>有两种解决方案，一种在ui上点，一种是把你已经同意好的协议文件拷贝到当前页面。那我们只能把自己电脑的电脑拷贝进去了，可是又遇到问题，我没有权限访问这个服务器那怎么复制到这个jekins服务器上了，那只能把这个协议文件上传到<a href=\"https://www.qiniu.com/\" target=\"_blank\" rel=\"noopener\">七牛</a>（或者其他托管服务器上），脚本如下</p>\n<pre><code># 进入下载好的android-sdk路径\ncd /root/.jenkins/tools/android-sdk\n# 新建协议文件夹\nmkdir licenses\n# 进入协议文件夹内\ncd /root/.jenkins/tools/android-sdk/licenses\n# rm -rf android-sdk-license\n# 下载已经同意好的android协议文件\nwget http://7xn0ue.com1.z0.glb.clouddn.com/android-sdk-license\n</code></pre><p>具体项目配置</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1534431-da840093cfec03e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>OK,重新构建一下，不过记得先把“构建环境”的配置勾选掉，要不然“构建环境有问题执行不到这个脚本”</p>\n<ul>\n<li>问题5</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1534431-82183912bc907638.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>你运行的系统缺少libGL.so.1库，那就需要安装这个库，找了下可以用</p>\n<pre><code>yum install mesa-libGL -y\n```脚本解决,已经要记得加“-y ”要不然会出错提示\n\n![image.png](http://upload-images.jianshu.io/upload_images/1534431-23a8a172c18ff124.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n- 问题6\n\n![image.png](http://upload-images.jianshu.io/upload_images/1534431-570f151c6e7b1551.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n你运行的系统内核版本过低需要升级，这个也是我比较纠结的要是升级那会不会影响测试服务器的运行。（如果你现在是正式环境下你就需要跟领导沟通只是斟酌了）。\n通过以下脚本可以解决，同\n</code></pre><h1 id=\"下载glibc-2-15-tar-gz内核文件，根据不同版本在http-ftp-gnu-org-gnu-glibc\"><a href=\"#下载glibc-2-15-tar-gz内核文件，根据不同版本在http-ftp-gnu-org-gnu-glibc\" class=\"headerlink\" title=\"下载glibc-2.15.tar.gz内核文件，根据不同版本在http://ftp.gnu.org/gnu/glibc/\"></a>下载glibc-2.15.tar.gz内核文件，根据不同版本在<a href=\"http://ftp.gnu.org/gnu/glibc/\" target=\"_blank\" rel=\"noopener\">http://ftp.gnu.org/gnu/glibc/</a></h1><p>下载<br>wget <a href=\"http://ftp.gnu.org/gnu/glibc/glibc-2.15.tar.gz\" target=\"_blank\" rel=\"noopener\">http://ftp.gnu.org/gnu/glibc/glibc-2.15.tar.gz</a></p>\n<h1 id=\"解压文件\"><a href=\"#解压文件\" class=\"headerlink\" title=\"解压文件\"></a>解压文件</h1><p>tar -xvf glibc-2.15.tar.gz</p>\n<h1 id=\"依赖库-glibc-ports-2-15-tar-gz\"><a href=\"#依赖库-glibc-ports-2-15-tar-gz\" class=\"headerlink\" title=\"依赖库(glibc-ports-2.15.tar.gz)\"></a>依赖库(glibc-ports-2.15.tar.gz)</h1><p>wget <a href=\"http://ftp.gnu.org/gnu/glibc/glibc-ports-2.15.tar.gz\" target=\"_blank\" rel=\"noopener\">http://ftp.gnu.org/gnu/glibc/glibc-ports-2.15.tar.gz</a></p>\n<h1 id=\"解压\"><a href=\"#解压\" class=\"headerlink\" title=\"解压\"></a>解压</h1><p>tar -xvf glibc-ports-2.15.tar.gz</p>\n<h1 id=\"依赖库解压目录移到到主目录中\"><a href=\"#依赖库解压目录移到到主目录中\" class=\"headerlink\" title=\"依赖库解压目录移到到主目录中\"></a>依赖库解压目录移到到主目录中</h1><p>mv glibc-ports-2.15 glibc-2.15/ports</p>\n<h1 id=\"创建编译目录\"><a href=\"#创建编译目录\" class=\"headerlink\" title=\"创建编译目录\"></a>创建编译目录</h1><p>mkdir glibc-build<br>cd glibc-build</p>\n<h1 id=\"运行以下命令编译及安装\"><a href=\"#运行以下命令编译及安装\" class=\"headerlink\" title=\"运行以下命令编译及安装\"></a>运行以下命令编译及安装</h1><p>../glibc-2.15/configure –prefix=/usr –disable-profile –enable-add-ons –with-headers=/usr/include –with-binutils=/usr/bin<br>make<br>make install<br>```<br>配置如下<br><img src=\"http://upload-images.jianshu.io/upload_images/1534431-f5153e0d9295fde4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>以上是我遇到的所有问题，希望这些坑可以对你有帮助。<br>那看下最后成功输出log和配置：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1534431-5a7844d2a0ded788.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"log\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1534431-1e5e1234553f21e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"JDK\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1534431-adb38281522b4c42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"源码仓库\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1534431-f59eff5b1878425c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"构建触发器和构建环境\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1534431-7705c3fbf55d287f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"构建\"></p>\n"},{"title":"代码开发效率提升方法","date":"2015-06-19T23:04:29.000Z","_content":"\n## 2015.06.19 - 技术分享，主题\"代码开发效率提升方法\"\n#### snippet的制作与使用 - 杨志平\n\n##### 备份路径\n> ~/Library/Developer/Xcode/UserData/CodeSnippets/\n\n##### 界面\n![image](http://static.oschina.net/uploads/space/2014/0306/145357_xj9O_868062.png)\n\n##### 使用\n\n###### 1.系统自带\n\n很多我们的代码提示都是snippet系统已经有的代码块如：\nblock变量定义\n\n> typedef <#returnType#>(^<#name#>)(<#arguments#>);\n\n###### 2.常用变量\n- strong\n- weak\n- assign\n- block\n\n###### 3.常用方法\n- 比如：hiddenKeyBoard\n- 网络请求：getData\n- 上下拉刷新，等等\n\n###### 4.常用模块\n- 常用的代理协议方法集\n\n\n\n##### 制作\n选中代码块拖入snippet library即可。为了方便调用可简单编辑\n\n![image2](http://static.oschina.net/uploads/space/2014/0306/143716_p6Kl_868062.png)\n\n##### PaintCode的简单使用\n\n简单的图形绘制，可像xib一样拖拽图形，并添加到view的CALayer层上\n\n- drawRect方法\n\n#### myEclipse分享 - 吴明\n - myEclipse主要WebService开发工具\n\n - MyEclipse，是在eclipse 基础上加上自己的插件开发而成的功能强大的企业级集成开发环境，主要用于Java、Java EE以及移动应用的开发。MyEclipse的功能非常强大，支持也十分广泛，尤其是对各种开源产品的支持相当不错。\n\n - [myEclipse使用ssh框架](http://www.cnblogs.com/younes/archive/2011/12/21/2295759.html)\n\n - myEclipse常用快捷键\n \t- Alt+Shift+s:\n \t\t打开myEclipse快捷键菜单\n\t\t- 自动生成get set方法\n\t\t- 自动生成无参和有参构造方法\n \t- Ctrl+D：删除当前行\n \t- Ctrl+Alt+↓：复制当前行到下一行(复制增加)\n \t- Ctrl+Alt+↑：复制当前行到上一行(复制增加)\n \t- Alt+↓：当前行和下面一行交互位置\n \t- Alt+↑：当前行和上面一行交互位置\n \t- Ctrl+Shift+O：快速生成import，当从网上拷贝一段程序后，不知道如何import进所调用的类\n - [ssh框架](http://baike.baidu.com/link?url=-FpesVZmaLqL3GJTVfPriU4jZQlvjIWKgbmy1lxgSlzT83WVAbFUA952pclZJbIkqzDTWVc7L-dTBalJjXTNH_)\n\n#### OSX 快捷键入门 - 曾铭\n\n##### OSX 系统级的快捷键支持\n\n- 统一标准的全局快捷键：如 FX、『设置』、opt\n\t- [一些『奇怪的』符号](https://support.apple.com/kb/PH18802?locale=zh_CN&viewlocale=zh_CN)\n\t- [Mac 键盘快捷键](https://support.apple.com/zh-cn/HT201236)\n\t- 有时，略略隐晦了些：如截图、奇葩的 cmd+tab,opt\n- 在统一之外，留意每个应用的快捷键：如 chrome：opt+cmd+i，cmd+l\n\n##### 讨论常用快捷键 （具体快捷键请自己查）\n\n- 设置\n- 剪切复制粘贴全选\n- 新建、新建 tab、切换 tab、关闭 tab、关闭应用\n- 光标的自由游走\n    - 上下左右（推荐 hjkl）、字符移动、行首行尾、文首文尾、向后删除、单词删除、行向前向后删除\n- Xcode\n\t- 上下移行 （@志平 推荐）\n\t- reveal to project navigator、切换 .h.m 文件\n\t- 显示隐藏 navigatiors、Debug area、Utilities\n\t- new tab、切换 tab、分割窗口\n\n##### 定制\n\n- System Preferences -> Keyboard : 配置快捷键、菜单快捷键、modifier keys\n- [Karabiner](https://pqrs.org/osx/karabiner/index.html.en)\n- [Keyboard Maestro 介绍](http://www.waerfa.com/keyboard-maestro)\n- 定制建议\n\t- 原生为主，定制为辅\n\t- fix 原生不爽、有冲突的个别快捷键\n        - 合理使用 opt， 规避冲突\n\t- 根据自己习惯定制\n\t- 常反思，记不住的快捷键都是『对你不重要』的快捷键\n\n#### VIM - 潘君\n\n##### vim起源\n- 源自开源vi\n- 作者Bram Moolenaar\n- 80年代末,Amiga计算机中无vi,作者自行开发\n- Vi IMitation(模拟) -> Vi IMproved(改良)\n\n##### vim应用场景\n\n- linux\n- 平时代码\n\n##### vim模式\n列举常用模式如下\n需要了解所有模式\n在vim中使用`:help vim-modes`\n\n- Insert模式\n\t- 进入\n\t\t- i -> 在光标前插入\n\t\t- I-> 在句首插入\n\t\t- a -> 在光标后插入\n\t\t- A -> 在句尾插入\n\t- 离开\n\t\t- Esc\n\t\t- Ctrl + c\n\t\t- Ctrl + [\n\n- Normal模式\n\t- 进入vim的默认模式\n\t- 命令的天下\n\t\t- 简单移动\n\t\t\t- h j k l  -> 左 下 上 右\n\t\t\t- 0 (数字零) -> 移动光标到行头\n\t\t\t- $ -> 移动光标到行尾\n\t\t\t- gg -> 到第一行\n\t\t\t- G -> 到最后一行\n\t\t\t- w -> 到下一个单词的开头。\n\t\t\t- e -> 到下一个单词的结尾。\n\t\t- 简单操作\n\t\t\t- dd -> 剪切当前行\n\t\t\t- yy ->  赋值当前行\n\t\t\t- p -> 粘贴\n\t\t\t- u -> 撤销\n\t- 神奇的`.`\n\t\t- 上次命令的重复\n\n\t- 命令的组合\n\t\t- daw -> 删除当前单词\n\t\t- 2dd -> 删除2行\n\t\t- 3p → 粘贴文本3次\n\t\t- 100idesu [ESC] → 会写下 “desu “100次\n\t\t- 0y$ -> 从行头拷贝到本行最后一个字符\n\n- visual模式\n\t- 进入\n\t\t- v\n\t\t- V\n\t\t- Ctrl + v\n\t- 退出\n\t\t- Esc\n\t\t- Ctrl + c\n\n- select模式\n\t- 进入\n\t\t- gh\n\t\t- gH\n\t\t- g(Ctrl + h)\n\n\t- 切换\n\t\t- Ctrl + o ->临时切换到可视化模式执行一个命令\n\t\t- Ctrl + g ->切换到可视化模式\n\n##### vim大冒险游戏\n- [游戏链接](http://vim-adventures.com/)\n\n#### VIM常用命令 - 王胜\n##### 光标移动\n- fx：移动光标到当前行的下一个 x 处。很明显，x 可以是任意一个字母，而且你可以使用 ; 来重复你的上一个 f 命令。\n- tx：和上面的命令类似，但是是移动到 x 的左边一个位置。\n- Fx：和 fx 类似，不过是往回找。\n- w：光标往前移动一个词。\n- b：光标往后移动一个词。\n- 0：移动光标到当前行首。\n- ^：移动光标到当前行的第一个字母位置。\n- $：移动光标到行尾。\n- )：移动光标到下一个句子。\n- ( ：移动光标到上一个句子\n\n##### 替换\n- :s/hello/world 替换当前行中第一个hello为world\n- :%s/hello/world 替换每一行中第一个hello为world\n- :s/hello/world/g 替换当前行中所有的hello为world\n- :%s/hello/world/g 替换每一行中所有的hello为world\n- :%s/hello/world/gc 找到当前文件中所有的hello，并逐一询问用户是否要替换\n\n##### 内容提取\n- :r !date 将当前时间插入到当前文件\n- :r /path/to/src.file 将src.file里的内容输出到当前文件\n\n##### 总结\nVIM的命令甚多，组合也很多，记忆是不能长时间记住的。唯一的捷径就是多多使用，用的多了，使用这些命令时就像手拿筷子一样，变成了本能。\n\n#### Xcode插件管理 - 张超耀\n - 古人云“工欲善其事,必先利其器”，打造一个强大的开发环境，是立即提升自身战斗力的绝佳途径！以下是常用的一些有力的XCode插件。\n\n - 插件管理器：[Alcatraz](http://alcatraz.io/) - The package manager for Xcode。\n\n - [ColorSense](https://github.com/omz/ColorSense-for-Xcode)XCode颜色显示插件\n \t- 代码里的那些冷冰冰的颜色数值，到底时什么颜色？如果你经常遇到这个问题，每每不得不运行下模拟器去看看，那么这个插件绝对不容错过。更彪悍的是你甚至可以点击显示的颜色面板，直接通过系统的ColorPicker来自动生成对应颜色代码，再也不用做各种颜色代码转换了！\n\n- [VVDocumenter](https://github.com/onevcat/VVDocumenter-Xcode)规范注释生成器\n\t- 很多时候，为了快速开发，很多的技术文档都是能省则省，这个时候注释就变得异常重要，再配合Doxygen这种注释自动生成文档的，就完美了。但是每次都要手动输入规范化的注释，着实也麻烦，但有了VVDocumenter，规范化的注释，主需要输入三个斜线“///”，就OK啦！\n\n- [XAlign](https://github.com/qfish/XAlign)代码整理\n\t- XAlign是一款专门用于代码整理的Xcode插件，其作者为来自Geek Zoo Studio的开发者QFish。XAlign能够对开发者的代码非常快速地进行对齐优化，有“=”、宏定义、属性三种对齐模式。当然，如果默认的对齐风格不是自己喜欢的，开发者还可以自定义或提出issues。\n\n- [FuzzyAutocompletePlugin](https://github.com/FuzzyAutocomplete/FuzzyAutocompletePlugin)代码自动补全插件\n\t- 通过添加模糊匹配来提高Xcode代码自动补全功能，开发者无需遵循从头匹配的原则，只要记得方法里某个关键字即可进行匹配，很好地提高了工作效率。\n\n- XcodeBoost\n\t- XcodeBoost是一款可以让开发者轻而易举地检查和修改Objective-C代码的插件。XcodeBoost能够自动进行一些繁琐的操作，比如方法的定义与声明、添加基于命令行的代码处理（剪切/复制/粘贴/重复/删除行）、持续高亮等。\n\n\n##### [盘点开发者最喜爱的十大开源Xcode插件](http://www.csdn.net/article/2014-05-04/2819586-the-best-xcode-plugins/1)\n##### [那些不能错过的Xcode插件](http://www.cocoachina.com/industry/20130918/7022.html)\n","source":"_posts/代码效率.md","raw":"title: 代码开发效率提升方法\ndate: 2015-06-19 23:04:29\ntags:\n- 开发效率\n- 效率\ncategories: 移动组周分享\n\n---\n\n## 2015.06.19 - 技术分享，主题\"代码开发效率提升方法\"\n#### snippet的制作与使用 - 杨志平\n\n##### 备份路径\n> ~/Library/Developer/Xcode/UserData/CodeSnippets/\n\n##### 界面\n![image](http://static.oschina.net/uploads/space/2014/0306/145357_xj9O_868062.png)\n\n##### 使用\n\n###### 1.系统自带\n\n很多我们的代码提示都是snippet系统已经有的代码块如：\nblock变量定义\n\n> typedef <#returnType#>(^<#name#>)(<#arguments#>);\n\n###### 2.常用变量\n- strong\n- weak\n- assign\n- block\n\n###### 3.常用方法\n- 比如：hiddenKeyBoard\n- 网络请求：getData\n- 上下拉刷新，等等\n\n###### 4.常用模块\n- 常用的代理协议方法集\n\n\n\n##### 制作\n选中代码块拖入snippet library即可。为了方便调用可简单编辑\n\n![image2](http://static.oschina.net/uploads/space/2014/0306/143716_p6Kl_868062.png)\n\n##### PaintCode的简单使用\n\n简单的图形绘制，可像xib一样拖拽图形，并添加到view的CALayer层上\n\n- drawRect方法\n\n#### myEclipse分享 - 吴明\n - myEclipse主要WebService开发工具\n\n - MyEclipse，是在eclipse 基础上加上自己的插件开发而成的功能强大的企业级集成开发环境，主要用于Java、Java EE以及移动应用的开发。MyEclipse的功能非常强大，支持也十分广泛，尤其是对各种开源产品的支持相当不错。\n\n - [myEclipse使用ssh框架](http://www.cnblogs.com/younes/archive/2011/12/21/2295759.html)\n\n - myEclipse常用快捷键\n \t- Alt+Shift+s:\n \t\t打开myEclipse快捷键菜单\n\t\t- 自动生成get set方法\n\t\t- 自动生成无参和有参构造方法\n \t- Ctrl+D：删除当前行\n \t- Ctrl+Alt+↓：复制当前行到下一行(复制增加)\n \t- Ctrl+Alt+↑：复制当前行到上一行(复制增加)\n \t- Alt+↓：当前行和下面一行交互位置\n \t- Alt+↑：当前行和上面一行交互位置\n \t- Ctrl+Shift+O：快速生成import，当从网上拷贝一段程序后，不知道如何import进所调用的类\n - [ssh框架](http://baike.baidu.com/link?url=-FpesVZmaLqL3GJTVfPriU4jZQlvjIWKgbmy1lxgSlzT83WVAbFUA952pclZJbIkqzDTWVc7L-dTBalJjXTNH_)\n\n#### OSX 快捷键入门 - 曾铭\n\n##### OSX 系统级的快捷键支持\n\n- 统一标准的全局快捷键：如 FX、『设置』、opt\n\t- [一些『奇怪的』符号](https://support.apple.com/kb/PH18802?locale=zh_CN&viewlocale=zh_CN)\n\t- [Mac 键盘快捷键](https://support.apple.com/zh-cn/HT201236)\n\t- 有时，略略隐晦了些：如截图、奇葩的 cmd+tab,opt\n- 在统一之外，留意每个应用的快捷键：如 chrome：opt+cmd+i，cmd+l\n\n##### 讨论常用快捷键 （具体快捷键请自己查）\n\n- 设置\n- 剪切复制粘贴全选\n- 新建、新建 tab、切换 tab、关闭 tab、关闭应用\n- 光标的自由游走\n    - 上下左右（推荐 hjkl）、字符移动、行首行尾、文首文尾、向后删除、单词删除、行向前向后删除\n- Xcode\n\t- 上下移行 （@志平 推荐）\n\t- reveal to project navigator、切换 .h.m 文件\n\t- 显示隐藏 navigatiors、Debug area、Utilities\n\t- new tab、切换 tab、分割窗口\n\n##### 定制\n\n- System Preferences -> Keyboard : 配置快捷键、菜单快捷键、modifier keys\n- [Karabiner](https://pqrs.org/osx/karabiner/index.html.en)\n- [Keyboard Maestro 介绍](http://www.waerfa.com/keyboard-maestro)\n- 定制建议\n\t- 原生为主，定制为辅\n\t- fix 原生不爽、有冲突的个别快捷键\n        - 合理使用 opt， 规避冲突\n\t- 根据自己习惯定制\n\t- 常反思，记不住的快捷键都是『对你不重要』的快捷键\n\n#### VIM - 潘君\n\n##### vim起源\n- 源自开源vi\n- 作者Bram Moolenaar\n- 80年代末,Amiga计算机中无vi,作者自行开发\n- Vi IMitation(模拟) -> Vi IMproved(改良)\n\n##### vim应用场景\n\n- linux\n- 平时代码\n\n##### vim模式\n列举常用模式如下\n需要了解所有模式\n在vim中使用`:help vim-modes`\n\n- Insert模式\n\t- 进入\n\t\t- i -> 在光标前插入\n\t\t- I-> 在句首插入\n\t\t- a -> 在光标后插入\n\t\t- A -> 在句尾插入\n\t- 离开\n\t\t- Esc\n\t\t- Ctrl + c\n\t\t- Ctrl + [\n\n- Normal模式\n\t- 进入vim的默认模式\n\t- 命令的天下\n\t\t- 简单移动\n\t\t\t- h j k l  -> 左 下 上 右\n\t\t\t- 0 (数字零) -> 移动光标到行头\n\t\t\t- $ -> 移动光标到行尾\n\t\t\t- gg -> 到第一行\n\t\t\t- G -> 到最后一行\n\t\t\t- w -> 到下一个单词的开头。\n\t\t\t- e -> 到下一个单词的结尾。\n\t\t- 简单操作\n\t\t\t- dd -> 剪切当前行\n\t\t\t- yy ->  赋值当前行\n\t\t\t- p -> 粘贴\n\t\t\t- u -> 撤销\n\t- 神奇的`.`\n\t\t- 上次命令的重复\n\n\t- 命令的组合\n\t\t- daw -> 删除当前单词\n\t\t- 2dd -> 删除2行\n\t\t- 3p → 粘贴文本3次\n\t\t- 100idesu [ESC] → 会写下 “desu “100次\n\t\t- 0y$ -> 从行头拷贝到本行最后一个字符\n\n- visual模式\n\t- 进入\n\t\t- v\n\t\t- V\n\t\t- Ctrl + v\n\t- 退出\n\t\t- Esc\n\t\t- Ctrl + c\n\n- select模式\n\t- 进入\n\t\t- gh\n\t\t- gH\n\t\t- g(Ctrl + h)\n\n\t- 切换\n\t\t- Ctrl + o ->临时切换到可视化模式执行一个命令\n\t\t- Ctrl + g ->切换到可视化模式\n\n##### vim大冒险游戏\n- [游戏链接](http://vim-adventures.com/)\n\n#### VIM常用命令 - 王胜\n##### 光标移动\n- fx：移动光标到当前行的下一个 x 处。很明显，x 可以是任意一个字母，而且你可以使用 ; 来重复你的上一个 f 命令。\n- tx：和上面的命令类似，但是是移动到 x 的左边一个位置。\n- Fx：和 fx 类似，不过是往回找。\n- w：光标往前移动一个词。\n- b：光标往后移动一个词。\n- 0：移动光标到当前行首。\n- ^：移动光标到当前行的第一个字母位置。\n- $：移动光标到行尾。\n- )：移动光标到下一个句子。\n- ( ：移动光标到上一个句子\n\n##### 替换\n- :s/hello/world 替换当前行中第一个hello为world\n- :%s/hello/world 替换每一行中第一个hello为world\n- :s/hello/world/g 替换当前行中所有的hello为world\n- :%s/hello/world/g 替换每一行中所有的hello为world\n- :%s/hello/world/gc 找到当前文件中所有的hello，并逐一询问用户是否要替换\n\n##### 内容提取\n- :r !date 将当前时间插入到当前文件\n- :r /path/to/src.file 将src.file里的内容输出到当前文件\n\n##### 总结\nVIM的命令甚多，组合也很多，记忆是不能长时间记住的。唯一的捷径就是多多使用，用的多了，使用这些命令时就像手拿筷子一样，变成了本能。\n\n#### Xcode插件管理 - 张超耀\n - 古人云“工欲善其事,必先利其器”，打造一个强大的开发环境，是立即提升自身战斗力的绝佳途径！以下是常用的一些有力的XCode插件。\n\n - 插件管理器：[Alcatraz](http://alcatraz.io/) - The package manager for Xcode。\n\n - [ColorSense](https://github.com/omz/ColorSense-for-Xcode)XCode颜色显示插件\n \t- 代码里的那些冷冰冰的颜色数值，到底时什么颜色？如果你经常遇到这个问题，每每不得不运行下模拟器去看看，那么这个插件绝对不容错过。更彪悍的是你甚至可以点击显示的颜色面板，直接通过系统的ColorPicker来自动生成对应颜色代码，再也不用做各种颜色代码转换了！\n\n- [VVDocumenter](https://github.com/onevcat/VVDocumenter-Xcode)规范注释生成器\n\t- 很多时候，为了快速开发，很多的技术文档都是能省则省，这个时候注释就变得异常重要，再配合Doxygen这种注释自动生成文档的，就完美了。但是每次都要手动输入规范化的注释，着实也麻烦，但有了VVDocumenter，规范化的注释，主需要输入三个斜线“///”，就OK啦！\n\n- [XAlign](https://github.com/qfish/XAlign)代码整理\n\t- XAlign是一款专门用于代码整理的Xcode插件，其作者为来自Geek Zoo Studio的开发者QFish。XAlign能够对开发者的代码非常快速地进行对齐优化，有“=”、宏定义、属性三种对齐模式。当然，如果默认的对齐风格不是自己喜欢的，开发者还可以自定义或提出issues。\n\n- [FuzzyAutocompletePlugin](https://github.com/FuzzyAutocomplete/FuzzyAutocompletePlugin)代码自动补全插件\n\t- 通过添加模糊匹配来提高Xcode代码自动补全功能，开发者无需遵循从头匹配的原则，只要记得方法里某个关键字即可进行匹配，很好地提高了工作效率。\n\n- XcodeBoost\n\t- XcodeBoost是一款可以让开发者轻而易举地检查和修改Objective-C代码的插件。XcodeBoost能够自动进行一些繁琐的操作，比如方法的定义与声明、添加基于命令行的代码处理（剪切/复制/粘贴/重复/删除行）、持续高亮等。\n\n\n##### [盘点开发者最喜爱的十大开源Xcode插件](http://www.csdn.net/article/2014-05-04/2819586-the-best-xcode-plugins/1)\n##### [那些不能错过的Xcode插件](http://www.cocoachina.com/industry/20130918/7022.html)\n","slug":"代码效率","published":1,"updated":"2021-09-10T07:04:21.945Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cktfeap41001kc2xxl7tca3lp","content":"<h2 id=\"2015-06-19-技术分享，主题”代码开发效率提升方法”\"><a href=\"#2015-06-19-技术分享，主题”代码开发效率提升方法”\" class=\"headerlink\" title=\"2015.06.19 - 技术分享，主题”代码开发效率提升方法”\"></a>2015.06.19 - 技术分享，主题”代码开发效率提升方法”</h2><h4 id=\"snippet的制作与使用-杨志平\"><a href=\"#snippet的制作与使用-杨志平\" class=\"headerlink\" title=\"snippet的制作与使用 - 杨志平\"></a>snippet的制作与使用 - 杨志平</h4><h5 id=\"备份路径\"><a href=\"#备份路径\" class=\"headerlink\" title=\"备份路径\"></a>备份路径</h5><blockquote>\n<p>~/Library/Developer/Xcode/UserData/CodeSnippets/</p>\n</blockquote>\n<h5 id=\"界面\"><a href=\"#界面\" class=\"headerlink\" title=\"界面\"></a>界面</h5><p><img src=\"http://static.oschina.net/uploads/space/2014/0306/145357_xj9O_868062.png\" alt=\"image\"></p>\n<h5 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h5><h6 id=\"1-系统自带\"><a href=\"#1-系统自带\" class=\"headerlink\" title=\"1.系统自带\"></a>1.系统自带</h6><p>很多我们的代码提示都是snippet系统已经有的代码块如：<br>block变量定义</p>\n<blockquote>\n<p>typedef &lt;#returnType#&gt;(^&lt;#name#&gt;)(&lt;#arguments#&gt;);</p>\n</blockquote>\n<h6 id=\"2-常用变量\"><a href=\"#2-常用变量\" class=\"headerlink\" title=\"2.常用变量\"></a>2.常用变量</h6><ul>\n<li>strong</li>\n<li>weak</li>\n<li>assign</li>\n<li>block</li>\n</ul>\n<h6 id=\"3-常用方法\"><a href=\"#3-常用方法\" class=\"headerlink\" title=\"3.常用方法\"></a>3.常用方法</h6><ul>\n<li>比如：hiddenKeyBoard</li>\n<li>网络请求：getData</li>\n<li>上下拉刷新，等等</li>\n</ul>\n<h6 id=\"4-常用模块\"><a href=\"#4-常用模块\" class=\"headerlink\" title=\"4.常用模块\"></a>4.常用模块</h6><ul>\n<li>常用的代理协议方法集</li>\n</ul>\n<h5 id=\"制作\"><a href=\"#制作\" class=\"headerlink\" title=\"制作\"></a>制作</h5><p>选中代码块拖入snippet library即可。为了方便调用可简单编辑</p>\n<p><img src=\"http://static.oschina.net/uploads/space/2014/0306/143716_p6Kl_868062.png\" alt=\"image2\"></p>\n<h5 id=\"PaintCode的简单使用\"><a href=\"#PaintCode的简单使用\" class=\"headerlink\" title=\"PaintCode的简单使用\"></a>PaintCode的简单使用</h5><p>简单的图形绘制，可像xib一样拖拽图形，并添加到view的CALayer层上</p>\n<ul>\n<li>drawRect方法</li>\n</ul>\n<h4 id=\"myEclipse分享-吴明\"><a href=\"#myEclipse分享-吴明\" class=\"headerlink\" title=\"myEclipse分享 - 吴明\"></a>myEclipse分享 - 吴明</h4><ul>\n<li><p>myEclipse主要WebService开发工具</p>\n</li>\n<li><p>MyEclipse，是在eclipse 基础上加上自己的插件开发而成的功能强大的企业级集成开发环境，主要用于Java、Java EE以及移动应用的开发。MyEclipse的功能非常强大，支持也十分广泛，尤其是对各种开源产品的支持相当不错。</p>\n</li>\n<li><p><a href=\"http://www.cnblogs.com/younes/archive/2011/12/21/2295759.html\" target=\"_blank\" rel=\"noopener\">myEclipse使用ssh框架</a></p>\n</li>\n<li><p>myEclipse常用快捷键</p>\n<ul>\n<li>Alt+Shift+s:<br>  打开myEclipse快捷键菜单<ul>\n<li>自动生成get set方法</li>\n<li>自动生成无参和有参构造方法</li>\n</ul>\n</li>\n<li>Ctrl+D：删除当前行</li>\n<li>Ctrl+Alt+↓：复制当前行到下一行(复制增加)</li>\n<li>Ctrl+Alt+↑：复制当前行到上一行(复制增加)</li>\n<li>Alt+↓：当前行和下面一行交互位置</li>\n<li>Alt+↑：当前行和上面一行交互位置</li>\n<li>Ctrl+Shift+O：快速生成import，当从网上拷贝一段程序后，不知道如何import进所调用的类</li>\n</ul>\n</li>\n<li><a href=\"http://baike.baidu.com/link?url=-FpesVZmaLqL3GJTVfPriU4jZQlvjIWKgbmy1lxgSlzT83WVAbFUA952pclZJbIkqzDTWVc7L-dTBalJjXTNH_\" target=\"_blank\" rel=\"noopener\">ssh框架</a></li>\n</ul>\n<h4 id=\"OSX-快捷键入门-曾铭\"><a href=\"#OSX-快捷键入门-曾铭\" class=\"headerlink\" title=\"OSX 快捷键入门 - 曾铭\"></a>OSX 快捷键入门 - 曾铭</h4><h5 id=\"OSX-系统级的快捷键支持\"><a href=\"#OSX-系统级的快捷键支持\" class=\"headerlink\" title=\"OSX 系统级的快捷键支持\"></a>OSX 系统级的快捷键支持</h5><ul>\n<li>统一标准的全局快捷键：如 FX、『设置』、opt<ul>\n<li><a href=\"https://support.apple.com/kb/PH18802?locale=zh_CN&amp;viewlocale=zh_CN\" target=\"_blank\" rel=\"noopener\">一些『奇怪的』符号</a></li>\n<li><a href=\"https://support.apple.com/zh-cn/HT201236\" target=\"_blank\" rel=\"noopener\">Mac 键盘快捷键</a></li>\n<li>有时，略略隐晦了些：如截图、奇葩的 cmd+tab,opt</li>\n</ul>\n</li>\n<li>在统一之外，留意每个应用的快捷键：如 chrome：opt+cmd+i，cmd+l</li>\n</ul>\n<h5 id=\"讨论常用快捷键-（具体快捷键请自己查）\"><a href=\"#讨论常用快捷键-（具体快捷键请自己查）\" class=\"headerlink\" title=\"讨论常用快捷键 （具体快捷键请自己查）\"></a>讨论常用快捷键 （具体快捷键请自己查）</h5><ul>\n<li>设置</li>\n<li>剪切复制粘贴全选</li>\n<li>新建、新建 tab、切换 tab、关闭 tab、关闭应用</li>\n<li>光标的自由游走<ul>\n<li>上下左右（推荐 hjkl）、字符移动、行首行尾、文首文尾、向后删除、单词删除、行向前向后删除</li>\n</ul>\n</li>\n<li>Xcode<ul>\n<li>上下移行 （@志平 推荐）</li>\n<li>reveal to project navigator、切换 .h.m 文件</li>\n<li>显示隐藏 navigatiors、Debug area、Utilities</li>\n<li>new tab、切换 tab、分割窗口</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"定制\"><a href=\"#定制\" class=\"headerlink\" title=\"定制\"></a>定制</h5><ul>\n<li>System Preferences -&gt; Keyboard : 配置快捷键、菜单快捷键、modifier keys</li>\n<li><a href=\"https://pqrs.org/osx/karabiner/index.html.en\" target=\"_blank\" rel=\"noopener\">Karabiner</a></li>\n<li><a href=\"http://www.waerfa.com/keyboard-maestro\" target=\"_blank\" rel=\"noopener\">Keyboard Maestro 介绍</a></li>\n<li>定制建议<ul>\n<li>原生为主，定制为辅</li>\n<li>fix 原生不爽、有冲突的个别快捷键<ul>\n<li>合理使用 opt， 规避冲突</li>\n</ul>\n</li>\n<li>根据自己习惯定制</li>\n<li>常反思，记不住的快捷键都是『对你不重要』的快捷键</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"VIM-潘君\"><a href=\"#VIM-潘君\" class=\"headerlink\" title=\"VIM - 潘君\"></a>VIM - 潘君</h4><h5 id=\"vim起源\"><a href=\"#vim起源\" class=\"headerlink\" title=\"vim起源\"></a>vim起源</h5><ul>\n<li>源自开源vi</li>\n<li>作者Bram Moolenaar</li>\n<li>80年代末,Amiga计算机中无vi,作者自行开发</li>\n<li>Vi IMitation(模拟) -&gt; Vi IMproved(改良)</li>\n</ul>\n<h5 id=\"vim应用场景\"><a href=\"#vim应用场景\" class=\"headerlink\" title=\"vim应用场景\"></a>vim应用场景</h5><ul>\n<li>linux</li>\n<li>平时代码</li>\n</ul>\n<h5 id=\"vim模式\"><a href=\"#vim模式\" class=\"headerlink\" title=\"vim模式\"></a>vim模式</h5><p>列举常用模式如下<br>需要了解所有模式<br>在vim中使用<code>:help vim-modes</code></p>\n<ul>\n<li><p>Insert模式</p>\n<ul>\n<li>进入<ul>\n<li>i -&gt; 在光标前插入</li>\n<li>I-&gt; 在句首插入</li>\n<li>a -&gt; 在光标后插入</li>\n<li>A -&gt; 在句尾插入</li>\n</ul>\n</li>\n<li>离开<ul>\n<li>Esc</li>\n<li>Ctrl + c</li>\n<li>Ctrl + [</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Normal模式</p>\n<ul>\n<li>进入vim的默认模式</li>\n<li>命令的天下<ul>\n<li>简单移动<ul>\n<li>h j k l  -&gt; 左 下 上 右</li>\n<li>0 (数字零) -&gt; 移动光标到行头</li>\n<li>$ -&gt; 移动光标到行尾</li>\n<li>gg -&gt; 到第一行</li>\n<li>G -&gt; 到最后一行</li>\n<li>w -&gt; 到下一个单词的开头。</li>\n<li>e -&gt; 到下一个单词的结尾。</li>\n</ul>\n</li>\n<li>简单操作<ul>\n<li>dd -&gt; 剪切当前行</li>\n<li>yy -&gt;  赋值当前行</li>\n<li>p -&gt; 粘贴</li>\n<li>u -&gt; 撤销</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>神奇的<code>.</code></p>\n<ul>\n<li>上次命令的重复</li>\n</ul>\n</li>\n<li><p>命令的组合</p>\n<ul>\n<li>daw -&gt; 删除当前单词</li>\n<li>2dd -&gt; 删除2行</li>\n<li>3p → 粘贴文本3次</li>\n<li>100idesu [ESC] → 会写下 “desu “100次</li>\n<li>0y$ -&gt; 从行头拷贝到本行最后一个字符</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>visual模式</p>\n<ul>\n<li>进入<ul>\n<li>v</li>\n<li>V</li>\n<li>Ctrl + v</li>\n</ul>\n</li>\n<li>退出<ul>\n<li>Esc</li>\n<li>Ctrl + c</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>select模式</p>\n<ul>\n<li><p>进入</p>\n<ul>\n<li>gh</li>\n<li>gH</li>\n<li>g(Ctrl + h)</li>\n</ul>\n</li>\n<li><p>切换</p>\n<ul>\n<li>Ctrl + o -&gt;临时切换到可视化模式执行一个命令</li>\n<li>Ctrl + g -&gt;切换到可视化模式</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"vim大冒险游戏\"><a href=\"#vim大冒险游戏\" class=\"headerlink\" title=\"vim大冒险游戏\"></a>vim大冒险游戏</h5><ul>\n<li><a href=\"http://vim-adventures.com/\" target=\"_blank\" rel=\"noopener\">游戏链接</a></li>\n</ul>\n<h4 id=\"VIM常用命令-王胜\"><a href=\"#VIM常用命令-王胜\" class=\"headerlink\" title=\"VIM常用命令 - 王胜\"></a>VIM常用命令 - 王胜</h4><h5 id=\"光标移动\"><a href=\"#光标移动\" class=\"headerlink\" title=\"光标移动\"></a>光标移动</h5><ul>\n<li>fx：移动光标到当前行的下一个 x 处。很明显，x 可以是任意一个字母，而且你可以使用 ; 来重复你的上一个 f 命令。</li>\n<li>tx：和上面的命令类似，但是是移动到 x 的左边一个位置。</li>\n<li>Fx：和 fx 类似，不过是往回找。</li>\n<li>w：光标往前移动一个词。</li>\n<li>b：光标往后移动一个词。</li>\n<li>0：移动光标到当前行首。</li>\n<li>^：移动光标到当前行的第一个字母位置。</li>\n<li>$：移动光标到行尾。</li>\n<li>)：移动光标到下一个句子。</li>\n<li>( ：移动光标到上一个句子</li>\n</ul>\n<h5 id=\"替换\"><a href=\"#替换\" class=\"headerlink\" title=\"替换\"></a>替换</h5><ul>\n<li>:s/hello/world 替换当前行中第一个hello为world</li>\n<li>:%s/hello/world 替换每一行中第一个hello为world</li>\n<li>:s/hello/world/g 替换当前行中所有的hello为world</li>\n<li>:%s/hello/world/g 替换每一行中所有的hello为world</li>\n<li>:%s/hello/world/gc 找到当前文件中所有的hello，并逐一询问用户是否要替换</li>\n</ul>\n<h5 id=\"内容提取\"><a href=\"#内容提取\" class=\"headerlink\" title=\"内容提取\"></a>内容提取</h5><ul>\n<li>:r !date 将当前时间插入到当前文件</li>\n<li>:r /path/to/src.file 将src.file里的内容输出到当前文件</li>\n</ul>\n<h5 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h5><p>VIM的命令甚多，组合也很多，记忆是不能长时间记住的。唯一的捷径就是多多使用，用的多了，使用这些命令时就像手拿筷子一样，变成了本能。</p>\n<h4 id=\"Xcode插件管理-张超耀\"><a href=\"#Xcode插件管理-张超耀\" class=\"headerlink\" title=\"Xcode插件管理 - 张超耀\"></a>Xcode插件管理 - 张超耀</h4><ul>\n<li><p>古人云“工欲善其事,必先利其器”，打造一个强大的开发环境，是立即提升自身战斗力的绝佳途径！以下是常用的一些有力的XCode插件。</p>\n</li>\n<li><p>插件管理器：<a href=\"http://alcatraz.io/\" target=\"_blank\" rel=\"noopener\">Alcatraz</a> - The package manager for Xcode。</p>\n</li>\n<li><p><a href=\"https://github.com/omz/ColorSense-for-Xcode\" target=\"_blank\" rel=\"noopener\">ColorSense</a>XCode颜色显示插件</p>\n<ul>\n<li>代码里的那些冷冰冰的颜色数值，到底时什么颜色？如果你经常遇到这个问题，每每不得不运行下模拟器去看看，那么这个插件绝对不容错过。更彪悍的是你甚至可以点击显示的颜色面板，直接通过系统的ColorPicker来自动生成对应颜色代码，再也不用做各种颜色代码转换了！</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p><a href=\"https://github.com/onevcat/VVDocumenter-Xcode\" target=\"_blank\" rel=\"noopener\">VVDocumenter</a>规范注释生成器</p>\n<ul>\n<li>很多时候，为了快速开发，很多的技术文档都是能省则省，这个时候注释就变得异常重要，再配合Doxygen这种注释自动生成文档的，就完美了。但是每次都要手动输入规范化的注释，着实也麻烦，但有了VVDocumenter，规范化的注释，主需要输入三个斜线“///”，就OK啦！</li>\n</ul>\n</li>\n<li><p><a href=\"https://github.com/qfish/XAlign\" target=\"_blank\" rel=\"noopener\">XAlign</a>代码整理</p>\n<ul>\n<li>XAlign是一款专门用于代码整理的Xcode插件，其作者为来自Geek Zoo Studio的开发者QFish。XAlign能够对开发者的代码非常快速地进行对齐优化，有“=”、宏定义、属性三种对齐模式。当然，如果默认的对齐风格不是自己喜欢的，开发者还可以自定义或提出issues。</li>\n</ul>\n</li>\n<li><p><a href=\"https://github.com/FuzzyAutocomplete/FuzzyAutocompletePlugin\" target=\"_blank\" rel=\"noopener\">FuzzyAutocompletePlugin</a>代码自动补全插件</p>\n<ul>\n<li>通过添加模糊匹配来提高Xcode代码自动补全功能，开发者无需遵循从头匹配的原则，只要记得方法里某个关键字即可进行匹配，很好地提高了工作效率。</li>\n</ul>\n</li>\n<li><p>XcodeBoost</p>\n<ul>\n<li>XcodeBoost是一款可以让开发者轻而易举地检查和修改Objective-C代码的插件。XcodeBoost能够自动进行一些繁琐的操作，比如方法的定义与声明、添加基于命令行的代码处理（剪切/复制/粘贴/重复/删除行）、持续高亮等。</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"盘点开发者最喜爱的十大开源Xcode插件\"><a href=\"#盘点开发者最喜爱的十大开源Xcode插件\" class=\"headerlink\" title=\"盘点开发者最喜爱的十大开源Xcode插件\"></a><a href=\"http://www.csdn.net/article/2014-05-04/2819586-the-best-xcode-plugins/1\" target=\"_blank\" rel=\"noopener\">盘点开发者最喜爱的十大开源Xcode插件</a></h5><h5 id=\"那些不能错过的Xcode插件\"><a href=\"#那些不能错过的Xcode插件\" class=\"headerlink\" title=\"那些不能错过的Xcode插件\"></a><a href=\"http://www.cocoachina.com/industry/20130918/7022.html\" target=\"_blank\" rel=\"noopener\">那些不能错过的Xcode插件</a></h5>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"2015-06-19-技术分享，主题”代码开发效率提升方法”\"><a href=\"#2015-06-19-技术分享，主题”代码开发效率提升方法”\" class=\"headerlink\" title=\"2015.06.19 - 技术分享，主题”代码开发效率提升方法”\"></a>2015.06.19 - 技术分享，主题”代码开发效率提升方法”</h2><h4 id=\"snippet的制作与使用-杨志平\"><a href=\"#snippet的制作与使用-杨志平\" class=\"headerlink\" title=\"snippet的制作与使用 - 杨志平\"></a>snippet的制作与使用 - 杨志平</h4><h5 id=\"备份路径\"><a href=\"#备份路径\" class=\"headerlink\" title=\"备份路径\"></a>备份路径</h5><blockquote>\n<p>~/Library/Developer/Xcode/UserData/CodeSnippets/</p>\n</blockquote>\n<h5 id=\"界面\"><a href=\"#界面\" class=\"headerlink\" title=\"界面\"></a>界面</h5><p><img src=\"http://static.oschina.net/uploads/space/2014/0306/145357_xj9O_868062.png\" alt=\"image\"></p>\n<h5 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h5><h6 id=\"1-系统自带\"><a href=\"#1-系统自带\" class=\"headerlink\" title=\"1.系统自带\"></a>1.系统自带</h6><p>很多我们的代码提示都是snippet系统已经有的代码块如：<br>block变量定义</p>\n<blockquote>\n<p>typedef &lt;#returnType#&gt;(^&lt;#name#&gt;)(&lt;#arguments#&gt;);</p>\n</blockquote>\n<h6 id=\"2-常用变量\"><a href=\"#2-常用变量\" class=\"headerlink\" title=\"2.常用变量\"></a>2.常用变量</h6><ul>\n<li>strong</li>\n<li>weak</li>\n<li>assign</li>\n<li>block</li>\n</ul>\n<h6 id=\"3-常用方法\"><a href=\"#3-常用方法\" class=\"headerlink\" title=\"3.常用方法\"></a>3.常用方法</h6><ul>\n<li>比如：hiddenKeyBoard</li>\n<li>网络请求：getData</li>\n<li>上下拉刷新，等等</li>\n</ul>\n<h6 id=\"4-常用模块\"><a href=\"#4-常用模块\" class=\"headerlink\" title=\"4.常用模块\"></a>4.常用模块</h6><ul>\n<li>常用的代理协议方法集</li>\n</ul>\n<h5 id=\"制作\"><a href=\"#制作\" class=\"headerlink\" title=\"制作\"></a>制作</h5><p>选中代码块拖入snippet library即可。为了方便调用可简单编辑</p>\n<p><img src=\"http://static.oschina.net/uploads/space/2014/0306/143716_p6Kl_868062.png\" alt=\"image2\"></p>\n<h5 id=\"PaintCode的简单使用\"><a href=\"#PaintCode的简单使用\" class=\"headerlink\" title=\"PaintCode的简单使用\"></a>PaintCode的简单使用</h5><p>简单的图形绘制，可像xib一样拖拽图形，并添加到view的CALayer层上</p>\n<ul>\n<li>drawRect方法</li>\n</ul>\n<h4 id=\"myEclipse分享-吴明\"><a href=\"#myEclipse分享-吴明\" class=\"headerlink\" title=\"myEclipse分享 - 吴明\"></a>myEclipse分享 - 吴明</h4><ul>\n<li><p>myEclipse主要WebService开发工具</p>\n</li>\n<li><p>MyEclipse，是在eclipse 基础上加上自己的插件开发而成的功能强大的企业级集成开发环境，主要用于Java、Java EE以及移动应用的开发。MyEclipse的功能非常强大，支持也十分广泛，尤其是对各种开源产品的支持相当不错。</p>\n</li>\n<li><p><a href=\"http://www.cnblogs.com/younes/archive/2011/12/21/2295759.html\" target=\"_blank\" rel=\"noopener\">myEclipse使用ssh框架</a></p>\n</li>\n<li><p>myEclipse常用快捷键</p>\n<ul>\n<li>Alt+Shift+s:<br>  打开myEclipse快捷键菜单<ul>\n<li>自动生成get set方法</li>\n<li>自动生成无参和有参构造方法</li>\n</ul>\n</li>\n<li>Ctrl+D：删除当前行</li>\n<li>Ctrl+Alt+↓：复制当前行到下一行(复制增加)</li>\n<li>Ctrl+Alt+↑：复制当前行到上一行(复制增加)</li>\n<li>Alt+↓：当前行和下面一行交互位置</li>\n<li>Alt+↑：当前行和上面一行交互位置</li>\n<li>Ctrl+Shift+O：快速生成import，当从网上拷贝一段程序后，不知道如何import进所调用的类</li>\n</ul>\n</li>\n<li><a href=\"http://baike.baidu.com/link?url=-FpesVZmaLqL3GJTVfPriU4jZQlvjIWKgbmy1lxgSlzT83WVAbFUA952pclZJbIkqzDTWVc7L-dTBalJjXTNH_\" target=\"_blank\" rel=\"noopener\">ssh框架</a></li>\n</ul>\n<h4 id=\"OSX-快捷键入门-曾铭\"><a href=\"#OSX-快捷键入门-曾铭\" class=\"headerlink\" title=\"OSX 快捷键入门 - 曾铭\"></a>OSX 快捷键入门 - 曾铭</h4><h5 id=\"OSX-系统级的快捷键支持\"><a href=\"#OSX-系统级的快捷键支持\" class=\"headerlink\" title=\"OSX 系统级的快捷键支持\"></a>OSX 系统级的快捷键支持</h5><ul>\n<li>统一标准的全局快捷键：如 FX、『设置』、opt<ul>\n<li><a href=\"https://support.apple.com/kb/PH18802?locale=zh_CN&amp;viewlocale=zh_CN\" target=\"_blank\" rel=\"noopener\">一些『奇怪的』符号</a></li>\n<li><a href=\"https://support.apple.com/zh-cn/HT201236\" target=\"_blank\" rel=\"noopener\">Mac 键盘快捷键</a></li>\n<li>有时，略略隐晦了些：如截图、奇葩的 cmd+tab,opt</li>\n</ul>\n</li>\n<li>在统一之外，留意每个应用的快捷键：如 chrome：opt+cmd+i，cmd+l</li>\n</ul>\n<h5 id=\"讨论常用快捷键-（具体快捷键请自己查）\"><a href=\"#讨论常用快捷键-（具体快捷键请自己查）\" class=\"headerlink\" title=\"讨论常用快捷键 （具体快捷键请自己查）\"></a>讨论常用快捷键 （具体快捷键请自己查）</h5><ul>\n<li>设置</li>\n<li>剪切复制粘贴全选</li>\n<li>新建、新建 tab、切换 tab、关闭 tab、关闭应用</li>\n<li>光标的自由游走<ul>\n<li>上下左右（推荐 hjkl）、字符移动、行首行尾、文首文尾、向后删除、单词删除、行向前向后删除</li>\n</ul>\n</li>\n<li>Xcode<ul>\n<li>上下移行 （@志平 推荐）</li>\n<li>reveal to project navigator、切换 .h.m 文件</li>\n<li>显示隐藏 navigatiors、Debug area、Utilities</li>\n<li>new tab、切换 tab、分割窗口</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"定制\"><a href=\"#定制\" class=\"headerlink\" title=\"定制\"></a>定制</h5><ul>\n<li>System Preferences -&gt; Keyboard : 配置快捷键、菜单快捷键、modifier keys</li>\n<li><a href=\"https://pqrs.org/osx/karabiner/index.html.en\" target=\"_blank\" rel=\"noopener\">Karabiner</a></li>\n<li><a href=\"http://www.waerfa.com/keyboard-maestro\" target=\"_blank\" rel=\"noopener\">Keyboard Maestro 介绍</a></li>\n<li>定制建议<ul>\n<li>原生为主，定制为辅</li>\n<li>fix 原生不爽、有冲突的个别快捷键<ul>\n<li>合理使用 opt， 规避冲突</li>\n</ul>\n</li>\n<li>根据自己习惯定制</li>\n<li>常反思，记不住的快捷键都是『对你不重要』的快捷键</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"VIM-潘君\"><a href=\"#VIM-潘君\" class=\"headerlink\" title=\"VIM - 潘君\"></a>VIM - 潘君</h4><h5 id=\"vim起源\"><a href=\"#vim起源\" class=\"headerlink\" title=\"vim起源\"></a>vim起源</h5><ul>\n<li>源自开源vi</li>\n<li>作者Bram Moolenaar</li>\n<li>80年代末,Amiga计算机中无vi,作者自行开发</li>\n<li>Vi IMitation(模拟) -&gt; Vi IMproved(改良)</li>\n</ul>\n<h5 id=\"vim应用场景\"><a href=\"#vim应用场景\" class=\"headerlink\" title=\"vim应用场景\"></a>vim应用场景</h5><ul>\n<li>linux</li>\n<li>平时代码</li>\n</ul>\n<h5 id=\"vim模式\"><a href=\"#vim模式\" class=\"headerlink\" title=\"vim模式\"></a>vim模式</h5><p>列举常用模式如下<br>需要了解所有模式<br>在vim中使用<code>:help vim-modes</code></p>\n<ul>\n<li><p>Insert模式</p>\n<ul>\n<li>进入<ul>\n<li>i -&gt; 在光标前插入</li>\n<li>I-&gt; 在句首插入</li>\n<li>a -&gt; 在光标后插入</li>\n<li>A -&gt; 在句尾插入</li>\n</ul>\n</li>\n<li>离开<ul>\n<li>Esc</li>\n<li>Ctrl + c</li>\n<li>Ctrl + [</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Normal模式</p>\n<ul>\n<li>进入vim的默认模式</li>\n<li>命令的天下<ul>\n<li>简单移动<ul>\n<li>h j k l  -&gt; 左 下 上 右</li>\n<li>0 (数字零) -&gt; 移动光标到行头</li>\n<li>$ -&gt; 移动光标到行尾</li>\n<li>gg -&gt; 到第一行</li>\n<li>G -&gt; 到最后一行</li>\n<li>w -&gt; 到下一个单词的开头。</li>\n<li>e -&gt; 到下一个单词的结尾。</li>\n</ul>\n</li>\n<li>简单操作<ul>\n<li>dd -&gt; 剪切当前行</li>\n<li>yy -&gt;  赋值当前行</li>\n<li>p -&gt; 粘贴</li>\n<li>u -&gt; 撤销</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>神奇的<code>.</code></p>\n<ul>\n<li>上次命令的重复</li>\n</ul>\n</li>\n<li><p>命令的组合</p>\n<ul>\n<li>daw -&gt; 删除当前单词</li>\n<li>2dd -&gt; 删除2行</li>\n<li>3p → 粘贴文本3次</li>\n<li>100idesu [ESC] → 会写下 “desu “100次</li>\n<li>0y$ -&gt; 从行头拷贝到本行最后一个字符</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>visual模式</p>\n<ul>\n<li>进入<ul>\n<li>v</li>\n<li>V</li>\n<li>Ctrl + v</li>\n</ul>\n</li>\n<li>退出<ul>\n<li>Esc</li>\n<li>Ctrl + c</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>select模式</p>\n<ul>\n<li><p>进入</p>\n<ul>\n<li>gh</li>\n<li>gH</li>\n<li>g(Ctrl + h)</li>\n</ul>\n</li>\n<li><p>切换</p>\n<ul>\n<li>Ctrl + o -&gt;临时切换到可视化模式执行一个命令</li>\n<li>Ctrl + g -&gt;切换到可视化模式</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"vim大冒险游戏\"><a href=\"#vim大冒险游戏\" class=\"headerlink\" title=\"vim大冒险游戏\"></a>vim大冒险游戏</h5><ul>\n<li><a href=\"http://vim-adventures.com/\" target=\"_blank\" rel=\"noopener\">游戏链接</a></li>\n</ul>\n<h4 id=\"VIM常用命令-王胜\"><a href=\"#VIM常用命令-王胜\" class=\"headerlink\" title=\"VIM常用命令 - 王胜\"></a>VIM常用命令 - 王胜</h4><h5 id=\"光标移动\"><a href=\"#光标移动\" class=\"headerlink\" title=\"光标移动\"></a>光标移动</h5><ul>\n<li>fx：移动光标到当前行的下一个 x 处。很明显，x 可以是任意一个字母，而且你可以使用 ; 来重复你的上一个 f 命令。</li>\n<li>tx：和上面的命令类似，但是是移动到 x 的左边一个位置。</li>\n<li>Fx：和 fx 类似，不过是往回找。</li>\n<li>w：光标往前移动一个词。</li>\n<li>b：光标往后移动一个词。</li>\n<li>0：移动光标到当前行首。</li>\n<li>^：移动光标到当前行的第一个字母位置。</li>\n<li>$：移动光标到行尾。</li>\n<li>)：移动光标到下一个句子。</li>\n<li>( ：移动光标到上一个句子</li>\n</ul>\n<h5 id=\"替换\"><a href=\"#替换\" class=\"headerlink\" title=\"替换\"></a>替换</h5><ul>\n<li>:s/hello/world 替换当前行中第一个hello为world</li>\n<li>:%s/hello/world 替换每一行中第一个hello为world</li>\n<li>:s/hello/world/g 替换当前行中所有的hello为world</li>\n<li>:%s/hello/world/g 替换每一行中所有的hello为world</li>\n<li>:%s/hello/world/gc 找到当前文件中所有的hello，并逐一询问用户是否要替换</li>\n</ul>\n<h5 id=\"内容提取\"><a href=\"#内容提取\" class=\"headerlink\" title=\"内容提取\"></a>内容提取</h5><ul>\n<li>:r !date 将当前时间插入到当前文件</li>\n<li>:r /path/to/src.file 将src.file里的内容输出到当前文件</li>\n</ul>\n<h5 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h5><p>VIM的命令甚多，组合也很多，记忆是不能长时间记住的。唯一的捷径就是多多使用，用的多了，使用这些命令时就像手拿筷子一样，变成了本能。</p>\n<h4 id=\"Xcode插件管理-张超耀\"><a href=\"#Xcode插件管理-张超耀\" class=\"headerlink\" title=\"Xcode插件管理 - 张超耀\"></a>Xcode插件管理 - 张超耀</h4><ul>\n<li><p>古人云“工欲善其事,必先利其器”，打造一个强大的开发环境，是立即提升自身战斗力的绝佳途径！以下是常用的一些有力的XCode插件。</p>\n</li>\n<li><p>插件管理器：<a href=\"http://alcatraz.io/\" target=\"_blank\" rel=\"noopener\">Alcatraz</a> - The package manager for Xcode。</p>\n</li>\n<li><p><a href=\"https://github.com/omz/ColorSense-for-Xcode\" target=\"_blank\" rel=\"noopener\">ColorSense</a>XCode颜色显示插件</p>\n<ul>\n<li>代码里的那些冷冰冰的颜色数值，到底时什么颜色？如果你经常遇到这个问题，每每不得不运行下模拟器去看看，那么这个插件绝对不容错过。更彪悍的是你甚至可以点击显示的颜色面板，直接通过系统的ColorPicker来自动生成对应颜色代码，再也不用做各种颜色代码转换了！</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p><a href=\"https://github.com/onevcat/VVDocumenter-Xcode\" target=\"_blank\" rel=\"noopener\">VVDocumenter</a>规范注释生成器</p>\n<ul>\n<li>很多时候，为了快速开发，很多的技术文档都是能省则省，这个时候注释就变得异常重要，再配合Doxygen这种注释自动生成文档的，就完美了。但是每次都要手动输入规范化的注释，着实也麻烦，但有了VVDocumenter，规范化的注释，主需要输入三个斜线“///”，就OK啦！</li>\n</ul>\n</li>\n<li><p><a href=\"https://github.com/qfish/XAlign\" target=\"_blank\" rel=\"noopener\">XAlign</a>代码整理</p>\n<ul>\n<li>XAlign是一款专门用于代码整理的Xcode插件，其作者为来自Geek Zoo Studio的开发者QFish。XAlign能够对开发者的代码非常快速地进行对齐优化，有“=”、宏定义、属性三种对齐模式。当然，如果默认的对齐风格不是自己喜欢的，开发者还可以自定义或提出issues。</li>\n</ul>\n</li>\n<li><p><a href=\"https://github.com/FuzzyAutocomplete/FuzzyAutocompletePlugin\" target=\"_blank\" rel=\"noopener\">FuzzyAutocompletePlugin</a>代码自动补全插件</p>\n<ul>\n<li>通过添加模糊匹配来提高Xcode代码自动补全功能，开发者无需遵循从头匹配的原则，只要记得方法里某个关键字即可进行匹配，很好地提高了工作效率。</li>\n</ul>\n</li>\n<li><p>XcodeBoost</p>\n<ul>\n<li>XcodeBoost是一款可以让开发者轻而易举地检查和修改Objective-C代码的插件。XcodeBoost能够自动进行一些繁琐的操作，比如方法的定义与声明、添加基于命令行的代码处理（剪切/复制/粘贴/重复/删除行）、持续高亮等。</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"盘点开发者最喜爱的十大开源Xcode插件\"><a href=\"#盘点开发者最喜爱的十大开源Xcode插件\" class=\"headerlink\" title=\"盘点开发者最喜爱的十大开源Xcode插件\"></a><a href=\"http://www.csdn.net/article/2014-05-04/2819586-the-best-xcode-plugins/1\" target=\"_blank\" rel=\"noopener\">盘点开发者最喜爱的十大开源Xcode插件</a></h5><h5 id=\"那些不能错过的Xcode插件\"><a href=\"#那些不能错过的Xcode插件\" class=\"headerlink\" title=\"那些不能错过的Xcode插件\"></a><a href=\"http://www.cocoachina.com/industry/20130918/7022.html\" target=\"_blank\" rel=\"noopener\">那些不能错过的Xcode插件</a></h5>"},{"title":"Why Git? Learn It!-曾铭","date":"2016-01-06T16:00:00.000Z","_content":"\n\n- 为什么要用 Git？\n- Git + SourceTree + Gitlab 的使用演示\n- 提醒和推荐\n\n## 为什么要用 Git？\n\n- 一个工具、一套方案，解决源码管理的问题\n\n### 对于版本控制，我们需要什么？\n\n- 代码历史追溯\n\t- 某一次提交的改动（SVN，Git）\n\t- 某一个功能的改动过程（好的提交习惯更重要，在多人协作情况下提交历史更清晰）\n- 协同开发\n\t- 用分支来隔离上线与开发中的代码\n\t- 多人多线并行开发：1 人对 N 线，N 人对 1 线都有可能\n\n> 秒极定律  \n> 一件事情如果能控制在 10s 内完成，人们就会极频繁的使用它。  \n> 举栗子：\n>  - docker 被推崇，从虚拟机到 Vagrant 到 docker，碰到了秒级定律\n>  - 持续集成，快速迭代\n\n### 秒级的代码管理？\n\n- 本地代码飞快变化至任意历史提交记录：SVN 30s-2min；Git 秒级\n\t- 工作状态快速切换\n- 代码提交速度飞快：SVN 受限于网络速度；Git commit 秒级，push 受限于网络速度\n- 代码创建、切换、合并分支飞快：SVN 速度慢，很麻烦；Git 赞！\n\t- 勇于原型探索，历史清晰，易调整方向，易新建，易弃用\n\t- 与 code review 结合\n\n## SVN 比 Git 好在哪里\n\n- 更简单，符合原有自主文件夹管理版本的心理预期\n\t- Git 暴露概念过多，学习曲线陡峭，这点不如 hg\n- SVN 有目录级的权限控制\n\t- 适合大中型中间件软件公司：目录划分权限，职能长期固定\n- 也许还有其它，我不清楚\n\n### Git 真实的影响力\n\n> I'm an egotistical bastard, and I name all my projects after myself. First Linux, now Git.  \n> —— Linus\n\n- 在 2016 问这个问题对互联网来说已是大势所趋\n\t- npm + pip 均托管在 Github\n\t- OpenJDK 使用 Hg（Mercurial）\n\t- Github 早已一统开源天下，Java 概莫能外\n- SVN 与 Git 二分天下，但 Git 占据的是互联网明星创业公司和 BAT 的优秀团队，为何？\n- 会 Git 找工作是加分项\n- 学习版本控制的另一种思维方式（学习一门语言就是学习一类思维方式）\n\n## 一些问题\n- Git 不能直接解决目前后端的开发环境\n\t- code 规范的 branch 流程\n\t- 依赖，理清 maven 依赖和配合方式\n\t- 秒级上线（测试、预发布、正式）\n\t- 相应（尽可能少人力介入的）自动化测试、监控\n\n## Git + SourceTree + Gitlab 的使用演示\n\n![Git 使用流程示意图](http://7j1xgb.com5.z0.glb.clouddn.com/FullSizeRender.jpg)\n\n### local repo\n\n- 用 SourceTree 初始化一个本地项目\n- 小步提交，介绍 staged 的用法\n\t- stage or unstage or discard\n\t- stage 某一行代码\n- 一次提交\n- 介绍 master 分支及 branchs 界面\n\t- 留意 commit 编号\n- 创建一个分支 feature/login\n- 新建 login.java 文件，index.html 加一行代码\n- commit，观察分支树变化\n- 切换分支，观察代码变化\n- 创建一个分支 feature/share\n- 新建 share.py 文件，index.html 改一行代码\n- commit，观察分支树变化\n- 切回 feature/login，临时处理事情，再切回 feature/share\n- feature/share 分支删几行代码，再提交一次\n- feature/share merge to master 分支，观察分支树变化\n- feature/login merge to master 分支，处理冲突\n- 初始化 Git-flow\n- 新建 feature/school 分支，commit once\n- 用 Git-flow-gui 完成 feature/school 分支\n- 留意刚才的所有提交都在本地，思考与 SVN 区别（很像，只是分支极灵活）\n- Q&A\n\n### Gitlab\n\n- 注册帐号，ssh-key 授权（略）\n- 介绍 Gitlab 结构：team-project\n- 新建项目 test-repo\n- 留意空项目向导，复制代码库 url\n- 本地配置 remote-url，观察 remotes 变化\n- push，注意是 push 多条分支，留意 local-remote 分支对应关系\n- 再看 remotes 变化，分支树变化\n\t- remotes branchs 与 local branchs 一致\n\t- 分支树中多了 origin/*\n- 观察 Gitlab 界面变化\n- 介绍 Gitlab 单个项目界面\n- Q&A\n\n### 来一次典型的开发过程（包含 code review）\n\n- 保证在 develop 分支，pull 最新代码\n- 网页端提交 readme 文件，造成 origin 变化，介绍 fetch，注意 branchs 变化\n- 重新 pull\n- 用 Git-flow-gui 建立 feature/news 分支\n- 产生两次 commit（包含 rename 文件）\n- 留意分支树变化，注意 Gitlab-web 端不存在刚才的提交，push，再对比\n- Gitlab-web 端新建 merge-request, 留意 source-branch, target-branch, title, ass\n- 被指派者 review 代码，web 端回复建议\n- 根据建议产生新的 commit，同时 push\n- 刷新 web 端观察变化：查看一次 commit，查看全部 changes\n- 被指派者回复 LGTM（look good to me），点击 merge\n- 回到 SourceTree，观察分支树变化，fetch 再看\n- 切回 develop 分支\n- Q&A\n\t- 有冲突 merge 按钮会不可点击，merge develop to work_branch ，在 develop 分支外解决冲突，commit&push，merge 按钮就可点击了\n\t- 可方便的与自动化测试等结合起来\n\n## 提醒和推荐\n\n## 一些提醒（坑）\n- 初次使用 Git，注意设置 `git config --global email&name`\n- Windows 下的 Git 使用的确有些不便（不过我不熟悉，也不清楚具体问题）\n- 授权方式推荐 ssh-key\n- 忽略文件的配置\n- 着手代码前思考终极问题：『我在哪里，要去何处？』（先认清所在分支，pull）\n- commit 已经 push 到远端了，这个时候不要想着再去修改了\n- 学习新东西，坑总是有的，多填了也就会了\n\n### 一些推荐\n\n- 强调思路，记住秒级定律，效率为王\n- 小步提交，每小时至少提交一次\n\t- 一次任务的实现过程：整体设计，框架（类），接口，单元测试，实现\n- 完整提交，完整提交，必须完整提交！不该有任一个提交项目不可运行。\n- 保证非工作期间，工作区间干净\n- 不想提交但要切换分支处理事物用 stash 处理\n- Github 经常被 X\n\t- coding.net 代码私有库托管可以用。找开源代码，永远是 Github\n\t- Google 也是被 X。珍爱生命，自配 VPN\n- 国内 Git 私有库托管推荐 coding.net，国外推荐 bitbucket（支持hg） 和 Gitlab\n\n## 其它\n- 依赖（迷信）工具不可取，但工具会影响思维方式，而思维方式非常重要\n\n> 举例：  \n> SVN 的思维方式决定了 diff patch 的开源合作方式。交流不顺畅，实现思路难以程现，这种合作方式很长时间里都是高端人士的特权。  \n> Git + Github 催生了 fork，成就了最大的程序员社交网站，也极力促进了开源社区的发展。\n","source":"_posts/Why-Git-Learn-It.md","raw":"title: Why Git? Learn It!-曾铭\ndate: 2016-01-06 16:00:00\ntags:\n- git\n\ncategories: 移动组周分享\n---\n\n\n- 为什么要用 Git？\n- Git + SourceTree + Gitlab 的使用演示\n- 提醒和推荐\n\n## 为什么要用 Git？\n\n- 一个工具、一套方案，解决源码管理的问题\n\n### 对于版本控制，我们需要什么？\n\n- 代码历史追溯\n\t- 某一次提交的改动（SVN，Git）\n\t- 某一个功能的改动过程（好的提交习惯更重要，在多人协作情况下提交历史更清晰）\n- 协同开发\n\t- 用分支来隔离上线与开发中的代码\n\t- 多人多线并行开发：1 人对 N 线，N 人对 1 线都有可能\n\n> 秒极定律  \n> 一件事情如果能控制在 10s 内完成，人们就会极频繁的使用它。  \n> 举栗子：\n>  - docker 被推崇，从虚拟机到 Vagrant 到 docker，碰到了秒级定律\n>  - 持续集成，快速迭代\n\n### 秒级的代码管理？\n\n- 本地代码飞快变化至任意历史提交记录：SVN 30s-2min；Git 秒级\n\t- 工作状态快速切换\n- 代码提交速度飞快：SVN 受限于网络速度；Git commit 秒级，push 受限于网络速度\n- 代码创建、切换、合并分支飞快：SVN 速度慢，很麻烦；Git 赞！\n\t- 勇于原型探索，历史清晰，易调整方向，易新建，易弃用\n\t- 与 code review 结合\n\n## SVN 比 Git 好在哪里\n\n- 更简单，符合原有自主文件夹管理版本的心理预期\n\t- Git 暴露概念过多，学习曲线陡峭，这点不如 hg\n- SVN 有目录级的权限控制\n\t- 适合大中型中间件软件公司：目录划分权限，职能长期固定\n- 也许还有其它，我不清楚\n\n### Git 真实的影响力\n\n> I'm an egotistical bastard, and I name all my projects after myself. First Linux, now Git.  \n> —— Linus\n\n- 在 2016 问这个问题对互联网来说已是大势所趋\n\t- npm + pip 均托管在 Github\n\t- OpenJDK 使用 Hg（Mercurial）\n\t- Github 早已一统开源天下，Java 概莫能外\n- SVN 与 Git 二分天下，但 Git 占据的是互联网明星创业公司和 BAT 的优秀团队，为何？\n- 会 Git 找工作是加分项\n- 学习版本控制的另一种思维方式（学习一门语言就是学习一类思维方式）\n\n## 一些问题\n- Git 不能直接解决目前后端的开发环境\n\t- code 规范的 branch 流程\n\t- 依赖，理清 maven 依赖和配合方式\n\t- 秒级上线（测试、预发布、正式）\n\t- 相应（尽可能少人力介入的）自动化测试、监控\n\n## Git + SourceTree + Gitlab 的使用演示\n\n![Git 使用流程示意图](http://7j1xgb.com5.z0.glb.clouddn.com/FullSizeRender.jpg)\n\n### local repo\n\n- 用 SourceTree 初始化一个本地项目\n- 小步提交，介绍 staged 的用法\n\t- stage or unstage or discard\n\t- stage 某一行代码\n- 一次提交\n- 介绍 master 分支及 branchs 界面\n\t- 留意 commit 编号\n- 创建一个分支 feature/login\n- 新建 login.java 文件，index.html 加一行代码\n- commit，观察分支树变化\n- 切换分支，观察代码变化\n- 创建一个分支 feature/share\n- 新建 share.py 文件，index.html 改一行代码\n- commit，观察分支树变化\n- 切回 feature/login，临时处理事情，再切回 feature/share\n- feature/share 分支删几行代码，再提交一次\n- feature/share merge to master 分支，观察分支树变化\n- feature/login merge to master 分支，处理冲突\n- 初始化 Git-flow\n- 新建 feature/school 分支，commit once\n- 用 Git-flow-gui 完成 feature/school 分支\n- 留意刚才的所有提交都在本地，思考与 SVN 区别（很像，只是分支极灵活）\n- Q&A\n\n### Gitlab\n\n- 注册帐号，ssh-key 授权（略）\n- 介绍 Gitlab 结构：team-project\n- 新建项目 test-repo\n- 留意空项目向导，复制代码库 url\n- 本地配置 remote-url，观察 remotes 变化\n- push，注意是 push 多条分支，留意 local-remote 分支对应关系\n- 再看 remotes 变化，分支树变化\n\t- remotes branchs 与 local branchs 一致\n\t- 分支树中多了 origin/*\n- 观察 Gitlab 界面变化\n- 介绍 Gitlab 单个项目界面\n- Q&A\n\n### 来一次典型的开发过程（包含 code review）\n\n- 保证在 develop 分支，pull 最新代码\n- 网页端提交 readme 文件，造成 origin 变化，介绍 fetch，注意 branchs 变化\n- 重新 pull\n- 用 Git-flow-gui 建立 feature/news 分支\n- 产生两次 commit（包含 rename 文件）\n- 留意分支树变化，注意 Gitlab-web 端不存在刚才的提交，push，再对比\n- Gitlab-web 端新建 merge-request, 留意 source-branch, target-branch, title, ass\n- 被指派者 review 代码，web 端回复建议\n- 根据建议产生新的 commit，同时 push\n- 刷新 web 端观察变化：查看一次 commit，查看全部 changes\n- 被指派者回复 LGTM（look good to me），点击 merge\n- 回到 SourceTree，观察分支树变化，fetch 再看\n- 切回 develop 分支\n- Q&A\n\t- 有冲突 merge 按钮会不可点击，merge develop to work_branch ，在 develop 分支外解决冲突，commit&push，merge 按钮就可点击了\n\t- 可方便的与自动化测试等结合起来\n\n## 提醒和推荐\n\n## 一些提醒（坑）\n- 初次使用 Git，注意设置 `git config --global email&name`\n- Windows 下的 Git 使用的确有些不便（不过我不熟悉，也不清楚具体问题）\n- 授权方式推荐 ssh-key\n- 忽略文件的配置\n- 着手代码前思考终极问题：『我在哪里，要去何处？』（先认清所在分支，pull）\n- commit 已经 push 到远端了，这个时候不要想着再去修改了\n- 学习新东西，坑总是有的，多填了也就会了\n\n### 一些推荐\n\n- 强调思路，记住秒级定律，效率为王\n- 小步提交，每小时至少提交一次\n\t- 一次任务的实现过程：整体设计，框架（类），接口，单元测试，实现\n- 完整提交，完整提交，必须完整提交！不该有任一个提交项目不可运行。\n- 保证非工作期间，工作区间干净\n- 不想提交但要切换分支处理事物用 stash 处理\n- Github 经常被 X\n\t- coding.net 代码私有库托管可以用。找开源代码，永远是 Github\n\t- Google 也是被 X。珍爱生命，自配 VPN\n- 国内 Git 私有库托管推荐 coding.net，国外推荐 bitbucket（支持hg） 和 Gitlab\n\n## 其它\n- 依赖（迷信）工具不可取，但工具会影响思维方式，而思维方式非常重要\n\n> 举例：  \n> SVN 的思维方式决定了 diff patch 的开源合作方式。交流不顺畅，实现思路难以程现，这种合作方式很长时间里都是高端人士的特权。  \n> Git + Github 催生了 fork，成就了最大的程序员社交网站，也极力促进了开源社区的发展。\n","slug":"Why-Git-Learn-It","published":1,"updated":"2021-09-10T07:04:21.944Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cktfeap42001nc2xxm9hp1tbm","content":"<ul>\n<li>为什么要用 Git？</li>\n<li>Git + SourceTree + Gitlab 的使用演示</li>\n<li>提醒和推荐</li>\n</ul>\n<h2 id=\"为什么要用-Git？\"><a href=\"#为什么要用-Git？\" class=\"headerlink\" title=\"为什么要用 Git？\"></a>为什么要用 Git？</h2><ul>\n<li>一个工具、一套方案，解决源码管理的问题</li>\n</ul>\n<h3 id=\"对于版本控制，我们需要什么？\"><a href=\"#对于版本控制，我们需要什么？\" class=\"headerlink\" title=\"对于版本控制，我们需要什么？\"></a>对于版本控制，我们需要什么？</h3><ul>\n<li>代码历史追溯<ul>\n<li>某一次提交的改动（SVN，Git）</li>\n<li>某一个功能的改动过程（好的提交习惯更重要，在多人协作情况下提交历史更清晰）</li>\n</ul>\n</li>\n<li>协同开发<ul>\n<li>用分支来隔离上线与开发中的代码</li>\n<li>多人多线并行开发：1 人对 N 线，N 人对 1 线都有可能</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>秒极定律<br>一件事情如果能控制在 10s 内完成，人们就会极频繁的使用它。<br>举栗子：</p>\n<ul>\n<li>docker 被推崇，从虚拟机到 Vagrant 到 docker，碰到了秒级定律</li>\n<li>持续集成，快速迭代</li>\n</ul>\n</blockquote>\n<h3 id=\"秒级的代码管理？\"><a href=\"#秒级的代码管理？\" class=\"headerlink\" title=\"秒级的代码管理？\"></a>秒级的代码管理？</h3><ul>\n<li>本地代码飞快变化至任意历史提交记录：SVN 30s-2min；Git 秒级<ul>\n<li>工作状态快速切换</li>\n</ul>\n</li>\n<li>代码提交速度飞快：SVN 受限于网络速度；Git commit 秒级，push 受限于网络速度</li>\n<li>代码创建、切换、合并分支飞快：SVN 速度慢，很麻烦；Git 赞！<ul>\n<li>勇于原型探索，历史清晰，易调整方向，易新建，易弃用</li>\n<li>与 code review 结合</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"SVN-比-Git-好在哪里\"><a href=\"#SVN-比-Git-好在哪里\" class=\"headerlink\" title=\"SVN 比 Git 好在哪里\"></a>SVN 比 Git 好在哪里</h2><ul>\n<li>更简单，符合原有自主文件夹管理版本的心理预期<ul>\n<li>Git 暴露概念过多，学习曲线陡峭，这点不如 hg</li>\n</ul>\n</li>\n<li>SVN 有目录级的权限控制<ul>\n<li>适合大中型中间件软件公司：目录划分权限，职能长期固定</li>\n</ul>\n</li>\n<li>也许还有其它，我不清楚</li>\n</ul>\n<h3 id=\"Git-真实的影响力\"><a href=\"#Git-真实的影响力\" class=\"headerlink\" title=\"Git 真实的影响力\"></a>Git 真实的影响力</h3><blockquote>\n<p>I’m an egotistical bastard, and I name all my projects after myself. First Linux, now Git.<br>—— Linus</p>\n</blockquote>\n<ul>\n<li>在 2016 问这个问题对互联网来说已是大势所趋<ul>\n<li>npm + pip 均托管在 Github</li>\n<li>OpenJDK 使用 Hg（Mercurial）</li>\n<li>Github 早已一统开源天下，Java 概莫能外</li>\n</ul>\n</li>\n<li>SVN 与 Git 二分天下，但 Git 占据的是互联网明星创业公司和 BAT 的优秀团队，为何？</li>\n<li>会 Git 找工作是加分项</li>\n<li>学习版本控制的另一种思维方式（学习一门语言就是学习一类思维方式）</li>\n</ul>\n<h2 id=\"一些问题\"><a href=\"#一些问题\" class=\"headerlink\" title=\"一些问题\"></a>一些问题</h2><ul>\n<li>Git 不能直接解决目前后端的开发环境<ul>\n<li>code 规范的 branch 流程</li>\n<li>依赖，理清 maven 依赖和配合方式</li>\n<li>秒级上线（测试、预发布、正式）</li>\n<li>相应（尽可能少人力介入的）自动化测试、监控</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Git-SourceTree-Gitlab-的使用演示\"><a href=\"#Git-SourceTree-Gitlab-的使用演示\" class=\"headerlink\" title=\"Git + SourceTree + Gitlab 的使用演示\"></a>Git + SourceTree + Gitlab 的使用演示</h2><p><img src=\"http://7j1xgb.com5.z0.glb.clouddn.com/FullSizeRender.jpg\" alt=\"Git 使用流程示意图\"></p>\n<h3 id=\"local-repo\"><a href=\"#local-repo\" class=\"headerlink\" title=\"local repo\"></a>local repo</h3><ul>\n<li>用 SourceTree 初始化一个本地项目</li>\n<li>小步提交，介绍 staged 的用法<ul>\n<li>stage or unstage or discard</li>\n<li>stage 某一行代码</li>\n</ul>\n</li>\n<li>一次提交</li>\n<li>介绍 master 分支及 branchs 界面<ul>\n<li>留意 commit 编号</li>\n</ul>\n</li>\n<li>创建一个分支 feature/login</li>\n<li>新建 login.java 文件，index.html 加一行代码</li>\n<li>commit，观察分支树变化</li>\n<li>切换分支，观察代码变化</li>\n<li>创建一个分支 feature/share</li>\n<li>新建 share.py 文件，index.html 改一行代码</li>\n<li>commit，观察分支树变化</li>\n<li>切回 feature/login，临时处理事情，再切回 feature/share</li>\n<li>feature/share 分支删几行代码，再提交一次</li>\n<li>feature/share merge to master 分支，观察分支树变化</li>\n<li>feature/login merge to master 分支，处理冲突</li>\n<li>初始化 Git-flow</li>\n<li>新建 feature/school 分支，commit once</li>\n<li>用 Git-flow-gui 完成 feature/school 分支</li>\n<li>留意刚才的所有提交都在本地，思考与 SVN 区别（很像，只是分支极灵活）</li>\n<li>Q&amp;A</li>\n</ul>\n<h3 id=\"Gitlab\"><a href=\"#Gitlab\" class=\"headerlink\" title=\"Gitlab\"></a>Gitlab</h3><ul>\n<li>注册帐号，ssh-key 授权（略）</li>\n<li>介绍 Gitlab 结构：team-project</li>\n<li>新建项目 test-repo</li>\n<li>留意空项目向导，复制代码库 url</li>\n<li>本地配置 remote-url，观察 remotes 变化</li>\n<li>push，注意是 push 多条分支，留意 local-remote 分支对应关系</li>\n<li>再看 remotes 变化，分支树变化<ul>\n<li>remotes branchs 与 local branchs 一致</li>\n<li>分支树中多了 origin/*</li>\n</ul>\n</li>\n<li>观察 Gitlab 界面变化</li>\n<li>介绍 Gitlab 单个项目界面</li>\n<li>Q&amp;A</li>\n</ul>\n<h3 id=\"来一次典型的开发过程（包含-code-review）\"><a href=\"#来一次典型的开发过程（包含-code-review）\" class=\"headerlink\" title=\"来一次典型的开发过程（包含 code review）\"></a>来一次典型的开发过程（包含 code review）</h3><ul>\n<li>保证在 develop 分支，pull 最新代码</li>\n<li>网页端提交 readme 文件，造成 origin 变化，介绍 fetch，注意 branchs 变化</li>\n<li>重新 pull</li>\n<li>用 Git-flow-gui 建立 feature/news 分支</li>\n<li>产生两次 commit（包含 rename 文件）</li>\n<li>留意分支树变化，注意 Gitlab-web 端不存在刚才的提交，push，再对比</li>\n<li>Gitlab-web 端新建 merge-request, 留意 source-branch, target-branch, title, ass</li>\n<li>被指派者 review 代码，web 端回复建议</li>\n<li>根据建议产生新的 commit，同时 push</li>\n<li>刷新 web 端观察变化：查看一次 commit，查看全部 changes</li>\n<li>被指派者回复 LGTM（look good to me），点击 merge</li>\n<li>回到 SourceTree，观察分支树变化，fetch 再看</li>\n<li>切回 develop 分支</li>\n<li>Q&amp;A<ul>\n<li>有冲突 merge 按钮会不可点击，merge develop to work_branch ，在 develop 分支外解决冲突，commit&amp;push，merge 按钮就可点击了</li>\n<li>可方便的与自动化测试等结合起来</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"提醒和推荐\"><a href=\"#提醒和推荐\" class=\"headerlink\" title=\"提醒和推荐\"></a>提醒和推荐</h2><h2 id=\"一些提醒（坑）\"><a href=\"#一些提醒（坑）\" class=\"headerlink\" title=\"一些提醒（坑）\"></a>一些提醒（坑）</h2><ul>\n<li>初次使用 Git，注意设置 <code>git config --global email&amp;name</code></li>\n<li>Windows 下的 Git 使用的确有些不便（不过我不熟悉，也不清楚具体问题）</li>\n<li>授权方式推荐 ssh-key</li>\n<li>忽略文件的配置</li>\n<li>着手代码前思考终极问题：『我在哪里，要去何处？』（先认清所在分支，pull）</li>\n<li>commit 已经 push 到远端了，这个时候不要想着再去修改了</li>\n<li>学习新东西，坑总是有的，多填了也就会了</li>\n</ul>\n<h3 id=\"一些推荐\"><a href=\"#一些推荐\" class=\"headerlink\" title=\"一些推荐\"></a>一些推荐</h3><ul>\n<li>强调思路，记住秒级定律，效率为王</li>\n<li>小步提交，每小时至少提交一次<ul>\n<li>一次任务的实现过程：整体设计，框架（类），接口，单元测试，实现</li>\n</ul>\n</li>\n<li>完整提交，完整提交，必须完整提交！不该有任一个提交项目不可运行。</li>\n<li>保证非工作期间，工作区间干净</li>\n<li>不想提交但要切换分支处理事物用 stash 处理</li>\n<li>Github 经常被 X<ul>\n<li>coding.net 代码私有库托管可以用。找开源代码，永远是 Github</li>\n<li>Google 也是被 X。珍爱生命，自配 VPN</li>\n</ul>\n</li>\n<li>国内 Git 私有库托管推荐 coding.net，国外推荐 bitbucket（支持hg） 和 Gitlab</li>\n</ul>\n<h2 id=\"其它\"><a href=\"#其它\" class=\"headerlink\" title=\"其它\"></a>其它</h2><ul>\n<li>依赖（迷信）工具不可取，但工具会影响思维方式，而思维方式非常重要</li>\n</ul>\n<blockquote>\n<p>举例：<br>SVN 的思维方式决定了 diff patch 的开源合作方式。交流不顺畅，实现思路难以程现，这种合作方式很长时间里都是高端人士的特权。<br>Git + Github 催生了 fork，成就了最大的程序员社交网站，也极力促进了开源社区的发展。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>为什么要用 Git？</li>\n<li>Git + SourceTree + Gitlab 的使用演示</li>\n<li>提醒和推荐</li>\n</ul>\n<h2 id=\"为什么要用-Git？\"><a href=\"#为什么要用-Git？\" class=\"headerlink\" title=\"为什么要用 Git？\"></a>为什么要用 Git？</h2><ul>\n<li>一个工具、一套方案，解决源码管理的问题</li>\n</ul>\n<h3 id=\"对于版本控制，我们需要什么？\"><a href=\"#对于版本控制，我们需要什么？\" class=\"headerlink\" title=\"对于版本控制，我们需要什么？\"></a>对于版本控制，我们需要什么？</h3><ul>\n<li>代码历史追溯<ul>\n<li>某一次提交的改动（SVN，Git）</li>\n<li>某一个功能的改动过程（好的提交习惯更重要，在多人协作情况下提交历史更清晰）</li>\n</ul>\n</li>\n<li>协同开发<ul>\n<li>用分支来隔离上线与开发中的代码</li>\n<li>多人多线并行开发：1 人对 N 线，N 人对 1 线都有可能</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>秒极定律<br>一件事情如果能控制在 10s 内完成，人们就会极频繁的使用它。<br>举栗子：</p>\n<ul>\n<li>docker 被推崇，从虚拟机到 Vagrant 到 docker，碰到了秒级定律</li>\n<li>持续集成，快速迭代</li>\n</ul>\n</blockquote>\n<h3 id=\"秒级的代码管理？\"><a href=\"#秒级的代码管理？\" class=\"headerlink\" title=\"秒级的代码管理？\"></a>秒级的代码管理？</h3><ul>\n<li>本地代码飞快变化至任意历史提交记录：SVN 30s-2min；Git 秒级<ul>\n<li>工作状态快速切换</li>\n</ul>\n</li>\n<li>代码提交速度飞快：SVN 受限于网络速度；Git commit 秒级，push 受限于网络速度</li>\n<li>代码创建、切换、合并分支飞快：SVN 速度慢，很麻烦；Git 赞！<ul>\n<li>勇于原型探索，历史清晰，易调整方向，易新建，易弃用</li>\n<li>与 code review 结合</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"SVN-比-Git-好在哪里\"><a href=\"#SVN-比-Git-好在哪里\" class=\"headerlink\" title=\"SVN 比 Git 好在哪里\"></a>SVN 比 Git 好在哪里</h2><ul>\n<li>更简单，符合原有自主文件夹管理版本的心理预期<ul>\n<li>Git 暴露概念过多，学习曲线陡峭，这点不如 hg</li>\n</ul>\n</li>\n<li>SVN 有目录级的权限控制<ul>\n<li>适合大中型中间件软件公司：目录划分权限，职能长期固定</li>\n</ul>\n</li>\n<li>也许还有其它，我不清楚</li>\n</ul>\n<h3 id=\"Git-真实的影响力\"><a href=\"#Git-真实的影响力\" class=\"headerlink\" title=\"Git 真实的影响力\"></a>Git 真实的影响力</h3><blockquote>\n<p>I’m an egotistical bastard, and I name all my projects after myself. First Linux, now Git.<br>—— Linus</p>\n</blockquote>\n<ul>\n<li>在 2016 问这个问题对互联网来说已是大势所趋<ul>\n<li>npm + pip 均托管在 Github</li>\n<li>OpenJDK 使用 Hg（Mercurial）</li>\n<li>Github 早已一统开源天下，Java 概莫能外</li>\n</ul>\n</li>\n<li>SVN 与 Git 二分天下，但 Git 占据的是互联网明星创业公司和 BAT 的优秀团队，为何？</li>\n<li>会 Git 找工作是加分项</li>\n<li>学习版本控制的另一种思维方式（学习一门语言就是学习一类思维方式）</li>\n</ul>\n<h2 id=\"一些问题\"><a href=\"#一些问题\" class=\"headerlink\" title=\"一些问题\"></a>一些问题</h2><ul>\n<li>Git 不能直接解决目前后端的开发环境<ul>\n<li>code 规范的 branch 流程</li>\n<li>依赖，理清 maven 依赖和配合方式</li>\n<li>秒级上线（测试、预发布、正式）</li>\n<li>相应（尽可能少人力介入的）自动化测试、监控</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Git-SourceTree-Gitlab-的使用演示\"><a href=\"#Git-SourceTree-Gitlab-的使用演示\" class=\"headerlink\" title=\"Git + SourceTree + Gitlab 的使用演示\"></a>Git + SourceTree + Gitlab 的使用演示</h2><p><img src=\"http://7j1xgb.com5.z0.glb.clouddn.com/FullSizeRender.jpg\" alt=\"Git 使用流程示意图\"></p>\n<h3 id=\"local-repo\"><a href=\"#local-repo\" class=\"headerlink\" title=\"local repo\"></a>local repo</h3><ul>\n<li>用 SourceTree 初始化一个本地项目</li>\n<li>小步提交，介绍 staged 的用法<ul>\n<li>stage or unstage or discard</li>\n<li>stage 某一行代码</li>\n</ul>\n</li>\n<li>一次提交</li>\n<li>介绍 master 分支及 branchs 界面<ul>\n<li>留意 commit 编号</li>\n</ul>\n</li>\n<li>创建一个分支 feature/login</li>\n<li>新建 login.java 文件，index.html 加一行代码</li>\n<li>commit，观察分支树变化</li>\n<li>切换分支，观察代码变化</li>\n<li>创建一个分支 feature/share</li>\n<li>新建 share.py 文件，index.html 改一行代码</li>\n<li>commit，观察分支树变化</li>\n<li>切回 feature/login，临时处理事情，再切回 feature/share</li>\n<li>feature/share 分支删几行代码，再提交一次</li>\n<li>feature/share merge to master 分支，观察分支树变化</li>\n<li>feature/login merge to master 分支，处理冲突</li>\n<li>初始化 Git-flow</li>\n<li>新建 feature/school 分支，commit once</li>\n<li>用 Git-flow-gui 完成 feature/school 分支</li>\n<li>留意刚才的所有提交都在本地，思考与 SVN 区别（很像，只是分支极灵活）</li>\n<li>Q&amp;A</li>\n</ul>\n<h3 id=\"Gitlab\"><a href=\"#Gitlab\" class=\"headerlink\" title=\"Gitlab\"></a>Gitlab</h3><ul>\n<li>注册帐号，ssh-key 授权（略）</li>\n<li>介绍 Gitlab 结构：team-project</li>\n<li>新建项目 test-repo</li>\n<li>留意空项目向导，复制代码库 url</li>\n<li>本地配置 remote-url，观察 remotes 变化</li>\n<li>push，注意是 push 多条分支，留意 local-remote 分支对应关系</li>\n<li>再看 remotes 变化，分支树变化<ul>\n<li>remotes branchs 与 local branchs 一致</li>\n<li>分支树中多了 origin/*</li>\n</ul>\n</li>\n<li>观察 Gitlab 界面变化</li>\n<li>介绍 Gitlab 单个项目界面</li>\n<li>Q&amp;A</li>\n</ul>\n<h3 id=\"来一次典型的开发过程（包含-code-review）\"><a href=\"#来一次典型的开发过程（包含-code-review）\" class=\"headerlink\" title=\"来一次典型的开发过程（包含 code review）\"></a>来一次典型的开发过程（包含 code review）</h3><ul>\n<li>保证在 develop 分支，pull 最新代码</li>\n<li>网页端提交 readme 文件，造成 origin 变化，介绍 fetch，注意 branchs 变化</li>\n<li>重新 pull</li>\n<li>用 Git-flow-gui 建立 feature/news 分支</li>\n<li>产生两次 commit（包含 rename 文件）</li>\n<li>留意分支树变化，注意 Gitlab-web 端不存在刚才的提交，push，再对比</li>\n<li>Gitlab-web 端新建 merge-request, 留意 source-branch, target-branch, title, ass</li>\n<li>被指派者 review 代码，web 端回复建议</li>\n<li>根据建议产生新的 commit，同时 push</li>\n<li>刷新 web 端观察变化：查看一次 commit，查看全部 changes</li>\n<li>被指派者回复 LGTM（look good to me），点击 merge</li>\n<li>回到 SourceTree，观察分支树变化，fetch 再看</li>\n<li>切回 develop 分支</li>\n<li>Q&amp;A<ul>\n<li>有冲突 merge 按钮会不可点击，merge develop to work_branch ，在 develop 分支外解决冲突，commit&amp;push，merge 按钮就可点击了</li>\n<li>可方便的与自动化测试等结合起来</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"提醒和推荐\"><a href=\"#提醒和推荐\" class=\"headerlink\" title=\"提醒和推荐\"></a>提醒和推荐</h2><h2 id=\"一些提醒（坑）\"><a href=\"#一些提醒（坑）\" class=\"headerlink\" title=\"一些提醒（坑）\"></a>一些提醒（坑）</h2><ul>\n<li>初次使用 Git，注意设置 <code>git config --global email&amp;name</code></li>\n<li>Windows 下的 Git 使用的确有些不便（不过我不熟悉，也不清楚具体问题）</li>\n<li>授权方式推荐 ssh-key</li>\n<li>忽略文件的配置</li>\n<li>着手代码前思考终极问题：『我在哪里，要去何处？』（先认清所在分支，pull）</li>\n<li>commit 已经 push 到远端了，这个时候不要想着再去修改了</li>\n<li>学习新东西，坑总是有的，多填了也就会了</li>\n</ul>\n<h3 id=\"一些推荐\"><a href=\"#一些推荐\" class=\"headerlink\" title=\"一些推荐\"></a>一些推荐</h3><ul>\n<li>强调思路，记住秒级定律，效率为王</li>\n<li>小步提交，每小时至少提交一次<ul>\n<li>一次任务的实现过程：整体设计，框架（类），接口，单元测试，实现</li>\n</ul>\n</li>\n<li>完整提交，完整提交，必须完整提交！不该有任一个提交项目不可运行。</li>\n<li>保证非工作期间，工作区间干净</li>\n<li>不想提交但要切换分支处理事物用 stash 处理</li>\n<li>Github 经常被 X<ul>\n<li>coding.net 代码私有库托管可以用。找开源代码，永远是 Github</li>\n<li>Google 也是被 X。珍爱生命，自配 VPN</li>\n</ul>\n</li>\n<li>国内 Git 私有库托管推荐 coding.net，国外推荐 bitbucket（支持hg） 和 Gitlab</li>\n</ul>\n<h2 id=\"其它\"><a href=\"#其它\" class=\"headerlink\" title=\"其它\"></a>其它</h2><ul>\n<li>依赖（迷信）工具不可取，但工具会影响思维方式，而思维方式非常重要</li>\n</ul>\n<blockquote>\n<p>举例：<br>SVN 的思维方式决定了 diff patch 的开源合作方式。交流不顺畅，实现思路难以程现，这种合作方式很长时间里都是高端人士的特权。<br>Git + Github 催生了 fork，成就了最大的程序员社交网站，也极力促进了开源社区的发展。</p>\n</blockquote>\n"},{"title":"tablayout方法setupWithViewPager()坑","date":"2016-01-29T10:30:00.000Z","_content":"\n\n\n为什么说慎用了？(最新TalLayout源码有改动，讨论只限之前的源码)\n先看TabLayout平常怎么使用setupWithViewPager()\n\n````\nViewPager viewPager=(ViewPager)findViewById(R.id.view_pager);\nTabLayout tabContainView = (TabLayout) findViewById(R.id.pick_school_category_contain);\nviewPager.setAdatper(new FragmentStatePagerAdapter(FragmentManager,fragments));\ntabContainView. setupWithViewPager(viewPager);\n````\n运行没有什么问题，但是深入看代码的你就会发现一些问题。\n查看setupWithViewPager()方法源码\n\n````\n public void setupWithViewPager(@NonNull ViewPager viewPager) {\n        final PagerAdapter adapter = viewPager.getAdapter();\n        if (adapter == null) {\n            throw new IllegalArgumentException(\"ViewPager does not have a PagerAdapter set\");\n        }\n\n        // First we'll add Tabs, using the adapter's page titles\n        setTabsFromPagerAdapter(adapter);\n\n        // Now we'll add our page change listener to the ViewPager\n        viewPager.addOnPageChangeListener(new TabLayoutOnPageChangeListener(this));\n\n        // Now we'll add a tab selected listener to set ViewPager's current item\n        setOnTabSelectedListener(new ViewPagerOnTabSelectedListener(viewPager));\n\n        // Make sure we reflect the currently set ViewPager item\n        if (adapter.getCount() > 0) {\n            final int curItem = viewPager.getCurrentItem();\n            if (getSelectedTabPosition() != curItem) {\n                selectTab(getTabAt(curItem));\n            }\n        }\n    }\n````\n获取ViewPager的Adapter后使用了三个方法\n```\nsetTabsFromPagerAdapter(adapter);\nsetOnTabSelectedListener(new ViewPagerOnTabSelectedListener(viewPager));\n//这个处理逻辑我们简单理解放在一个方法处理\nif (adapter.getCount() > 0) {\n            final int curItem = viewPager.getCurrentItem();\n            if (getSelectedTabPosition() != curItem) {\n                selectTab(getTabAt(curItem));\n            }\n        }\n```\n###setTabsFromPagerAdapter\n首先看第一个方法实现\n````\npublic void setTabsFromPagerAdapter(@NonNull PagerAdapter adapter) {\n        removeAllTabs();\n        for (int i = 0, count = adapter.getCount(); i < count; i++) {\n            addTab(newTab().setText(adapter.getPageTitle(i)));\n        }\n    }\n````\nremoveAllTabs()这个就是说把前面所有TabLayout添加的view都删掉,并都设置view的title。\n>我觉的有问题：1.从逻辑来讲前面都是通过判断adapter为空在进行下一步操作，那就是说adapter必须先不为null才能执行逻辑代码。可是我们已经为ViewPager初始化设置了adapter那还有必要这里重复需要初始化adapter？\n\n###setOnTabSelectedListener(new ViewPagerOnTabSelectedListener(viewPager));\n\t\n````\n\t\tpublic static class ViewPagerOnTabSelectedListener implements TabLayout.OnTabSelectedListener {\n        private final ViewPager mViewPager;\n\n        public ViewPagerOnTabSelectedListener(ViewPager viewPager) {\n            mViewPager = viewPager;\n        }\n        @Override\n        public void onTabSelected(TabLayout.Tab tab) {\n            mViewPager.setCurrentItem(tab.getPosition());\n        }\n        @Override\n        public void onTabUnselected(TabLayout.Tab tab) {\n            // No-op\n        }\n\n        @Override\n        public void onTabReselected(TabLayout.Tab tab) {\n            // No-op\n        }\n    }\n  ````\n> 这里本身没有太多问题，就是如果已经设置了 监听，点击tab不是滚动的，这里重新设置就会设置为滚动了\n### selectTab(getTabAt(curItem));\n````\n\tif (adapter.getCount() > 0) {\n            final int curItem = viewPager.getCurrentItem();\n            if (getSelectedTabPosition() != curItem) {\n                selectTab(getTabAt(curItem));\n            }\n        }\n````\n>前面方法setTabsFromPagerAdapter都初始化清空了，肯定getCurrentItem()=0啊，这里还需要设置吗？难道还考虑多线程？\n###总结\n总结TabLayout.setupWithViewPager（）设计很不合理。\n\nps：其实主要的是提醒自己以后不要光api调用而不去研究具体api做了什么。\n\t\n","source":"_posts/tablayout方法setupWithViewPager()坑.md","raw":"title: tablayout方法setupWithViewPager()坑\ndate: 2016-01-29  10:30:00\ntags:\n- tablayout\n- Chrome\n- 坑\n\ncategories: Android\n---\n\n\n\n为什么说慎用了？(最新TalLayout源码有改动，讨论只限之前的源码)\n先看TabLayout平常怎么使用setupWithViewPager()\n\n````\nViewPager viewPager=(ViewPager)findViewById(R.id.view_pager);\nTabLayout tabContainView = (TabLayout) findViewById(R.id.pick_school_category_contain);\nviewPager.setAdatper(new FragmentStatePagerAdapter(FragmentManager,fragments));\ntabContainView. setupWithViewPager(viewPager);\n````\n运行没有什么问题，但是深入看代码的你就会发现一些问题。\n查看setupWithViewPager()方法源码\n\n````\n public void setupWithViewPager(@NonNull ViewPager viewPager) {\n        final PagerAdapter adapter = viewPager.getAdapter();\n        if (adapter == null) {\n            throw new IllegalArgumentException(\"ViewPager does not have a PagerAdapter set\");\n        }\n\n        // First we'll add Tabs, using the adapter's page titles\n        setTabsFromPagerAdapter(adapter);\n\n        // Now we'll add our page change listener to the ViewPager\n        viewPager.addOnPageChangeListener(new TabLayoutOnPageChangeListener(this));\n\n        // Now we'll add a tab selected listener to set ViewPager's current item\n        setOnTabSelectedListener(new ViewPagerOnTabSelectedListener(viewPager));\n\n        // Make sure we reflect the currently set ViewPager item\n        if (adapter.getCount() > 0) {\n            final int curItem = viewPager.getCurrentItem();\n            if (getSelectedTabPosition() != curItem) {\n                selectTab(getTabAt(curItem));\n            }\n        }\n    }\n````\n获取ViewPager的Adapter后使用了三个方法\n```\nsetTabsFromPagerAdapter(adapter);\nsetOnTabSelectedListener(new ViewPagerOnTabSelectedListener(viewPager));\n//这个处理逻辑我们简单理解放在一个方法处理\nif (adapter.getCount() > 0) {\n            final int curItem = viewPager.getCurrentItem();\n            if (getSelectedTabPosition() != curItem) {\n                selectTab(getTabAt(curItem));\n            }\n        }\n```\n###setTabsFromPagerAdapter\n首先看第一个方法实现\n````\npublic void setTabsFromPagerAdapter(@NonNull PagerAdapter adapter) {\n        removeAllTabs();\n        for (int i = 0, count = adapter.getCount(); i < count; i++) {\n            addTab(newTab().setText(adapter.getPageTitle(i)));\n        }\n    }\n````\nremoveAllTabs()这个就是说把前面所有TabLayout添加的view都删掉,并都设置view的title。\n>我觉的有问题：1.从逻辑来讲前面都是通过判断adapter为空在进行下一步操作，那就是说adapter必须先不为null才能执行逻辑代码。可是我们已经为ViewPager初始化设置了adapter那还有必要这里重复需要初始化adapter？\n\n###setOnTabSelectedListener(new ViewPagerOnTabSelectedListener(viewPager));\n\t\n````\n\t\tpublic static class ViewPagerOnTabSelectedListener implements TabLayout.OnTabSelectedListener {\n        private final ViewPager mViewPager;\n\n        public ViewPagerOnTabSelectedListener(ViewPager viewPager) {\n            mViewPager = viewPager;\n        }\n        @Override\n        public void onTabSelected(TabLayout.Tab tab) {\n            mViewPager.setCurrentItem(tab.getPosition());\n        }\n        @Override\n        public void onTabUnselected(TabLayout.Tab tab) {\n            // No-op\n        }\n\n        @Override\n        public void onTabReselected(TabLayout.Tab tab) {\n            // No-op\n        }\n    }\n  ````\n> 这里本身没有太多问题，就是如果已经设置了 监听，点击tab不是滚动的，这里重新设置就会设置为滚动了\n### selectTab(getTabAt(curItem));\n````\n\tif (adapter.getCount() > 0) {\n            final int curItem = viewPager.getCurrentItem();\n            if (getSelectedTabPosition() != curItem) {\n                selectTab(getTabAt(curItem));\n            }\n        }\n````\n>前面方法setTabsFromPagerAdapter都初始化清空了，肯定getCurrentItem()=0啊，这里还需要设置吗？难道还考虑多线程？\n###总结\n总结TabLayout.setupWithViewPager（）设计很不合理。\n\nps：其实主要的是提醒自己以后不要光api调用而不去研究具体api做了什么。\n\t\n","slug":"tablayout方法setupWithViewPager-坑","published":1,"updated":"2021-09-10T07:04:21.944Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cktfeap43001qc2xxc3ng3zkn","content":"<p>为什么说慎用了？(最新TalLayout源码有改动，讨论只限之前的源码)<br>先看TabLayout平常怎么使用setupWithViewPager()</p>\n<pre><code>ViewPager viewPager=(ViewPager)findViewById(R.id.view_pager);\nTabLayout tabContainView = (TabLayout) findViewById(R.id.pick_school_category_contain);\nviewPager.setAdatper(new FragmentStatePagerAdapter(FragmentManager,fragments));\ntabContainView. setupWithViewPager(viewPager);\n</code></pre><p>运行没有什么问题，但是深入看代码的你就会发现一些问题。<br>查看setupWithViewPager()方法源码</p>\n<pre><code> public void setupWithViewPager(@NonNull ViewPager viewPager) {\n        final PagerAdapter adapter = viewPager.getAdapter();\n        if (adapter == null) {\n            throw new IllegalArgumentException(&quot;ViewPager does not have a PagerAdapter set&quot;);\n        }\n\n        // First we&#39;ll add Tabs, using the adapter&#39;s page titles\n        setTabsFromPagerAdapter(adapter);\n\n        // Now we&#39;ll add our page change listener to the ViewPager\n        viewPager.addOnPageChangeListener(new TabLayoutOnPageChangeListener(this));\n\n        // Now we&#39;ll add a tab selected listener to set ViewPager&#39;s current item\n        setOnTabSelectedListener(new ViewPagerOnTabSelectedListener(viewPager));\n\n        // Make sure we reflect the currently set ViewPager item\n        if (adapter.getCount() &gt; 0) {\n            final int curItem = viewPager.getCurrentItem();\n            if (getSelectedTabPosition() != curItem) {\n                selectTab(getTabAt(curItem));\n            }\n        }\n    }\n</code></pre><p>获取ViewPager的Adapter后使用了三个方法</p>\n<pre><code>setTabsFromPagerAdapter(adapter);\nsetOnTabSelectedListener(new ViewPagerOnTabSelectedListener(viewPager));\n//这个处理逻辑我们简单理解放在一个方法处理\nif (adapter.getCount() &gt; 0) {\n            final int curItem = viewPager.getCurrentItem();\n            if (getSelectedTabPosition() != curItem) {\n                selectTab(getTabAt(curItem));\n            }\n        }\n</code></pre><p>###setTabsFromPagerAdapter<br>首先看第一个方法实现</p>\n<pre><code>public void setTabsFromPagerAdapter(@NonNull PagerAdapter adapter) {\n        removeAllTabs();\n        for (int i = 0, count = adapter.getCount(); i &lt; count; i++) {\n            addTab(newTab().setText(adapter.getPageTitle(i)));\n        }\n    }\n</code></pre><p>removeAllTabs()这个就是说把前面所有TabLayout添加的view都删掉,并都设置view的title。</p>\n<blockquote>\n<p>我觉的有问题：1.从逻辑来讲前面都是通过判断adapter为空在进行下一步操作，那就是说adapter必须先不为null才能执行逻辑代码。可是我们已经为ViewPager初始化设置了adapter那还有必要这里重复需要初始化adapter？</p>\n</blockquote>\n<p>###setOnTabSelectedListener(new ViewPagerOnTabSelectedListener(viewPager));</p>\n<pre><code>        public static class ViewPagerOnTabSelectedListener implements TabLayout.OnTabSelectedListener {\n        private final ViewPager mViewPager;\n\n        public ViewPagerOnTabSelectedListener(ViewPager viewPager) {\n            mViewPager = viewPager;\n        }\n        @Override\n        public void onTabSelected(TabLayout.Tab tab) {\n            mViewPager.setCurrentItem(tab.getPosition());\n        }\n        @Override\n        public void onTabUnselected(TabLayout.Tab tab) {\n            // No-op\n        }\n\n        @Override\n        public void onTabReselected(TabLayout.Tab tab) {\n            // No-op\n        }\n    }\n</code></pre><blockquote>\n<p>这里本身没有太多问题，就是如果已经设置了 监听，点击tab不是滚动的，这里重新设置就会设置为滚动了</p>\n<h3 id=\"selectTab-getTabAt-curItem\"><a href=\"#selectTab-getTabAt-curItem\" class=\"headerlink\" title=\"selectTab(getTabAt(curItem));\"></a>selectTab(getTabAt(curItem));</h3><pre><code>    if (adapter.getCount() &gt; 0) {\n            final int curItem = viewPager.getCurrentItem();\n            if (getSelectedTabPosition() != curItem) {\n                selectTab(getTabAt(curItem));\n            }\n        }\n</code></pre><p>前面方法setTabsFromPagerAdapter都初始化清空了，肯定getCurrentItem()=0啊，这里还需要设置吗？难道还考虑多线程？</p>\n<p>###总结<br>总结TabLayout.setupWithViewPager（）设计很不合理。</p>\n</blockquote>\n<p>ps：其实主要的是提醒自己以后不要光api调用而不去研究具体api做了什么。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>为什么说慎用了？(最新TalLayout源码有改动，讨论只限之前的源码)<br>先看TabLayout平常怎么使用setupWithViewPager()</p>\n<pre><code>ViewPager viewPager=(ViewPager)findViewById(R.id.view_pager);\nTabLayout tabContainView = (TabLayout) findViewById(R.id.pick_school_category_contain);\nviewPager.setAdatper(new FragmentStatePagerAdapter(FragmentManager,fragments));\ntabContainView. setupWithViewPager(viewPager);\n</code></pre><p>运行没有什么问题，但是深入看代码的你就会发现一些问题。<br>查看setupWithViewPager()方法源码</p>\n<pre><code> public void setupWithViewPager(@NonNull ViewPager viewPager) {\n        final PagerAdapter adapter = viewPager.getAdapter();\n        if (adapter == null) {\n            throw new IllegalArgumentException(&quot;ViewPager does not have a PagerAdapter set&quot;);\n        }\n\n        // First we&#39;ll add Tabs, using the adapter&#39;s page titles\n        setTabsFromPagerAdapter(adapter);\n\n        // Now we&#39;ll add our page change listener to the ViewPager\n        viewPager.addOnPageChangeListener(new TabLayoutOnPageChangeListener(this));\n\n        // Now we&#39;ll add a tab selected listener to set ViewPager&#39;s current item\n        setOnTabSelectedListener(new ViewPagerOnTabSelectedListener(viewPager));\n\n        // Make sure we reflect the currently set ViewPager item\n        if (adapter.getCount() &gt; 0) {\n            final int curItem = viewPager.getCurrentItem();\n            if (getSelectedTabPosition() != curItem) {\n                selectTab(getTabAt(curItem));\n            }\n        }\n    }\n</code></pre><p>获取ViewPager的Adapter后使用了三个方法</p>\n<pre><code>setTabsFromPagerAdapter(adapter);\nsetOnTabSelectedListener(new ViewPagerOnTabSelectedListener(viewPager));\n//这个处理逻辑我们简单理解放在一个方法处理\nif (adapter.getCount() &gt; 0) {\n            final int curItem = viewPager.getCurrentItem();\n            if (getSelectedTabPosition() != curItem) {\n                selectTab(getTabAt(curItem));\n            }\n        }\n</code></pre><p>###setTabsFromPagerAdapter<br>首先看第一个方法实现</p>\n<pre><code>public void setTabsFromPagerAdapter(@NonNull PagerAdapter adapter) {\n        removeAllTabs();\n        for (int i = 0, count = adapter.getCount(); i &lt; count; i++) {\n            addTab(newTab().setText(adapter.getPageTitle(i)));\n        }\n    }\n</code></pre><p>removeAllTabs()这个就是说把前面所有TabLayout添加的view都删掉,并都设置view的title。</p>\n<blockquote>\n<p>我觉的有问题：1.从逻辑来讲前面都是通过判断adapter为空在进行下一步操作，那就是说adapter必须先不为null才能执行逻辑代码。可是我们已经为ViewPager初始化设置了adapter那还有必要这里重复需要初始化adapter？</p>\n</blockquote>\n<p>###setOnTabSelectedListener(new ViewPagerOnTabSelectedListener(viewPager));</p>\n<pre><code>        public static class ViewPagerOnTabSelectedListener implements TabLayout.OnTabSelectedListener {\n        private final ViewPager mViewPager;\n\n        public ViewPagerOnTabSelectedListener(ViewPager viewPager) {\n            mViewPager = viewPager;\n        }\n        @Override\n        public void onTabSelected(TabLayout.Tab tab) {\n            mViewPager.setCurrentItem(tab.getPosition());\n        }\n        @Override\n        public void onTabUnselected(TabLayout.Tab tab) {\n            // No-op\n        }\n\n        @Override\n        public void onTabReselected(TabLayout.Tab tab) {\n            // No-op\n        }\n    }\n</code></pre><blockquote>\n<p>这里本身没有太多问题，就是如果已经设置了 监听，点击tab不是滚动的，这里重新设置就会设置为滚动了</p>\n<h3 id=\"selectTab-getTabAt-curItem\"><a href=\"#selectTab-getTabAt-curItem\" class=\"headerlink\" title=\"selectTab(getTabAt(curItem));\"></a>selectTab(getTabAt(curItem));</h3><pre><code>    if (adapter.getCount() &gt; 0) {\n            final int curItem = viewPager.getCurrentItem();\n            if (getSelectedTabPosition() != curItem) {\n                selectTab(getTabAt(curItem));\n            }\n        }\n</code></pre><p>前面方法setTabsFromPagerAdapter都初始化清空了，肯定getCurrentItem()=0啊，这里还需要设置吗？难道还考虑多线程？</p>\n<p>###总结<br>总结TabLayout.setupWithViewPager（）设计很不合理。</p>\n</blockquote>\n<p>ps：其实主要的是提醒自己以后不要光api调用而不去研究具体api做了什么。</p>\n"},{"title":"优秀APP推荐","date":"2015-03-27T23:04:29.000Z","_content":"\n\n\n#### APP分享 - 张超耀\n- [网易云音乐](http://music.163.com/#/download)\n\t- 播放界面的毛玻璃效果值得借鉴。\n\t- 网易云音乐是一款专注于发现与分享的音乐产品,依托专业音乐人、DJ、好友推荐及社交功能,为用户打造全新的音乐生活。\n\n- [一问](http://yiwen.fm)\n \t- 「一问」会坚持每天介绍一家创业公司，包括该创业公司的一开始的想法和思路，想创业的童靴可以参考下。\n\n- [forest](https://itunes.apple.com/tw/app/forest-bao-chi-zhuan-zhu-ju/id866450515?l=zh&mt=8)\n\t- 「Forest」是一个帮助您专心于生活中每个重要时刻的APP。\n\t- Forest能帮助您远离智慧型手机的诱惑。每当您想要专注时，种下种籽吧！在接下来的30分钟内，它将成长成为一棵大树。\n\n- [500px](https://500px.com)\n\t- 「500px」是一个致力于来自世界各地的摄影师的摄影分享、发现、售卖的专业平台。\n\t-  APP的loading不错，小创意值得学习。\n\n- [any.do](http://www.any.do)\n\t- 无论从UI设计、易用性、实用性来讲，Any.Do 都在上流水准！Any.Do凭借简洁大方的界面设计和便捷直观的操作收获了大量用户，并通过云技术将日程安排等数据自动同步，帮助用户随时随地更系统更方便地管理自己的日程安排，让它来管理的你的日常生活再好不过了。\n\n#### App 分享 - 王胜\n\n- [金山词霸](http://www.iciba.com)\n\t- 本地、在线翻译功能\n\t- 每日一句很有文艺范\n\t- 最大亮点拍照翻译功能，支持自动取词、点击取词、长句拍译。以后再看到不会输入的日韩文字，一拍照，轻松搞定\n- [手机百度](http://xbox.m.baidu.com/wuxian)\n\t- 搜索功能\n\t- 最大亮点拍照搜索，以后参观植物园、动物园再也不用担心不知道这个是什么花，那个是什么动物了\n\n\n\n#### App 分享 - 曾铭\n\n- [Slack](https://slack.com/)\n\t- 坐上火箭的公司[36Kr](http://www.36kr.com/p/219324.html)\n\t- 交流：（人员:channels、信息流 integration）\n\t- 重视用户反馈\n- [Tweetbot](http://tapbots.com/tweetbot/)\n\t- 无数神细节\n\t- 发布@#以及草稿\n\t- 一个@的产品设计\n- [GBA4iOS](http://www.gba4iosapp.com/)\n\t- 一个模拟器该有的样子\n\t- 开源\n- [世界迷雾](http://zh-hans.fogofworld.com/)\n\t- 一个应用（游戏）的世界观\n\t- 使用一生的应用\n- [Seven](http://www.perigee.se/seven.php)\n\t- 7分钟，坚持七个月 5%%\n\t- 成就+❤，进度+回顾\n\t- 收费\n\n### App 分享 - 吴明\n\n- [快递100](http://www.kuaidi100.com/)\n   - 方便查询附近快递员电话\n   - 扫描快递单号跟踪快递信息\n- [Axure RP原型设计](http://rj.baidu.com/soft/detail/15574.html?ald)\n   - Axure RP是一个专业的快速原型设计工具\n   - Axure RP生成的原型文件是网页版，跨平台支持\n   - Axure RP工具操作。\n\n","source":"_posts/优秀APP推荐.md","raw":"title: 优秀APP推荐\ndate: 2015-03-27 23:04:29\ntags:\ncategories: 移动组周分享\n---\n\n\n\n#### APP分享 - 张超耀\n- [网易云音乐](http://music.163.com/#/download)\n\t- 播放界面的毛玻璃效果值得借鉴。\n\t- 网易云音乐是一款专注于发现与分享的音乐产品,依托专业音乐人、DJ、好友推荐及社交功能,为用户打造全新的音乐生活。\n\n- [一问](http://yiwen.fm)\n \t- 「一问」会坚持每天介绍一家创业公司，包括该创业公司的一开始的想法和思路，想创业的童靴可以参考下。\n\n- [forest](https://itunes.apple.com/tw/app/forest-bao-chi-zhuan-zhu-ju/id866450515?l=zh&mt=8)\n\t- 「Forest」是一个帮助您专心于生活中每个重要时刻的APP。\n\t- Forest能帮助您远离智慧型手机的诱惑。每当您想要专注时，种下种籽吧！在接下来的30分钟内，它将成长成为一棵大树。\n\n- [500px](https://500px.com)\n\t- 「500px」是一个致力于来自世界各地的摄影师的摄影分享、发现、售卖的专业平台。\n\t-  APP的loading不错，小创意值得学习。\n\n- [any.do](http://www.any.do)\n\t- 无论从UI设计、易用性、实用性来讲，Any.Do 都在上流水准！Any.Do凭借简洁大方的界面设计和便捷直观的操作收获了大量用户，并通过云技术将日程安排等数据自动同步，帮助用户随时随地更系统更方便地管理自己的日程安排，让它来管理的你的日常生活再好不过了。\n\n#### App 分享 - 王胜\n\n- [金山词霸](http://www.iciba.com)\n\t- 本地、在线翻译功能\n\t- 每日一句很有文艺范\n\t- 最大亮点拍照翻译功能，支持自动取词、点击取词、长句拍译。以后再看到不会输入的日韩文字，一拍照，轻松搞定\n- [手机百度](http://xbox.m.baidu.com/wuxian)\n\t- 搜索功能\n\t- 最大亮点拍照搜索，以后参观植物园、动物园再也不用担心不知道这个是什么花，那个是什么动物了\n\n\n\n#### App 分享 - 曾铭\n\n- [Slack](https://slack.com/)\n\t- 坐上火箭的公司[36Kr](http://www.36kr.com/p/219324.html)\n\t- 交流：（人员:channels、信息流 integration）\n\t- 重视用户反馈\n- [Tweetbot](http://tapbots.com/tweetbot/)\n\t- 无数神细节\n\t- 发布@#以及草稿\n\t- 一个@的产品设计\n- [GBA4iOS](http://www.gba4iosapp.com/)\n\t- 一个模拟器该有的样子\n\t- 开源\n- [世界迷雾](http://zh-hans.fogofworld.com/)\n\t- 一个应用（游戏）的世界观\n\t- 使用一生的应用\n- [Seven](http://www.perigee.se/seven.php)\n\t- 7分钟，坚持七个月 5%%\n\t- 成就+❤，进度+回顾\n\t- 收费\n\n### App 分享 - 吴明\n\n- [快递100](http://www.kuaidi100.com/)\n   - 方便查询附近快递员电话\n   - 扫描快递单号跟踪快递信息\n- [Axure RP原型设计](http://rj.baidu.com/soft/detail/15574.html?ald)\n   - Axure RP是一个专业的快速原型设计工具\n   - Axure RP生成的原型文件是网页版，跨平台支持\n   - Axure RP工具操作。\n\n","slug":"优秀APP推荐","published":1,"updated":"2021-09-10T07:04:21.945Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cktfeap44001sc2xx0iuvc4mw","content":"<h4 id=\"APP分享-张超耀\"><a href=\"#APP分享-张超耀\" class=\"headerlink\" title=\"APP分享 - 张超耀\"></a>APP分享 - 张超耀</h4><ul>\n<li><p><a href=\"http://music.163.com/#/download\" target=\"_blank\" rel=\"noopener\">网易云音乐</a></p>\n<ul>\n<li>播放界面的毛玻璃效果值得借鉴。</li>\n<li>网易云音乐是一款专注于发现与分享的音乐产品,依托专业音乐人、DJ、好友推荐及社交功能,为用户打造全新的音乐生活。</li>\n</ul>\n</li>\n<li><p><a href=\"http://yiwen.fm\" target=\"_blank\" rel=\"noopener\">一问</a></p>\n<ul>\n<li>「一问」会坚持每天介绍一家创业公司，包括该创业公司的一开始的想法和思路，想创业的童靴可以参考下。</li>\n</ul>\n</li>\n<li><p><a href=\"https://itunes.apple.com/tw/app/forest-bao-chi-zhuan-zhu-ju/id866450515?l=zh&amp;mt=8\" target=\"_blank\" rel=\"noopener\">forest</a></p>\n<ul>\n<li>「Forest」是一个帮助您专心于生活中每个重要时刻的APP。</li>\n<li>Forest能帮助您远离智慧型手机的诱惑。每当您想要专注时，种下种籽吧！在接下来的30分钟内，它将成长成为一棵大树。</li>\n</ul>\n</li>\n<li><p><a href=\"https://500px.com\" target=\"_blank\" rel=\"noopener\">500px</a></p>\n<ul>\n<li>「500px」是一个致力于来自世界各地的摄影师的摄影分享、发现、售卖的专业平台。</li>\n<li>APP的loading不错，小创意值得学习。</li>\n</ul>\n</li>\n<li><p><a href=\"http://www.any.do\" target=\"_blank\" rel=\"noopener\">any.do</a></p>\n<ul>\n<li>无论从UI设计、易用性、实用性来讲，Any.Do 都在上流水准！Any.Do凭借简洁大方的界面设计和便捷直观的操作收获了大量用户，并通过云技术将日程安排等数据自动同步，帮助用户随时随地更系统更方便地管理自己的日程安排，让它来管理的你的日常生活再好不过了。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"App-分享-王胜\"><a href=\"#App-分享-王胜\" class=\"headerlink\" title=\"App 分享 - 王胜\"></a>App 分享 - 王胜</h4><ul>\n<li><a href=\"http://www.iciba.com\" target=\"_blank\" rel=\"noopener\">金山词霸</a><ul>\n<li>本地、在线翻译功能</li>\n<li>每日一句很有文艺范</li>\n<li>最大亮点拍照翻译功能，支持自动取词、点击取词、长句拍译。以后再看到不会输入的日韩文字，一拍照，轻松搞定</li>\n</ul>\n</li>\n<li><a href=\"http://xbox.m.baidu.com/wuxian\" target=\"_blank\" rel=\"noopener\">手机百度</a><ul>\n<li>搜索功能</li>\n<li>最大亮点拍照搜索，以后参观植物园、动物园再也不用担心不知道这个是什么花，那个是什么动物了</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"App-分享-曾铭\"><a href=\"#App-分享-曾铭\" class=\"headerlink\" title=\"App 分享 - 曾铭\"></a>App 分享 - 曾铭</h4><ul>\n<li><a href=\"https://slack.com/\" target=\"_blank\" rel=\"noopener\">Slack</a><ul>\n<li>坐上火箭的公司<a href=\"http://www.36kr.com/p/219324.html\" target=\"_blank\" rel=\"noopener\">36Kr</a></li>\n<li>交流：（人员:channels、信息流 integration）</li>\n<li>重视用户反馈</li>\n</ul>\n</li>\n<li><a href=\"http://tapbots.com/tweetbot/\" target=\"_blank\" rel=\"noopener\">Tweetbot</a><ul>\n<li>无数神细节</li>\n<li>发布@#以及草稿</li>\n<li>一个@的产品设计</li>\n</ul>\n</li>\n<li><a href=\"http://www.gba4iosapp.com/\" target=\"_blank\" rel=\"noopener\">GBA4iOS</a><ul>\n<li>一个模拟器该有的样子</li>\n<li>开源</li>\n</ul>\n</li>\n<li><a href=\"http://zh-hans.fogofworld.com/\" target=\"_blank\" rel=\"noopener\">世界迷雾</a><ul>\n<li>一个应用（游戏）的世界观</li>\n<li>使用一生的应用</li>\n</ul>\n</li>\n<li><a href=\"http://www.perigee.se/seven.php\" target=\"_blank\" rel=\"noopener\">Seven</a><ul>\n<li>7分钟，坚持七个月 5%%</li>\n<li>成就+❤，进度+回顾</li>\n<li>收费</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"App-分享-吴明\"><a href=\"#App-分享-吴明\" class=\"headerlink\" title=\"App 分享 - 吴明\"></a>App 分享 - 吴明</h3><ul>\n<li><a href=\"http://www.kuaidi100.com/\" target=\"_blank\" rel=\"noopener\">快递100</a><ul>\n<li>方便查询附近快递员电话</li>\n<li>扫描快递单号跟踪快递信息</li>\n</ul>\n</li>\n<li><a href=\"http://rj.baidu.com/soft/detail/15574.html?ald\" target=\"_blank\" rel=\"noopener\">Axure RP原型设计</a><ul>\n<li>Axure RP是一个专业的快速原型设计工具</li>\n<li>Axure RP生成的原型文件是网页版，跨平台支持</li>\n<li>Axure RP工具操作。</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"APP分享-张超耀\"><a href=\"#APP分享-张超耀\" class=\"headerlink\" title=\"APP分享 - 张超耀\"></a>APP分享 - 张超耀</h4><ul>\n<li><p><a href=\"http://music.163.com/#/download\" target=\"_blank\" rel=\"noopener\">网易云音乐</a></p>\n<ul>\n<li>播放界面的毛玻璃效果值得借鉴。</li>\n<li>网易云音乐是一款专注于发现与分享的音乐产品,依托专业音乐人、DJ、好友推荐及社交功能,为用户打造全新的音乐生活。</li>\n</ul>\n</li>\n<li><p><a href=\"http://yiwen.fm\" target=\"_blank\" rel=\"noopener\">一问</a></p>\n<ul>\n<li>「一问」会坚持每天介绍一家创业公司，包括该创业公司的一开始的想法和思路，想创业的童靴可以参考下。</li>\n</ul>\n</li>\n<li><p><a href=\"https://itunes.apple.com/tw/app/forest-bao-chi-zhuan-zhu-ju/id866450515?l=zh&amp;mt=8\" target=\"_blank\" rel=\"noopener\">forest</a></p>\n<ul>\n<li>「Forest」是一个帮助您专心于生活中每个重要时刻的APP。</li>\n<li>Forest能帮助您远离智慧型手机的诱惑。每当您想要专注时，种下种籽吧！在接下来的30分钟内，它将成长成为一棵大树。</li>\n</ul>\n</li>\n<li><p><a href=\"https://500px.com\" target=\"_blank\" rel=\"noopener\">500px</a></p>\n<ul>\n<li>「500px」是一个致力于来自世界各地的摄影师的摄影分享、发现、售卖的专业平台。</li>\n<li>APP的loading不错，小创意值得学习。</li>\n</ul>\n</li>\n<li><p><a href=\"http://www.any.do\" target=\"_blank\" rel=\"noopener\">any.do</a></p>\n<ul>\n<li>无论从UI设计、易用性、实用性来讲，Any.Do 都在上流水准！Any.Do凭借简洁大方的界面设计和便捷直观的操作收获了大量用户，并通过云技术将日程安排等数据自动同步，帮助用户随时随地更系统更方便地管理自己的日程安排，让它来管理的你的日常生活再好不过了。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"App-分享-王胜\"><a href=\"#App-分享-王胜\" class=\"headerlink\" title=\"App 分享 - 王胜\"></a>App 分享 - 王胜</h4><ul>\n<li><a href=\"http://www.iciba.com\" target=\"_blank\" rel=\"noopener\">金山词霸</a><ul>\n<li>本地、在线翻译功能</li>\n<li>每日一句很有文艺范</li>\n<li>最大亮点拍照翻译功能，支持自动取词、点击取词、长句拍译。以后再看到不会输入的日韩文字，一拍照，轻松搞定</li>\n</ul>\n</li>\n<li><a href=\"http://xbox.m.baidu.com/wuxian\" target=\"_blank\" rel=\"noopener\">手机百度</a><ul>\n<li>搜索功能</li>\n<li>最大亮点拍照搜索，以后参观植物园、动物园再也不用担心不知道这个是什么花，那个是什么动物了</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"App-分享-曾铭\"><a href=\"#App-分享-曾铭\" class=\"headerlink\" title=\"App 分享 - 曾铭\"></a>App 分享 - 曾铭</h4><ul>\n<li><a href=\"https://slack.com/\" target=\"_blank\" rel=\"noopener\">Slack</a><ul>\n<li>坐上火箭的公司<a href=\"http://www.36kr.com/p/219324.html\" target=\"_blank\" rel=\"noopener\">36Kr</a></li>\n<li>交流：（人员:channels、信息流 integration）</li>\n<li>重视用户反馈</li>\n</ul>\n</li>\n<li><a href=\"http://tapbots.com/tweetbot/\" target=\"_blank\" rel=\"noopener\">Tweetbot</a><ul>\n<li>无数神细节</li>\n<li>发布@#以及草稿</li>\n<li>一个@的产品设计</li>\n</ul>\n</li>\n<li><a href=\"http://www.gba4iosapp.com/\" target=\"_blank\" rel=\"noopener\">GBA4iOS</a><ul>\n<li>一个模拟器该有的样子</li>\n<li>开源</li>\n</ul>\n</li>\n<li><a href=\"http://zh-hans.fogofworld.com/\" target=\"_blank\" rel=\"noopener\">世界迷雾</a><ul>\n<li>一个应用（游戏）的世界观</li>\n<li>使用一生的应用</li>\n</ul>\n</li>\n<li><a href=\"http://www.perigee.se/seven.php\" target=\"_blank\" rel=\"noopener\">Seven</a><ul>\n<li>7分钟，坚持七个月 5%%</li>\n<li>成就+❤，进度+回顾</li>\n<li>收费</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"App-分享-吴明\"><a href=\"#App-分享-吴明\" class=\"headerlink\" title=\"App 分享 - 吴明\"></a>App 分享 - 吴明</h3><ul>\n<li><a href=\"http://www.kuaidi100.com/\" target=\"_blank\" rel=\"noopener\">快递100</a><ul>\n<li>方便查询附近快递员电话</li>\n<li>扫描快递单号跟踪快递信息</li>\n</ul>\n</li>\n<li><a href=\"http://rj.baidu.com/soft/detail/15574.html?ald\" target=\"_blank\" rel=\"noopener\">Axure RP原型设计</a><ul>\n<li>Axure RP是一个专业的快速原型设计工具</li>\n<li>Axure RP生成的原型文件是网页版，跨平台支持</li>\n<li>Axure RP工具操作。</li>\n</ul>\n</li>\n</ul>\n"},{"title":"前端入门（2）","date":"2015-12-11T10:30:00.000Z","_content":"\n\n### [博客地址]()\n\n## Swift柯里化 Curring 学习\n\n### 什么是Curring\n> [维基百科解释](https://zh.wikipedia.org/wiki/%E6%9F%AF%E9%87%8C%E5%8C%96)\n> 在计算机科学中，柯里化（英语：Currying），又译为卡瑞化或加里化，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。\n\n概念看上去还是有点抽象，直接看代码\n\n\n**例子**\n注：所有swift代码都可以放到playgroun中运行查看输出\n```\nimport UIKit\n\n// 一个普通求sum函数\nfunc add(a: Int, b: Int, c: Int) -> Int{\n    print(\"\\(a) + \\(b) + \\(c) = \\(a + b + c)\")\n    return a + b + c\n}\n\nadd(1, b: 2,c: 3) // 打印1 + 2 + 3 = 6\n\n// 柯里化版本的求sum函数\nfunc addCur(a: Int)(b: Int)(c: Int) -> Int{\n    print(\"\\(a) + \\(b) + \\(c) = \\(a + b + c)\")\n    return a + b + c\n}\n\naddCur(1)(b: 2)(c: 3) // 打印1 + 2 + 3 = 6\n\n```\n\n你也许觉得Curring只是用一个特殊的写法\n其他与普通函数无异 \n那么换一种curring的调用方式\n\n```\n// curring 另类调用方式\nlet funcWithA = addCur(1)\nprint(\"funcWithA type : \\(funcWithA.dynamicType)\")\nlet funcWithAB = funcWithA(b: 2)\nprint(\"funcWithAB type : \\(funcWithAB.dynamicType)\")\nlet resultCurring = funcWithAB(c: 3)\nprint(\"resultCurring type : \\(resultCurring.dynamicType)\")\n``` \n\n此时你还是会觉得这只是把一个函数拆开来调用了 那么我们打印一下 每个调用步骤中变量的类型\n\n```\nlet funcWithA = addCur(1)\nprint(\"funcWithA type : \\(funcWithA.dynamicType)\") //\nlet funcWithAB = funcWithA(b: 2)\nprint(\"funcWithAB type : \\(funcWithAB.dynamicType)\")\nlet resultCurring = funcWithAB(c: 3)\nprint(\"resultCurring type : \\(resultCurring.dynamicType)\")\n```\n\n打印结果为\n```\n1 + 2 + 3 = 6\nfuncWithA type : Int -> Int -> Int\nfuncWithAB type : Int -> Int\n1 + 2 + 3 = 6\nresultCurring type : Int\n```\n\n可以看到 变量funcWithA 为 Int -> Int -> Int 类型\nfuncWithAB 为Int -> Int\n\n这说明 curring函数在绑定最后一个参数之前 每个步骤返回的值都是一个函数\n\n### Curring实现原理\n\nSwift实现Curring的基础有两个\n- 函数是一级公民\n- 闭包\n\n[啊崢的Swift Curring文章](http://www.jianshu.com/p/6eaacadafa1a)代码例子解释的已经很清楚了\n```\nclass Currying\n{\n    /*** uncurried:普通函数 ***/\n    // 接收多个参数的函数\n    func add(a: Int, b: Int, c: Int) -> Int{\n        println(\"\\(a) + \\(b) + \\(c)\")\n        return a + b + c\n    }\n\n    /*** 手动实现柯里化函数 ***/\n    // 把上面的函数转换为柯里化函数，首先转成接收第一个参数a，并且返回接收余下第一个参数b的新函数（采用闭包）\n    // 为了让大家都能看懂,我帮你们拆解来看下\n    // (a: Int) : 参数\n    // (b:Int) -> (c: Int) -> Int : 函数返回值（一个接收参数b的函数,并且这个函数又返回一个接收参数c,返回值为Int类型的函数)\n\n    // 定义一个接收参数a,并且返回一个接收参数b的函数,并且这个函数又返回一个接收参数c,返回值为Int类型的函数\n    func add(a: Int) -> (b:Int) -> (c: Int) -> Int{\n\n        // 一个接收参数b的函数,并且这个函数又返回一个接收参数c,返回值为Int类型的函数\n        return { (b:Int) -> (c: Int) -> Int in\n\n            // 返回一个接收余下第一个参数c，并且有返回结果为Int类型的函数\n            return { (c: Int) -> Int in\n\n                return a + b + c;\n\n     注解： 这里为什么能使用参数a,b,c?\n           利用闭包的值捕获特性，即使这些值作用域不在了，也可以捕获到他们的值。\n           闭包会自动判断捕获的值是值拷贝还是值引用，如果修改了，就是值引用，否则值拷贝。\n\n           注意只有在闭包中才可以，a,b,c都在闭包中。\n\n            }\n\n        }\n\n    }\n\n\n    /*** curried: 系统自带的柯里化函数 ***/\n    func addCur(a: Int)(b: Int)(c: Int) -> Int{\n        println(\"\\(a) + \\(b) + \\(c)\")\n        return a + b + c\n    }\n\n\n}\n```\n\n### OC版的Curring\n\n大部分的iOS程序员都还是习惯写OC 找了一个[OC版本的Curring](https://gist.github.com/lukhnos/1771842)实现 我们可以理解的更深刻\n\n```\n#include <stdio.h>\nint f(int x, int y)\n{\n    return x + y;\n}\n\nint main()\n{\n\t// 闭包1 绑定第一个参数\n    typedef int (^int_to_int_t)(int);\n    // 闭包2 绑定第二个参数\n    typedef int_to_int_t (^int_to_int_to_int_t)(int);\n\n    int_to_int_to_int_t h = ^(int x) {\n        int_to_int_t g = ^(int y) {\n\t        // 将两个闭包持有的参数做处理 返回结果\n            return f(x, y);  \n        };\n\n        return g;        \n    };\n    \n    // 第一个闭包持有 5\n    int_to_int_t g = h(5);\n    \n    int z;\n    // 第二个闭包持有10 并返回结果\n    z = g(10);\n    printf(\"%d\\n\", z);\n}\n```\n\n### 什么？你觉得然并卵！\n\n你一定觉得这是一个然并卵的东西\n\n好吧 我第一个看到的时候 只是觉得有趣 其实也没有想到较好的应用场景 \n\n[为什么要柯里化](https://gist.github.com/jcouyang/b56a830cd55bd230049f)这篇文章提供的例子给了很多启发\n\n用Swift重新实现了一遍 又加了一点打印 豁然开朗\n\n上代码\n```\n// 拼接字符\nfunc concat(chars: Array<String>) {\n    var resultString = \"\"\n    for char in chars {\n        resultString += char\n    }\n    print(resultString)\n}\n\nconcat([\"1\",\"2\",\"3\"])\nprint(\"**************\")\n\n// 每个字符代表的数字 + 1 后再拼接\nfunc concatAdd(chars: Array<String>, addNum: Int) {\n    var resultString = \"\"\n    for char in chars {\n        var num = Int(char)!\n        num = num + addNum\n        let newChar = String(num)\n        resultString += newChar\n    }\n    print(resultString)\n}\n\nconcatAdd([\"1\",\"2\",\"3\"], addNum: 1)\nconcatAdd([\"1\",\"2\",\"3\"], addNum: 2)\nconcatAdd([\"1\",\"2\",\"3\"], addNum: 3)\n\nprint(\"**************\")\n// 每个字符代表的数字 *10 后再拼接\nfunc concatMultiply(chars: Array<String>, multiplyNum: Int) {\n    var resultString = \"\"\n    for char in chars {\n        var num = Int(char)!\n        num = num * multiplyNum\n        let newChar = String(num)\n        resultString += newChar\n    }\n    print(resultString)\n}\n\nconcatMultiply([\"1\",\"2\",\"3\"], multiplyNum: 1)\nconcatMultiply([\"1\",\"2\",\"3\"], multiplyNum: 2)\nconcatMultiply([\"1\",\"2\",\"3\"], multiplyNum: 3)\n\nprint(\"**************\")\n/****\n让我们使用柯里化吧\n*****/\nfunc add(a: Int)(b: Int) -> Int{\n    return a + b\n}\n\nfunc multiply(a: Int)(b: Int) -> Int{\n    return a * b\n}\n\nfunc concatByCurring(chars: Array<String>)(caculateFunc: (Int)->Int) {\n    var resultString = \"\"\n    for char in chars {\n        var num = Int(char)!\n        var newNum = caculateFunc(num)\n        let newChar = String(newNum)\n        resultString += newChar\n    }\n    print(resultString)\n}\n\nconcatByCurring([\"1\",\"2\",\"3\"])(caculateFunc: add(1))\nconcatByCurring([\"1\",\"2\",\"3\"])(caculateFunc: add(2))\nconcatByCurring([\"1\",\"2\",\"3\"])(caculateFunc: add(3))\n\nprint(\"**************\")\nconcatByCurring([\"1\",\"2\",\"3\"])(caculateFunc: multiply(1))\nconcatByCurring([\"1\",\"2\",\"3\"])(caculateFunc: multiply(2))\nconcatByCurring([\"1\",\"2\",\"3\"])(caculateFunc: multiply(3))\n\n```\n\n以上的代码用普通的函数 和 Curring函数 处理了同一个功能\n\nCurring优势明显\n- 重用了拼接代码\n- 支持更为灵活的算法替换\n- 写功能扩展的人不用怎么关心老代码的实现\n\n###iOS开发中可以应用的场景\n\n**使用Curring处理selector**\n这个例子是我在看[王巍的Swifter](https://selfstore.io/~onevcat)时候看到的一个例子\n\n不废话 直接上代码\n```\n// 打印func类型\nclass People: NSObject {\n    func speak(){\n        print(\"hello\")\n    }\n    \n    func printSpeak() {\n        print(\"People func speak  : \\(People.speak.dynamicType)\")\n    }\n\n}\n\nPeople().printSpeak() \n// 打印结果为 People func speak  : People -> () -> ()\n// 可见实例的方法就是一个Curring结构\n```\n\n 下面是[Instance Methods are Curried Functions in Swift](http://oleb.net/blog/2014/07/swift-instance-methods-curried-functions/?utm_campaign=iOS_Dev_Weekly_Issue_157&utm_medium=email&utm_source=iOS%2BDev%2BWeekly)中的例子 很开脑洞\n \n```\n//Selector demo\nprotocol TargetAction {\n    func performAction()\n}\n\nstruct TargetActionWrapper<T: AnyObject> : TargetAction {\n    weak var target: T?\n    \n    // 此处的action类型是不是和我上面代码中打印的结构一致\n    let action: (T) -> () -> ()\n    \n    func performAction() -> () {\n        if let t = target {\n\t        // Curring调用\n            action(t)()\n        }\n    }\n}\n\nenum ControlEvent {\n    case TouchUpInside\n    case ValueChanged\n}\n\nclass Control {\n    var actions = [ControlEvent: TargetAction]()\n    \n    func setTarget<T: AnyObject>(target: T, action: (T) -> () -> (), controlEvent: ControlEvent) {\n        actions[controlEvent] = TargetActionWrapper(target: target, action: action)\n    }\n    \n    func removeTargetForControlEvent(controlEvent: ControlEvent) {\n        actions[controlEvent] = nil\n    }\n    \n    func performActionForControlEvent(controlEvent: ControlEvent) {\n        actions[controlEvent]?.performAction()\n    }\n}\n\nclass MyViewController {\n    let button = Control()\n    \n    func viewDidLoad() {\n        button.setTarget(self, action: MyViewController.onButtonTap, controlEvent: .TouchUpInside)\n    }\n    \n    func onButtonTap() {\n        print(\"Button was tapped\")\n    }\n}\n\n// 调用\nMyViewController().onButtonTap()\n```\n\n### 小结\n- Curring让计算过程更清晰 函数式编程的有点初见端倪\n- Curring让计算过程更独立 可重用\n- Curring让计算功能扩展更方便\n- Curring让Swift中Selector的重构可以实现\n\n\n\n## Umeng分享遇到的小坑 -- 张超耀\n### 写在前面的话\n- 在iOS9下，系统默认会拦截对http协议接口的访问，因此无法获取http协议接口的数据。对Umeng来说，具体表现可能是，无法授权、分享、获取用户信息等。\n- iOS9新建项目默认需要支持bitcode，而不支持bitcode的SDK会导致无法编译运行。[App Thining](https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/AppDistributionGuide/AppThinning/AppThinning.html#//apple_ref/doc/uid/TP40012582-CH35)）\n\n[Umeng适配iOS9](http://dev.umeng.com/social/ios/ios9)\n\n### 针对iOS9的Https特性，解决方案\n- Plan A: 暂时退回到http协议:\n\n>**1**、在项目的info.plist中添加一个Key：NSAppTransportSecurity，类型为字典类型。\n>**2**、然后给它添加一个Key：NSAllowsArbitraryLoads，类型为Boolean类型，值为YES；\n\n- Plan B：设置域。可以简单理解成，把不支持https协议的接口设置成http的接口\n\n\n>**1**、在项目的info.plist中添加一个Key：NSAppTransportSecurity，类型为字典类型。\n\n>**2**、然后给它添加一个NSExceptionDomains，类型为字典类型；\n\n>**3**、把需要的支持的域添加給NSExceptionDomains。其中域作为Key，类型为字典类型。\n\n>**4**、每个域下面需要设置3个属性：NSIncludesSubdomains、\t\tNSExceptionRequiresForwardSecrecy、\t\tNSExceptionAllowsInsecureHTTPLoads。\n\t均为Boolean类型，值分别为YES、NO、YES。\n\t\n### 针对App Thinning\n\n### 添加Scheme白名单实现应用跳转（SSO等）\n- 问题描述：在iOS 9下涉及到平台客户端跳转，系统会自动到项目info.plist下检测是否设置平台Scheme。对于需要配置的平台，如果没有配置，就无法正常跳转平台客户端。因此要支持客户端的分享和授权等，需要配置Scheme名单。\n- 解决方案：\n\n具体方法：\n>1、在项目的info.plist中添加一LSApplicationQueriesSchemes，类型为Array。\n\n>2、然后给它添加一个需要支持的项目，类型为字符串类型\n\n\n### 注意\n- 由于苹果审核政策需求，需要对未安装客户端平台进行隐藏，在设置QQ、微信AppID之后调用下面的方法，\n\n```\n[UMSocialConfig hiddenNotInstallPlatforms:@[UMShareToQQ, UMShareToQzone, UMShareToWechatSession, UMShareToWechatTimeline]];\n\n```\n - but  这个接口只对默认分享面板平台有隐藏功能，自定义分享面板或登录按钮需要自己处理\n \n- 对于自定义分享面板处理：\n\t- UmengSDK已经嵌入相关API，直接用就好\n\n### 只要按照官方文档来，基本上就能马到成功（）\n\n\n\n## MarkDown 的 CSS 实现配置 - 杨志平\n\n#### 题目灵感来源\n> 起源于我们现有的博客引擎主题交互很不错，但是排版烂的要死 ，我水平有限这里只是浅显介绍实现修改我们的markdown编译器的一些排版样式\n\n#### 研究方向\n> 自定义一个非标准化，有其他多元素的MarkDown解析器 如下几点:\n\n-  可选框\n `- [ ] `\n- 本地图片索引，可控制对齐及大小 \n`![Alt text](http://path/to/img.jpg \"optional title\" 100x200)`\n`![Alt text](./1449756974449.png)`\n- 标签功能\n`@(Share)[css, Markdown]`\n- 代码高亮（不同语言）\n\n`swift`\n\n``` swift\n    private var majorModel = PickMajorModel()\n    private var subjectModel = OFFKeyNameModel()\n    required init?(coder aDecoder: NSCoder) {\n        super.init(coder: aDecoder)\n    }\n```\n\n`objectivec`\n\n``` objectivec\n    UIScrollView *scrollView = [[UIScrollView alloc] initWithFrame:CGRectMake(0, 0, kScreenW, kScreenH)];\n    scrollView.showsVerticalScrollIndicator = NO;\n    [scrollView addSubview:self.downMainView];\n```\n\n\n**有一种惨不忍睹的即视感**\n![Alt text](./1449756974449.png)\n\n### MarkDown来源及实现\n> Markdown is a plain text format for writing structured documents, based on conventions used for indicating formatting in email and usenet posts. It was developed in 2004 by John Gruber, who wrote the first markdown-to-html converter in Perl, and it soon became widely used in websites. By 2014 there were dozens of implementations in many languages.\n\n`见知乎上回答`\n[实现一个markdown解析器需要具备那些知识](http://www.zhihu.com/question/28756456)\n\n### 如何简单的改善文字编排的效果\n##### 更换博客主题（简单粗暴）\n> 我们使用的博客引擎Hexo来举例，列举下面三个主题\n> \n- landscape\n- hexo-theme-vno-master\n- hexo-theme-yilia-master\n\n##### 更换MarkDown编译器的主题\n> 以 ***Mou*** 举例子，它提供了多套markdown语法下的排版样式\n> 手动新创建一个CSS文本布局配置 ***Blog***\n![Alt text](./1449768288128.png)\n\n#### CSS配置文件修改\n详细配置参数如下：\n\n```\nhtml { font-size: 62.5%; }\nhtml, body { height: 100%; }\n\nbody {\n  font-family: Helvetica, Arial, sans-serif;\n  font-size: 150%;\n  line-height: 1.3;\n  color: #f6e6cc;\n  width: 700px;\n  margin: auto;\n  background: #27221a;\n  position: relative;\n  padding: 0 30px;\n}\n```\n\n多级标题配置\n\n```\nh1 {\n  font-size: 28px;\n  color: black; }\n\nh2 {\n  font-size: 24px;\n  border-bottom: 1px solid #cccccc;\n  color: black; }\n\nh3 {\n  font-size: 18px; }\n\nh4 {\n  font-size: 16px; }\n\nh5 {\n  font-size: 14px; }\n\nh6 {\n  color: #777777;\n  font-size: 14px; }\n```\n\n表格\n\n```\ntable {\n  padding: 0;border-collapse: collapse; }\n  table tr {\n    border-top: 1px solid #cccccc;\n    background-color: white;\n    margin: 0;\n    padding: 0; }\n    table tr:nth-child(2n) {\n      background-color: #f8f8f8; }\n    table tr th {\n      font-weight: bold;\n      border: 1px solid #cccccc;\n      margin: 0;\n      padding: 6px 13px; }\n    table tr td {\n      border: 1px solid #cccccc;\n      margin: 0;\n      padding: 6px 13px; }\n    table tr th :first-child, table tr td :first-child {\n      margin-top: 0; }\n    table tr th :last-child, table tr td :last-child {\n      margin-bottom: 0; }\n```\n\n代码高亮\n\n```\ncode, tt {\n  margin: 0 2px;\n  padding: 0 5px;\n  white-space: nowrap;\n  border: 1px solid #eaeaea;\n  background-color: #f8f8f8;\n  border-radius: 3px; }\n\n code {\n  margin: 0;\n  padding: 0;\n\n  border: none;\n  background: transparent; }\n```\n\n","source":"_posts/前端入门（2）.md","raw":"title: 前端入门（2）\ndate: 2015-12-11  10:30:00\ntags:\ncategories: 移动组周分享\n---\n\n\n### [博客地址]()\n\n## Swift柯里化 Curring 学习\n\n### 什么是Curring\n> [维基百科解释](https://zh.wikipedia.org/wiki/%E6%9F%AF%E9%87%8C%E5%8C%96)\n> 在计算机科学中，柯里化（英语：Currying），又译为卡瑞化或加里化，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。\n\n概念看上去还是有点抽象，直接看代码\n\n\n**例子**\n注：所有swift代码都可以放到playgroun中运行查看输出\n```\nimport UIKit\n\n// 一个普通求sum函数\nfunc add(a: Int, b: Int, c: Int) -> Int{\n    print(\"\\(a) + \\(b) + \\(c) = \\(a + b + c)\")\n    return a + b + c\n}\n\nadd(1, b: 2,c: 3) // 打印1 + 2 + 3 = 6\n\n// 柯里化版本的求sum函数\nfunc addCur(a: Int)(b: Int)(c: Int) -> Int{\n    print(\"\\(a) + \\(b) + \\(c) = \\(a + b + c)\")\n    return a + b + c\n}\n\naddCur(1)(b: 2)(c: 3) // 打印1 + 2 + 3 = 6\n\n```\n\n你也许觉得Curring只是用一个特殊的写法\n其他与普通函数无异 \n那么换一种curring的调用方式\n\n```\n// curring 另类调用方式\nlet funcWithA = addCur(1)\nprint(\"funcWithA type : \\(funcWithA.dynamicType)\")\nlet funcWithAB = funcWithA(b: 2)\nprint(\"funcWithAB type : \\(funcWithAB.dynamicType)\")\nlet resultCurring = funcWithAB(c: 3)\nprint(\"resultCurring type : \\(resultCurring.dynamicType)\")\n``` \n\n此时你还是会觉得这只是把一个函数拆开来调用了 那么我们打印一下 每个调用步骤中变量的类型\n\n```\nlet funcWithA = addCur(1)\nprint(\"funcWithA type : \\(funcWithA.dynamicType)\") //\nlet funcWithAB = funcWithA(b: 2)\nprint(\"funcWithAB type : \\(funcWithAB.dynamicType)\")\nlet resultCurring = funcWithAB(c: 3)\nprint(\"resultCurring type : \\(resultCurring.dynamicType)\")\n```\n\n打印结果为\n```\n1 + 2 + 3 = 6\nfuncWithA type : Int -> Int -> Int\nfuncWithAB type : Int -> Int\n1 + 2 + 3 = 6\nresultCurring type : Int\n```\n\n可以看到 变量funcWithA 为 Int -> Int -> Int 类型\nfuncWithAB 为Int -> Int\n\n这说明 curring函数在绑定最后一个参数之前 每个步骤返回的值都是一个函数\n\n### Curring实现原理\n\nSwift实现Curring的基础有两个\n- 函数是一级公民\n- 闭包\n\n[啊崢的Swift Curring文章](http://www.jianshu.com/p/6eaacadafa1a)代码例子解释的已经很清楚了\n```\nclass Currying\n{\n    /*** uncurried:普通函数 ***/\n    // 接收多个参数的函数\n    func add(a: Int, b: Int, c: Int) -> Int{\n        println(\"\\(a) + \\(b) + \\(c)\")\n        return a + b + c\n    }\n\n    /*** 手动实现柯里化函数 ***/\n    // 把上面的函数转换为柯里化函数，首先转成接收第一个参数a，并且返回接收余下第一个参数b的新函数（采用闭包）\n    // 为了让大家都能看懂,我帮你们拆解来看下\n    // (a: Int) : 参数\n    // (b:Int) -> (c: Int) -> Int : 函数返回值（一个接收参数b的函数,并且这个函数又返回一个接收参数c,返回值为Int类型的函数)\n\n    // 定义一个接收参数a,并且返回一个接收参数b的函数,并且这个函数又返回一个接收参数c,返回值为Int类型的函数\n    func add(a: Int) -> (b:Int) -> (c: Int) -> Int{\n\n        // 一个接收参数b的函数,并且这个函数又返回一个接收参数c,返回值为Int类型的函数\n        return { (b:Int) -> (c: Int) -> Int in\n\n            // 返回一个接收余下第一个参数c，并且有返回结果为Int类型的函数\n            return { (c: Int) -> Int in\n\n                return a + b + c;\n\n     注解： 这里为什么能使用参数a,b,c?\n           利用闭包的值捕获特性，即使这些值作用域不在了，也可以捕获到他们的值。\n           闭包会自动判断捕获的值是值拷贝还是值引用，如果修改了，就是值引用，否则值拷贝。\n\n           注意只有在闭包中才可以，a,b,c都在闭包中。\n\n            }\n\n        }\n\n    }\n\n\n    /*** curried: 系统自带的柯里化函数 ***/\n    func addCur(a: Int)(b: Int)(c: Int) -> Int{\n        println(\"\\(a) + \\(b) + \\(c)\")\n        return a + b + c\n    }\n\n\n}\n```\n\n### OC版的Curring\n\n大部分的iOS程序员都还是习惯写OC 找了一个[OC版本的Curring](https://gist.github.com/lukhnos/1771842)实现 我们可以理解的更深刻\n\n```\n#include <stdio.h>\nint f(int x, int y)\n{\n    return x + y;\n}\n\nint main()\n{\n\t// 闭包1 绑定第一个参数\n    typedef int (^int_to_int_t)(int);\n    // 闭包2 绑定第二个参数\n    typedef int_to_int_t (^int_to_int_to_int_t)(int);\n\n    int_to_int_to_int_t h = ^(int x) {\n        int_to_int_t g = ^(int y) {\n\t        // 将两个闭包持有的参数做处理 返回结果\n            return f(x, y);  \n        };\n\n        return g;        \n    };\n    \n    // 第一个闭包持有 5\n    int_to_int_t g = h(5);\n    \n    int z;\n    // 第二个闭包持有10 并返回结果\n    z = g(10);\n    printf(\"%d\\n\", z);\n}\n```\n\n### 什么？你觉得然并卵！\n\n你一定觉得这是一个然并卵的东西\n\n好吧 我第一个看到的时候 只是觉得有趣 其实也没有想到较好的应用场景 \n\n[为什么要柯里化](https://gist.github.com/jcouyang/b56a830cd55bd230049f)这篇文章提供的例子给了很多启发\n\n用Swift重新实现了一遍 又加了一点打印 豁然开朗\n\n上代码\n```\n// 拼接字符\nfunc concat(chars: Array<String>) {\n    var resultString = \"\"\n    for char in chars {\n        resultString += char\n    }\n    print(resultString)\n}\n\nconcat([\"1\",\"2\",\"3\"])\nprint(\"**************\")\n\n// 每个字符代表的数字 + 1 后再拼接\nfunc concatAdd(chars: Array<String>, addNum: Int) {\n    var resultString = \"\"\n    for char in chars {\n        var num = Int(char)!\n        num = num + addNum\n        let newChar = String(num)\n        resultString += newChar\n    }\n    print(resultString)\n}\n\nconcatAdd([\"1\",\"2\",\"3\"], addNum: 1)\nconcatAdd([\"1\",\"2\",\"3\"], addNum: 2)\nconcatAdd([\"1\",\"2\",\"3\"], addNum: 3)\n\nprint(\"**************\")\n// 每个字符代表的数字 *10 后再拼接\nfunc concatMultiply(chars: Array<String>, multiplyNum: Int) {\n    var resultString = \"\"\n    for char in chars {\n        var num = Int(char)!\n        num = num * multiplyNum\n        let newChar = String(num)\n        resultString += newChar\n    }\n    print(resultString)\n}\n\nconcatMultiply([\"1\",\"2\",\"3\"], multiplyNum: 1)\nconcatMultiply([\"1\",\"2\",\"3\"], multiplyNum: 2)\nconcatMultiply([\"1\",\"2\",\"3\"], multiplyNum: 3)\n\nprint(\"**************\")\n/****\n让我们使用柯里化吧\n*****/\nfunc add(a: Int)(b: Int) -> Int{\n    return a + b\n}\n\nfunc multiply(a: Int)(b: Int) -> Int{\n    return a * b\n}\n\nfunc concatByCurring(chars: Array<String>)(caculateFunc: (Int)->Int) {\n    var resultString = \"\"\n    for char in chars {\n        var num = Int(char)!\n        var newNum = caculateFunc(num)\n        let newChar = String(newNum)\n        resultString += newChar\n    }\n    print(resultString)\n}\n\nconcatByCurring([\"1\",\"2\",\"3\"])(caculateFunc: add(1))\nconcatByCurring([\"1\",\"2\",\"3\"])(caculateFunc: add(2))\nconcatByCurring([\"1\",\"2\",\"3\"])(caculateFunc: add(3))\n\nprint(\"**************\")\nconcatByCurring([\"1\",\"2\",\"3\"])(caculateFunc: multiply(1))\nconcatByCurring([\"1\",\"2\",\"3\"])(caculateFunc: multiply(2))\nconcatByCurring([\"1\",\"2\",\"3\"])(caculateFunc: multiply(3))\n\n```\n\n以上的代码用普通的函数 和 Curring函数 处理了同一个功能\n\nCurring优势明显\n- 重用了拼接代码\n- 支持更为灵活的算法替换\n- 写功能扩展的人不用怎么关心老代码的实现\n\n###iOS开发中可以应用的场景\n\n**使用Curring处理selector**\n这个例子是我在看[王巍的Swifter](https://selfstore.io/~onevcat)时候看到的一个例子\n\n不废话 直接上代码\n```\n// 打印func类型\nclass People: NSObject {\n    func speak(){\n        print(\"hello\")\n    }\n    \n    func printSpeak() {\n        print(\"People func speak  : \\(People.speak.dynamicType)\")\n    }\n\n}\n\nPeople().printSpeak() \n// 打印结果为 People func speak  : People -> () -> ()\n// 可见实例的方法就是一个Curring结构\n```\n\n 下面是[Instance Methods are Curried Functions in Swift](http://oleb.net/blog/2014/07/swift-instance-methods-curried-functions/?utm_campaign=iOS_Dev_Weekly_Issue_157&utm_medium=email&utm_source=iOS%2BDev%2BWeekly)中的例子 很开脑洞\n \n```\n//Selector demo\nprotocol TargetAction {\n    func performAction()\n}\n\nstruct TargetActionWrapper<T: AnyObject> : TargetAction {\n    weak var target: T?\n    \n    // 此处的action类型是不是和我上面代码中打印的结构一致\n    let action: (T) -> () -> ()\n    \n    func performAction() -> () {\n        if let t = target {\n\t        // Curring调用\n            action(t)()\n        }\n    }\n}\n\nenum ControlEvent {\n    case TouchUpInside\n    case ValueChanged\n}\n\nclass Control {\n    var actions = [ControlEvent: TargetAction]()\n    \n    func setTarget<T: AnyObject>(target: T, action: (T) -> () -> (), controlEvent: ControlEvent) {\n        actions[controlEvent] = TargetActionWrapper(target: target, action: action)\n    }\n    \n    func removeTargetForControlEvent(controlEvent: ControlEvent) {\n        actions[controlEvent] = nil\n    }\n    \n    func performActionForControlEvent(controlEvent: ControlEvent) {\n        actions[controlEvent]?.performAction()\n    }\n}\n\nclass MyViewController {\n    let button = Control()\n    \n    func viewDidLoad() {\n        button.setTarget(self, action: MyViewController.onButtonTap, controlEvent: .TouchUpInside)\n    }\n    \n    func onButtonTap() {\n        print(\"Button was tapped\")\n    }\n}\n\n// 调用\nMyViewController().onButtonTap()\n```\n\n### 小结\n- Curring让计算过程更清晰 函数式编程的有点初见端倪\n- Curring让计算过程更独立 可重用\n- Curring让计算功能扩展更方便\n- Curring让Swift中Selector的重构可以实现\n\n\n\n## Umeng分享遇到的小坑 -- 张超耀\n### 写在前面的话\n- 在iOS9下，系统默认会拦截对http协议接口的访问，因此无法获取http协议接口的数据。对Umeng来说，具体表现可能是，无法授权、分享、获取用户信息等。\n- iOS9新建项目默认需要支持bitcode，而不支持bitcode的SDK会导致无法编译运行。[App Thining](https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/AppDistributionGuide/AppThinning/AppThinning.html#//apple_ref/doc/uid/TP40012582-CH35)）\n\n[Umeng适配iOS9](http://dev.umeng.com/social/ios/ios9)\n\n### 针对iOS9的Https特性，解决方案\n- Plan A: 暂时退回到http协议:\n\n>**1**、在项目的info.plist中添加一个Key：NSAppTransportSecurity，类型为字典类型。\n>**2**、然后给它添加一个Key：NSAllowsArbitraryLoads，类型为Boolean类型，值为YES；\n\n- Plan B：设置域。可以简单理解成，把不支持https协议的接口设置成http的接口\n\n\n>**1**、在项目的info.plist中添加一个Key：NSAppTransportSecurity，类型为字典类型。\n\n>**2**、然后给它添加一个NSExceptionDomains，类型为字典类型；\n\n>**3**、把需要的支持的域添加給NSExceptionDomains。其中域作为Key，类型为字典类型。\n\n>**4**、每个域下面需要设置3个属性：NSIncludesSubdomains、\t\tNSExceptionRequiresForwardSecrecy、\t\tNSExceptionAllowsInsecureHTTPLoads。\n\t均为Boolean类型，值分别为YES、NO、YES。\n\t\n### 针对App Thinning\n\n### 添加Scheme白名单实现应用跳转（SSO等）\n- 问题描述：在iOS 9下涉及到平台客户端跳转，系统会自动到项目info.plist下检测是否设置平台Scheme。对于需要配置的平台，如果没有配置，就无法正常跳转平台客户端。因此要支持客户端的分享和授权等，需要配置Scheme名单。\n- 解决方案：\n\n具体方法：\n>1、在项目的info.plist中添加一LSApplicationQueriesSchemes，类型为Array。\n\n>2、然后给它添加一个需要支持的项目，类型为字符串类型\n\n\n### 注意\n- 由于苹果审核政策需求，需要对未安装客户端平台进行隐藏，在设置QQ、微信AppID之后调用下面的方法，\n\n```\n[UMSocialConfig hiddenNotInstallPlatforms:@[UMShareToQQ, UMShareToQzone, UMShareToWechatSession, UMShareToWechatTimeline]];\n\n```\n - but  这个接口只对默认分享面板平台有隐藏功能，自定义分享面板或登录按钮需要自己处理\n \n- 对于自定义分享面板处理：\n\t- UmengSDK已经嵌入相关API，直接用就好\n\n### 只要按照官方文档来，基本上就能马到成功（）\n\n\n\n## MarkDown 的 CSS 实现配置 - 杨志平\n\n#### 题目灵感来源\n> 起源于我们现有的博客引擎主题交互很不错，但是排版烂的要死 ，我水平有限这里只是浅显介绍实现修改我们的markdown编译器的一些排版样式\n\n#### 研究方向\n> 自定义一个非标准化，有其他多元素的MarkDown解析器 如下几点:\n\n-  可选框\n `- [ ] `\n- 本地图片索引，可控制对齐及大小 \n`![Alt text](http://path/to/img.jpg \"optional title\" 100x200)`\n`![Alt text](./1449756974449.png)`\n- 标签功能\n`@(Share)[css, Markdown]`\n- 代码高亮（不同语言）\n\n`swift`\n\n``` swift\n    private var majorModel = PickMajorModel()\n    private var subjectModel = OFFKeyNameModel()\n    required init?(coder aDecoder: NSCoder) {\n        super.init(coder: aDecoder)\n    }\n```\n\n`objectivec`\n\n``` objectivec\n    UIScrollView *scrollView = [[UIScrollView alloc] initWithFrame:CGRectMake(0, 0, kScreenW, kScreenH)];\n    scrollView.showsVerticalScrollIndicator = NO;\n    [scrollView addSubview:self.downMainView];\n```\n\n\n**有一种惨不忍睹的即视感**\n![Alt text](./1449756974449.png)\n\n### MarkDown来源及实现\n> Markdown is a plain text format for writing structured documents, based on conventions used for indicating formatting in email and usenet posts. It was developed in 2004 by John Gruber, who wrote the first markdown-to-html converter in Perl, and it soon became widely used in websites. By 2014 there were dozens of implementations in many languages.\n\n`见知乎上回答`\n[实现一个markdown解析器需要具备那些知识](http://www.zhihu.com/question/28756456)\n\n### 如何简单的改善文字编排的效果\n##### 更换博客主题（简单粗暴）\n> 我们使用的博客引擎Hexo来举例，列举下面三个主题\n> \n- landscape\n- hexo-theme-vno-master\n- hexo-theme-yilia-master\n\n##### 更换MarkDown编译器的主题\n> 以 ***Mou*** 举例子，它提供了多套markdown语法下的排版样式\n> 手动新创建一个CSS文本布局配置 ***Blog***\n![Alt text](./1449768288128.png)\n\n#### CSS配置文件修改\n详细配置参数如下：\n\n```\nhtml { font-size: 62.5%; }\nhtml, body { height: 100%; }\n\nbody {\n  font-family: Helvetica, Arial, sans-serif;\n  font-size: 150%;\n  line-height: 1.3;\n  color: #f6e6cc;\n  width: 700px;\n  margin: auto;\n  background: #27221a;\n  position: relative;\n  padding: 0 30px;\n}\n```\n\n多级标题配置\n\n```\nh1 {\n  font-size: 28px;\n  color: black; }\n\nh2 {\n  font-size: 24px;\n  border-bottom: 1px solid #cccccc;\n  color: black; }\n\nh3 {\n  font-size: 18px; }\n\nh4 {\n  font-size: 16px; }\n\nh5 {\n  font-size: 14px; }\n\nh6 {\n  color: #777777;\n  font-size: 14px; }\n```\n\n表格\n\n```\ntable {\n  padding: 0;border-collapse: collapse; }\n  table tr {\n    border-top: 1px solid #cccccc;\n    background-color: white;\n    margin: 0;\n    padding: 0; }\n    table tr:nth-child(2n) {\n      background-color: #f8f8f8; }\n    table tr th {\n      font-weight: bold;\n      border: 1px solid #cccccc;\n      margin: 0;\n      padding: 6px 13px; }\n    table tr td {\n      border: 1px solid #cccccc;\n      margin: 0;\n      padding: 6px 13px; }\n    table tr th :first-child, table tr td :first-child {\n      margin-top: 0; }\n    table tr th :last-child, table tr td :last-child {\n      margin-bottom: 0; }\n```\n\n代码高亮\n\n```\ncode, tt {\n  margin: 0 2px;\n  padding: 0 5px;\n  white-space: nowrap;\n  border: 1px solid #eaeaea;\n  background-color: #f8f8f8;\n  border-radius: 3px; }\n\n code {\n  margin: 0;\n  padding: 0;\n\n  border: none;\n  background: transparent; }\n```\n\n","slug":"前端入门（2）","published":1,"updated":"2021-09-10T07:04:21.946Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cktfeap45001uc2xxy9j6w16m","content":"<h3 id=\"博客地址\"><a href=\"#博客地址\" class=\"headerlink\" title=\"博客地址\"></a><a href>博客地址</a></h3><h2 id=\"Swift柯里化-Curring-学习\"><a href=\"#Swift柯里化-Curring-学习\" class=\"headerlink\" title=\"Swift柯里化 Curring 学习\"></a>Swift柯里化 Curring 学习</h2><h3 id=\"什么是Curring\"><a href=\"#什么是Curring\" class=\"headerlink\" title=\"什么是Curring\"></a>什么是Curring</h3><blockquote>\n<p><a href=\"https://zh.wikipedia.org/wiki/%E6%9F%AF%E9%87%8C%E5%8C%96\" target=\"_blank\" rel=\"noopener\">维基百科解释</a><br>在计算机科学中，柯里化（英语：Currying），又译为卡瑞化或加里化，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。</p>\n</blockquote>\n<p>概念看上去还是有点抽象，直接看代码</p>\n<p><strong>例子</strong><br>注：所有swift代码都可以放到playgroun中运行查看输出</p>\n<pre><code>import UIKit\n\n// 一个普通求sum函数\nfunc add(a: Int, b: Int, c: Int) -&gt; Int{\n    print(&quot;\\(a) + \\(b) + \\(c) = \\(a + b + c)&quot;)\n    return a + b + c\n}\n\nadd(1, b: 2,c: 3) // 打印1 + 2 + 3 = 6\n\n// 柯里化版本的求sum函数\nfunc addCur(a: Int)(b: Int)(c: Int) -&gt; Int{\n    print(&quot;\\(a) + \\(b) + \\(c) = \\(a + b + c)&quot;)\n    return a + b + c\n}\n\naddCur(1)(b: 2)(c: 3) // 打印1 + 2 + 3 = 6\n</code></pre><p>你也许觉得Curring只是用一个特殊的写法<br>其他与普通函数无异<br>那么换一种curring的调用方式</p>\n<pre><code>// curring 另类调用方式\nlet funcWithA = addCur(1)\nprint(&quot;funcWithA type : \\(funcWithA.dynamicType)&quot;)\nlet funcWithAB = funcWithA(b: 2)\nprint(&quot;funcWithAB type : \\(funcWithAB.dynamicType)&quot;)\nlet resultCurring = funcWithAB(c: 3)\nprint(&quot;resultCurring type : \\(resultCurring.dynamicType)&quot;)\n</code></pre><p>此时你还是会觉得这只是把一个函数拆开来调用了 那么我们打印一下 每个调用步骤中变量的类型</p>\n<pre><code>let funcWithA = addCur(1)\nprint(&quot;funcWithA type : \\(funcWithA.dynamicType)&quot;) //\nlet funcWithAB = funcWithA(b: 2)\nprint(&quot;funcWithAB type : \\(funcWithAB.dynamicType)&quot;)\nlet resultCurring = funcWithAB(c: 3)\nprint(&quot;resultCurring type : \\(resultCurring.dynamicType)&quot;)\n</code></pre><p>打印结果为</p>\n<pre><code>1 + 2 + 3 = 6\nfuncWithA type : Int -&gt; Int -&gt; Int\nfuncWithAB type : Int -&gt; Int\n1 + 2 + 3 = 6\nresultCurring type : Int\n</code></pre><p>可以看到 变量funcWithA 为 Int -&gt; Int -&gt; Int 类型<br>funcWithAB 为Int -&gt; Int</p>\n<p>这说明 curring函数在绑定最后一个参数之前 每个步骤返回的值都是一个函数</p>\n<h3 id=\"Curring实现原理\"><a href=\"#Curring实现原理\" class=\"headerlink\" title=\"Curring实现原理\"></a>Curring实现原理</h3><p>Swift实现Curring的基础有两个</p>\n<ul>\n<li>函数是一级公民</li>\n<li>闭包</li>\n</ul>\n<p><a href=\"http://www.jianshu.com/p/6eaacadafa1a\" target=\"_blank\" rel=\"noopener\">啊崢的Swift Curring文章</a>代码例子解释的已经很清楚了</p>\n<pre><code>class Currying\n{\n    /*** uncurried:普通函数 ***/\n    // 接收多个参数的函数\n    func add(a: Int, b: Int, c: Int) -&gt; Int{\n        println(&quot;\\(a) + \\(b) + \\(c)&quot;)\n        return a + b + c\n    }\n\n    /*** 手动实现柯里化函数 ***/\n    // 把上面的函数转换为柯里化函数，首先转成接收第一个参数a，并且返回接收余下第一个参数b的新函数（采用闭包）\n    // 为了让大家都能看懂,我帮你们拆解来看下\n    // (a: Int) : 参数\n    // (b:Int) -&gt; (c: Int) -&gt; Int : 函数返回值（一个接收参数b的函数,并且这个函数又返回一个接收参数c,返回值为Int类型的函数)\n\n    // 定义一个接收参数a,并且返回一个接收参数b的函数,并且这个函数又返回一个接收参数c,返回值为Int类型的函数\n    func add(a: Int) -&gt; (b:Int) -&gt; (c: Int) -&gt; Int{\n\n        // 一个接收参数b的函数,并且这个函数又返回一个接收参数c,返回值为Int类型的函数\n        return { (b:Int) -&gt; (c: Int) -&gt; Int in\n\n            // 返回一个接收余下第一个参数c，并且有返回结果为Int类型的函数\n            return { (c: Int) -&gt; Int in\n\n                return a + b + c;\n\n     注解： 这里为什么能使用参数a,b,c?\n           利用闭包的值捕获特性，即使这些值作用域不在了，也可以捕获到他们的值。\n           闭包会自动判断捕获的值是值拷贝还是值引用，如果修改了，就是值引用，否则值拷贝。\n\n           注意只有在闭包中才可以，a,b,c都在闭包中。\n\n            }\n\n        }\n\n    }\n\n\n    /*** curried: 系统自带的柯里化函数 ***/\n    func addCur(a: Int)(b: Int)(c: Int) -&gt; Int{\n        println(&quot;\\(a) + \\(b) + \\(c)&quot;)\n        return a + b + c\n    }\n\n\n}\n</code></pre><h3 id=\"OC版的Curring\"><a href=\"#OC版的Curring\" class=\"headerlink\" title=\"OC版的Curring\"></a>OC版的Curring</h3><p>大部分的iOS程序员都还是习惯写OC 找了一个<a href=\"https://gist.github.com/lukhnos/1771842\" target=\"_blank\" rel=\"noopener\">OC版本的Curring</a>实现 我们可以理解的更深刻</p>\n<pre><code>#include &lt;stdio.h&gt;\nint f(int x, int y)\n{\n    return x + y;\n}\n\nint main()\n{\n    // 闭包1 绑定第一个参数\n    typedef int (^int_to_int_t)(int);\n    // 闭包2 绑定第二个参数\n    typedef int_to_int_t (^int_to_int_to_int_t)(int);\n\n    int_to_int_to_int_t h = ^(int x) {\n        int_to_int_t g = ^(int y) {\n            // 将两个闭包持有的参数做处理 返回结果\n            return f(x, y);  \n        };\n\n        return g;        \n    };\n\n    // 第一个闭包持有 5\n    int_to_int_t g = h(5);\n\n    int z;\n    // 第二个闭包持有10 并返回结果\n    z = g(10);\n    printf(&quot;%d\\n&quot;, z);\n}\n</code></pre><h3 id=\"什么？你觉得然并卵！\"><a href=\"#什么？你觉得然并卵！\" class=\"headerlink\" title=\"什么？你觉得然并卵！\"></a>什么？你觉得然并卵！</h3><p>你一定觉得这是一个然并卵的东西</p>\n<p>好吧 我第一个看到的时候 只是觉得有趣 其实也没有想到较好的应用场景 </p>\n<p><a href=\"https://gist.github.com/jcouyang/b56a830cd55bd230049f\" target=\"_blank\" rel=\"noopener\">为什么要柯里化</a>这篇文章提供的例子给了很多启发</p>\n<p>用Swift重新实现了一遍 又加了一点打印 豁然开朗</p>\n<p>上代码</p>\n<pre><code>// 拼接字符\nfunc concat(chars: Array&lt;String&gt;) {\n    var resultString = &quot;&quot;\n    for char in chars {\n        resultString += char\n    }\n    print(resultString)\n}\n\nconcat([&quot;1&quot;,&quot;2&quot;,&quot;3&quot;])\nprint(&quot;**************&quot;)\n\n// 每个字符代表的数字 + 1 后再拼接\nfunc concatAdd(chars: Array&lt;String&gt;, addNum: Int) {\n    var resultString = &quot;&quot;\n    for char in chars {\n        var num = Int(char)!\n        num = num + addNum\n        let newChar = String(num)\n        resultString += newChar\n    }\n    print(resultString)\n}\n\nconcatAdd([&quot;1&quot;,&quot;2&quot;,&quot;3&quot;], addNum: 1)\nconcatAdd([&quot;1&quot;,&quot;2&quot;,&quot;3&quot;], addNum: 2)\nconcatAdd([&quot;1&quot;,&quot;2&quot;,&quot;3&quot;], addNum: 3)\n\nprint(&quot;**************&quot;)\n// 每个字符代表的数字 *10 后再拼接\nfunc concatMultiply(chars: Array&lt;String&gt;, multiplyNum: Int) {\n    var resultString = &quot;&quot;\n    for char in chars {\n        var num = Int(char)!\n        num = num * multiplyNum\n        let newChar = String(num)\n        resultString += newChar\n    }\n    print(resultString)\n}\n\nconcatMultiply([&quot;1&quot;,&quot;2&quot;,&quot;3&quot;], multiplyNum: 1)\nconcatMultiply([&quot;1&quot;,&quot;2&quot;,&quot;3&quot;], multiplyNum: 2)\nconcatMultiply([&quot;1&quot;,&quot;2&quot;,&quot;3&quot;], multiplyNum: 3)\n\nprint(&quot;**************&quot;)\n/****\n让我们使用柯里化吧\n*****/\nfunc add(a: Int)(b: Int) -&gt; Int{\n    return a + b\n}\n\nfunc multiply(a: Int)(b: Int) -&gt; Int{\n    return a * b\n}\n\nfunc concatByCurring(chars: Array&lt;String&gt;)(caculateFunc: (Int)-&gt;Int) {\n    var resultString = &quot;&quot;\n    for char in chars {\n        var num = Int(char)!\n        var newNum = caculateFunc(num)\n        let newChar = String(newNum)\n        resultString += newChar\n    }\n    print(resultString)\n}\n\nconcatByCurring([&quot;1&quot;,&quot;2&quot;,&quot;3&quot;])(caculateFunc: add(1))\nconcatByCurring([&quot;1&quot;,&quot;2&quot;,&quot;3&quot;])(caculateFunc: add(2))\nconcatByCurring([&quot;1&quot;,&quot;2&quot;,&quot;3&quot;])(caculateFunc: add(3))\n\nprint(&quot;**************&quot;)\nconcatByCurring([&quot;1&quot;,&quot;2&quot;,&quot;3&quot;])(caculateFunc: multiply(1))\nconcatByCurring([&quot;1&quot;,&quot;2&quot;,&quot;3&quot;])(caculateFunc: multiply(2))\nconcatByCurring([&quot;1&quot;,&quot;2&quot;,&quot;3&quot;])(caculateFunc: multiply(3))\n</code></pre><p>以上的代码用普通的函数 和 Curring函数 处理了同一个功能</p>\n<p>Curring优势明显</p>\n<ul>\n<li>重用了拼接代码</li>\n<li>支持更为灵活的算法替换</li>\n<li>写功能扩展的人不用怎么关心老代码的实现</li>\n</ul>\n<p>###iOS开发中可以应用的场景</p>\n<p><strong>使用Curring处理selector</strong><br>这个例子是我在看<a href=\"https://selfstore.io/~onevcat\" target=\"_blank\" rel=\"noopener\">王巍的Swifter</a>时候看到的一个例子</p>\n<p>不废话 直接上代码</p>\n<pre><code>// 打印func类型\nclass People: NSObject {\n    func speak(){\n        print(&quot;hello&quot;)\n    }\n\n    func printSpeak() {\n        print(&quot;People func speak  : \\(People.speak.dynamicType)&quot;)\n    }\n\n}\n\nPeople().printSpeak() \n// 打印结果为 People func speak  : People -&gt; () -&gt; ()\n// 可见实例的方法就是一个Curring结构\n</code></pre><p> 下面是<a href=\"http://oleb.net/blog/2014/07/swift-instance-methods-curried-functions/?utm_campaign=iOS_Dev_Weekly_Issue_157&amp;utm_medium=email&amp;utm_source=iOS%2BDev%2BWeekly\" target=\"_blank\" rel=\"noopener\">Instance Methods are Curried Functions in Swift</a>中的例子 很开脑洞</p>\n<pre><code>//Selector demo\nprotocol TargetAction {\n    func performAction()\n}\n\nstruct TargetActionWrapper&lt;T: AnyObject&gt; : TargetAction {\n    weak var target: T?\n\n    // 此处的action类型是不是和我上面代码中打印的结构一致\n    let action: (T) -&gt; () -&gt; ()\n\n    func performAction() -&gt; () {\n        if let t = target {\n            // Curring调用\n            action(t)()\n        }\n    }\n}\n\nenum ControlEvent {\n    case TouchUpInside\n    case ValueChanged\n}\n\nclass Control {\n    var actions = [ControlEvent: TargetAction]()\n\n    func setTarget&lt;T: AnyObject&gt;(target: T, action: (T) -&gt; () -&gt; (), controlEvent: ControlEvent) {\n        actions[controlEvent] = TargetActionWrapper(target: target, action: action)\n    }\n\n    func removeTargetForControlEvent(controlEvent: ControlEvent) {\n        actions[controlEvent] = nil\n    }\n\n    func performActionForControlEvent(controlEvent: ControlEvent) {\n        actions[controlEvent]?.performAction()\n    }\n}\n\nclass MyViewController {\n    let button = Control()\n\n    func viewDidLoad() {\n        button.setTarget(self, action: MyViewController.onButtonTap, controlEvent: .TouchUpInside)\n    }\n\n    func onButtonTap() {\n        print(&quot;Button was tapped&quot;)\n    }\n}\n\n// 调用\nMyViewController().onButtonTap()\n</code></pre><h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><ul>\n<li>Curring让计算过程更清晰 函数式编程的有点初见端倪</li>\n<li>Curring让计算过程更独立 可重用</li>\n<li>Curring让计算功能扩展更方便</li>\n<li>Curring让Swift中Selector的重构可以实现</li>\n</ul>\n<h2 id=\"Umeng分享遇到的小坑-–-张超耀\"><a href=\"#Umeng分享遇到的小坑-–-张超耀\" class=\"headerlink\" title=\"Umeng分享遇到的小坑 – 张超耀\"></a>Umeng分享遇到的小坑 – 张超耀</h2><h3 id=\"写在前面的话\"><a href=\"#写在前面的话\" class=\"headerlink\" title=\"写在前面的话\"></a>写在前面的话</h3><ul>\n<li>在iOS9下，系统默认会拦截对http协议接口的访问，因此无法获取http协议接口的数据。对Umeng来说，具体表现可能是，无法授权、分享、获取用户信息等。</li>\n<li>iOS9新建项目默认需要支持bitcode，而不支持bitcode的SDK会导致无法编译运行。<a href=\"https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/AppDistributionGuide/AppThinning/AppThinning.html#//apple_ref/doc/uid/TP40012582-CH35\" target=\"_blank\" rel=\"noopener\">App Thining</a>）</li>\n</ul>\n<p><a href=\"http://dev.umeng.com/social/ios/ios9\" target=\"_blank\" rel=\"noopener\">Umeng适配iOS9</a></p>\n<h3 id=\"针对iOS9的Https特性，解决方案\"><a href=\"#针对iOS9的Https特性，解决方案\" class=\"headerlink\" title=\"针对iOS9的Https特性，解决方案\"></a>针对iOS9的Https特性，解决方案</h3><ul>\n<li>Plan A: 暂时退回到http协议:</li>\n</ul>\n<blockquote>\n<p><strong>1</strong>、在项目的info.plist中添加一个Key：NSAppTransportSecurity，类型为字典类型。<br><strong>2</strong>、然后给它添加一个Key：NSAllowsArbitraryLoads，类型为Boolean类型，值为YES；</p>\n</blockquote>\n<ul>\n<li>Plan B：设置域。可以简单理解成，把不支持https协议的接口设置成http的接口</li>\n</ul>\n<blockquote>\n<p><strong>1</strong>、在项目的info.plist中添加一个Key：NSAppTransportSecurity，类型为字典类型。</p>\n<p><strong>2</strong>、然后给它添加一个NSExceptionDomains，类型为字典类型；</p>\n<p><strong>3</strong>、把需要的支持的域添加給NSExceptionDomains。其中域作为Key，类型为字典类型。</p>\n<p><strong>4</strong>、每个域下面需要设置3个属性：NSIncludesSubdomains、        NSExceptionRequiresForwardSecrecy、        NSExceptionAllowsInsecureHTTPLoads。<br>    均为Boolean类型，值分别为YES、NO、YES。</p>\n</blockquote>\n<h3 id=\"针对App-Thinning\"><a href=\"#针对App-Thinning\" class=\"headerlink\" title=\"针对App Thinning\"></a>针对App Thinning</h3><h3 id=\"添加Scheme白名单实现应用跳转（SSO等）\"><a href=\"#添加Scheme白名单实现应用跳转（SSO等）\" class=\"headerlink\" title=\"添加Scheme白名单实现应用跳转（SSO等）\"></a>添加Scheme白名单实现应用跳转（SSO等）</h3><ul>\n<li>问题描述：在iOS 9下涉及到平台客户端跳转，系统会自动到项目info.plist下检测是否设置平台Scheme。对于需要配置的平台，如果没有配置，就无法正常跳转平台客户端。因此要支持客户端的分享和授权等，需要配置Scheme名单。</li>\n<li>解决方案：</li>\n</ul>\n<p>具体方法：</p>\n<blockquote>\n<p>1、在项目的info.plist中添加一LSApplicationQueriesSchemes，类型为Array。</p>\n<p>2、然后给它添加一个需要支持的项目，类型为字符串类型</p>\n</blockquote>\n<h3 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h3><ul>\n<li>由于苹果审核政策需求，需要对未安装客户端平台进行隐藏，在设置QQ、微信AppID之后调用下面的方法，</li>\n</ul>\n<pre><code>[UMSocialConfig hiddenNotInstallPlatforms:@[UMShareToQQ, UMShareToQzone, UMShareToWechatSession, UMShareToWechatTimeline]];\n</code></pre><ul>\n<li>but  这个接口只对默认分享面板平台有隐藏功能，自定义分享面板或登录按钮需要自己处理</li>\n</ul>\n<ul>\n<li>对于自定义分享面板处理：<ul>\n<li>UmengSDK已经嵌入相关API，直接用就好</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"只要按照官方文档来，基本上就能马到成功（）\"><a href=\"#只要按照官方文档来，基本上就能马到成功（）\" class=\"headerlink\" title=\"只要按照官方文档来，基本上就能马到成功（）\"></a>只要按照官方文档来，基本上就能马到成功（）</h3><h2 id=\"MarkDown-的-CSS-实现配置-杨志平\"><a href=\"#MarkDown-的-CSS-实现配置-杨志平\" class=\"headerlink\" title=\"MarkDown 的 CSS 实现配置 - 杨志平\"></a>MarkDown 的 CSS 实现配置 - 杨志平</h2><h4 id=\"题目灵感来源\"><a href=\"#题目灵感来源\" class=\"headerlink\" title=\"题目灵感来源\"></a>题目灵感来源</h4><blockquote>\n<p>起源于我们现有的博客引擎主题交互很不错，但是排版烂的要死 ，我水平有限这里只是浅显介绍实现修改我们的markdown编译器的一些排版样式</p>\n</blockquote>\n<h4 id=\"研究方向\"><a href=\"#研究方向\" class=\"headerlink\" title=\"研究方向\"></a>研究方向</h4><blockquote>\n<p>自定义一个非标准化，有其他多元素的MarkDown解析器 如下几点:</p>\n</blockquote>\n<ul>\n<li>可选框<br><code>- [ ]</code></li>\n<li>本地图片索引，可控制对齐及大小<br><code>![Alt text](http://path/to/img.jpg &quot;optional title&quot; 100x200)</code><br><code>![Alt text](./1449756974449.png)</code></li>\n<li>标签功能<br><code>@(Share)[css, Markdown]</code></li>\n<li>代码高亮（不同语言）</li>\n</ul>\n<p><code>swift</code></p>\n<pre><code class=\"swift\">    private var majorModel = PickMajorModel()\n    private var subjectModel = OFFKeyNameModel()\n    required init?(coder aDecoder: NSCoder) {\n        super.init(coder: aDecoder)\n    }\n</code></pre>\n<p><code>objectivec</code></p>\n<pre><code class=\"objectivec\">    UIScrollView *scrollView = [[UIScrollView alloc] initWithFrame:CGRectMake(0, 0, kScreenW, kScreenH)];\n    scrollView.showsVerticalScrollIndicator = NO;\n    [scrollView addSubview:self.downMainView];\n</code></pre>\n<p><strong>有一种惨不忍睹的即视感</strong><br><img src=\"./1449756974449.png\" alt=\"Alt text\"></p>\n<h3 id=\"MarkDown来源及实现\"><a href=\"#MarkDown来源及实现\" class=\"headerlink\" title=\"MarkDown来源及实现\"></a>MarkDown来源及实现</h3><blockquote>\n<p>Markdown is a plain text format for writing structured documents, based on conventions used for indicating formatting in email and usenet posts. It was developed in 2004 by John Gruber, who wrote the first markdown-to-html converter in Perl, and it soon became widely used in websites. By 2014 there were dozens of implementations in many languages.</p>\n</blockquote>\n<p><code>见知乎上回答</code><br><a href=\"http://www.zhihu.com/question/28756456\" target=\"_blank\" rel=\"noopener\">实现一个markdown解析器需要具备那些知识</a></p>\n<h3 id=\"如何简单的改善文字编排的效果\"><a href=\"#如何简单的改善文字编排的效果\" class=\"headerlink\" title=\"如何简单的改善文字编排的效果\"></a>如何简单的改善文字编排的效果</h3><h5 id=\"更换博客主题（简单粗暴）\"><a href=\"#更换博客主题（简单粗暴）\" class=\"headerlink\" title=\"更换博客主题（简单粗暴）\"></a>更换博客主题（简单粗暴）</h5><blockquote>\n<p>我们使用的博客引擎Hexo来举例，列举下面三个主题</p>\n<ul>\n<li>landscape</li>\n<li>hexo-theme-vno-master</li>\n<li>hexo-theme-yilia-master</li>\n</ul>\n</blockquote>\n<h5 id=\"更换MarkDown编译器的主题\"><a href=\"#更换MarkDown编译器的主题\" class=\"headerlink\" title=\"更换MarkDown编译器的主题\"></a>更换MarkDown编译器的主题</h5><blockquote>\n<p>以 <strong><em>Mou</em></strong> 举例子，它提供了多套markdown语法下的排版样式<br>手动新创建一个CSS文本布局配置 <strong><em>Blog</em></strong><br><img src=\"./1449768288128.png\" alt=\"Alt text\"></p>\n</blockquote>\n<h4 id=\"CSS配置文件修改\"><a href=\"#CSS配置文件修改\" class=\"headerlink\" title=\"CSS配置文件修改\"></a>CSS配置文件修改</h4><p>详细配置参数如下：</p>\n<pre><code>html { font-size: 62.5%; }\nhtml, body { height: 100%; }\n\nbody {\n  font-family: Helvetica, Arial, sans-serif;\n  font-size: 150%;\n  line-height: 1.3;\n  color: #f6e6cc;\n  width: 700px;\n  margin: auto;\n  background: #27221a;\n  position: relative;\n  padding: 0 30px;\n}\n</code></pre><p>多级标题配置</p>\n<pre><code>h1 {\n  font-size: 28px;\n  color: black; }\n\nh2 {\n  font-size: 24px;\n  border-bottom: 1px solid #cccccc;\n  color: black; }\n\nh3 {\n  font-size: 18px; }\n\nh4 {\n  font-size: 16px; }\n\nh5 {\n  font-size: 14px; }\n\nh6 {\n  color: #777777;\n  font-size: 14px; }\n</code></pre><p>表格</p>\n<pre><code>table {\n  padding: 0;border-collapse: collapse; }\n  table tr {\n    border-top: 1px solid #cccccc;\n    background-color: white;\n    margin: 0;\n    padding: 0; }\n    table tr:nth-child(2n) {\n      background-color: #f8f8f8; }\n    table tr th {\n      font-weight: bold;\n      border: 1px solid #cccccc;\n      margin: 0;\n      padding: 6px 13px; }\n    table tr td {\n      border: 1px solid #cccccc;\n      margin: 0;\n      padding: 6px 13px; }\n    table tr th :first-child, table tr td :first-child {\n      margin-top: 0; }\n    table tr th :last-child, table tr td :last-child {\n      margin-bottom: 0; }\n</code></pre><p>代码高亮</p>\n<pre><code>code, tt {\n  margin: 0 2px;\n  padding: 0 5px;\n  white-space: nowrap;\n  border: 1px solid #eaeaea;\n  background-color: #f8f8f8;\n  border-radius: 3px; }\n\n code {\n  margin: 0;\n  padding: 0;\n\n  border: none;\n  background: transparent; }\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"博客地址\"><a href=\"#博客地址\" class=\"headerlink\" title=\"博客地址\"></a><a href>博客地址</a></h3><h2 id=\"Swift柯里化-Curring-学习\"><a href=\"#Swift柯里化-Curring-学习\" class=\"headerlink\" title=\"Swift柯里化 Curring 学习\"></a>Swift柯里化 Curring 学习</h2><h3 id=\"什么是Curring\"><a href=\"#什么是Curring\" class=\"headerlink\" title=\"什么是Curring\"></a>什么是Curring</h3><blockquote>\n<p><a href=\"https://zh.wikipedia.org/wiki/%E6%9F%AF%E9%87%8C%E5%8C%96\" target=\"_blank\" rel=\"noopener\">维基百科解释</a><br>在计算机科学中，柯里化（英语：Currying），又译为卡瑞化或加里化，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。</p>\n</blockquote>\n<p>概念看上去还是有点抽象，直接看代码</p>\n<p><strong>例子</strong><br>注：所有swift代码都可以放到playgroun中运行查看输出</p>\n<pre><code>import UIKit\n\n// 一个普通求sum函数\nfunc add(a: Int, b: Int, c: Int) -&gt; Int{\n    print(&quot;\\(a) + \\(b) + \\(c) = \\(a + b + c)&quot;)\n    return a + b + c\n}\n\nadd(1, b: 2,c: 3) // 打印1 + 2 + 3 = 6\n\n// 柯里化版本的求sum函数\nfunc addCur(a: Int)(b: Int)(c: Int) -&gt; Int{\n    print(&quot;\\(a) + \\(b) + \\(c) = \\(a + b + c)&quot;)\n    return a + b + c\n}\n\naddCur(1)(b: 2)(c: 3) // 打印1 + 2 + 3 = 6\n</code></pre><p>你也许觉得Curring只是用一个特殊的写法<br>其他与普通函数无异<br>那么换一种curring的调用方式</p>\n<pre><code>// curring 另类调用方式\nlet funcWithA = addCur(1)\nprint(&quot;funcWithA type : \\(funcWithA.dynamicType)&quot;)\nlet funcWithAB = funcWithA(b: 2)\nprint(&quot;funcWithAB type : \\(funcWithAB.dynamicType)&quot;)\nlet resultCurring = funcWithAB(c: 3)\nprint(&quot;resultCurring type : \\(resultCurring.dynamicType)&quot;)\n</code></pre><p>此时你还是会觉得这只是把一个函数拆开来调用了 那么我们打印一下 每个调用步骤中变量的类型</p>\n<pre><code>let funcWithA = addCur(1)\nprint(&quot;funcWithA type : \\(funcWithA.dynamicType)&quot;) //\nlet funcWithAB = funcWithA(b: 2)\nprint(&quot;funcWithAB type : \\(funcWithAB.dynamicType)&quot;)\nlet resultCurring = funcWithAB(c: 3)\nprint(&quot;resultCurring type : \\(resultCurring.dynamicType)&quot;)\n</code></pre><p>打印结果为</p>\n<pre><code>1 + 2 + 3 = 6\nfuncWithA type : Int -&gt; Int -&gt; Int\nfuncWithAB type : Int -&gt; Int\n1 + 2 + 3 = 6\nresultCurring type : Int\n</code></pre><p>可以看到 变量funcWithA 为 Int -&gt; Int -&gt; Int 类型<br>funcWithAB 为Int -&gt; Int</p>\n<p>这说明 curring函数在绑定最后一个参数之前 每个步骤返回的值都是一个函数</p>\n<h3 id=\"Curring实现原理\"><a href=\"#Curring实现原理\" class=\"headerlink\" title=\"Curring实现原理\"></a>Curring实现原理</h3><p>Swift实现Curring的基础有两个</p>\n<ul>\n<li>函数是一级公民</li>\n<li>闭包</li>\n</ul>\n<p><a href=\"http://www.jianshu.com/p/6eaacadafa1a\" target=\"_blank\" rel=\"noopener\">啊崢的Swift Curring文章</a>代码例子解释的已经很清楚了</p>\n<pre><code>class Currying\n{\n    /*** uncurried:普通函数 ***/\n    // 接收多个参数的函数\n    func add(a: Int, b: Int, c: Int) -&gt; Int{\n        println(&quot;\\(a) + \\(b) + \\(c)&quot;)\n        return a + b + c\n    }\n\n    /*** 手动实现柯里化函数 ***/\n    // 把上面的函数转换为柯里化函数，首先转成接收第一个参数a，并且返回接收余下第一个参数b的新函数（采用闭包）\n    // 为了让大家都能看懂,我帮你们拆解来看下\n    // (a: Int) : 参数\n    // (b:Int) -&gt; (c: Int) -&gt; Int : 函数返回值（一个接收参数b的函数,并且这个函数又返回一个接收参数c,返回值为Int类型的函数)\n\n    // 定义一个接收参数a,并且返回一个接收参数b的函数,并且这个函数又返回一个接收参数c,返回值为Int类型的函数\n    func add(a: Int) -&gt; (b:Int) -&gt; (c: Int) -&gt; Int{\n\n        // 一个接收参数b的函数,并且这个函数又返回一个接收参数c,返回值为Int类型的函数\n        return { (b:Int) -&gt; (c: Int) -&gt; Int in\n\n            // 返回一个接收余下第一个参数c，并且有返回结果为Int类型的函数\n            return { (c: Int) -&gt; Int in\n\n                return a + b + c;\n\n     注解： 这里为什么能使用参数a,b,c?\n           利用闭包的值捕获特性，即使这些值作用域不在了，也可以捕获到他们的值。\n           闭包会自动判断捕获的值是值拷贝还是值引用，如果修改了，就是值引用，否则值拷贝。\n\n           注意只有在闭包中才可以，a,b,c都在闭包中。\n\n            }\n\n        }\n\n    }\n\n\n    /*** curried: 系统自带的柯里化函数 ***/\n    func addCur(a: Int)(b: Int)(c: Int) -&gt; Int{\n        println(&quot;\\(a) + \\(b) + \\(c)&quot;)\n        return a + b + c\n    }\n\n\n}\n</code></pre><h3 id=\"OC版的Curring\"><a href=\"#OC版的Curring\" class=\"headerlink\" title=\"OC版的Curring\"></a>OC版的Curring</h3><p>大部分的iOS程序员都还是习惯写OC 找了一个<a href=\"https://gist.github.com/lukhnos/1771842\" target=\"_blank\" rel=\"noopener\">OC版本的Curring</a>实现 我们可以理解的更深刻</p>\n<pre><code>#include &lt;stdio.h&gt;\nint f(int x, int y)\n{\n    return x + y;\n}\n\nint main()\n{\n    // 闭包1 绑定第一个参数\n    typedef int (^int_to_int_t)(int);\n    // 闭包2 绑定第二个参数\n    typedef int_to_int_t (^int_to_int_to_int_t)(int);\n\n    int_to_int_to_int_t h = ^(int x) {\n        int_to_int_t g = ^(int y) {\n            // 将两个闭包持有的参数做处理 返回结果\n            return f(x, y);  \n        };\n\n        return g;        \n    };\n\n    // 第一个闭包持有 5\n    int_to_int_t g = h(5);\n\n    int z;\n    // 第二个闭包持有10 并返回结果\n    z = g(10);\n    printf(&quot;%d\\n&quot;, z);\n}\n</code></pre><h3 id=\"什么？你觉得然并卵！\"><a href=\"#什么？你觉得然并卵！\" class=\"headerlink\" title=\"什么？你觉得然并卵！\"></a>什么？你觉得然并卵！</h3><p>你一定觉得这是一个然并卵的东西</p>\n<p>好吧 我第一个看到的时候 只是觉得有趣 其实也没有想到较好的应用场景 </p>\n<p><a href=\"https://gist.github.com/jcouyang/b56a830cd55bd230049f\" target=\"_blank\" rel=\"noopener\">为什么要柯里化</a>这篇文章提供的例子给了很多启发</p>\n<p>用Swift重新实现了一遍 又加了一点打印 豁然开朗</p>\n<p>上代码</p>\n<pre><code>// 拼接字符\nfunc concat(chars: Array&lt;String&gt;) {\n    var resultString = &quot;&quot;\n    for char in chars {\n        resultString += char\n    }\n    print(resultString)\n}\n\nconcat([&quot;1&quot;,&quot;2&quot;,&quot;3&quot;])\nprint(&quot;**************&quot;)\n\n// 每个字符代表的数字 + 1 后再拼接\nfunc concatAdd(chars: Array&lt;String&gt;, addNum: Int) {\n    var resultString = &quot;&quot;\n    for char in chars {\n        var num = Int(char)!\n        num = num + addNum\n        let newChar = String(num)\n        resultString += newChar\n    }\n    print(resultString)\n}\n\nconcatAdd([&quot;1&quot;,&quot;2&quot;,&quot;3&quot;], addNum: 1)\nconcatAdd([&quot;1&quot;,&quot;2&quot;,&quot;3&quot;], addNum: 2)\nconcatAdd([&quot;1&quot;,&quot;2&quot;,&quot;3&quot;], addNum: 3)\n\nprint(&quot;**************&quot;)\n// 每个字符代表的数字 *10 后再拼接\nfunc concatMultiply(chars: Array&lt;String&gt;, multiplyNum: Int) {\n    var resultString = &quot;&quot;\n    for char in chars {\n        var num = Int(char)!\n        num = num * multiplyNum\n        let newChar = String(num)\n        resultString += newChar\n    }\n    print(resultString)\n}\n\nconcatMultiply([&quot;1&quot;,&quot;2&quot;,&quot;3&quot;], multiplyNum: 1)\nconcatMultiply([&quot;1&quot;,&quot;2&quot;,&quot;3&quot;], multiplyNum: 2)\nconcatMultiply([&quot;1&quot;,&quot;2&quot;,&quot;3&quot;], multiplyNum: 3)\n\nprint(&quot;**************&quot;)\n/****\n让我们使用柯里化吧\n*****/\nfunc add(a: Int)(b: Int) -&gt; Int{\n    return a + b\n}\n\nfunc multiply(a: Int)(b: Int) -&gt; Int{\n    return a * b\n}\n\nfunc concatByCurring(chars: Array&lt;String&gt;)(caculateFunc: (Int)-&gt;Int) {\n    var resultString = &quot;&quot;\n    for char in chars {\n        var num = Int(char)!\n        var newNum = caculateFunc(num)\n        let newChar = String(newNum)\n        resultString += newChar\n    }\n    print(resultString)\n}\n\nconcatByCurring([&quot;1&quot;,&quot;2&quot;,&quot;3&quot;])(caculateFunc: add(1))\nconcatByCurring([&quot;1&quot;,&quot;2&quot;,&quot;3&quot;])(caculateFunc: add(2))\nconcatByCurring([&quot;1&quot;,&quot;2&quot;,&quot;3&quot;])(caculateFunc: add(3))\n\nprint(&quot;**************&quot;)\nconcatByCurring([&quot;1&quot;,&quot;2&quot;,&quot;3&quot;])(caculateFunc: multiply(1))\nconcatByCurring([&quot;1&quot;,&quot;2&quot;,&quot;3&quot;])(caculateFunc: multiply(2))\nconcatByCurring([&quot;1&quot;,&quot;2&quot;,&quot;3&quot;])(caculateFunc: multiply(3))\n</code></pre><p>以上的代码用普通的函数 和 Curring函数 处理了同一个功能</p>\n<p>Curring优势明显</p>\n<ul>\n<li>重用了拼接代码</li>\n<li>支持更为灵活的算法替换</li>\n<li>写功能扩展的人不用怎么关心老代码的实现</li>\n</ul>\n<p>###iOS开发中可以应用的场景</p>\n<p><strong>使用Curring处理selector</strong><br>这个例子是我在看<a href=\"https://selfstore.io/~onevcat\" target=\"_blank\" rel=\"noopener\">王巍的Swifter</a>时候看到的一个例子</p>\n<p>不废话 直接上代码</p>\n<pre><code>// 打印func类型\nclass People: NSObject {\n    func speak(){\n        print(&quot;hello&quot;)\n    }\n\n    func printSpeak() {\n        print(&quot;People func speak  : \\(People.speak.dynamicType)&quot;)\n    }\n\n}\n\nPeople().printSpeak() \n// 打印结果为 People func speak  : People -&gt; () -&gt; ()\n// 可见实例的方法就是一个Curring结构\n</code></pre><p> 下面是<a href=\"http://oleb.net/blog/2014/07/swift-instance-methods-curried-functions/?utm_campaign=iOS_Dev_Weekly_Issue_157&amp;utm_medium=email&amp;utm_source=iOS%2BDev%2BWeekly\" target=\"_blank\" rel=\"noopener\">Instance Methods are Curried Functions in Swift</a>中的例子 很开脑洞</p>\n<pre><code>//Selector demo\nprotocol TargetAction {\n    func performAction()\n}\n\nstruct TargetActionWrapper&lt;T: AnyObject&gt; : TargetAction {\n    weak var target: T?\n\n    // 此处的action类型是不是和我上面代码中打印的结构一致\n    let action: (T) -&gt; () -&gt; ()\n\n    func performAction() -&gt; () {\n        if let t = target {\n            // Curring调用\n            action(t)()\n        }\n    }\n}\n\nenum ControlEvent {\n    case TouchUpInside\n    case ValueChanged\n}\n\nclass Control {\n    var actions = [ControlEvent: TargetAction]()\n\n    func setTarget&lt;T: AnyObject&gt;(target: T, action: (T) -&gt; () -&gt; (), controlEvent: ControlEvent) {\n        actions[controlEvent] = TargetActionWrapper(target: target, action: action)\n    }\n\n    func removeTargetForControlEvent(controlEvent: ControlEvent) {\n        actions[controlEvent] = nil\n    }\n\n    func performActionForControlEvent(controlEvent: ControlEvent) {\n        actions[controlEvent]?.performAction()\n    }\n}\n\nclass MyViewController {\n    let button = Control()\n\n    func viewDidLoad() {\n        button.setTarget(self, action: MyViewController.onButtonTap, controlEvent: .TouchUpInside)\n    }\n\n    func onButtonTap() {\n        print(&quot;Button was tapped&quot;)\n    }\n}\n\n// 调用\nMyViewController().onButtonTap()\n</code></pre><h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><ul>\n<li>Curring让计算过程更清晰 函数式编程的有点初见端倪</li>\n<li>Curring让计算过程更独立 可重用</li>\n<li>Curring让计算功能扩展更方便</li>\n<li>Curring让Swift中Selector的重构可以实现</li>\n</ul>\n<h2 id=\"Umeng分享遇到的小坑-–-张超耀\"><a href=\"#Umeng分享遇到的小坑-–-张超耀\" class=\"headerlink\" title=\"Umeng分享遇到的小坑 – 张超耀\"></a>Umeng分享遇到的小坑 – 张超耀</h2><h3 id=\"写在前面的话\"><a href=\"#写在前面的话\" class=\"headerlink\" title=\"写在前面的话\"></a>写在前面的话</h3><ul>\n<li>在iOS9下，系统默认会拦截对http协议接口的访问，因此无法获取http协议接口的数据。对Umeng来说，具体表现可能是，无法授权、分享、获取用户信息等。</li>\n<li>iOS9新建项目默认需要支持bitcode，而不支持bitcode的SDK会导致无法编译运行。<a href=\"https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/AppDistributionGuide/AppThinning/AppThinning.html#//apple_ref/doc/uid/TP40012582-CH35\" target=\"_blank\" rel=\"noopener\">App Thining</a>）</li>\n</ul>\n<p><a href=\"http://dev.umeng.com/social/ios/ios9\" target=\"_blank\" rel=\"noopener\">Umeng适配iOS9</a></p>\n<h3 id=\"针对iOS9的Https特性，解决方案\"><a href=\"#针对iOS9的Https特性，解决方案\" class=\"headerlink\" title=\"针对iOS9的Https特性，解决方案\"></a>针对iOS9的Https特性，解决方案</h3><ul>\n<li>Plan A: 暂时退回到http协议:</li>\n</ul>\n<blockquote>\n<p><strong>1</strong>、在项目的info.plist中添加一个Key：NSAppTransportSecurity，类型为字典类型。<br><strong>2</strong>、然后给它添加一个Key：NSAllowsArbitraryLoads，类型为Boolean类型，值为YES；</p>\n</blockquote>\n<ul>\n<li>Plan B：设置域。可以简单理解成，把不支持https协议的接口设置成http的接口</li>\n</ul>\n<blockquote>\n<p><strong>1</strong>、在项目的info.plist中添加一个Key：NSAppTransportSecurity，类型为字典类型。</p>\n<p><strong>2</strong>、然后给它添加一个NSExceptionDomains，类型为字典类型；</p>\n<p><strong>3</strong>、把需要的支持的域添加給NSExceptionDomains。其中域作为Key，类型为字典类型。</p>\n<p><strong>4</strong>、每个域下面需要设置3个属性：NSIncludesSubdomains、        NSExceptionRequiresForwardSecrecy、        NSExceptionAllowsInsecureHTTPLoads。<br>    均为Boolean类型，值分别为YES、NO、YES。</p>\n</blockquote>\n<h3 id=\"针对App-Thinning\"><a href=\"#针对App-Thinning\" class=\"headerlink\" title=\"针对App Thinning\"></a>针对App Thinning</h3><h3 id=\"添加Scheme白名单实现应用跳转（SSO等）\"><a href=\"#添加Scheme白名单实现应用跳转（SSO等）\" class=\"headerlink\" title=\"添加Scheme白名单实现应用跳转（SSO等）\"></a>添加Scheme白名单实现应用跳转（SSO等）</h3><ul>\n<li>问题描述：在iOS 9下涉及到平台客户端跳转，系统会自动到项目info.plist下检测是否设置平台Scheme。对于需要配置的平台，如果没有配置，就无法正常跳转平台客户端。因此要支持客户端的分享和授权等，需要配置Scheme名单。</li>\n<li>解决方案：</li>\n</ul>\n<p>具体方法：</p>\n<blockquote>\n<p>1、在项目的info.plist中添加一LSApplicationQueriesSchemes，类型为Array。</p>\n<p>2、然后给它添加一个需要支持的项目，类型为字符串类型</p>\n</blockquote>\n<h3 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h3><ul>\n<li>由于苹果审核政策需求，需要对未安装客户端平台进行隐藏，在设置QQ、微信AppID之后调用下面的方法，</li>\n</ul>\n<pre><code>[UMSocialConfig hiddenNotInstallPlatforms:@[UMShareToQQ, UMShareToQzone, UMShareToWechatSession, UMShareToWechatTimeline]];\n</code></pre><ul>\n<li>but  这个接口只对默认分享面板平台有隐藏功能，自定义分享面板或登录按钮需要自己处理</li>\n</ul>\n<ul>\n<li>对于自定义分享面板处理：<ul>\n<li>UmengSDK已经嵌入相关API，直接用就好</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"只要按照官方文档来，基本上就能马到成功（）\"><a href=\"#只要按照官方文档来，基本上就能马到成功（）\" class=\"headerlink\" title=\"只要按照官方文档来，基本上就能马到成功（）\"></a>只要按照官方文档来，基本上就能马到成功（）</h3><h2 id=\"MarkDown-的-CSS-实现配置-杨志平\"><a href=\"#MarkDown-的-CSS-实现配置-杨志平\" class=\"headerlink\" title=\"MarkDown 的 CSS 实现配置 - 杨志平\"></a>MarkDown 的 CSS 实现配置 - 杨志平</h2><h4 id=\"题目灵感来源\"><a href=\"#题目灵感来源\" class=\"headerlink\" title=\"题目灵感来源\"></a>题目灵感来源</h4><blockquote>\n<p>起源于我们现有的博客引擎主题交互很不错，但是排版烂的要死 ，我水平有限这里只是浅显介绍实现修改我们的markdown编译器的一些排版样式</p>\n</blockquote>\n<h4 id=\"研究方向\"><a href=\"#研究方向\" class=\"headerlink\" title=\"研究方向\"></a>研究方向</h4><blockquote>\n<p>自定义一个非标准化，有其他多元素的MarkDown解析器 如下几点:</p>\n</blockquote>\n<ul>\n<li>可选框<br><code>- [ ]</code></li>\n<li>本地图片索引，可控制对齐及大小<br><code>![Alt text](http://path/to/img.jpg &quot;optional title&quot; 100x200)</code><br><code>![Alt text](./1449756974449.png)</code></li>\n<li>标签功能<br><code>@(Share)[css, Markdown]</code></li>\n<li>代码高亮（不同语言）</li>\n</ul>\n<p><code>swift</code></p>\n<pre><code class=\"swift\">    private var majorModel = PickMajorModel()\n    private var subjectModel = OFFKeyNameModel()\n    required init?(coder aDecoder: NSCoder) {\n        super.init(coder: aDecoder)\n    }\n</code></pre>\n<p><code>objectivec</code></p>\n<pre><code class=\"objectivec\">    UIScrollView *scrollView = [[UIScrollView alloc] initWithFrame:CGRectMake(0, 0, kScreenW, kScreenH)];\n    scrollView.showsVerticalScrollIndicator = NO;\n    [scrollView addSubview:self.downMainView];\n</code></pre>\n<p><strong>有一种惨不忍睹的即视感</strong><br><img src=\"./1449756974449.png\" alt=\"Alt text\"></p>\n<h3 id=\"MarkDown来源及实现\"><a href=\"#MarkDown来源及实现\" class=\"headerlink\" title=\"MarkDown来源及实现\"></a>MarkDown来源及实现</h3><blockquote>\n<p>Markdown is a plain text format for writing structured documents, based on conventions used for indicating formatting in email and usenet posts. It was developed in 2004 by John Gruber, who wrote the first markdown-to-html converter in Perl, and it soon became widely used in websites. By 2014 there were dozens of implementations in many languages.</p>\n</blockquote>\n<p><code>见知乎上回答</code><br><a href=\"http://www.zhihu.com/question/28756456\" target=\"_blank\" rel=\"noopener\">实现一个markdown解析器需要具备那些知识</a></p>\n<h3 id=\"如何简单的改善文字编排的效果\"><a href=\"#如何简单的改善文字编排的效果\" class=\"headerlink\" title=\"如何简单的改善文字编排的效果\"></a>如何简单的改善文字编排的效果</h3><h5 id=\"更换博客主题（简单粗暴）\"><a href=\"#更换博客主题（简单粗暴）\" class=\"headerlink\" title=\"更换博客主题（简单粗暴）\"></a>更换博客主题（简单粗暴）</h5><blockquote>\n<p>我们使用的博客引擎Hexo来举例，列举下面三个主题</p>\n<ul>\n<li>landscape</li>\n<li>hexo-theme-vno-master</li>\n<li>hexo-theme-yilia-master</li>\n</ul>\n</blockquote>\n<h5 id=\"更换MarkDown编译器的主题\"><a href=\"#更换MarkDown编译器的主题\" class=\"headerlink\" title=\"更换MarkDown编译器的主题\"></a>更换MarkDown编译器的主题</h5><blockquote>\n<p>以 <strong><em>Mou</em></strong> 举例子，它提供了多套markdown语法下的排版样式<br>手动新创建一个CSS文本布局配置 <strong><em>Blog</em></strong><br><img src=\"./1449768288128.png\" alt=\"Alt text\"></p>\n</blockquote>\n<h4 id=\"CSS配置文件修改\"><a href=\"#CSS配置文件修改\" class=\"headerlink\" title=\"CSS配置文件修改\"></a>CSS配置文件修改</h4><p>详细配置参数如下：</p>\n<pre><code>html { font-size: 62.5%; }\nhtml, body { height: 100%; }\n\nbody {\n  font-family: Helvetica, Arial, sans-serif;\n  font-size: 150%;\n  line-height: 1.3;\n  color: #f6e6cc;\n  width: 700px;\n  margin: auto;\n  background: #27221a;\n  position: relative;\n  padding: 0 30px;\n}\n</code></pre><p>多级标题配置</p>\n<pre><code>h1 {\n  font-size: 28px;\n  color: black; }\n\nh2 {\n  font-size: 24px;\n  border-bottom: 1px solid #cccccc;\n  color: black; }\n\nh3 {\n  font-size: 18px; }\n\nh4 {\n  font-size: 16px; }\n\nh5 {\n  font-size: 14px; }\n\nh6 {\n  color: #777777;\n  font-size: 14px; }\n</code></pre><p>表格</p>\n<pre><code>table {\n  padding: 0;border-collapse: collapse; }\n  table tr {\n    border-top: 1px solid #cccccc;\n    background-color: white;\n    margin: 0;\n    padding: 0; }\n    table tr:nth-child(2n) {\n      background-color: #f8f8f8; }\n    table tr th {\n      font-weight: bold;\n      border: 1px solid #cccccc;\n      margin: 0;\n      padding: 6px 13px; }\n    table tr td {\n      border: 1px solid #cccccc;\n      margin: 0;\n      padding: 6px 13px; }\n    table tr th :first-child, table tr td :first-child {\n      margin-top: 0; }\n    table tr th :last-child, table tr td :last-child {\n      margin-bottom: 0; }\n</code></pre><p>代码高亮</p>\n<pre><code>code, tt {\n  margin: 0 2px;\n  padding: 0 5px;\n  white-space: nowrap;\n  border: 1px solid #eaeaea;\n  background-color: #f8f8f8;\n  border-radius: 3px; }\n\n code {\n  margin: 0;\n  padding: 0;\n\n  border: none;\n  background: transparent; }\n</code></pre>"},{"title":"前端入门（1）","date":"2015-12-02T10:30:00.000Z","_content":"\n## Ruby on Rails 初体验 - 王胜\n\n### 使用命令行快速创建应用的步骤\n\n- 创建应用程序\n\n  ```Shell\n  $rails new hello -d mysql\n  ```\n  **备注** 这里演示使用mysql作为数据持久层\n- 浏览hello world界面\n\n  ```Shell\n  $cd hello\n  $rake db:create RAILS_ENV='development' // 创建开发数据库\n  $bin/rails server\n  ```\n  **备注** 由于这里的rails版本是4.2.1，与msqyl2的最高版本有不兼容行，所以需要手动将Gemfile中mysql2降级。降级之后执行bundle install。\n  ```\n  gem 'mysql2' -> gem 'mysql2', '~> 0.3.18'\n  ```\n- 使用脚手架，创建模型、数据迁移脚本以及控制器和试图\n\n  ```Shell\n  $bin/rails generate scaffold Person name:string age:integer\n  ```\n- 执行数据迁移\n\n  ```Shell\n  $bin/rake db:migrate RAILS_ENV=development\n  ```\n- 启动应用\n\n  ```Shell\n  $bin/rails server\n  ```\n- 浏览效果\n\n  ```\n  http://localhost:3000/people\n  ```\n\n**备注**\n\n此演示项目，ruby、gems和Rails的版本信息如下:\n\n- ruby: 2.0.0p481\n- rubygems: 2.4.5\n- rails: 4.2.1\n\n参考：\n\n- [rubyonrails.org](http://guides.rubyonrails.org/command_line.html)\n\n\n\n## 矢量图在Android 上应用 - 王进\n\n### VectorDrawable\n示例：\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<vector xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        <!--  intrinsic  size  of  the  drawable  -->\n        android:height=\"300dp\"\n        android:width=\"300dp\"\n        <!-- size of the virtual canvas -->\n        android:viewportHeight=\"40\"\n        android:viewportWidth=\"40\"\n        >\n        <path android:fillColor=\"#ff00ff\"\n                android:pathData=\"M20.5,9.5\n                        c-1.955,0,-3.83,1.268,-4.5,3\n                        c-0.67,-1.732,-2.547,-3,-4.5,-3\n                        C8.957,9.5,7,11.432,7,14\n                        c0,3.53,3.793,6.257,9,11.5\n                        c5.207,-5.242,9,-7.97,9,-11.5\n                        C25,11.432,23.043,9.5,20.5,9.5z\"\n                />\n</vector>\n```\n### SVG→Vector\nAndroid并不原生支持读取常见的向量文件格式，如ＳＶＧ\n（主要是缺少ｃｓｓ支持），但是支持相同路径数据语法，\n所以ＳＶＧ资源需要经过一定的转换；\n\n### 使用SVG Path Data \n- M： move to 移动绘制点\n- L：line to 直线\n- Z：close 闭合\n- C：cubic bezier 三次贝塞尔曲线\n- Q：quatratic bezier 二次贝塞尔曲线\n- A：ellipse 圆弧\n\n>每个命令都有大小写形式，大写代表后面的参数是绝对坐标，小写表示相对坐标。参数之间用空格或逗号隔开\n\n**命令详解：**\n- M (x y) 移动到x,y\n- L (x y) 直线连到x,y，还有简化命令H(x) 水平连接、V(y)垂直连接\n- Z，没有参数，连接起点和终点\n- C(x1 y1 x2 y2 x y)，控制点x1,y1 x2,y2，终点x,y\n- Q(x1 y1 x y)，控制点x1,y1，终点x,y\n- A(rx ry x-axis-rotation large-arc-flag sweep-flag x y) \n - rx ry 椭圆半径 \n - x-axis-rotation x轴旋转角度 \n - large-arc-flag 为0时表示取小弧度，1时取大弧度 \n - sweep-flag 0取逆时针方向，1取顺时针方向  \n  ![](http://static.oschina.net/uploads/img/201510/01095231_IR6O.svg)\n\n详细参考：http://www.w3.org/TR/SVG11/paths.html#PathData\n\n### Icon Font \n解决矢量图低版本不兼容问题\n\n详细参考：\n1,http://blog.csdn.net/a345017062/article/details/46455745\n2,http://blog.csdn.net/goodlixueyong/article/details/41448483\n\n## WordPress快速建站 --杨俊构\n\n### 准备工具\n\n- 服务器php套件（ Nginx+PHP7.0）： [UPUPW绿色服务器](http://www.upupw.net/)\n\n- WordPress代码包：[wordpress-4.3.1-zh_CN](https://cn.wordpress.org/)\n\n### 操作步骤\n\n- 配置服务器和数据库\n\n 1. 解压UPUPW_NP7.0-1511.7z 到本地目录\n 2. 打开解压包后的upupw.exe配置平台。\n  ![](http://7xohph.com1.z0.glb.clouddn.com/05120101.jpg)\n 3. 输入“S1”开启全部服务\n 4. 打开地址 http://127.0.0.1/ 会看到UPUPWPHP探针页面\n  ![](http://7xohph.com1.z0.glb.clouddn.com/05120103.jpg)\n 5. 打开地址 http://127.0.0.1/pmd/ 配置mysql数据库（默认用户名密码都是root）\n 6. 新建数据库，用户名，密码\n 7. 打开地址 http://127.0.0.1/ 使用数据库连接测试连接数据库是否正常\n\n- 安装配置wordpress\n 1. 解压wordpress-4.3.1-zh_CN.zip压缩包\n 2. 将wordpress文件夹拷贝到UPUPW发布根目录/htdocs文件夹下\n 3. 打来地址http://127.0.0.1/wordpress，根据开始安装\n 4. 输入刚才配置的数据库名，用户名，密码，点击提交进行\n 5. 设置站点标题，后台登陆用户名，后台密码，邮件地址完成安装\n 6. 再次打开地址http://127.0.0.1/wordpress测试安装完成\n ![](http://7xohph.com1.z0.glb.clouddn.com/05120105.jpg)\n\n### WordPress相关资源\n - 推荐主题 ：[威言威语](http://www.weisay.com/blog/)     [prower](http://www.prower.cn/)\n \n - 推荐插件 ： [多说](http://duoshuo.com/) （评论快速提交，文章聚合发布）   [七牛镜像存储wordpress 插件](http://developer.qiniu.com/download/index.html)     [youpzt-optimizer](http://www.youpzt.com/267.html)（网站优化工具）\n \n - [NextApp](http://www.oschina.net/news/55174/nextapp-opensource) —— 开源的WordPress手机博客 App 自动生成系统\n\n\n## 51offer Android重构之Architecture - xpleemoon\n### 历史\n- 我们的app经历了一次重构，在重构过程中将IDE切换到Android Studio，并且编译脚本从Ant切换到了Gradle。\n- 不介绍IDE和Gradle的优势，主要介绍重构后app的Architecture相关部分。\n\n> 从0到1是一个开始，再从1到N又是另一个开始。\n\n### Architecture\n- 当前我们的结构主要为4层：\n\t1. app\n\t2. core\n\t3. lib\n\t4. model\n\n![project结构](http://7xohph.com1.z0.glb.clouddn.com/X3.jpg)\n\n- app依赖core，而core依赖lib和model。随着以后的业务发展、产品迭代或者有更好的结构划分，会再做调整。\n\n![module依赖](http://7xohph.com1.z0.glb.clouddn.com/X1.jpg)\n\n### app——展现层（presention）\n- 用于页面展现，主要包含MVP模式中的VP。我们对V采用接口的方式去定义，然后让Activity或者Fragment去实现V接口，这样我们就达到接口编程的目的，P只需要关注V接口即可。以注册中的地区列表页面为例\n\n![VP](http://7xohph.com1.z0.glb.clouddn.com/X4.jpg)\n\n- V\n\n```java\n/**\n * 地区view，MVP－V\n */\npublic interface IRegionView {\n    /**\n     * 搜索更新\n     */\n    void search2Update();\n}\n```\n- P\n\n```java\n/**\n * 国家地区，MVP－P\n */\npublic class RegionPresenter {\n    private List<Region> mRegions = OFRRegionHelper.getRegions();\n\n    /**\n     * 获取地区列表\n     *\n     * @return\n     */\n    public List<Region> getRegions() {\n        return mRegions;\n    }\n\n    /**\n     * 搜索\n     *\n     * @param regionView\n     * @param searchRegion\n     */\n    public void search(@NonNull IRegionView regionView, String searchRegion) {\n        mRegions.clear();\n        if (TextUtils.isEmpty(searchRegion)) {\n            mRegions.addAll(OFRRegionHelper.getRegions());\n        } else {\n            mRegions.addAll(OFRRegionHelper.searchRegions(searchRegion));\n        }\n        regionView.search2Update();\n    }\n}\n```\n- 另外，我们的app有太多的业务逻辑，所以我们也使用了比较多的策略模式，方便以后的扩展和维护。比如不同的国家，它在意向单展现时就有不同的表现：\n\t- 可以同时选择的最多意向单数量\n\t- 每个学校可以同时选择的最多专业数量 \n\t- 意向单名字\n- 于是，我们就对此采用了策略模式\n\n![国家意向单策略图](http://7xohph.com1.z0.glb.clouddn.com/X2.jpg)\n\n- 国家意向单策略接口\n\n```java\n/**\n * 国家策略\n * <ul>\n * <li>不同国家可选的意向单数量不同，具体见{@link #maxCount2Select()}</li>\n * <li>不同国家的学校专业可选数量不同，具体见{@link #maxCountOfPerSchool2Select()}</li>\n * </ul>\n */\npublic interface ICountryPurpose {\n    /**\n     * 国家可以同时选择的最多意向单数量\n     *\n     * @return\n     */\n    int maxCount2Select();\n\n    /**\n     * 每个学校可以同时选择的最多专业数量\n     *\n     * @return\n     */\n    int maxCountOfPerSchool2Select();\n\n    /**\n     * 意向单名字，目前可用名字为：\n     * <ol>\n     * <li>专业</li>\n     * <li>入学时间，当前只限日本</>\n     * </ol>\n     *\n     * @param ctx\n     * @return\n     */\n    String getName(@NonNull Context ctx);\n}\n```\n### core\n- 核心层，主要用于应用相关的URL拼接、图片加载、网络请求、json解析、第三方平台、配置和工具。\n\n### lib\n- 通用库层，不依赖于应用的任何业务，方便快速的移植到其它项目.\n\n### model\n- 数据层，作为MVP的M，用于应用的数据模型.\n\n## 简单HTML5 吴明\n- [烟火效果](http://www.17sucai.com/pins/demoshow/4583)\n- [404动画](http://www.html5tricks.com/demo/html5-css3-404-animation/index.html)\n- [爱心树](http://keleyi.com/keleyi/phtml/html5/31.htm)\n- 开发ide storm\n- 目录结构\n\t- dist:第三库存放地方，以下为存放指定文件类型目录\n\t\t- css\n\t\t- js\n\t\t- doc\n\t\t- img\n\t- \tsrc:项目指定文件类型目录\n\t\t- css\n\t\t- js\n\t\t- doc\n\t\t- img  \n- 简单代码\n\n```\n<!--html5网页声明-->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <title>mobile</title>\n    <meta charset=\"UTF-8\">\n    <!-- 此处还可以插入其他meta,样式单等信息-->\n    <script type=\"text/javascript\"></script>\n\n</head>\n\n<body>\n<!--页面部分-->\n<p>现实是残酷的,别做梦,从hello word开始吧!</p>\n<canvas id=\"canvas\">不支持html5</canvas>\n\n\n<script type=\"text/javascript\">\n    <!-- 获取内容中id为canvas的元素-->\n    var canvas = document.getElementById('canvas');\n//    获取canvas的环境,\n    var ctx = canvas.getContext('2d');\n//      填充的样式为红色\n    ctx.fillStyle = '#ff0000';\n    ctx.st//    画一个矩形,位置x,y,w,h\n    ctx.fillRect(0, 0, 600, 100);\n</script>\n</body>\n</html>\n\n```\n\n- 参考链接\n\t- [链接一](http://caniuse.com/)\n\t- [链接二](https://developer.mozilla.org/zh-CN/docs/Web/HTML)\n","source":"_posts/前端入门（1）.md","raw":"title: 前端入门（1）\ndate: 2015-12-02  10:30:00\ntags:\ncategories: 移动组周分享\n---\n\n## Ruby on Rails 初体验 - 王胜\n\n### 使用命令行快速创建应用的步骤\n\n- 创建应用程序\n\n  ```Shell\n  $rails new hello -d mysql\n  ```\n  **备注** 这里演示使用mysql作为数据持久层\n- 浏览hello world界面\n\n  ```Shell\n  $cd hello\n  $rake db:create RAILS_ENV='development' // 创建开发数据库\n  $bin/rails server\n  ```\n  **备注** 由于这里的rails版本是4.2.1，与msqyl2的最高版本有不兼容行，所以需要手动将Gemfile中mysql2降级。降级之后执行bundle install。\n  ```\n  gem 'mysql2' -> gem 'mysql2', '~> 0.3.18'\n  ```\n- 使用脚手架，创建模型、数据迁移脚本以及控制器和试图\n\n  ```Shell\n  $bin/rails generate scaffold Person name:string age:integer\n  ```\n- 执行数据迁移\n\n  ```Shell\n  $bin/rake db:migrate RAILS_ENV=development\n  ```\n- 启动应用\n\n  ```Shell\n  $bin/rails server\n  ```\n- 浏览效果\n\n  ```\n  http://localhost:3000/people\n  ```\n\n**备注**\n\n此演示项目，ruby、gems和Rails的版本信息如下:\n\n- ruby: 2.0.0p481\n- rubygems: 2.4.5\n- rails: 4.2.1\n\n参考：\n\n- [rubyonrails.org](http://guides.rubyonrails.org/command_line.html)\n\n\n\n## 矢量图在Android 上应用 - 王进\n\n### VectorDrawable\n示例：\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<vector xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        <!--  intrinsic  size  of  the  drawable  -->\n        android:height=\"300dp\"\n        android:width=\"300dp\"\n        <!-- size of the virtual canvas -->\n        android:viewportHeight=\"40\"\n        android:viewportWidth=\"40\"\n        >\n        <path android:fillColor=\"#ff00ff\"\n                android:pathData=\"M20.5,9.5\n                        c-1.955,0,-3.83,1.268,-4.5,3\n                        c-0.67,-1.732,-2.547,-3,-4.5,-3\n                        C8.957,9.5,7,11.432,7,14\n                        c0,3.53,3.793,6.257,9,11.5\n                        c5.207,-5.242,9,-7.97,9,-11.5\n                        C25,11.432,23.043,9.5,20.5,9.5z\"\n                />\n</vector>\n```\n### SVG→Vector\nAndroid并不原生支持读取常见的向量文件格式，如ＳＶＧ\n（主要是缺少ｃｓｓ支持），但是支持相同路径数据语法，\n所以ＳＶＧ资源需要经过一定的转换；\n\n### 使用SVG Path Data \n- M： move to 移动绘制点\n- L：line to 直线\n- Z：close 闭合\n- C：cubic bezier 三次贝塞尔曲线\n- Q：quatratic bezier 二次贝塞尔曲线\n- A：ellipse 圆弧\n\n>每个命令都有大小写形式，大写代表后面的参数是绝对坐标，小写表示相对坐标。参数之间用空格或逗号隔开\n\n**命令详解：**\n- M (x y) 移动到x,y\n- L (x y) 直线连到x,y，还有简化命令H(x) 水平连接、V(y)垂直连接\n- Z，没有参数，连接起点和终点\n- C(x1 y1 x2 y2 x y)，控制点x1,y1 x2,y2，终点x,y\n- Q(x1 y1 x y)，控制点x1,y1，终点x,y\n- A(rx ry x-axis-rotation large-arc-flag sweep-flag x y) \n - rx ry 椭圆半径 \n - x-axis-rotation x轴旋转角度 \n - large-arc-flag 为0时表示取小弧度，1时取大弧度 \n - sweep-flag 0取逆时针方向，1取顺时针方向  \n  ![](http://static.oschina.net/uploads/img/201510/01095231_IR6O.svg)\n\n详细参考：http://www.w3.org/TR/SVG11/paths.html#PathData\n\n### Icon Font \n解决矢量图低版本不兼容问题\n\n详细参考：\n1,http://blog.csdn.net/a345017062/article/details/46455745\n2,http://blog.csdn.net/goodlixueyong/article/details/41448483\n\n## WordPress快速建站 --杨俊构\n\n### 准备工具\n\n- 服务器php套件（ Nginx+PHP7.0）： [UPUPW绿色服务器](http://www.upupw.net/)\n\n- WordPress代码包：[wordpress-4.3.1-zh_CN](https://cn.wordpress.org/)\n\n### 操作步骤\n\n- 配置服务器和数据库\n\n 1. 解压UPUPW_NP7.0-1511.7z 到本地目录\n 2. 打开解压包后的upupw.exe配置平台。\n  ![](http://7xohph.com1.z0.glb.clouddn.com/05120101.jpg)\n 3. 输入“S1”开启全部服务\n 4. 打开地址 http://127.0.0.1/ 会看到UPUPWPHP探针页面\n  ![](http://7xohph.com1.z0.glb.clouddn.com/05120103.jpg)\n 5. 打开地址 http://127.0.0.1/pmd/ 配置mysql数据库（默认用户名密码都是root）\n 6. 新建数据库，用户名，密码\n 7. 打开地址 http://127.0.0.1/ 使用数据库连接测试连接数据库是否正常\n\n- 安装配置wordpress\n 1. 解压wordpress-4.3.1-zh_CN.zip压缩包\n 2. 将wordpress文件夹拷贝到UPUPW发布根目录/htdocs文件夹下\n 3. 打来地址http://127.0.0.1/wordpress，根据开始安装\n 4. 输入刚才配置的数据库名，用户名，密码，点击提交进行\n 5. 设置站点标题，后台登陆用户名，后台密码，邮件地址完成安装\n 6. 再次打开地址http://127.0.0.1/wordpress测试安装完成\n ![](http://7xohph.com1.z0.glb.clouddn.com/05120105.jpg)\n\n### WordPress相关资源\n - 推荐主题 ：[威言威语](http://www.weisay.com/blog/)     [prower](http://www.prower.cn/)\n \n - 推荐插件 ： [多说](http://duoshuo.com/) （评论快速提交，文章聚合发布）   [七牛镜像存储wordpress 插件](http://developer.qiniu.com/download/index.html)     [youpzt-optimizer](http://www.youpzt.com/267.html)（网站优化工具）\n \n - [NextApp](http://www.oschina.net/news/55174/nextapp-opensource) —— 开源的WordPress手机博客 App 自动生成系统\n\n\n## 51offer Android重构之Architecture - xpleemoon\n### 历史\n- 我们的app经历了一次重构，在重构过程中将IDE切换到Android Studio，并且编译脚本从Ant切换到了Gradle。\n- 不介绍IDE和Gradle的优势，主要介绍重构后app的Architecture相关部分。\n\n> 从0到1是一个开始，再从1到N又是另一个开始。\n\n### Architecture\n- 当前我们的结构主要为4层：\n\t1. app\n\t2. core\n\t3. lib\n\t4. model\n\n![project结构](http://7xohph.com1.z0.glb.clouddn.com/X3.jpg)\n\n- app依赖core，而core依赖lib和model。随着以后的业务发展、产品迭代或者有更好的结构划分，会再做调整。\n\n![module依赖](http://7xohph.com1.z0.glb.clouddn.com/X1.jpg)\n\n### app——展现层（presention）\n- 用于页面展现，主要包含MVP模式中的VP。我们对V采用接口的方式去定义，然后让Activity或者Fragment去实现V接口，这样我们就达到接口编程的目的，P只需要关注V接口即可。以注册中的地区列表页面为例\n\n![VP](http://7xohph.com1.z0.glb.clouddn.com/X4.jpg)\n\n- V\n\n```java\n/**\n * 地区view，MVP－V\n */\npublic interface IRegionView {\n    /**\n     * 搜索更新\n     */\n    void search2Update();\n}\n```\n- P\n\n```java\n/**\n * 国家地区，MVP－P\n */\npublic class RegionPresenter {\n    private List<Region> mRegions = OFRRegionHelper.getRegions();\n\n    /**\n     * 获取地区列表\n     *\n     * @return\n     */\n    public List<Region> getRegions() {\n        return mRegions;\n    }\n\n    /**\n     * 搜索\n     *\n     * @param regionView\n     * @param searchRegion\n     */\n    public void search(@NonNull IRegionView regionView, String searchRegion) {\n        mRegions.clear();\n        if (TextUtils.isEmpty(searchRegion)) {\n            mRegions.addAll(OFRRegionHelper.getRegions());\n        } else {\n            mRegions.addAll(OFRRegionHelper.searchRegions(searchRegion));\n        }\n        regionView.search2Update();\n    }\n}\n```\n- 另外，我们的app有太多的业务逻辑，所以我们也使用了比较多的策略模式，方便以后的扩展和维护。比如不同的国家，它在意向单展现时就有不同的表现：\n\t- 可以同时选择的最多意向单数量\n\t- 每个学校可以同时选择的最多专业数量 \n\t- 意向单名字\n- 于是，我们就对此采用了策略模式\n\n![国家意向单策略图](http://7xohph.com1.z0.glb.clouddn.com/X2.jpg)\n\n- 国家意向单策略接口\n\n```java\n/**\n * 国家策略\n * <ul>\n * <li>不同国家可选的意向单数量不同，具体见{@link #maxCount2Select()}</li>\n * <li>不同国家的学校专业可选数量不同，具体见{@link #maxCountOfPerSchool2Select()}</li>\n * </ul>\n */\npublic interface ICountryPurpose {\n    /**\n     * 国家可以同时选择的最多意向单数量\n     *\n     * @return\n     */\n    int maxCount2Select();\n\n    /**\n     * 每个学校可以同时选择的最多专业数量\n     *\n     * @return\n     */\n    int maxCountOfPerSchool2Select();\n\n    /**\n     * 意向单名字，目前可用名字为：\n     * <ol>\n     * <li>专业</li>\n     * <li>入学时间，当前只限日本</>\n     * </ol>\n     *\n     * @param ctx\n     * @return\n     */\n    String getName(@NonNull Context ctx);\n}\n```\n### core\n- 核心层，主要用于应用相关的URL拼接、图片加载、网络请求、json解析、第三方平台、配置和工具。\n\n### lib\n- 通用库层，不依赖于应用的任何业务，方便快速的移植到其它项目.\n\n### model\n- 数据层，作为MVP的M，用于应用的数据模型.\n\n## 简单HTML5 吴明\n- [烟火效果](http://www.17sucai.com/pins/demoshow/4583)\n- [404动画](http://www.html5tricks.com/demo/html5-css3-404-animation/index.html)\n- [爱心树](http://keleyi.com/keleyi/phtml/html5/31.htm)\n- 开发ide storm\n- 目录结构\n\t- dist:第三库存放地方，以下为存放指定文件类型目录\n\t\t- css\n\t\t- js\n\t\t- doc\n\t\t- img\n\t- \tsrc:项目指定文件类型目录\n\t\t- css\n\t\t- js\n\t\t- doc\n\t\t- img  \n- 简单代码\n\n```\n<!--html5网页声明-->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <title>mobile</title>\n    <meta charset=\"UTF-8\">\n    <!-- 此处还可以插入其他meta,样式单等信息-->\n    <script type=\"text/javascript\"></script>\n\n</head>\n\n<body>\n<!--页面部分-->\n<p>现实是残酷的,别做梦,从hello word开始吧!</p>\n<canvas id=\"canvas\">不支持html5</canvas>\n\n\n<script type=\"text/javascript\">\n    <!-- 获取内容中id为canvas的元素-->\n    var canvas = document.getElementById('canvas');\n//    获取canvas的环境,\n    var ctx = canvas.getContext('2d');\n//      填充的样式为红色\n    ctx.fillStyle = '#ff0000';\n    ctx.st//    画一个矩形,位置x,y,w,h\n    ctx.fillRect(0, 0, 600, 100);\n</script>\n</body>\n</html>\n\n```\n\n- 参考链接\n\t- [链接一](http://caniuse.com/)\n\t- [链接二](https://developer.mozilla.org/zh-CN/docs/Web/HTML)\n","slug":"前端入门（1）","published":1,"updated":"2021-09-10T07:04:21.945Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cktfeap46001xc2xx5kyctiek","content":"<h2 id=\"Ruby-on-Rails-初体验-王胜\"><a href=\"#Ruby-on-Rails-初体验-王胜\" class=\"headerlink\" title=\"Ruby on Rails 初体验 - 王胜\"></a>Ruby on Rails 初体验 - 王胜</h2><h3 id=\"使用命令行快速创建应用的步骤\"><a href=\"#使用命令行快速创建应用的步骤\" class=\"headerlink\" title=\"使用命令行快速创建应用的步骤\"></a>使用命令行快速创建应用的步骤</h3><ul>\n<li><p>创建应用程序</p>\n<pre><code class=\"Shell\">$rails new hello -d mysql\n</code></pre>\n<p><strong>备注</strong> 这里演示使用mysql作为数据持久层</p>\n</li>\n<li><p>浏览hello world界面</p>\n<pre><code class=\"Shell\">$cd hello\n$rake db:create RAILS_ENV=&#39;development&#39; // 创建开发数据库\n$bin/rails server\n</code></pre>\n<p><strong>备注</strong> 由于这里的rails版本是4.2.1，与msqyl2的最高版本有不兼容行，所以需要手动将Gemfile中mysql2降级。降级之后执行bundle install。</p>\n<pre><code>gem &#39;mysql2&#39; -&gt; gem &#39;mysql2&#39;, &#39;~&gt; 0.3.18&#39;\n</code></pre></li>\n<li><p>使用脚手架，创建模型、数据迁移脚本以及控制器和试图</p>\n<pre><code class=\"Shell\">$bin/rails generate scaffold Person name:string age:integer\n</code></pre>\n</li>\n<li><p>执行数据迁移</p>\n<pre><code class=\"Shell\">$bin/rake db:migrate RAILS_ENV=development\n</code></pre>\n</li>\n<li><p>启动应用</p>\n<pre><code class=\"Shell\">$bin/rails server\n</code></pre>\n</li>\n<li><p>浏览效果</p>\n<pre><code>http://localhost:3000/people\n</code></pre></li>\n</ul>\n<p><strong>备注</strong></p>\n<p>此演示项目，ruby、gems和Rails的版本信息如下:</p>\n<ul>\n<li>ruby: 2.0.0p481</li>\n<li>rubygems: 2.4.5</li>\n<li>rails: 4.2.1</li>\n</ul>\n<p>参考：</p>\n<ul>\n<li><a href=\"http://guides.rubyonrails.org/command_line.html\" target=\"_blank\" rel=\"noopener\">rubyonrails.org</a></li>\n</ul>\n<h2 id=\"矢量图在Android-上应用-王进\"><a href=\"#矢量图在Android-上应用-王进\" class=\"headerlink\" title=\"矢量图在Android 上应用 - 王进\"></a>矢量图在Android 上应用 - 王进</h2><h3 id=\"VectorDrawable\"><a href=\"#VectorDrawable\" class=\"headerlink\" title=\"VectorDrawable\"></a>VectorDrawable</h3><p>示例：</p>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n        &lt;!--  intrinsic  size  of  the  drawable  --&gt;\n        android:height=&quot;300dp&quot;\n        android:width=&quot;300dp&quot;\n        &lt;!-- size of the virtual canvas --&gt;\n        android:viewportHeight=&quot;40&quot;\n        android:viewportWidth=&quot;40&quot;\n        &gt;\n        &lt;path android:fillColor=&quot;#ff00ff&quot;\n                android:pathData=&quot;M20.5,9.5\n                        c-1.955,0,-3.83,1.268,-4.5,3\n                        c-0.67,-1.732,-2.547,-3,-4.5,-3\n                        C8.957,9.5,7,11.432,7,14\n                        c0,3.53,3.793,6.257,9,11.5\n                        c5.207,-5.242,9,-7.97,9,-11.5\n                        C25,11.432,23.043,9.5,20.5,9.5z&quot;\n                /&gt;\n&lt;/vector&gt;\n</code></pre><h3 id=\"SVG→Vector\"><a href=\"#SVG→Vector\" class=\"headerlink\" title=\"SVG→Vector\"></a>SVG→Vector</h3><p>Android并不原生支持读取常见的向量文件格式，如ＳＶＧ<br>（主要是缺少ｃｓｓ支持），但是支持相同路径数据语法，<br>所以ＳＶＧ资源需要经过一定的转换；</p>\n<h3 id=\"使用SVG-Path-Data\"><a href=\"#使用SVG-Path-Data\" class=\"headerlink\" title=\"使用SVG Path Data\"></a>使用SVG Path Data</h3><ul>\n<li>M： move to 移动绘制点</li>\n<li>L：line to 直线</li>\n<li>Z：close 闭合</li>\n<li>C：cubic bezier 三次贝塞尔曲线</li>\n<li>Q：quatratic bezier 二次贝塞尔曲线</li>\n<li>A：ellipse 圆弧</li>\n</ul>\n<blockquote>\n<p>每个命令都有大小写形式，大写代表后面的参数是绝对坐标，小写表示相对坐标。参数之间用空格或逗号隔开</p>\n</blockquote>\n<p><strong>命令详解：</strong></p>\n<ul>\n<li>M (x y) 移动到x,y</li>\n<li>L (x y) 直线连到x,y，还有简化命令H(x) 水平连接、V(y)垂直连接</li>\n<li>Z，没有参数，连接起点和终点</li>\n<li>C(x1 y1 x2 y2 x y)，控制点x1,y1 x2,y2，终点x,y</li>\n<li>Q(x1 y1 x y)，控制点x1,y1，终点x,y</li>\n<li>A(rx ry x-axis-rotation large-arc-flag sweep-flag x y) <ul>\n<li>rx ry 椭圆半径 </li>\n<li>x-axis-rotation x轴旋转角度 </li>\n<li>large-arc-flag 为0时表示取小弧度，1时取大弧度 </li>\n<li>sweep-flag 0取逆时针方向，1取顺时针方向<br><img src=\"http://static.oschina.net/uploads/img/201510/01095231_IR6O.svg\" alt></li>\n</ul>\n</li>\n</ul>\n<p>详细参考：<a href=\"http://www.w3.org/TR/SVG11/paths.html#PathData\" target=\"_blank\" rel=\"noopener\">http://www.w3.org/TR/SVG11/paths.html#PathData</a></p>\n<h3 id=\"Icon-Font\"><a href=\"#Icon-Font\" class=\"headerlink\" title=\"Icon Font\"></a>Icon Font</h3><p>解决矢量图低版本不兼容问题</p>\n<p>详细参考：<br>1,<a href=\"http://blog.csdn.net/a345017062/article/details/46455745\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/a345017062/article/details/46455745</a><br>2,<a href=\"http://blog.csdn.net/goodlixueyong/article/details/41448483\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/goodlixueyong/article/details/41448483</a></p>\n<h2 id=\"WordPress快速建站-–杨俊构\"><a href=\"#WordPress快速建站-–杨俊构\" class=\"headerlink\" title=\"WordPress快速建站 –杨俊构\"></a>WordPress快速建站 –杨俊构</h2><h3 id=\"准备工具\"><a href=\"#准备工具\" class=\"headerlink\" title=\"准备工具\"></a>准备工具</h3><ul>\n<li><p>服务器php套件（ Nginx+PHP7.0）： <a href=\"http://www.upupw.net/\" target=\"_blank\" rel=\"noopener\">UPUPW绿色服务器</a></p>\n</li>\n<li><p>WordPress代码包：<a href=\"https://cn.wordpress.org/\" target=\"_blank\" rel=\"noopener\">wordpress-4.3.1-zh_CN</a></p>\n</li>\n</ul>\n<h3 id=\"操作步骤\"><a href=\"#操作步骤\" class=\"headerlink\" title=\"操作步骤\"></a>操作步骤</h3><ul>\n<li><p>配置服务器和数据库</p>\n<ol>\n<li>解压UPUPW_NP7.0-1511.7z 到本地目录</li>\n<li>打开解压包后的upupw.exe配置平台。<br><img src=\"http://7xohph.com1.z0.glb.clouddn.com/05120101.jpg\" alt></li>\n<li>输入“S1”开启全部服务</li>\n<li>打开地址 <a href=\"http://127.0.0.1/\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1/</a> 会看到UPUPWPHP探针页面<br><img src=\"http://7xohph.com1.z0.glb.clouddn.com/05120103.jpg\" alt></li>\n<li>打开地址 <a href=\"http://127.0.0.1/pmd/\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1/pmd/</a> 配置mysql数据库（默认用户名密码都是root）</li>\n<li>新建数据库，用户名，密码</li>\n<li>打开地址 <a href=\"http://127.0.0.1/\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1/</a> 使用数据库连接测试连接数据库是否正常</li>\n</ol>\n</li>\n<li><p>安装配置wordpress</p>\n<ol>\n<li>解压wordpress-4.3.1-zh_CN.zip压缩包</li>\n<li>将wordpress文件夹拷贝到UPUPW发布根目录/htdocs文件夹下</li>\n<li>打来地址<a href=\"http://127.0.0.1/wordpress，根据开始安装\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1/wordpress，根据开始安装</a></li>\n<li>输入刚才配置的数据库名，用户名，密码，点击提交进行</li>\n<li>设置站点标题，后台登陆用户名，后台密码，邮件地址完成安装</li>\n<li>再次打开地址<a href=\"http://127.0.0.1/wordpress测试安装完成\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1/wordpress测试安装完成</a><br><img src=\"http://7xohph.com1.z0.glb.clouddn.com/05120105.jpg\" alt></li>\n</ol>\n</li>\n</ul>\n<h3 id=\"WordPress相关资源\"><a href=\"#WordPress相关资源\" class=\"headerlink\" title=\"WordPress相关资源\"></a>WordPress相关资源</h3><ul>\n<li><p>推荐主题 ：<a href=\"http://www.weisay.com/blog/\" target=\"_blank\" rel=\"noopener\">威言威语</a>     <a href=\"http://www.prower.cn/\" target=\"_blank\" rel=\"noopener\">prower</a></p>\n</li>\n<li><p>推荐插件 ： <a href=\"http://duoshuo.com/\" target=\"_blank\" rel=\"noopener\">多说</a> （评论快速提交，文章聚合发布）   <a href=\"http://developer.qiniu.com/download/index.html\" target=\"_blank\" rel=\"noopener\">七牛镜像存储wordpress 插件</a>     <a href=\"http://www.youpzt.com/267.html\" target=\"_blank\" rel=\"noopener\">youpzt-optimizer</a>（网站优化工具）</p>\n</li>\n<li><p><a href=\"http://www.oschina.net/news/55174/nextapp-opensource\" target=\"_blank\" rel=\"noopener\">NextApp</a> —— 开源的WordPress手机博客 App 自动生成系统</p>\n</li>\n</ul>\n<h2 id=\"51offer-Android重构之Architecture-xpleemoon\"><a href=\"#51offer-Android重构之Architecture-xpleemoon\" class=\"headerlink\" title=\"51offer Android重构之Architecture - xpleemoon\"></a>51offer Android重构之Architecture - xpleemoon</h2><h3 id=\"历史\"><a href=\"#历史\" class=\"headerlink\" title=\"历史\"></a>历史</h3><ul>\n<li>我们的app经历了一次重构，在重构过程中将IDE切换到Android Studio，并且编译脚本从Ant切换到了Gradle。</li>\n<li>不介绍IDE和Gradle的优势，主要介绍重构后app的Architecture相关部分。</li>\n</ul>\n<blockquote>\n<p>从0到1是一个开始，再从1到N又是另一个开始。</p>\n</blockquote>\n<h3 id=\"Architecture\"><a href=\"#Architecture\" class=\"headerlink\" title=\"Architecture\"></a>Architecture</h3><ul>\n<li>当前我们的结构主要为4层：<ol>\n<li>app</li>\n<li>core</li>\n<li>lib</li>\n<li>model</li>\n</ol>\n</li>\n</ul>\n<p><img src=\"http://7xohph.com1.z0.glb.clouddn.com/X3.jpg\" alt=\"project结构\"></p>\n<ul>\n<li>app依赖core，而core依赖lib和model。随着以后的业务发展、产品迭代或者有更好的结构划分，会再做调整。</li>\n</ul>\n<p><img src=\"http://7xohph.com1.z0.glb.clouddn.com/X1.jpg\" alt=\"module依赖\"></p>\n<h3 id=\"app——展现层（presention）\"><a href=\"#app——展现层（presention）\" class=\"headerlink\" title=\"app——展现层（presention）\"></a>app——展现层（presention）</h3><ul>\n<li>用于页面展现，主要包含MVP模式中的VP。我们对V采用接口的方式去定义，然后让Activity或者Fragment去实现V接口，这样我们就达到接口编程的目的，P只需要关注V接口即可。以注册中的地区列表页面为例</li>\n</ul>\n<p><img src=\"http://7xohph.com1.z0.glb.clouddn.com/X4.jpg\" alt=\"VP\"></p>\n<ul>\n<li>V</li>\n</ul>\n<pre><code class=\"java\">/**\n * 地区view，MVP－V\n */\npublic interface IRegionView {\n    /**\n     * 搜索更新\n     */\n    void search2Update();\n}\n</code></pre>\n<ul>\n<li>P</li>\n</ul>\n<pre><code class=\"java\">/**\n * 国家地区，MVP－P\n */\npublic class RegionPresenter {\n    private List&lt;Region&gt; mRegions = OFRRegionHelper.getRegions();\n\n    /**\n     * 获取地区列表\n     *\n     * @return\n     */\n    public List&lt;Region&gt; getRegions() {\n        return mRegions;\n    }\n\n    /**\n     * 搜索\n     *\n     * @param regionView\n     * @param searchRegion\n     */\n    public void search(@NonNull IRegionView regionView, String searchRegion) {\n        mRegions.clear();\n        if (TextUtils.isEmpty(searchRegion)) {\n            mRegions.addAll(OFRRegionHelper.getRegions());\n        } else {\n            mRegions.addAll(OFRRegionHelper.searchRegions(searchRegion));\n        }\n        regionView.search2Update();\n    }\n}\n</code></pre>\n<ul>\n<li>另外，我们的app有太多的业务逻辑，所以我们也使用了比较多的策略模式，方便以后的扩展和维护。比如不同的国家，它在意向单展现时就有不同的表现：<ul>\n<li>可以同时选择的最多意向单数量</li>\n<li>每个学校可以同时选择的最多专业数量 </li>\n<li>意向单名字</li>\n</ul>\n</li>\n<li>于是，我们就对此采用了策略模式</li>\n</ul>\n<p><img src=\"http://7xohph.com1.z0.glb.clouddn.com/X2.jpg\" alt=\"国家意向单策略图\"></p>\n<ul>\n<li>国家意向单策略接口</li>\n</ul>\n<pre><code class=\"java\">/**\n * 国家策略\n * &lt;ul&gt;\n * &lt;li&gt;不同国家可选的意向单数量不同，具体见{@link #maxCount2Select()}&lt;/li&gt;\n * &lt;li&gt;不同国家的学校专业可选数量不同，具体见{@link #maxCountOfPerSchool2Select()}&lt;/li&gt;\n * &lt;/ul&gt;\n */\npublic interface ICountryPurpose {\n    /**\n     * 国家可以同时选择的最多意向单数量\n     *\n     * @return\n     */\n    int maxCount2Select();\n\n    /**\n     * 每个学校可以同时选择的最多专业数量\n     *\n     * @return\n     */\n    int maxCountOfPerSchool2Select();\n\n    /**\n     * 意向单名字，目前可用名字为：\n     * &lt;ol&gt;\n     * &lt;li&gt;专业&lt;/li&gt;\n     * &lt;li&gt;入学时间，当前只限日本&lt;/&gt;\n     * &lt;/ol&gt;\n     *\n     * @param ctx\n     * @return\n     */\n    String getName(@NonNull Context ctx);\n}\n</code></pre>\n<h3 id=\"core\"><a href=\"#core\" class=\"headerlink\" title=\"core\"></a>core</h3><ul>\n<li>核心层，主要用于应用相关的URL拼接、图片加载、网络请求、json解析、第三方平台、配置和工具。</li>\n</ul>\n<h3 id=\"lib\"><a href=\"#lib\" class=\"headerlink\" title=\"lib\"></a>lib</h3><ul>\n<li>通用库层，不依赖于应用的任何业务，方便快速的移植到其它项目.</li>\n</ul>\n<h3 id=\"model\"><a href=\"#model\" class=\"headerlink\" title=\"model\"></a>model</h3><ul>\n<li>数据层，作为MVP的M，用于应用的数据模型.</li>\n</ul>\n<h2 id=\"简单HTML5-吴明\"><a href=\"#简单HTML5-吴明\" class=\"headerlink\" title=\"简单HTML5 吴明\"></a>简单HTML5 吴明</h2><ul>\n<li><a href=\"http://www.17sucai.com/pins/demoshow/4583\" target=\"_blank\" rel=\"noopener\">烟火效果</a></li>\n<li><a href=\"http://www.html5tricks.com/demo/html5-css3-404-animation/index.html\" target=\"_blank\" rel=\"noopener\">404动画</a></li>\n<li><a href=\"http://keleyi.com/keleyi/phtml/html5/31.htm\" target=\"_blank\" rel=\"noopener\">爱心树</a></li>\n<li>开发ide storm</li>\n<li>目录结构<ul>\n<li>dist:第三库存放地方，以下为存放指定文件类型目录<ul>\n<li>css</li>\n<li>js</li>\n<li>doc</li>\n<li>img</li>\n</ul>\n</li>\n<li>src:项目指定文件类型目录<ul>\n<li>css</li>\n<li>js</li>\n<li>doc</li>\n<li>img  </li>\n</ul>\n</li>\n</ul>\n</li>\n<li>简单代码</li>\n</ul>\n<pre><code>&lt;!--html5网页声明--&gt;\n&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;title&gt;mobile&lt;/title&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;!-- 此处还可以插入其他meta,样式单等信息--&gt;\n    &lt;script type=&quot;text/javascript&quot;&gt;&lt;/script&gt;\n\n&lt;/head&gt;\n\n&lt;body&gt;\n&lt;!--页面部分--&gt;\n&lt;p&gt;现实是残酷的,别做梦,从hello word开始吧!&lt;/p&gt;\n&lt;canvas id=&quot;canvas&quot;&gt;不支持html5&lt;/canvas&gt;\n\n\n&lt;script type=&quot;text/javascript&quot;&gt;\n    &lt;!-- 获取内容中id为canvas的元素--&gt;\n    var canvas = document.getElementById(&#39;canvas&#39;);\n//    获取canvas的环境,\n    var ctx = canvas.getContext(&#39;2d&#39;);\n//      填充的样式为红色\n    ctx.fillStyle = &#39;#ff0000&#39;;\n    ctx.st//    画一个矩形,位置x,y,w,h\n    ctx.fillRect(0, 0, 600, 100);\n&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><ul>\n<li>参考链接<ul>\n<li><a href=\"http://caniuse.com/\" target=\"_blank\" rel=\"noopener\">链接一</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML\" target=\"_blank\" rel=\"noopener\">链接二</a></li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Ruby-on-Rails-初体验-王胜\"><a href=\"#Ruby-on-Rails-初体验-王胜\" class=\"headerlink\" title=\"Ruby on Rails 初体验 - 王胜\"></a>Ruby on Rails 初体验 - 王胜</h2><h3 id=\"使用命令行快速创建应用的步骤\"><a href=\"#使用命令行快速创建应用的步骤\" class=\"headerlink\" title=\"使用命令行快速创建应用的步骤\"></a>使用命令行快速创建应用的步骤</h3><ul>\n<li><p>创建应用程序</p>\n<pre><code class=\"Shell\">$rails new hello -d mysql\n</code></pre>\n<p><strong>备注</strong> 这里演示使用mysql作为数据持久层</p>\n</li>\n<li><p>浏览hello world界面</p>\n<pre><code class=\"Shell\">$cd hello\n$rake db:create RAILS_ENV=&#39;development&#39; // 创建开发数据库\n$bin/rails server\n</code></pre>\n<p><strong>备注</strong> 由于这里的rails版本是4.2.1，与msqyl2的最高版本有不兼容行，所以需要手动将Gemfile中mysql2降级。降级之后执行bundle install。</p>\n<pre><code>gem &#39;mysql2&#39; -&gt; gem &#39;mysql2&#39;, &#39;~&gt; 0.3.18&#39;\n</code></pre></li>\n<li><p>使用脚手架，创建模型、数据迁移脚本以及控制器和试图</p>\n<pre><code class=\"Shell\">$bin/rails generate scaffold Person name:string age:integer\n</code></pre>\n</li>\n<li><p>执行数据迁移</p>\n<pre><code class=\"Shell\">$bin/rake db:migrate RAILS_ENV=development\n</code></pre>\n</li>\n<li><p>启动应用</p>\n<pre><code class=\"Shell\">$bin/rails server\n</code></pre>\n</li>\n<li><p>浏览效果</p>\n<pre><code>http://localhost:3000/people\n</code></pre></li>\n</ul>\n<p><strong>备注</strong></p>\n<p>此演示项目，ruby、gems和Rails的版本信息如下:</p>\n<ul>\n<li>ruby: 2.0.0p481</li>\n<li>rubygems: 2.4.5</li>\n<li>rails: 4.2.1</li>\n</ul>\n<p>参考：</p>\n<ul>\n<li><a href=\"http://guides.rubyonrails.org/command_line.html\" target=\"_blank\" rel=\"noopener\">rubyonrails.org</a></li>\n</ul>\n<h2 id=\"矢量图在Android-上应用-王进\"><a href=\"#矢量图在Android-上应用-王进\" class=\"headerlink\" title=\"矢量图在Android 上应用 - 王进\"></a>矢量图在Android 上应用 - 王进</h2><h3 id=\"VectorDrawable\"><a href=\"#VectorDrawable\" class=\"headerlink\" title=\"VectorDrawable\"></a>VectorDrawable</h3><p>示例：</p>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n        &lt;!--  intrinsic  size  of  the  drawable  --&gt;\n        android:height=&quot;300dp&quot;\n        android:width=&quot;300dp&quot;\n        &lt;!-- size of the virtual canvas --&gt;\n        android:viewportHeight=&quot;40&quot;\n        android:viewportWidth=&quot;40&quot;\n        &gt;\n        &lt;path android:fillColor=&quot;#ff00ff&quot;\n                android:pathData=&quot;M20.5,9.5\n                        c-1.955,0,-3.83,1.268,-4.5,3\n                        c-0.67,-1.732,-2.547,-3,-4.5,-3\n                        C8.957,9.5,7,11.432,7,14\n                        c0,3.53,3.793,6.257,9,11.5\n                        c5.207,-5.242,9,-7.97,9,-11.5\n                        C25,11.432,23.043,9.5,20.5,9.5z&quot;\n                /&gt;\n&lt;/vector&gt;\n</code></pre><h3 id=\"SVG→Vector\"><a href=\"#SVG→Vector\" class=\"headerlink\" title=\"SVG→Vector\"></a>SVG→Vector</h3><p>Android并不原生支持读取常见的向量文件格式，如ＳＶＧ<br>（主要是缺少ｃｓｓ支持），但是支持相同路径数据语法，<br>所以ＳＶＧ资源需要经过一定的转换；</p>\n<h3 id=\"使用SVG-Path-Data\"><a href=\"#使用SVG-Path-Data\" class=\"headerlink\" title=\"使用SVG Path Data\"></a>使用SVG Path Data</h3><ul>\n<li>M： move to 移动绘制点</li>\n<li>L：line to 直线</li>\n<li>Z：close 闭合</li>\n<li>C：cubic bezier 三次贝塞尔曲线</li>\n<li>Q：quatratic bezier 二次贝塞尔曲线</li>\n<li>A：ellipse 圆弧</li>\n</ul>\n<blockquote>\n<p>每个命令都有大小写形式，大写代表后面的参数是绝对坐标，小写表示相对坐标。参数之间用空格或逗号隔开</p>\n</blockquote>\n<p><strong>命令详解：</strong></p>\n<ul>\n<li>M (x y) 移动到x,y</li>\n<li>L (x y) 直线连到x,y，还有简化命令H(x) 水平连接、V(y)垂直连接</li>\n<li>Z，没有参数，连接起点和终点</li>\n<li>C(x1 y1 x2 y2 x y)，控制点x1,y1 x2,y2，终点x,y</li>\n<li>Q(x1 y1 x y)，控制点x1,y1，终点x,y</li>\n<li>A(rx ry x-axis-rotation large-arc-flag sweep-flag x y) <ul>\n<li>rx ry 椭圆半径 </li>\n<li>x-axis-rotation x轴旋转角度 </li>\n<li>large-arc-flag 为0时表示取小弧度，1时取大弧度 </li>\n<li>sweep-flag 0取逆时针方向，1取顺时针方向<br><img src=\"http://static.oschina.net/uploads/img/201510/01095231_IR6O.svg\" alt></li>\n</ul>\n</li>\n</ul>\n<p>详细参考：<a href=\"http://www.w3.org/TR/SVG11/paths.html#PathData\" target=\"_blank\" rel=\"noopener\">http://www.w3.org/TR/SVG11/paths.html#PathData</a></p>\n<h3 id=\"Icon-Font\"><a href=\"#Icon-Font\" class=\"headerlink\" title=\"Icon Font\"></a>Icon Font</h3><p>解决矢量图低版本不兼容问题</p>\n<p>详细参考：<br>1,<a href=\"http://blog.csdn.net/a345017062/article/details/46455745\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/a345017062/article/details/46455745</a><br>2,<a href=\"http://blog.csdn.net/goodlixueyong/article/details/41448483\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/goodlixueyong/article/details/41448483</a></p>\n<h2 id=\"WordPress快速建站-–杨俊构\"><a href=\"#WordPress快速建站-–杨俊构\" class=\"headerlink\" title=\"WordPress快速建站 –杨俊构\"></a>WordPress快速建站 –杨俊构</h2><h3 id=\"准备工具\"><a href=\"#准备工具\" class=\"headerlink\" title=\"准备工具\"></a>准备工具</h3><ul>\n<li><p>服务器php套件（ Nginx+PHP7.0）： <a href=\"http://www.upupw.net/\" target=\"_blank\" rel=\"noopener\">UPUPW绿色服务器</a></p>\n</li>\n<li><p>WordPress代码包：<a href=\"https://cn.wordpress.org/\" target=\"_blank\" rel=\"noopener\">wordpress-4.3.1-zh_CN</a></p>\n</li>\n</ul>\n<h3 id=\"操作步骤\"><a href=\"#操作步骤\" class=\"headerlink\" title=\"操作步骤\"></a>操作步骤</h3><ul>\n<li><p>配置服务器和数据库</p>\n<ol>\n<li>解压UPUPW_NP7.0-1511.7z 到本地目录</li>\n<li>打开解压包后的upupw.exe配置平台。<br><img src=\"http://7xohph.com1.z0.glb.clouddn.com/05120101.jpg\" alt></li>\n<li>输入“S1”开启全部服务</li>\n<li>打开地址 <a href=\"http://127.0.0.1/\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1/</a> 会看到UPUPWPHP探针页面<br><img src=\"http://7xohph.com1.z0.glb.clouddn.com/05120103.jpg\" alt></li>\n<li>打开地址 <a href=\"http://127.0.0.1/pmd/\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1/pmd/</a> 配置mysql数据库（默认用户名密码都是root）</li>\n<li>新建数据库，用户名，密码</li>\n<li>打开地址 <a href=\"http://127.0.0.1/\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1/</a> 使用数据库连接测试连接数据库是否正常</li>\n</ol>\n</li>\n<li><p>安装配置wordpress</p>\n<ol>\n<li>解压wordpress-4.3.1-zh_CN.zip压缩包</li>\n<li>将wordpress文件夹拷贝到UPUPW发布根目录/htdocs文件夹下</li>\n<li>打来地址<a href=\"http://127.0.0.1/wordpress，根据开始安装\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1/wordpress，根据开始安装</a></li>\n<li>输入刚才配置的数据库名，用户名，密码，点击提交进行</li>\n<li>设置站点标题，后台登陆用户名，后台密码，邮件地址完成安装</li>\n<li>再次打开地址<a href=\"http://127.0.0.1/wordpress测试安装完成\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1/wordpress测试安装完成</a><br><img src=\"http://7xohph.com1.z0.glb.clouddn.com/05120105.jpg\" alt></li>\n</ol>\n</li>\n</ul>\n<h3 id=\"WordPress相关资源\"><a href=\"#WordPress相关资源\" class=\"headerlink\" title=\"WordPress相关资源\"></a>WordPress相关资源</h3><ul>\n<li><p>推荐主题 ：<a href=\"http://www.weisay.com/blog/\" target=\"_blank\" rel=\"noopener\">威言威语</a>     <a href=\"http://www.prower.cn/\" target=\"_blank\" rel=\"noopener\">prower</a></p>\n</li>\n<li><p>推荐插件 ： <a href=\"http://duoshuo.com/\" target=\"_blank\" rel=\"noopener\">多说</a> （评论快速提交，文章聚合发布）   <a href=\"http://developer.qiniu.com/download/index.html\" target=\"_blank\" rel=\"noopener\">七牛镜像存储wordpress 插件</a>     <a href=\"http://www.youpzt.com/267.html\" target=\"_blank\" rel=\"noopener\">youpzt-optimizer</a>（网站优化工具）</p>\n</li>\n<li><p><a href=\"http://www.oschina.net/news/55174/nextapp-opensource\" target=\"_blank\" rel=\"noopener\">NextApp</a> —— 开源的WordPress手机博客 App 自动生成系统</p>\n</li>\n</ul>\n<h2 id=\"51offer-Android重构之Architecture-xpleemoon\"><a href=\"#51offer-Android重构之Architecture-xpleemoon\" class=\"headerlink\" title=\"51offer Android重构之Architecture - xpleemoon\"></a>51offer Android重构之Architecture - xpleemoon</h2><h3 id=\"历史\"><a href=\"#历史\" class=\"headerlink\" title=\"历史\"></a>历史</h3><ul>\n<li>我们的app经历了一次重构，在重构过程中将IDE切换到Android Studio，并且编译脚本从Ant切换到了Gradle。</li>\n<li>不介绍IDE和Gradle的优势，主要介绍重构后app的Architecture相关部分。</li>\n</ul>\n<blockquote>\n<p>从0到1是一个开始，再从1到N又是另一个开始。</p>\n</blockquote>\n<h3 id=\"Architecture\"><a href=\"#Architecture\" class=\"headerlink\" title=\"Architecture\"></a>Architecture</h3><ul>\n<li>当前我们的结构主要为4层：<ol>\n<li>app</li>\n<li>core</li>\n<li>lib</li>\n<li>model</li>\n</ol>\n</li>\n</ul>\n<p><img src=\"http://7xohph.com1.z0.glb.clouddn.com/X3.jpg\" alt=\"project结构\"></p>\n<ul>\n<li>app依赖core，而core依赖lib和model。随着以后的业务发展、产品迭代或者有更好的结构划分，会再做调整。</li>\n</ul>\n<p><img src=\"http://7xohph.com1.z0.glb.clouddn.com/X1.jpg\" alt=\"module依赖\"></p>\n<h3 id=\"app——展现层（presention）\"><a href=\"#app——展现层（presention）\" class=\"headerlink\" title=\"app——展现层（presention）\"></a>app——展现层（presention）</h3><ul>\n<li>用于页面展现，主要包含MVP模式中的VP。我们对V采用接口的方式去定义，然后让Activity或者Fragment去实现V接口，这样我们就达到接口编程的目的，P只需要关注V接口即可。以注册中的地区列表页面为例</li>\n</ul>\n<p><img src=\"http://7xohph.com1.z0.glb.clouddn.com/X4.jpg\" alt=\"VP\"></p>\n<ul>\n<li>V</li>\n</ul>\n<pre><code class=\"java\">/**\n * 地区view，MVP－V\n */\npublic interface IRegionView {\n    /**\n     * 搜索更新\n     */\n    void search2Update();\n}\n</code></pre>\n<ul>\n<li>P</li>\n</ul>\n<pre><code class=\"java\">/**\n * 国家地区，MVP－P\n */\npublic class RegionPresenter {\n    private List&lt;Region&gt; mRegions = OFRRegionHelper.getRegions();\n\n    /**\n     * 获取地区列表\n     *\n     * @return\n     */\n    public List&lt;Region&gt; getRegions() {\n        return mRegions;\n    }\n\n    /**\n     * 搜索\n     *\n     * @param regionView\n     * @param searchRegion\n     */\n    public void search(@NonNull IRegionView regionView, String searchRegion) {\n        mRegions.clear();\n        if (TextUtils.isEmpty(searchRegion)) {\n            mRegions.addAll(OFRRegionHelper.getRegions());\n        } else {\n            mRegions.addAll(OFRRegionHelper.searchRegions(searchRegion));\n        }\n        regionView.search2Update();\n    }\n}\n</code></pre>\n<ul>\n<li>另外，我们的app有太多的业务逻辑，所以我们也使用了比较多的策略模式，方便以后的扩展和维护。比如不同的国家，它在意向单展现时就有不同的表现：<ul>\n<li>可以同时选择的最多意向单数量</li>\n<li>每个学校可以同时选择的最多专业数量 </li>\n<li>意向单名字</li>\n</ul>\n</li>\n<li>于是，我们就对此采用了策略模式</li>\n</ul>\n<p><img src=\"http://7xohph.com1.z0.glb.clouddn.com/X2.jpg\" alt=\"国家意向单策略图\"></p>\n<ul>\n<li>国家意向单策略接口</li>\n</ul>\n<pre><code class=\"java\">/**\n * 国家策略\n * &lt;ul&gt;\n * &lt;li&gt;不同国家可选的意向单数量不同，具体见{@link #maxCount2Select()}&lt;/li&gt;\n * &lt;li&gt;不同国家的学校专业可选数量不同，具体见{@link #maxCountOfPerSchool2Select()}&lt;/li&gt;\n * &lt;/ul&gt;\n */\npublic interface ICountryPurpose {\n    /**\n     * 国家可以同时选择的最多意向单数量\n     *\n     * @return\n     */\n    int maxCount2Select();\n\n    /**\n     * 每个学校可以同时选择的最多专业数量\n     *\n     * @return\n     */\n    int maxCountOfPerSchool2Select();\n\n    /**\n     * 意向单名字，目前可用名字为：\n     * &lt;ol&gt;\n     * &lt;li&gt;专业&lt;/li&gt;\n     * &lt;li&gt;入学时间，当前只限日本&lt;/&gt;\n     * &lt;/ol&gt;\n     *\n     * @param ctx\n     * @return\n     */\n    String getName(@NonNull Context ctx);\n}\n</code></pre>\n<h3 id=\"core\"><a href=\"#core\" class=\"headerlink\" title=\"core\"></a>core</h3><ul>\n<li>核心层，主要用于应用相关的URL拼接、图片加载、网络请求、json解析、第三方平台、配置和工具。</li>\n</ul>\n<h3 id=\"lib\"><a href=\"#lib\" class=\"headerlink\" title=\"lib\"></a>lib</h3><ul>\n<li>通用库层，不依赖于应用的任何业务，方便快速的移植到其它项目.</li>\n</ul>\n<h3 id=\"model\"><a href=\"#model\" class=\"headerlink\" title=\"model\"></a>model</h3><ul>\n<li>数据层，作为MVP的M，用于应用的数据模型.</li>\n</ul>\n<h2 id=\"简单HTML5-吴明\"><a href=\"#简单HTML5-吴明\" class=\"headerlink\" title=\"简单HTML5 吴明\"></a>简单HTML5 吴明</h2><ul>\n<li><a href=\"http://www.17sucai.com/pins/demoshow/4583\" target=\"_blank\" rel=\"noopener\">烟火效果</a></li>\n<li><a href=\"http://www.html5tricks.com/demo/html5-css3-404-animation/index.html\" target=\"_blank\" rel=\"noopener\">404动画</a></li>\n<li><a href=\"http://keleyi.com/keleyi/phtml/html5/31.htm\" target=\"_blank\" rel=\"noopener\">爱心树</a></li>\n<li>开发ide storm</li>\n<li>目录结构<ul>\n<li>dist:第三库存放地方，以下为存放指定文件类型目录<ul>\n<li>css</li>\n<li>js</li>\n<li>doc</li>\n<li>img</li>\n</ul>\n</li>\n<li>src:项目指定文件类型目录<ul>\n<li>css</li>\n<li>js</li>\n<li>doc</li>\n<li>img  </li>\n</ul>\n</li>\n</ul>\n</li>\n<li>简单代码</li>\n</ul>\n<pre><code>&lt;!--html5网页声明--&gt;\n&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;title&gt;mobile&lt;/title&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;!-- 此处还可以插入其他meta,样式单等信息--&gt;\n    &lt;script type=&quot;text/javascript&quot;&gt;&lt;/script&gt;\n\n&lt;/head&gt;\n\n&lt;body&gt;\n&lt;!--页面部分--&gt;\n&lt;p&gt;现实是残酷的,别做梦,从hello word开始吧!&lt;/p&gt;\n&lt;canvas id=&quot;canvas&quot;&gt;不支持html5&lt;/canvas&gt;\n\n\n&lt;script type=&quot;text/javascript&quot;&gt;\n    &lt;!-- 获取内容中id为canvas的元素--&gt;\n    var canvas = document.getElementById(&#39;canvas&#39;);\n//    获取canvas的环境,\n    var ctx = canvas.getContext(&#39;2d&#39;);\n//      填充的样式为红色\n    ctx.fillStyle = &#39;#ff0000&#39;;\n    ctx.st//    画一个矩形,位置x,y,w,h\n    ctx.fillRect(0, 0, 600, 100);\n&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><ul>\n<li>参考链接<ul>\n<li><a href=\"http://caniuse.com/\" target=\"_blank\" rel=\"noopener\">链接一</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML\" target=\"_blank\" rel=\"noopener\">链接二</a></li>\n</ul>\n</li>\n</ul>\n"},{"title":"单位和度量","date":"2015-09-25T10:30:00.000Z","_content":"\n\n#### Android基本单位规范  \n##### 单位和度量\n- 像素密度\n    - 每英寸的像素数被称为“像素密度”。\n    - DPI =屏幕宽度（或高度）像素/屏幕宽度（或高度）英寸\n    - mdpi-160dpi,\n      hdpi-480x800-240dpi,\n      xhdpi-720x1280-320dpi,\n      xxhdpi-1080x1920-480dpi\n    - mipmap-hdpi,\n    \tdrawable-hdpi区别:用mipmap会缩放图片并优化性能。\n    - ![MacDown Screenshot](http://www.2cto.com/uploadfile/Collfiles/20150718/2015071808335256.png)\n- 密度独立像素\n\t- “密度独立”是指在屏幕上用不同的密度来统一的显示用户界面元素\n\t- ![MacDown Screenshot](http://wiki.jikexueyuan.com/project/material-design/images/4_5.png)\n\t- 1dp 和 160 dpi 屏幕的一个物理像素相等。计算 dp 的方法：\n\t\n\t```\n\tdp =(宽度像素*160)/ dpi\n\t```\n- 可扩展像素（sp）\n\t- 在为安卓系统开发程序时，可扩展的像素（SP）提供和DP一样的功能，但只是在字体上。一个 SP 的默认值和 DP 上的默认值一样。\n\t- density==scaledDensity,即1sp=1dp，\n\t- 还是采用dp替代sp,[为什么](http://www.oschina.net/question/272860_70761)\n\n```\n\tpublic static float applyDimension(int unit, float value,DisplayMetrics metrics)\n{\n    switch (unit) {\n    case COMPLEX_UNIT_PX:\n        return value;\n    case COMPLEX_UNIT_DIP:\n        return value * metrics.density;\n    case COMPLEX_UNIT_SP:\n        return value * metrics.scaledDensity;\n    case COMPLEX_UNIT_PT:\n        return value * metrics.xdpi * (1.0f/72);\n    case COMPLEX_UNIT_IN:\n        return value * metrics.xdpi;\n    case COMPLEX_UNIT_MM:\n        return value * metrics.xdpi * (1.0f/25.4f);\n    }\n    return 0;\n}\n```\n- pt(磅)，标准的长度单位，1pt＝1/72英寸，用于印刷业,买蛋糕的时候挺说最多\n- em,em指字体高,1em=16px,任意浏览器的默认字体高都是16px.\n\t\n##### 字体排版\n- 字体排版的缩放和基本样式\n\t- 同时使用过多的字体尺寸和样式可以很轻易的毁掉布局,最基本的样式集合就是基于 12、14、16、20 和 34 号的字体排版缩放,以下Google建议字体尺寸:\n\t![MacDown Screenshot](http://7xn0ue.com1.z0.glb.clouddn.com/style_typography_style1.png)\n- 基本色/色彩对比度\n\t-  最基本的常识是，相同颜色的背景和文字是很难阅读的。但有些人不知道的是，带有过强对比度的文本会有些炫目，同样难以阅读。\n\t-  文本应当满足对比度7:1的是最适合阅读,最低的对比度4.5:1(依据明度计算),\n\t-  Google对比度建议:![MacDown Screenshot](http://wiki.jikexueyuan.com/project/material-design/images/style-typography-16_large_mdpi.png)\n- 行高\n\t- 只有“主体”、“次要标题”、“大纲”等类似的样式中才允许使用自动换行。其它所有样式应当以单行形式出现。\n\t- ![MacDown Screenshot](http://7xn0ue.com1.z0.glb.clouddn.com/style_typography_lineheight_tall1.png)\n\t- For all styles, line height is 0.1em larger than the English-like languages. English and English-like languages mostly use a portion of the em box, often the lower portion below the x-height. Chinese, Japanese, and Korean (CJK) ideographic characters use the entire em box. Characters in tall languages often have long descenders and/or ascenders. To achieve the same design intention as English for CJK and to avoid potential text clipping between two lines next to each other for tall languages, the line height needs to be larger than in English for tall and dense languages.\n- 换行规则/连字符\n\t- 正确：\n\t![MacDown Screenshot](http://wiki.jikexueyuan.com/project/material-design/images/style-typography-32_large_mdpi.png)\n\t- 错误\n\t![MacDown Screenshot](http://wiki.jikexueyuan.com/project/material-design/images/style-typography-33_large_mdpi.png)\n- 每行字符\n \t- [每行应当保持在50-60个字符左右](http://baymard.com/blog/line-length-readability)\n \t- 太长,用户的眼睛将难以找到在文本上对焦。这是因为过长的文字导致用户难以判断一行的起始点，甚至在大段文字中出现读错行的现象\n \t- 太短，会导致眼睛来回扫视过于频繁，破坏阅读的节奏。过短的内容还会给人压力，导致用户完成本行阅读前过早跳转到下一行阅读(因此会错过潜在的重要信息)\n \t- ![MacDown Screenshot](http://7xn0ue.com1.z0.glb.clouddn.com/style_typography_styles_linelengths1.png)\n\n\t- ![MacDown Screenshot](http://7xn0ue.com1.z0.glb.clouddn.com/style_typography_styles_linelengths2.png)\n- 字间距\n\t- ![MacDown Screenshot](http://7xn0ue.com1.z0.glb.clouddn.com/style_typography_styles_tracking.png)\n\t\n\t\n","source":"_posts/单位和度量.md","raw":"title: 单位和度量\ndate: 2015-09-25  10:30:00\ntags: Android,dp,单位\n---\n\n\n#### Android基本单位规范  \n##### 单位和度量\n- 像素密度\n    - 每英寸的像素数被称为“像素密度”。\n    - DPI =屏幕宽度（或高度）像素/屏幕宽度（或高度）英寸\n    - mdpi-160dpi,\n      hdpi-480x800-240dpi,\n      xhdpi-720x1280-320dpi,\n      xxhdpi-1080x1920-480dpi\n    - mipmap-hdpi,\n    \tdrawable-hdpi区别:用mipmap会缩放图片并优化性能。\n    - ![MacDown Screenshot](http://www.2cto.com/uploadfile/Collfiles/20150718/2015071808335256.png)\n- 密度独立像素\n\t- “密度独立”是指在屏幕上用不同的密度来统一的显示用户界面元素\n\t- ![MacDown Screenshot](http://wiki.jikexueyuan.com/project/material-design/images/4_5.png)\n\t- 1dp 和 160 dpi 屏幕的一个物理像素相等。计算 dp 的方法：\n\t\n\t```\n\tdp =(宽度像素*160)/ dpi\n\t```\n- 可扩展像素（sp）\n\t- 在为安卓系统开发程序时，可扩展的像素（SP）提供和DP一样的功能，但只是在字体上。一个 SP 的默认值和 DP 上的默认值一样。\n\t- density==scaledDensity,即1sp=1dp，\n\t- 还是采用dp替代sp,[为什么](http://www.oschina.net/question/272860_70761)\n\n```\n\tpublic static float applyDimension(int unit, float value,DisplayMetrics metrics)\n{\n    switch (unit) {\n    case COMPLEX_UNIT_PX:\n        return value;\n    case COMPLEX_UNIT_DIP:\n        return value * metrics.density;\n    case COMPLEX_UNIT_SP:\n        return value * metrics.scaledDensity;\n    case COMPLEX_UNIT_PT:\n        return value * metrics.xdpi * (1.0f/72);\n    case COMPLEX_UNIT_IN:\n        return value * metrics.xdpi;\n    case COMPLEX_UNIT_MM:\n        return value * metrics.xdpi * (1.0f/25.4f);\n    }\n    return 0;\n}\n```\n- pt(磅)，标准的长度单位，1pt＝1/72英寸，用于印刷业,买蛋糕的时候挺说最多\n- em,em指字体高,1em=16px,任意浏览器的默认字体高都是16px.\n\t\n##### 字体排版\n- 字体排版的缩放和基本样式\n\t- 同时使用过多的字体尺寸和样式可以很轻易的毁掉布局,最基本的样式集合就是基于 12、14、16、20 和 34 号的字体排版缩放,以下Google建议字体尺寸:\n\t![MacDown Screenshot](http://7xn0ue.com1.z0.glb.clouddn.com/style_typography_style1.png)\n- 基本色/色彩对比度\n\t-  最基本的常识是，相同颜色的背景和文字是很难阅读的。但有些人不知道的是，带有过强对比度的文本会有些炫目，同样难以阅读。\n\t-  文本应当满足对比度7:1的是最适合阅读,最低的对比度4.5:1(依据明度计算),\n\t-  Google对比度建议:![MacDown Screenshot](http://wiki.jikexueyuan.com/project/material-design/images/style-typography-16_large_mdpi.png)\n- 行高\n\t- 只有“主体”、“次要标题”、“大纲”等类似的样式中才允许使用自动换行。其它所有样式应当以单行形式出现。\n\t- ![MacDown Screenshot](http://7xn0ue.com1.z0.glb.clouddn.com/style_typography_lineheight_tall1.png)\n\t- For all styles, line height is 0.1em larger than the English-like languages. English and English-like languages mostly use a portion of the em box, often the lower portion below the x-height. Chinese, Japanese, and Korean (CJK) ideographic characters use the entire em box. Characters in tall languages often have long descenders and/or ascenders. To achieve the same design intention as English for CJK and to avoid potential text clipping between two lines next to each other for tall languages, the line height needs to be larger than in English for tall and dense languages.\n- 换行规则/连字符\n\t- 正确：\n\t![MacDown Screenshot](http://wiki.jikexueyuan.com/project/material-design/images/style-typography-32_large_mdpi.png)\n\t- 错误\n\t![MacDown Screenshot](http://wiki.jikexueyuan.com/project/material-design/images/style-typography-33_large_mdpi.png)\n- 每行字符\n \t- [每行应当保持在50-60个字符左右](http://baymard.com/blog/line-length-readability)\n \t- 太长,用户的眼睛将难以找到在文本上对焦。这是因为过长的文字导致用户难以判断一行的起始点，甚至在大段文字中出现读错行的现象\n \t- 太短，会导致眼睛来回扫视过于频繁，破坏阅读的节奏。过短的内容还会给人压力，导致用户完成本行阅读前过早跳转到下一行阅读(因此会错过潜在的重要信息)\n \t- ![MacDown Screenshot](http://7xn0ue.com1.z0.glb.clouddn.com/style_typography_styles_linelengths1.png)\n\n\t- ![MacDown Screenshot](http://7xn0ue.com1.z0.glb.clouddn.com/style_typography_styles_linelengths2.png)\n- 字间距\n\t- ![MacDown Screenshot](http://7xn0ue.com1.z0.glb.clouddn.com/style_typography_styles_tracking.png)\n\t\n\t\n","slug":"单位和度量","published":1,"updated":"2021-09-10T07:04:21.946Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cktfeap47001zc2xxrc5623lw","content":"<h4 id=\"Android基本单位规范\"><a href=\"#Android基本单位规范\" class=\"headerlink\" title=\"Android基本单位规范\"></a>Android基本单位规范</h4><h5 id=\"单位和度量\"><a href=\"#单位和度量\" class=\"headerlink\" title=\"单位和度量\"></a>单位和度量</h5><ul>\n<li>像素密度<ul>\n<li>每英寸的像素数被称为“像素密度”。</li>\n<li>DPI =屏幕宽度（或高度）像素/屏幕宽度（或高度）英寸</li>\n<li>mdpi-160dpi,<br>hdpi-480x800-240dpi,<br>xhdpi-720x1280-320dpi,<br>xxhdpi-1080x1920-480dpi</li>\n<li>mipmap-hdpi,<br>  drawable-hdpi区别:用mipmap会缩放图片并优化性能。</li>\n<li><img src=\"http://www.2cto.com/uploadfile/Collfiles/20150718/2015071808335256.png\" alt=\"MacDown Screenshot\"></li>\n</ul>\n</li>\n<li><p>密度独立像素</p>\n<ul>\n<li>“密度独立”是指在屏幕上用不同的密度来统一的显示用户界面元素</li>\n<li><img src=\"http://wiki.jikexueyuan.com/project/material-design/images/4_5.png\" alt=\"MacDown Screenshot\"></li>\n<li><p>1dp 和 160 dpi 屏幕的一个物理像素相等。计算 dp 的方法：</p>\n<pre><code>dp =(宽度像素*160)/ dpi\n</code></pre></li>\n</ul>\n</li>\n<li>可扩展像素（sp）<ul>\n<li>在为安卓系统开发程序时，可扩展的像素（SP）提供和DP一样的功能，但只是在字体上。一个 SP 的默认值和 DP 上的默认值一样。</li>\n<li>density==scaledDensity,即1sp=1dp，</li>\n<li>还是采用dp替代sp,<a href=\"http://www.oschina.net/question/272860_70761\" target=\"_blank\" rel=\"noopener\">为什么</a></li>\n</ul>\n</li>\n</ul>\n<pre><code>    public static float applyDimension(int unit, float value,DisplayMetrics metrics)\n{\n    switch (unit) {\n    case COMPLEX_UNIT_PX:\n        return value;\n    case COMPLEX_UNIT_DIP:\n        return value * metrics.density;\n    case COMPLEX_UNIT_SP:\n        return value * metrics.scaledDensity;\n    case COMPLEX_UNIT_PT:\n        return value * metrics.xdpi * (1.0f/72);\n    case COMPLEX_UNIT_IN:\n        return value * metrics.xdpi;\n    case COMPLEX_UNIT_MM:\n        return value * metrics.xdpi * (1.0f/25.4f);\n    }\n    return 0;\n}\n</code></pre><ul>\n<li>pt(磅)，标准的长度单位，1pt＝1/72英寸，用于印刷业,买蛋糕的时候挺说最多</li>\n<li>em,em指字体高,1em=16px,任意浏览器的默认字体高都是16px.</li>\n</ul>\n<h5 id=\"字体排版\"><a href=\"#字体排版\" class=\"headerlink\" title=\"字体排版\"></a>字体排版</h5><ul>\n<li>字体排版的缩放和基本样式<ul>\n<li>同时使用过多的字体尺寸和样式可以很轻易的毁掉布局,最基本的样式集合就是基于 12、14、16、20 和 34 号的字体排版缩放,以下Google建议字体尺寸:<br><img src=\"http://7xn0ue.com1.z0.glb.clouddn.com/style_typography_style1.png\" alt=\"MacDown Screenshot\"></li>\n</ul>\n</li>\n<li>基本色/色彩对比度<ul>\n<li>最基本的常识是，相同颜色的背景和文字是很难阅读的。但有些人不知道的是，带有过强对比度的文本会有些炫目，同样难以阅读。</li>\n<li>文本应当满足对比度7:1的是最适合阅读,最低的对比度4.5:1(依据明度计算),</li>\n<li>Google对比度建议:<img src=\"http://wiki.jikexueyuan.com/project/material-design/images/style-typography-16_large_mdpi.png\" alt=\"MacDown Screenshot\"></li>\n</ul>\n</li>\n<li>行高<ul>\n<li>只有“主体”、“次要标题”、“大纲”等类似的样式中才允许使用自动换行。其它所有样式应当以单行形式出现。</li>\n<li><img src=\"http://7xn0ue.com1.z0.glb.clouddn.com/style_typography_lineheight_tall1.png\" alt=\"MacDown Screenshot\"></li>\n<li>For all styles, line height is 0.1em larger than the English-like languages. English and English-like languages mostly use a portion of the em box, often the lower portion below the x-height. Chinese, Japanese, and Korean (CJK) ideographic characters use the entire em box. Characters in tall languages often have long descenders and/or ascenders. To achieve the same design intention as English for CJK and to avoid potential text clipping between two lines next to each other for tall languages, the line height needs to be larger than in English for tall and dense languages.</li>\n</ul>\n</li>\n<li>换行规则/连字符<ul>\n<li>正确：<br><img src=\"http://wiki.jikexueyuan.com/project/material-design/images/style-typography-32_large_mdpi.png\" alt=\"MacDown Screenshot\"></li>\n<li>错误<br><img src=\"http://wiki.jikexueyuan.com/project/material-design/images/style-typography-33_large_mdpi.png\" alt=\"MacDown Screenshot\"></li>\n</ul>\n</li>\n<li><p>每行字符</p>\n<ul>\n<li><a href=\"http://baymard.com/blog/line-length-readability\" target=\"_blank\" rel=\"noopener\">每行应当保持在50-60个字符左右</a></li>\n<li>太长,用户的眼睛将难以找到在文本上对焦。这是因为过长的文字导致用户难以判断一行的起始点，甚至在大段文字中出现读错行的现象</li>\n<li>太短，会导致眼睛来回扫视过于频繁，破坏阅读的节奏。过短的内容还会给人压力，导致用户完成本行阅读前过早跳转到下一行阅读(因此会错过潜在的重要信息)</li>\n<li><p><img src=\"http://7xn0ue.com1.z0.glb.clouddn.com/style_typography_styles_linelengths1.png\" alt=\"MacDown Screenshot\"></p>\n<ul>\n<li><img src=\"http://7xn0ue.com1.z0.glb.clouddn.com/style_typography_styles_linelengths2.png\" alt=\"MacDown Screenshot\"></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>字间距<ul>\n<li><img src=\"http://7xn0ue.com1.z0.glb.clouddn.com/style_typography_styles_tracking.png\" alt=\"MacDown Screenshot\"></li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"Android基本单位规范\"><a href=\"#Android基本单位规范\" class=\"headerlink\" title=\"Android基本单位规范\"></a>Android基本单位规范</h4><h5 id=\"单位和度量\"><a href=\"#单位和度量\" class=\"headerlink\" title=\"单位和度量\"></a>单位和度量</h5><ul>\n<li>像素密度<ul>\n<li>每英寸的像素数被称为“像素密度”。</li>\n<li>DPI =屏幕宽度（或高度）像素/屏幕宽度（或高度）英寸</li>\n<li>mdpi-160dpi,<br>hdpi-480x800-240dpi,<br>xhdpi-720x1280-320dpi,<br>xxhdpi-1080x1920-480dpi</li>\n<li>mipmap-hdpi,<br>  drawable-hdpi区别:用mipmap会缩放图片并优化性能。</li>\n<li><img src=\"http://www.2cto.com/uploadfile/Collfiles/20150718/2015071808335256.png\" alt=\"MacDown Screenshot\"></li>\n</ul>\n</li>\n<li><p>密度独立像素</p>\n<ul>\n<li>“密度独立”是指在屏幕上用不同的密度来统一的显示用户界面元素</li>\n<li><img src=\"http://wiki.jikexueyuan.com/project/material-design/images/4_5.png\" alt=\"MacDown Screenshot\"></li>\n<li><p>1dp 和 160 dpi 屏幕的一个物理像素相等。计算 dp 的方法：</p>\n<pre><code>dp =(宽度像素*160)/ dpi\n</code></pre></li>\n</ul>\n</li>\n<li>可扩展像素（sp）<ul>\n<li>在为安卓系统开发程序时，可扩展的像素（SP）提供和DP一样的功能，但只是在字体上。一个 SP 的默认值和 DP 上的默认值一样。</li>\n<li>density==scaledDensity,即1sp=1dp，</li>\n<li>还是采用dp替代sp,<a href=\"http://www.oschina.net/question/272860_70761\" target=\"_blank\" rel=\"noopener\">为什么</a></li>\n</ul>\n</li>\n</ul>\n<pre><code>    public static float applyDimension(int unit, float value,DisplayMetrics metrics)\n{\n    switch (unit) {\n    case COMPLEX_UNIT_PX:\n        return value;\n    case COMPLEX_UNIT_DIP:\n        return value * metrics.density;\n    case COMPLEX_UNIT_SP:\n        return value * metrics.scaledDensity;\n    case COMPLEX_UNIT_PT:\n        return value * metrics.xdpi * (1.0f/72);\n    case COMPLEX_UNIT_IN:\n        return value * metrics.xdpi;\n    case COMPLEX_UNIT_MM:\n        return value * metrics.xdpi * (1.0f/25.4f);\n    }\n    return 0;\n}\n</code></pre><ul>\n<li>pt(磅)，标准的长度单位，1pt＝1/72英寸，用于印刷业,买蛋糕的时候挺说最多</li>\n<li>em,em指字体高,1em=16px,任意浏览器的默认字体高都是16px.</li>\n</ul>\n<h5 id=\"字体排版\"><a href=\"#字体排版\" class=\"headerlink\" title=\"字体排版\"></a>字体排版</h5><ul>\n<li>字体排版的缩放和基本样式<ul>\n<li>同时使用过多的字体尺寸和样式可以很轻易的毁掉布局,最基本的样式集合就是基于 12、14、16、20 和 34 号的字体排版缩放,以下Google建议字体尺寸:<br><img src=\"http://7xn0ue.com1.z0.glb.clouddn.com/style_typography_style1.png\" alt=\"MacDown Screenshot\"></li>\n</ul>\n</li>\n<li>基本色/色彩对比度<ul>\n<li>最基本的常识是，相同颜色的背景和文字是很难阅读的。但有些人不知道的是，带有过强对比度的文本会有些炫目，同样难以阅读。</li>\n<li>文本应当满足对比度7:1的是最适合阅读,最低的对比度4.5:1(依据明度计算),</li>\n<li>Google对比度建议:<img src=\"http://wiki.jikexueyuan.com/project/material-design/images/style-typography-16_large_mdpi.png\" alt=\"MacDown Screenshot\"></li>\n</ul>\n</li>\n<li>行高<ul>\n<li>只有“主体”、“次要标题”、“大纲”等类似的样式中才允许使用自动换行。其它所有样式应当以单行形式出现。</li>\n<li><img src=\"http://7xn0ue.com1.z0.glb.clouddn.com/style_typography_lineheight_tall1.png\" alt=\"MacDown Screenshot\"></li>\n<li>For all styles, line height is 0.1em larger than the English-like languages. English and English-like languages mostly use a portion of the em box, often the lower portion below the x-height. Chinese, Japanese, and Korean (CJK) ideographic characters use the entire em box. Characters in tall languages often have long descenders and/or ascenders. To achieve the same design intention as English for CJK and to avoid potential text clipping between two lines next to each other for tall languages, the line height needs to be larger than in English for tall and dense languages.</li>\n</ul>\n</li>\n<li>换行规则/连字符<ul>\n<li>正确：<br><img src=\"http://wiki.jikexueyuan.com/project/material-design/images/style-typography-32_large_mdpi.png\" alt=\"MacDown Screenshot\"></li>\n<li>错误<br><img src=\"http://wiki.jikexueyuan.com/project/material-design/images/style-typography-33_large_mdpi.png\" alt=\"MacDown Screenshot\"></li>\n</ul>\n</li>\n<li><p>每行字符</p>\n<ul>\n<li><a href=\"http://baymard.com/blog/line-length-readability\" target=\"_blank\" rel=\"noopener\">每行应当保持在50-60个字符左右</a></li>\n<li>太长,用户的眼睛将难以找到在文本上对焦。这是因为过长的文字导致用户难以判断一行的起始点，甚至在大段文字中出现读错行的现象</li>\n<li>太短，会导致眼睛来回扫视过于频繁，破坏阅读的节奏。过短的内容还会给人压力，导致用户完成本行阅读前过早跳转到下一行阅读(因此会错过潜在的重要信息)</li>\n<li><p><img src=\"http://7xn0ue.com1.z0.glb.clouddn.com/style_typography_styles_linelengths1.png\" alt=\"MacDown Screenshot\"></p>\n<ul>\n<li><img src=\"http://7xn0ue.com1.z0.glb.clouddn.com/style_typography_styles_linelengths2.png\" alt=\"MacDown Screenshot\"></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>字间距<ul>\n<li><img src=\"http://7xn0ue.com1.z0.glb.clouddn.com/style_typography_styles_tracking.png\" alt=\"MacDown Screenshot\"></li>\n</ul>\n</li>\n</ul>\n"},{"title":"单元测试","date":"2016-07-15T15:30:00.000Z","_content":"\n\n- 注：基于[小创](http://chriszou.com/)分享的总结\n\n#### 明确概念\n- 单元测试 or 集成测试：\n- 单元测试在[维基百科](https://zh.wikipedia.org/wiki/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95)是这样定义的\n\n```\n单元测试（英语：Unit Testing）又称为模块测试, 是针对程序模块（软件设计的最小单位）来进行正确性检验的测试工作。程序单元是应用的最小可测试部件。在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类（超类）、抽象类、或者派生类（子类）中的方法。\n```\n集成测试在[维基百科](https://zh.wikipedia.org/wiki/%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95)的定义\n```\n集成测试,整合测试又称组装测试，即对程序模块采用一次性或增殖方式组装起来，对系统的接口进行正确性检验的测试工作。整合测试一般在单元测试之后、系统测试之前进行。实践表明，有时模块虽然可以单独工作，但是并不能保证组装起来也可以同时工作\n```\n有没有理解?那我们在借鉴下《单元测试的艺术》对单元测试和集成测试的定义：\n\n```\n一个单元测试时一段自动化的代码，这段代码调用被测试的工作单元，之后对这个单元的单个最终结果的某些假设进行检验。单元测试几乎都是用单元测试框架编写。单元测试容易编写，能快速运行。单元测试可靠，可读，并且可维护。只要产品代码不发生变化，单元测试的结果是稳定的。\n```\n\n```\n集成测试是对一个工作单元进行的测试，这个测试对被测试的工作单元没有完全控制，并使用该单元的一个或者多个真实依赖物，例如时间，网络，数据库，线程或随机数产生器等。\n```\n现在应该了解吧，没有了解不要紧，我们再通过他们关系比对\n 那单元测试和集成测试的关系是怎么样了？\n ![单元测试和集成测试](http://7xod3k.com1.z0.glb.clouddn.com/qtijqabixtlihxsuujkwnlzelrqnwqnz)\n [链接](http://chriszou.com/2016/04/13/android-unit-testing-start-from-what.html)\n#### 优点\n- 保证代码质量，防止bug或尽早发现bug的作用\n- 改善代码的设计，节约开发调试时间\n- 大大减少重构中手动验证正确性的时间。\n- 在写单元测试的时候也能发现方法乃至系统结构设计的不合理\n\n- 前面都是官方文字，现在讲点实在的。单元测试就是测试方法，方法我们又分为两种\n\t- 有返回值方法\n\t- 无返回值方法\n- 有返回值方法，我们测试这个方法直接通过测试这个方法返回的值是否跟你预期一样。我们就以一个登陆的demo来解析吧\n\t- 环境\n\t\t- IDE:Android Studio\n\t\t- Java测试库:junit，在build.gradle配置\n\t\t\n\t\t````\n\t\ttestCompile 'junit:junit:4.12'\n\t\t````\n   \n![目录结构](http://upload-images.jianshu.io/upload_images/1534431-784a1cb7911ccafa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n````\n  public class ExampleUnitTest {\n    @Test\n    public void addition_isCorrect() throws Exception {\n        assertEquals(4, 2 + 2);\n    }\n}\n````\n这个是新近一个Android新建的项目，生成的单元测试，直接通过点击方法的运行就能看的结果了。\n\n![代码](http://upload-images.jianshu.io/upload_images/1534431-6287758ce0be0d42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![运行结果](http://upload-images.jianshu.io/upload_images/1534431-82ee776821842f50.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n![代码](http://upload-images.jianshu.io/upload_images/1534431-d33f48cff28cc3a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![错误运行结果](http://upload-images.jianshu.io/upload_images/1534431-a0b2da8b0c4418b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n实际开发中我们也是通过get()获取指定值比较这个应该比较容易理解。重点就是第二个了\n\n- 无返回值方法，我们只能通过方法内某个对象的方法是否被调用并且调用参数一样。这里就要用到mock，mock其实就是虚拟一个对象，然后根据这个对象方法判断是否被调用，mock目前比较成熟的框架是Mockito，所有我们这里要引用Mockito框架\n\n````\ndependencies {    \ncompile fileTree(dir: 'libs', include: ['*.jar'])    \nandroidTestCompile('com.android.support.test.espresso:espresso-core:2.2.2', \n{        \n  exclude group: 'com.android.support', module: 'support-annotations'    })\n   \n compile 'com.android.support:appcompat-v7:23.4.0'    \ncompile 'com.android.support.constraint:constraint-layout:1.0.0-alpha4'    \n//以下测试框架    \ntestCompile \"junit:junit:4.12\"    \n//mockito    \ntestCompile \"org.mockito:mockito-core:1.+\"}\n````\n先看代码这个是一个简单的login代码\nActivity\n\n ````\n public class MainActivity extends AppCompatActivity implements View.OnClickListener, ILoginView {\n\n    private EditText mUserNameView;\n    private EditText mPassWordView;\n    private LoginPresenter mPresenter;\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        findViewById(R.id.login).setOnClickListener(this);\n        mUserNameView = (EditText) findViewById(R.id.username);\n        mPassWordView = (EditText) findViewById(R.id.password);\n        mPresenter = new LoginPresenter(this, HttpClient.getInstance());\n    }\n    @Override\n    public void onClick(View v) {\n        switch (v.getId()) {\n            case R.id.login:\n                String username = mUserNameView.getText().toString();\n                String password = mPassWordView.getText().toString();\n                if (TextUtils.isEmpty(username)) {\n                    Toast.makeText(this, \"用户名不能为空\", Toast.LENGTH_LONG).show();\n                    return;\n                } else if (TextUtils.isEmpty(password)) {\n                    Toast.makeText(this, \"密码不能为空\", Toast.LENGTH_LONG).show();\n                    return;\n                }\n                mPresenter.login(username, password);\n                break;\n        }\n    }\n\n    @Override\n    public void startHomeView() {\n        Toast.makeText(this, \"跳转主页\", Toast.LENGTH_LONG).show();\n    }\n\n    @Override\n    public void onError() {\n        Toast.makeText(this, \"密码错误\", Toast.LENGTH_LONG).show();\n    }\n}\n ````\nILoginView接口\n\n ````\n public interface ILoginView {\n    /**\n     * 跳转主页\n     */\n    void startHomeView();\n\n    /**\n     * 错误\n     */\n    void onError();\n}\n ````\n \nHttpClient\n\n````\npublic class HttpClient {\n    public static HttpClient mClient;\n\n    public static HttpClient getInstance() {\n        if (mClient == null) {\n            synchronized (HttpClient.class) {\n                if (mClient == null) {\n                    mClient = new HttpClient();\n                }\n            }\n        }\n        return mClient;\n    }\n\n    public interface Callback {\n        void onSuccess(String phone);\n\n        void onError(String error);\n    }\n\n    public void login(String username, String password, Callback callback) {\n        //为了简单,没有实际操作网络请求只是简单判断返回结果\n        if (username.length() < 5) {\n            callback.onError(\"用户名太短\");\n        } else {\n            callback.onSuccess(\"110110\");\n        }\n\n    }\n}\n\n````\nLoginPresenter\n\n````\npublic class LoginPresenter {\n    private ILoginView mLoginView;\n    private HttpClient mClient;\n\n    public LoginPresenter(@NonNull ILoginView mLoginView,@NonNull HttpClient client) {\n        this.mLoginView = mLoginView;\n        this.mClient = client;\n    }\n\n    public void login(String username, String password) {\n        mClient.login(username, password, new HttpClient.Callback() {\n            @Override\n            public void onSuccess(String phone) {\n                mLoginView.startHomeView();\n            }\n\n            @Override\n            public void onError(String error) {\n                mLoginView.onError();\n            }\n        });\n    }\n\n    public String getDevice() {\n        return \"nexus6p\";\n    }\n}\n\n````\n\n单元测试，mock出来的对象一定要set到这个LoginPresenter对象中，要不然报错org.mockito.exceptions.misusing.NotAMockException\n\n\n````\npublic class LoginPresenterTest {    \nprivate LoginPresenter mPresenter;    \nprivate ILoginView mLoginView;    \nprivate HttpClient mClient;    \n//初始化,每测试一个方法都会掉这个    \n@Before    \npublic void setUp() throws Exception {        \nmLoginView = Mockito.mock(ILoginView.class);        \nmClient = Mockito.mock(HttpClient.class);        \nmPresenter = new LoginPresenter(mLoginView, mClient);   \n }    \n@Test    \npublic void login() throws Exception {        \n//无返回值方法        \nmPresenter.login(\"123456\", \"123456\");   \n     Mockito.verify(mClient).login(\"123456\", \"123456\", null);    \n}    \n@Test    \npublic void loginTest() throws Exception {        \n//无返回值方法        \nmPresenter.loginTest(\"123456\", \"123456\");        \nMockito.verify(mClient).login(\"123456\", \"123456\", null);    \n}    \n@Test    \npublic void getDevice() throws Exception {        \n//有返回值方法\"        \nAssert.assertEquals(mPresenter.getDevice(), \"nexus6p\");    \n}\n}\n````\n运行看结果\n\n \n![结果](http://upload-images.jianshu.io/upload_images/1534431-6e66d663c451a176.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n可以看出login方法有问题，这个错误是正常的，就是我要的结果，可是loginTest方法运行正常，最主要的是他们callback为null，login方法执行的callback不是null，所有login方法执行的时候验证出来就是不一致的。\n\n\n- 资料\n\t- [Demo地址]()\n\t- [小创](http://chriszou.com/)\n\t- [美团点评技术团队](http://tech.meituan.com/)\n\t- [单元测试的艺术](http://www.ituring.com.cn/book/1336)\n","source":"_posts/单元测试.md","raw":"title: 单元测试\ndate: 2016-07-15  15:30:00\ntags:\ncategories: 单元测试\n---\n\n\n- 注：基于[小创](http://chriszou.com/)分享的总结\n\n#### 明确概念\n- 单元测试 or 集成测试：\n- 单元测试在[维基百科](https://zh.wikipedia.org/wiki/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95)是这样定义的\n\n```\n单元测试（英语：Unit Testing）又称为模块测试, 是针对程序模块（软件设计的最小单位）来进行正确性检验的测试工作。程序单元是应用的最小可测试部件。在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类（超类）、抽象类、或者派生类（子类）中的方法。\n```\n集成测试在[维基百科](https://zh.wikipedia.org/wiki/%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95)的定义\n```\n集成测试,整合测试又称组装测试，即对程序模块采用一次性或增殖方式组装起来，对系统的接口进行正确性检验的测试工作。整合测试一般在单元测试之后、系统测试之前进行。实践表明，有时模块虽然可以单独工作，但是并不能保证组装起来也可以同时工作\n```\n有没有理解?那我们在借鉴下《单元测试的艺术》对单元测试和集成测试的定义：\n\n```\n一个单元测试时一段自动化的代码，这段代码调用被测试的工作单元，之后对这个单元的单个最终结果的某些假设进行检验。单元测试几乎都是用单元测试框架编写。单元测试容易编写，能快速运行。单元测试可靠，可读，并且可维护。只要产品代码不发生变化，单元测试的结果是稳定的。\n```\n\n```\n集成测试是对一个工作单元进行的测试，这个测试对被测试的工作单元没有完全控制，并使用该单元的一个或者多个真实依赖物，例如时间，网络，数据库，线程或随机数产生器等。\n```\n现在应该了解吧，没有了解不要紧，我们再通过他们关系比对\n 那单元测试和集成测试的关系是怎么样了？\n ![单元测试和集成测试](http://7xod3k.com1.z0.glb.clouddn.com/qtijqabixtlihxsuujkwnlzelrqnwqnz)\n [链接](http://chriszou.com/2016/04/13/android-unit-testing-start-from-what.html)\n#### 优点\n- 保证代码质量，防止bug或尽早发现bug的作用\n- 改善代码的设计，节约开发调试时间\n- 大大减少重构中手动验证正确性的时间。\n- 在写单元测试的时候也能发现方法乃至系统结构设计的不合理\n\n- 前面都是官方文字，现在讲点实在的。单元测试就是测试方法，方法我们又分为两种\n\t- 有返回值方法\n\t- 无返回值方法\n- 有返回值方法，我们测试这个方法直接通过测试这个方法返回的值是否跟你预期一样。我们就以一个登陆的demo来解析吧\n\t- 环境\n\t\t- IDE:Android Studio\n\t\t- Java测试库:junit，在build.gradle配置\n\t\t\n\t\t````\n\t\ttestCompile 'junit:junit:4.12'\n\t\t````\n   \n![目录结构](http://upload-images.jianshu.io/upload_images/1534431-784a1cb7911ccafa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n````\n  public class ExampleUnitTest {\n    @Test\n    public void addition_isCorrect() throws Exception {\n        assertEquals(4, 2 + 2);\n    }\n}\n````\n这个是新近一个Android新建的项目，生成的单元测试，直接通过点击方法的运行就能看的结果了。\n\n![代码](http://upload-images.jianshu.io/upload_images/1534431-6287758ce0be0d42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![运行结果](http://upload-images.jianshu.io/upload_images/1534431-82ee776821842f50.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n![代码](http://upload-images.jianshu.io/upload_images/1534431-d33f48cff28cc3a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![错误运行结果](http://upload-images.jianshu.io/upload_images/1534431-a0b2da8b0c4418b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n实际开发中我们也是通过get()获取指定值比较这个应该比较容易理解。重点就是第二个了\n\n- 无返回值方法，我们只能通过方法内某个对象的方法是否被调用并且调用参数一样。这里就要用到mock，mock其实就是虚拟一个对象，然后根据这个对象方法判断是否被调用，mock目前比较成熟的框架是Mockito，所有我们这里要引用Mockito框架\n\n````\ndependencies {    \ncompile fileTree(dir: 'libs', include: ['*.jar'])    \nandroidTestCompile('com.android.support.test.espresso:espresso-core:2.2.2', \n{        \n  exclude group: 'com.android.support', module: 'support-annotations'    })\n   \n compile 'com.android.support:appcompat-v7:23.4.0'    \ncompile 'com.android.support.constraint:constraint-layout:1.0.0-alpha4'    \n//以下测试框架    \ntestCompile \"junit:junit:4.12\"    \n//mockito    \ntestCompile \"org.mockito:mockito-core:1.+\"}\n````\n先看代码这个是一个简单的login代码\nActivity\n\n ````\n public class MainActivity extends AppCompatActivity implements View.OnClickListener, ILoginView {\n\n    private EditText mUserNameView;\n    private EditText mPassWordView;\n    private LoginPresenter mPresenter;\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        findViewById(R.id.login).setOnClickListener(this);\n        mUserNameView = (EditText) findViewById(R.id.username);\n        mPassWordView = (EditText) findViewById(R.id.password);\n        mPresenter = new LoginPresenter(this, HttpClient.getInstance());\n    }\n    @Override\n    public void onClick(View v) {\n        switch (v.getId()) {\n            case R.id.login:\n                String username = mUserNameView.getText().toString();\n                String password = mPassWordView.getText().toString();\n                if (TextUtils.isEmpty(username)) {\n                    Toast.makeText(this, \"用户名不能为空\", Toast.LENGTH_LONG).show();\n                    return;\n                } else if (TextUtils.isEmpty(password)) {\n                    Toast.makeText(this, \"密码不能为空\", Toast.LENGTH_LONG).show();\n                    return;\n                }\n                mPresenter.login(username, password);\n                break;\n        }\n    }\n\n    @Override\n    public void startHomeView() {\n        Toast.makeText(this, \"跳转主页\", Toast.LENGTH_LONG).show();\n    }\n\n    @Override\n    public void onError() {\n        Toast.makeText(this, \"密码错误\", Toast.LENGTH_LONG).show();\n    }\n}\n ````\nILoginView接口\n\n ````\n public interface ILoginView {\n    /**\n     * 跳转主页\n     */\n    void startHomeView();\n\n    /**\n     * 错误\n     */\n    void onError();\n}\n ````\n \nHttpClient\n\n````\npublic class HttpClient {\n    public static HttpClient mClient;\n\n    public static HttpClient getInstance() {\n        if (mClient == null) {\n            synchronized (HttpClient.class) {\n                if (mClient == null) {\n                    mClient = new HttpClient();\n                }\n            }\n        }\n        return mClient;\n    }\n\n    public interface Callback {\n        void onSuccess(String phone);\n\n        void onError(String error);\n    }\n\n    public void login(String username, String password, Callback callback) {\n        //为了简单,没有实际操作网络请求只是简单判断返回结果\n        if (username.length() < 5) {\n            callback.onError(\"用户名太短\");\n        } else {\n            callback.onSuccess(\"110110\");\n        }\n\n    }\n}\n\n````\nLoginPresenter\n\n````\npublic class LoginPresenter {\n    private ILoginView mLoginView;\n    private HttpClient mClient;\n\n    public LoginPresenter(@NonNull ILoginView mLoginView,@NonNull HttpClient client) {\n        this.mLoginView = mLoginView;\n        this.mClient = client;\n    }\n\n    public void login(String username, String password) {\n        mClient.login(username, password, new HttpClient.Callback() {\n            @Override\n            public void onSuccess(String phone) {\n                mLoginView.startHomeView();\n            }\n\n            @Override\n            public void onError(String error) {\n                mLoginView.onError();\n            }\n        });\n    }\n\n    public String getDevice() {\n        return \"nexus6p\";\n    }\n}\n\n````\n\n单元测试，mock出来的对象一定要set到这个LoginPresenter对象中，要不然报错org.mockito.exceptions.misusing.NotAMockException\n\n\n````\npublic class LoginPresenterTest {    \nprivate LoginPresenter mPresenter;    \nprivate ILoginView mLoginView;    \nprivate HttpClient mClient;    \n//初始化,每测试一个方法都会掉这个    \n@Before    \npublic void setUp() throws Exception {        \nmLoginView = Mockito.mock(ILoginView.class);        \nmClient = Mockito.mock(HttpClient.class);        \nmPresenter = new LoginPresenter(mLoginView, mClient);   \n }    \n@Test    \npublic void login() throws Exception {        \n//无返回值方法        \nmPresenter.login(\"123456\", \"123456\");   \n     Mockito.verify(mClient).login(\"123456\", \"123456\", null);    \n}    \n@Test    \npublic void loginTest() throws Exception {        \n//无返回值方法        \nmPresenter.loginTest(\"123456\", \"123456\");        \nMockito.verify(mClient).login(\"123456\", \"123456\", null);    \n}    \n@Test    \npublic void getDevice() throws Exception {        \n//有返回值方法\"        \nAssert.assertEquals(mPresenter.getDevice(), \"nexus6p\");    \n}\n}\n````\n运行看结果\n\n \n![结果](http://upload-images.jianshu.io/upload_images/1534431-6e66d663c451a176.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n可以看出login方法有问题，这个错误是正常的，就是我要的结果，可是loginTest方法运行正常，最主要的是他们callback为null，login方法执行的callback不是null，所有login方法执行的时候验证出来就是不一致的。\n\n\n- 资料\n\t- [Demo地址]()\n\t- [小创](http://chriszou.com/)\n\t- [美团点评技术团队](http://tech.meituan.com/)\n\t- [单元测试的艺术](http://www.ituring.com.cn/book/1336)\n","slug":"单元测试","published":1,"updated":"2021-09-10T07:04:21.946Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cktfeap480022c2xxa2a4568q","content":"<ul>\n<li>注：基于<a href=\"http://chriszou.com/\" target=\"_blank\" rel=\"noopener\">小创</a>分享的总结</li>\n</ul>\n<h4 id=\"明确概念\"><a href=\"#明确概念\" class=\"headerlink\" title=\"明确概念\"></a>明确概念</h4><ul>\n<li>单元测试 or 集成测试：</li>\n<li>单元测试在<a href=\"https://zh.wikipedia.org/wiki/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95\" target=\"_blank\" rel=\"noopener\">维基百科</a>是这样定义的</li>\n</ul>\n<pre><code>单元测试（英语：Unit Testing）又称为模块测试, 是针对程序模块（软件设计的最小单位）来进行正确性检验的测试工作。程序单元是应用的最小可测试部件。在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类（超类）、抽象类、或者派生类（子类）中的方法。\n</code></pre><p>集成测试在<a href=\"https://zh.wikipedia.org/wiki/%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95\" target=\"_blank\" rel=\"noopener\">维基百科</a>的定义</p>\n<pre><code>集成测试,整合测试又称组装测试，即对程序模块采用一次性或增殖方式组装起来，对系统的接口进行正确性检验的测试工作。整合测试一般在单元测试之后、系统测试之前进行。实践表明，有时模块虽然可以单独工作，但是并不能保证组装起来也可以同时工作\n</code></pre><p>有没有理解?那我们在借鉴下《单元测试的艺术》对单元测试和集成测试的定义：</p>\n<pre><code>一个单元测试时一段自动化的代码，这段代码调用被测试的工作单元，之后对这个单元的单个最终结果的某些假设进行检验。单元测试几乎都是用单元测试框架编写。单元测试容易编写，能快速运行。单元测试可靠，可读，并且可维护。只要产品代码不发生变化，单元测试的结果是稳定的。\n</code></pre><pre><code>集成测试是对一个工作单元进行的测试，这个测试对被测试的工作单元没有完全控制，并使用该单元的一个或者多个真实依赖物，例如时间，网络，数据库，线程或随机数产生器等。\n</code></pre><p>现在应该了解吧，没有了解不要紧，我们再通过他们关系比对<br> 那单元测试和集成测试的关系是怎么样了？<br> <img src=\"http://7xod3k.com1.z0.glb.clouddn.com/qtijqabixtlihxsuujkwnlzelrqnwqnz\" alt=\"单元测试和集成测试\"><br> <a href=\"http://chriszou.com/2016/04/13/android-unit-testing-start-from-what.html\" target=\"_blank\" rel=\"noopener\">链接</a></p>\n<h4 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h4><ul>\n<li>保证代码质量，防止bug或尽早发现bug的作用</li>\n<li>改善代码的设计，节约开发调试时间</li>\n<li>大大减少重构中手动验证正确性的时间。</li>\n<li><p>在写单元测试的时候也能发现方法乃至系统结构设计的不合理</p>\n</li>\n<li><p>前面都是官方文字，现在讲点实在的。单元测试就是测试方法，方法我们又分为两种</p>\n<ul>\n<li>有返回值方法</li>\n<li>无返回值方法</li>\n</ul>\n</li>\n<li><p>有返回值方法，我们测试这个方法直接通过测试这个方法返回的值是否跟你预期一样。我们就以一个登陆的demo来解析吧</p>\n<ul>\n<li><p>环境</p>\n<ul>\n<li>IDE:Android Studio</li>\n<li><p>Java测试库:junit，在build.gradle配置</p>\n<pre><code>testCompile &#39;junit:junit:4.12&#39;\n</code></pre></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1534431-784a1cb7911ccafa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"目录结构\"></p>\n<pre><code>  public class ExampleUnitTest {\n    @Test\n    public void addition_isCorrect() throws Exception {\n        assertEquals(4, 2 + 2);\n    }\n}\n</code></pre><p>这个是新近一个Android新建的项目，生成的单元测试，直接通过点击方法的运行就能看的结果了。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1534431-6287758ce0be0d42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"代码\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1534431-82ee776821842f50.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"运行结果\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1534431-d33f48cff28cc3a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"代码\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1534431-a0b2da8b0c4418b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"错误运行结果\"><br>实际开发中我们也是通过get()获取指定值比较这个应该比较容易理解。重点就是第二个了</p>\n<ul>\n<li>无返回值方法，我们只能通过方法内某个对象的方法是否被调用并且调用参数一样。这里就要用到mock，mock其实就是虚拟一个对象，然后根据这个对象方法判断是否被调用，mock目前比较成熟的框架是Mockito，所有我们这里要引用Mockito框架</li>\n</ul>\n<pre><code>dependencies {    \ncompile fileTree(dir: &#39;libs&#39;, include: [&#39;*.jar&#39;])    \nandroidTestCompile(&#39;com.android.support.test.espresso:espresso-core:2.2.2&#39;, \n{        \n  exclude group: &#39;com.android.support&#39;, module: &#39;support-annotations&#39;    })\n\n compile &#39;com.android.support:appcompat-v7:23.4.0&#39;    \ncompile &#39;com.android.support.constraint:constraint-layout:1.0.0-alpha4&#39;    \n//以下测试框架    \ntestCompile &quot;junit:junit:4.12&quot;    \n//mockito    \ntestCompile &quot;org.mockito:mockito-core:1.+&quot;}\n</code></pre><p>先看代码这个是一个简单的login代码<br>Activity</p>\n<pre><code> public class MainActivity extends AppCompatActivity implements View.OnClickListener, ILoginView {\n\n    private EditText mUserNameView;\n    private EditText mPassWordView;\n    private LoginPresenter mPresenter;\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        findViewById(R.id.login).setOnClickListener(this);\n        mUserNameView = (EditText) findViewById(R.id.username);\n        mPassWordView = (EditText) findViewById(R.id.password);\n        mPresenter = new LoginPresenter(this, HttpClient.getInstance());\n    }\n    @Override\n    public void onClick(View v) {\n        switch (v.getId()) {\n            case R.id.login:\n                String username = mUserNameView.getText().toString();\n                String password = mPassWordView.getText().toString();\n                if (TextUtils.isEmpty(username)) {\n                    Toast.makeText(this, &quot;用户名不能为空&quot;, Toast.LENGTH_LONG).show();\n                    return;\n                } else if (TextUtils.isEmpty(password)) {\n                    Toast.makeText(this, &quot;密码不能为空&quot;, Toast.LENGTH_LONG).show();\n                    return;\n                }\n                mPresenter.login(username, password);\n                break;\n        }\n    }\n\n    @Override\n    public void startHomeView() {\n        Toast.makeText(this, &quot;跳转主页&quot;, Toast.LENGTH_LONG).show();\n    }\n\n    @Override\n    public void onError() {\n        Toast.makeText(this, &quot;密码错误&quot;, Toast.LENGTH_LONG).show();\n    }\n}\n</code></pre><p>ILoginView接口</p>\n<pre><code> public interface ILoginView {\n    /**\n     * 跳转主页\n     */\n    void startHomeView();\n\n    /**\n     * 错误\n     */\n    void onError();\n}\n</code></pre><p>HttpClient</p>\n<pre><code>public class HttpClient {\n    public static HttpClient mClient;\n\n    public static HttpClient getInstance() {\n        if (mClient == null) {\n            synchronized (HttpClient.class) {\n                if (mClient == null) {\n                    mClient = new HttpClient();\n                }\n            }\n        }\n        return mClient;\n    }\n\n    public interface Callback {\n        void onSuccess(String phone);\n\n        void onError(String error);\n    }\n\n    public void login(String username, String password, Callback callback) {\n        //为了简单,没有实际操作网络请求只是简单判断返回结果\n        if (username.length() &lt; 5) {\n            callback.onError(&quot;用户名太短&quot;);\n        } else {\n            callback.onSuccess(&quot;110110&quot;);\n        }\n\n    }\n}\n</code></pre><p>LoginPresenter</p>\n<pre><code>public class LoginPresenter {\n    private ILoginView mLoginView;\n    private HttpClient mClient;\n\n    public LoginPresenter(@NonNull ILoginView mLoginView,@NonNull HttpClient client) {\n        this.mLoginView = mLoginView;\n        this.mClient = client;\n    }\n\n    public void login(String username, String password) {\n        mClient.login(username, password, new HttpClient.Callback() {\n            @Override\n            public void onSuccess(String phone) {\n                mLoginView.startHomeView();\n            }\n\n            @Override\n            public void onError(String error) {\n                mLoginView.onError();\n            }\n        });\n    }\n\n    public String getDevice() {\n        return &quot;nexus6p&quot;;\n    }\n}\n</code></pre><p>单元测试，mock出来的对象一定要set到这个LoginPresenter对象中，要不然报错org.mockito.exceptions.misusing.NotAMockException</p>\n<pre><code>public class LoginPresenterTest {    \nprivate LoginPresenter mPresenter;    \nprivate ILoginView mLoginView;    \nprivate HttpClient mClient;    \n//初始化,每测试一个方法都会掉这个    \n@Before    \npublic void setUp() throws Exception {        \nmLoginView = Mockito.mock(ILoginView.class);        \nmClient = Mockito.mock(HttpClient.class);        \nmPresenter = new LoginPresenter(mLoginView, mClient);   \n }    \n@Test    \npublic void login() throws Exception {        \n//无返回值方法        \nmPresenter.login(&quot;123456&quot;, &quot;123456&quot;);   \n     Mockito.verify(mClient).login(&quot;123456&quot;, &quot;123456&quot;, null);    \n}    \n@Test    \npublic void loginTest() throws Exception {        \n//无返回值方法        \nmPresenter.loginTest(&quot;123456&quot;, &quot;123456&quot;);        \nMockito.verify(mClient).login(&quot;123456&quot;, &quot;123456&quot;, null);    \n}    \n@Test    \npublic void getDevice() throws Exception {        \n//有返回值方法&quot;        \nAssert.assertEquals(mPresenter.getDevice(), &quot;nexus6p&quot;);    \n}\n}\n</code></pre><p>运行看结果</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1534431-6e66d663c451a176.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"结果\"><br>可以看出login方法有问题，这个错误是正常的，就是我要的结果，可是loginTest方法运行正常，最主要的是他们callback为null，login方法执行的callback不是null，所有login方法执行的时候验证出来就是不一致的。</p>\n<ul>\n<li>资料<ul>\n<li><a href>Demo地址</a></li>\n<li><a href=\"http://chriszou.com/\" target=\"_blank\" rel=\"noopener\">小创</a></li>\n<li><a href=\"http://tech.meituan.com/\" target=\"_blank\" rel=\"noopener\">美团点评技术团队</a></li>\n<li><a href=\"http://www.ituring.com.cn/book/1336\" target=\"_blank\" rel=\"noopener\">单元测试的艺术</a></li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>注：基于<a href=\"http://chriszou.com/\" target=\"_blank\" rel=\"noopener\">小创</a>分享的总结</li>\n</ul>\n<h4 id=\"明确概念\"><a href=\"#明确概念\" class=\"headerlink\" title=\"明确概念\"></a>明确概念</h4><ul>\n<li>单元测试 or 集成测试：</li>\n<li>单元测试在<a href=\"https://zh.wikipedia.org/wiki/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95\" target=\"_blank\" rel=\"noopener\">维基百科</a>是这样定义的</li>\n</ul>\n<pre><code>单元测试（英语：Unit Testing）又称为模块测试, 是针对程序模块（软件设计的最小单位）来进行正确性检验的测试工作。程序单元是应用的最小可测试部件。在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类（超类）、抽象类、或者派生类（子类）中的方法。\n</code></pre><p>集成测试在<a href=\"https://zh.wikipedia.org/wiki/%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95\" target=\"_blank\" rel=\"noopener\">维基百科</a>的定义</p>\n<pre><code>集成测试,整合测试又称组装测试，即对程序模块采用一次性或增殖方式组装起来，对系统的接口进行正确性检验的测试工作。整合测试一般在单元测试之后、系统测试之前进行。实践表明，有时模块虽然可以单独工作，但是并不能保证组装起来也可以同时工作\n</code></pre><p>有没有理解?那我们在借鉴下《单元测试的艺术》对单元测试和集成测试的定义：</p>\n<pre><code>一个单元测试时一段自动化的代码，这段代码调用被测试的工作单元，之后对这个单元的单个最终结果的某些假设进行检验。单元测试几乎都是用单元测试框架编写。单元测试容易编写，能快速运行。单元测试可靠，可读，并且可维护。只要产品代码不发生变化，单元测试的结果是稳定的。\n</code></pre><pre><code>集成测试是对一个工作单元进行的测试，这个测试对被测试的工作单元没有完全控制，并使用该单元的一个或者多个真实依赖物，例如时间，网络，数据库，线程或随机数产生器等。\n</code></pre><p>现在应该了解吧，没有了解不要紧，我们再通过他们关系比对<br> 那单元测试和集成测试的关系是怎么样了？<br> <img src=\"http://7xod3k.com1.z0.glb.clouddn.com/qtijqabixtlihxsuujkwnlzelrqnwqnz\" alt=\"单元测试和集成测试\"><br> <a href=\"http://chriszou.com/2016/04/13/android-unit-testing-start-from-what.html\" target=\"_blank\" rel=\"noopener\">链接</a></p>\n<h4 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h4><ul>\n<li>保证代码质量，防止bug或尽早发现bug的作用</li>\n<li>改善代码的设计，节约开发调试时间</li>\n<li>大大减少重构中手动验证正确性的时间。</li>\n<li><p>在写单元测试的时候也能发现方法乃至系统结构设计的不合理</p>\n</li>\n<li><p>前面都是官方文字，现在讲点实在的。单元测试就是测试方法，方法我们又分为两种</p>\n<ul>\n<li>有返回值方法</li>\n<li>无返回值方法</li>\n</ul>\n</li>\n<li><p>有返回值方法，我们测试这个方法直接通过测试这个方法返回的值是否跟你预期一样。我们就以一个登陆的demo来解析吧</p>\n<ul>\n<li><p>环境</p>\n<ul>\n<li>IDE:Android Studio</li>\n<li><p>Java测试库:junit，在build.gradle配置</p>\n<pre><code>testCompile &#39;junit:junit:4.12&#39;\n</code></pre></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1534431-784a1cb7911ccafa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"目录结构\"></p>\n<pre><code>  public class ExampleUnitTest {\n    @Test\n    public void addition_isCorrect() throws Exception {\n        assertEquals(4, 2 + 2);\n    }\n}\n</code></pre><p>这个是新近一个Android新建的项目，生成的单元测试，直接通过点击方法的运行就能看的结果了。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1534431-6287758ce0be0d42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"代码\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1534431-82ee776821842f50.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"运行结果\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1534431-d33f48cff28cc3a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"代码\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1534431-a0b2da8b0c4418b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"错误运行结果\"><br>实际开发中我们也是通过get()获取指定值比较这个应该比较容易理解。重点就是第二个了</p>\n<ul>\n<li>无返回值方法，我们只能通过方法内某个对象的方法是否被调用并且调用参数一样。这里就要用到mock，mock其实就是虚拟一个对象，然后根据这个对象方法判断是否被调用，mock目前比较成熟的框架是Mockito，所有我们这里要引用Mockito框架</li>\n</ul>\n<pre><code>dependencies {    \ncompile fileTree(dir: &#39;libs&#39;, include: [&#39;*.jar&#39;])    \nandroidTestCompile(&#39;com.android.support.test.espresso:espresso-core:2.2.2&#39;, \n{        \n  exclude group: &#39;com.android.support&#39;, module: &#39;support-annotations&#39;    })\n\n compile &#39;com.android.support:appcompat-v7:23.4.0&#39;    \ncompile &#39;com.android.support.constraint:constraint-layout:1.0.0-alpha4&#39;    \n//以下测试框架    \ntestCompile &quot;junit:junit:4.12&quot;    \n//mockito    \ntestCompile &quot;org.mockito:mockito-core:1.+&quot;}\n</code></pre><p>先看代码这个是一个简单的login代码<br>Activity</p>\n<pre><code> public class MainActivity extends AppCompatActivity implements View.OnClickListener, ILoginView {\n\n    private EditText mUserNameView;\n    private EditText mPassWordView;\n    private LoginPresenter mPresenter;\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        findViewById(R.id.login).setOnClickListener(this);\n        mUserNameView = (EditText) findViewById(R.id.username);\n        mPassWordView = (EditText) findViewById(R.id.password);\n        mPresenter = new LoginPresenter(this, HttpClient.getInstance());\n    }\n    @Override\n    public void onClick(View v) {\n        switch (v.getId()) {\n            case R.id.login:\n                String username = mUserNameView.getText().toString();\n                String password = mPassWordView.getText().toString();\n                if (TextUtils.isEmpty(username)) {\n                    Toast.makeText(this, &quot;用户名不能为空&quot;, Toast.LENGTH_LONG).show();\n                    return;\n                } else if (TextUtils.isEmpty(password)) {\n                    Toast.makeText(this, &quot;密码不能为空&quot;, Toast.LENGTH_LONG).show();\n                    return;\n                }\n                mPresenter.login(username, password);\n                break;\n        }\n    }\n\n    @Override\n    public void startHomeView() {\n        Toast.makeText(this, &quot;跳转主页&quot;, Toast.LENGTH_LONG).show();\n    }\n\n    @Override\n    public void onError() {\n        Toast.makeText(this, &quot;密码错误&quot;, Toast.LENGTH_LONG).show();\n    }\n}\n</code></pre><p>ILoginView接口</p>\n<pre><code> public interface ILoginView {\n    /**\n     * 跳转主页\n     */\n    void startHomeView();\n\n    /**\n     * 错误\n     */\n    void onError();\n}\n</code></pre><p>HttpClient</p>\n<pre><code>public class HttpClient {\n    public static HttpClient mClient;\n\n    public static HttpClient getInstance() {\n        if (mClient == null) {\n            synchronized (HttpClient.class) {\n                if (mClient == null) {\n                    mClient = new HttpClient();\n                }\n            }\n        }\n        return mClient;\n    }\n\n    public interface Callback {\n        void onSuccess(String phone);\n\n        void onError(String error);\n    }\n\n    public void login(String username, String password, Callback callback) {\n        //为了简单,没有实际操作网络请求只是简单判断返回结果\n        if (username.length() &lt; 5) {\n            callback.onError(&quot;用户名太短&quot;);\n        } else {\n            callback.onSuccess(&quot;110110&quot;);\n        }\n\n    }\n}\n</code></pre><p>LoginPresenter</p>\n<pre><code>public class LoginPresenter {\n    private ILoginView mLoginView;\n    private HttpClient mClient;\n\n    public LoginPresenter(@NonNull ILoginView mLoginView,@NonNull HttpClient client) {\n        this.mLoginView = mLoginView;\n        this.mClient = client;\n    }\n\n    public void login(String username, String password) {\n        mClient.login(username, password, new HttpClient.Callback() {\n            @Override\n            public void onSuccess(String phone) {\n                mLoginView.startHomeView();\n            }\n\n            @Override\n            public void onError(String error) {\n                mLoginView.onError();\n            }\n        });\n    }\n\n    public String getDevice() {\n        return &quot;nexus6p&quot;;\n    }\n}\n</code></pre><p>单元测试，mock出来的对象一定要set到这个LoginPresenter对象中，要不然报错org.mockito.exceptions.misusing.NotAMockException</p>\n<pre><code>public class LoginPresenterTest {    \nprivate LoginPresenter mPresenter;    \nprivate ILoginView mLoginView;    \nprivate HttpClient mClient;    \n//初始化,每测试一个方法都会掉这个    \n@Before    \npublic void setUp() throws Exception {        \nmLoginView = Mockito.mock(ILoginView.class);        \nmClient = Mockito.mock(HttpClient.class);        \nmPresenter = new LoginPresenter(mLoginView, mClient);   \n }    \n@Test    \npublic void login() throws Exception {        \n//无返回值方法        \nmPresenter.login(&quot;123456&quot;, &quot;123456&quot;);   \n     Mockito.verify(mClient).login(&quot;123456&quot;, &quot;123456&quot;, null);    \n}    \n@Test    \npublic void loginTest() throws Exception {        \n//无返回值方法        \nmPresenter.loginTest(&quot;123456&quot;, &quot;123456&quot;);        \nMockito.verify(mClient).login(&quot;123456&quot;, &quot;123456&quot;, null);    \n}    \n@Test    \npublic void getDevice() throws Exception {        \n//有返回值方法&quot;        \nAssert.assertEquals(mPresenter.getDevice(), &quot;nexus6p&quot;);    \n}\n}\n</code></pre><p>运行看结果</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1534431-6e66d663c451a176.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"结果\"><br>可以看出login方法有问题，这个错误是正常的，就是我要的结果，可是loginTest方法运行正常，最主要的是他们callback为null，login方法执行的callback不是null，所有login方法执行的时候验证出来就是不一致的。</p>\n<ul>\n<li>资料<ul>\n<li><a href>Demo地址</a></li>\n<li><a href=\"http://chriszou.com/\" target=\"_blank\" rel=\"noopener\">小创</a></li>\n<li><a href=\"http://tech.meituan.com/\" target=\"_blank\" rel=\"noopener\">美团点评技术团队</a></li>\n<li><a href=\"http://www.ituring.com.cn/book/1336\" target=\"_blank\" rel=\"noopener\">单元测试的艺术</a></li>\n</ul>\n</li>\n</ul>\n"},{"title":"博客分享","date":"2015-06-05T23:04:29.000Z","_content":"\n\n### android学习网站 - 王胜\n\n- [Android官网](http://developer.android.com/index.html)\n  - 官方SDK\n  - 官方API文档\n  - 官方training教程\n  - 官方Sample【1.x之后的Android Studio有直接导入Sample的功能】\n- [任玉刚博客](http://blog.csdn.net/singwhatiwanna/)\n  专注Android底层实现机制解析\n\n#### android博客与学习网站 - 李仙鹏\n\n- [Android官方开发博客](http://android-developers.blogspot.hk)，并非[Android开发者官网](http://developer.android.com/index.html)，官方会维护更新，非常适合Android开发者学习。\n- [Android Development G+](https://plus.google.com/communities/105153134372062985968)\n- [Romain Guy](http://www.curious-creature.com/category/android/)(google android工程师)\n- [Trinea](http://www.trinea.cn)\n- [android开源项目分析](http://www.codekk.com/open-source-project-analysis)\n\n#### 博客框架与网站&&博客推荐 - 杨志平\n##### 常见博客框架\n\n- [Ghost](https://ghost.org) 优美简易（收费）\n\n\t- 范例见 [Onev博客](http://onevcat.com)\n\t- [开源代码](https://github.com/TryGhost/Ghost)\n\t- [开源主题样式](https://github.com/search?utf8=%E2%9C%93&q=Ghost+theme&type=Repositories&ref=searchresults)\n\t- [主题 - 官方](http://marketplace.ghost.org/)\n\n\n- [Octopress](http://octopress.org) 免费，比较繁琐\n\n\t- 范例见 [唐巧博客](http://blog.devtang.com)\n\t- [开源代码](https://github.com/imathis/octopress)\n\t- [主题样式](https://github.com/search?utf8=%E2%9C%93&q=Octopress+theme&type=Repositories&ref=searchresults)\n\n- [Hexo](http://hexo.io) 没用过\n\n\t- 范例见 [Onev博客](http://onevcat.com)\n\t- [开源代码](https://github.com/search?utf8=%E2%9C%93&q=hexo+theme&type=Repositories&ref=searchresults)\n\t- [主题样式 - 官方](http://hexo.io/themes/)\n\t- [开源主题样式](https://github.com/search?utf8=%E2%9C%93&q=hexo+theme&type=Repositories&ref=searchresults)\n\n##### 常见iOS开发博客网站\n\n- 国内\n\t- [onev](http://onevcat.com/)\n\t- [唐巧](http://blog.devtang.com/)\n\t- [limboy](http://limboy.me/)\n\t- [objc中国](http://objccn.io/)\n\t- [NSHipster中国](http://nshipster.cn/)\n\t- [玉令天下 ](http://yulingtianxia.com/)\n\t- [不会开机的男孩 ](http://studentdeng.github.io/blog/archives/)\n\n- 国外\n\t- [objc](http://www.objc.io/)\n\t- [MainiacDev](https://maniacdev.com/)\n\t- [Ray Wenderlich](http://www.raywenderlich.com/ios-tutorials)\n\t- [NSHipster](http://nshipster.com/)\n\n####  Android博客分享 - 吴明\n\n   - [代码家](http://blog.daimajia.com)\n\n       - 最新好玩的android效果\n       - 1到2周更新一次\n       - 提供源码\n\n   - [郭霖博客](http://blog.csdn.net/guolin_blog/)\n       - 资深Android开发工程师、架构师\n       - 畅销技术书籍《第一行代码——Android》\n       - 博客主要针对android的最新技术分享透彻逻辑性强\n\n   - [android性能优化](http://hukai.me/android-training-course-in-chinese/index.html)\n       - 学习Android应用开发的绝佳资料\n       - Google Android团队在2012年的时候开设了Android Training板块\n\n   - [Android开发资源汇总](http://www.2cto.com/kf/201406/307331.html)\n\n#### 博客工具与博客推荐 - 潘君\n\n- 博客工具Feedly\n\t- 优点\n\t\t- 全平台\n\t\t- 可批量导入RSS订阅OPML文件([唐巧推荐博客OPML](https://raw.githubusercontent.com/tangqiaoboy/iOSBlogCN/master/blogcn.opml))\n\t\t- 内置搜索功能，根据关键词搜索感兴趣的博客\n\n- 博客推荐\n\n\t- [Limboy](http://limboy.me/)\n\t\t- 技术之余不乏鸡汤\n\t\t- 涉猎较广,不仅限iOS\n\t\t- iOS相关类较为深入,很有借鉴意义\n\t\t- 优秀重点博文推荐-[读 Facebook App 头文件的一些收获](http://limboy.me/ios/2014/11/28/facebook-app-headers.html)\n\t\t\t- 相关工具索引:[class-dump](http://stevenygard.com/projects/class-dump/)\n\t\t\t- 相关文章教程:[iOS 使用Class-dump分析App内部实现](http://itony.me/200.html)\n\n\t- [阮一峰的网络日志](http://www.ruanyifeng.com/blog/)\n\t\t- 内容都较为浅显易懂,比较适合开拓眼界\n\t\t- 内容都较为与时俱进,都是当前较为流行的一些主题\n\t\t- 优秀重点博文推荐-[React 入门实例教程](http://www.ruanyifeng.com/blog/2015/03/react.html)\n\n\n#### 聊聊静态博客平台 - 曾铭\n\n- WordPress\n- Blogger\n- Tumblr\n- Ghost (node.js) WordPress 替代\n\n##### 博客的需求：\n\n>\n- 写文章：（markdown，draft，category，tag）\n- 交流：评论、社区\n- 好看：theme（排版、中文排版、代码）\n- 好玩：自定义\n- 域名\n\n\n\n##### 静态博客\n\n>\n- 博客何必动态生成，静态页面即可\n- 评论用第三方：多说，Disqus\n\n- Jekyll （Github Pager）ruby\n- Octopress 基于 Jekyll\n- Hexo (node.js)\n\n##### 非静态\n\n>\n- 我只是想『漂亮』的写文章\n\n- Scriptogr.am\n\t- dropbox 同步\n\t- 自定义主题\n- FarBox\n\t- dropbox 同步\n\t- 自定义主题\n\t- Mac 客户端\n- pancake.io\n- Medium\n\t- 有社区，大部分是设计师\n\t- 漂亮\n\t- 有 App\n\t- 不能导出 md\n- Logdown\n- [作业部落](https://www.zybuluo.com/mdeditor)\n- [简书](http://www.jianshu.com/)\n\n##### 大道无形\n\n>\n- 写 ： 无论静态博客多好玩，多写点文字才是最重要的\n- [为什么你应该（从现在开始就）写博客](http://mindhacks.cn/2009/02/15/why-you-should-start-blogging-now/)\n\n\n\n#### 技术博客分享 - 张超耀\n- [objc中国](http://objccn.io)\n\t- [onevcat](http://onev.cat) 创建，文章源自[objc.io](http://www.objc.io)，由[objc中国项目组](https://github.com/objccn) 整理维护\n\t- 为中国 `Objective-C` 社区带来最佳实践和先进技术.\n\n\n- [唐巧的技术博客](http://www.devtang.com/blog/categories/ios/)(记录下自己学习的点滴)\n\t- 唐巧：猿题库iOS开发工程师，给InfoQ的「iOS 开发周报」供稿，并且转载到个人博客上。\n\n- [ITeye](http://www.iteye.com)\n\t- [ITeye起源](http://baike.baidu.com/link?url=bKegOkXpVAHodrvY1dSVwb0m7w3lgHPS4sUfR6kFo27giN181V4BnRlpmHNR9fEbnuXa3BkINVZVMAWAPR94wK)：ITeye即创办于2003年9月的javaEye，缘起是创始人范凯自己在学习和研究java的开源框架却发现没有一个讨论的地方，于是自己就办一个。\n\t- 一个优秀的Java学习交流分享平台。\n","source":"_posts/博客分享.md","raw":"title: 博客分享\ndate: 2015-06-05 23:04:29\ntags:\n- 博客\n- 网站\ncategories: 移动组周分享\n\n---\n\n\n### android学习网站 - 王胜\n\n- [Android官网](http://developer.android.com/index.html)\n  - 官方SDK\n  - 官方API文档\n  - 官方training教程\n  - 官方Sample【1.x之后的Android Studio有直接导入Sample的功能】\n- [任玉刚博客](http://blog.csdn.net/singwhatiwanna/)\n  专注Android底层实现机制解析\n\n#### android博客与学习网站 - 李仙鹏\n\n- [Android官方开发博客](http://android-developers.blogspot.hk)，并非[Android开发者官网](http://developer.android.com/index.html)，官方会维护更新，非常适合Android开发者学习。\n- [Android Development G+](https://plus.google.com/communities/105153134372062985968)\n- [Romain Guy](http://www.curious-creature.com/category/android/)(google android工程师)\n- [Trinea](http://www.trinea.cn)\n- [android开源项目分析](http://www.codekk.com/open-source-project-analysis)\n\n#### 博客框架与网站&&博客推荐 - 杨志平\n##### 常见博客框架\n\n- [Ghost](https://ghost.org) 优美简易（收费）\n\n\t- 范例见 [Onev博客](http://onevcat.com)\n\t- [开源代码](https://github.com/TryGhost/Ghost)\n\t- [开源主题样式](https://github.com/search?utf8=%E2%9C%93&q=Ghost+theme&type=Repositories&ref=searchresults)\n\t- [主题 - 官方](http://marketplace.ghost.org/)\n\n\n- [Octopress](http://octopress.org) 免费，比较繁琐\n\n\t- 范例见 [唐巧博客](http://blog.devtang.com)\n\t- [开源代码](https://github.com/imathis/octopress)\n\t- [主题样式](https://github.com/search?utf8=%E2%9C%93&q=Octopress+theme&type=Repositories&ref=searchresults)\n\n- [Hexo](http://hexo.io) 没用过\n\n\t- 范例见 [Onev博客](http://onevcat.com)\n\t- [开源代码](https://github.com/search?utf8=%E2%9C%93&q=hexo+theme&type=Repositories&ref=searchresults)\n\t- [主题样式 - 官方](http://hexo.io/themes/)\n\t- [开源主题样式](https://github.com/search?utf8=%E2%9C%93&q=hexo+theme&type=Repositories&ref=searchresults)\n\n##### 常见iOS开发博客网站\n\n- 国内\n\t- [onev](http://onevcat.com/)\n\t- [唐巧](http://blog.devtang.com/)\n\t- [limboy](http://limboy.me/)\n\t- [objc中国](http://objccn.io/)\n\t- [NSHipster中国](http://nshipster.cn/)\n\t- [玉令天下 ](http://yulingtianxia.com/)\n\t- [不会开机的男孩 ](http://studentdeng.github.io/blog/archives/)\n\n- 国外\n\t- [objc](http://www.objc.io/)\n\t- [MainiacDev](https://maniacdev.com/)\n\t- [Ray Wenderlich](http://www.raywenderlich.com/ios-tutorials)\n\t- [NSHipster](http://nshipster.com/)\n\n####  Android博客分享 - 吴明\n\n   - [代码家](http://blog.daimajia.com)\n\n       - 最新好玩的android效果\n       - 1到2周更新一次\n       - 提供源码\n\n   - [郭霖博客](http://blog.csdn.net/guolin_blog/)\n       - 资深Android开发工程师、架构师\n       - 畅销技术书籍《第一行代码——Android》\n       - 博客主要针对android的最新技术分享透彻逻辑性强\n\n   - [android性能优化](http://hukai.me/android-training-course-in-chinese/index.html)\n       - 学习Android应用开发的绝佳资料\n       - Google Android团队在2012年的时候开设了Android Training板块\n\n   - [Android开发资源汇总](http://www.2cto.com/kf/201406/307331.html)\n\n#### 博客工具与博客推荐 - 潘君\n\n- 博客工具Feedly\n\t- 优点\n\t\t- 全平台\n\t\t- 可批量导入RSS订阅OPML文件([唐巧推荐博客OPML](https://raw.githubusercontent.com/tangqiaoboy/iOSBlogCN/master/blogcn.opml))\n\t\t- 内置搜索功能，根据关键词搜索感兴趣的博客\n\n- 博客推荐\n\n\t- [Limboy](http://limboy.me/)\n\t\t- 技术之余不乏鸡汤\n\t\t- 涉猎较广,不仅限iOS\n\t\t- iOS相关类较为深入,很有借鉴意义\n\t\t- 优秀重点博文推荐-[读 Facebook App 头文件的一些收获](http://limboy.me/ios/2014/11/28/facebook-app-headers.html)\n\t\t\t- 相关工具索引:[class-dump](http://stevenygard.com/projects/class-dump/)\n\t\t\t- 相关文章教程:[iOS 使用Class-dump分析App内部实现](http://itony.me/200.html)\n\n\t- [阮一峰的网络日志](http://www.ruanyifeng.com/blog/)\n\t\t- 内容都较为浅显易懂,比较适合开拓眼界\n\t\t- 内容都较为与时俱进,都是当前较为流行的一些主题\n\t\t- 优秀重点博文推荐-[React 入门实例教程](http://www.ruanyifeng.com/blog/2015/03/react.html)\n\n\n#### 聊聊静态博客平台 - 曾铭\n\n- WordPress\n- Blogger\n- Tumblr\n- Ghost (node.js) WordPress 替代\n\n##### 博客的需求：\n\n>\n- 写文章：（markdown，draft，category，tag）\n- 交流：评论、社区\n- 好看：theme（排版、中文排版、代码）\n- 好玩：自定义\n- 域名\n\n\n\n##### 静态博客\n\n>\n- 博客何必动态生成，静态页面即可\n- 评论用第三方：多说，Disqus\n\n- Jekyll （Github Pager）ruby\n- Octopress 基于 Jekyll\n- Hexo (node.js)\n\n##### 非静态\n\n>\n- 我只是想『漂亮』的写文章\n\n- Scriptogr.am\n\t- dropbox 同步\n\t- 自定义主题\n- FarBox\n\t- dropbox 同步\n\t- 自定义主题\n\t- Mac 客户端\n- pancake.io\n- Medium\n\t- 有社区，大部分是设计师\n\t- 漂亮\n\t- 有 App\n\t- 不能导出 md\n- Logdown\n- [作业部落](https://www.zybuluo.com/mdeditor)\n- [简书](http://www.jianshu.com/)\n\n##### 大道无形\n\n>\n- 写 ： 无论静态博客多好玩，多写点文字才是最重要的\n- [为什么你应该（从现在开始就）写博客](http://mindhacks.cn/2009/02/15/why-you-should-start-blogging-now/)\n\n\n\n#### 技术博客分享 - 张超耀\n- [objc中国](http://objccn.io)\n\t- [onevcat](http://onev.cat) 创建，文章源自[objc.io](http://www.objc.io)，由[objc中国项目组](https://github.com/objccn) 整理维护\n\t- 为中国 `Objective-C` 社区带来最佳实践和先进技术.\n\n\n- [唐巧的技术博客](http://www.devtang.com/blog/categories/ios/)(记录下自己学习的点滴)\n\t- 唐巧：猿题库iOS开发工程师，给InfoQ的「iOS 开发周报」供稿，并且转载到个人博客上。\n\n- [ITeye](http://www.iteye.com)\n\t- [ITeye起源](http://baike.baidu.com/link?url=bKegOkXpVAHodrvY1dSVwb0m7w3lgHPS4sUfR6kFo27giN181V4BnRlpmHNR9fEbnuXa3BkINVZVMAWAPR94wK)：ITeye即创办于2003年9月的javaEye，缘起是创始人范凯自己在学习和研究java的开源框架却发现没有一个讨论的地方，于是自己就办一个。\n\t- 一个优秀的Java学习交流分享平台。\n","slug":"博客分享","published":1,"updated":"2021-09-10T07:04:21.946Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cktfeap490025c2xxf4iktke5","content":"<h3 id=\"android学习网站-王胜\"><a href=\"#android学习网站-王胜\" class=\"headerlink\" title=\"android学习网站 - 王胜\"></a>android学习网站 - 王胜</h3><ul>\n<li><a href=\"http://developer.android.com/index.html\" target=\"_blank\" rel=\"noopener\">Android官网</a><ul>\n<li>官方SDK</li>\n<li>官方API文档</li>\n<li>官方training教程</li>\n<li>官方Sample【1.x之后的Android Studio有直接导入Sample的功能】</li>\n</ul>\n</li>\n<li><a href=\"http://blog.csdn.net/singwhatiwanna/\" target=\"_blank\" rel=\"noopener\">任玉刚博客</a><br>专注Android底层实现机制解析</li>\n</ul>\n<h4 id=\"android博客与学习网站-李仙鹏\"><a href=\"#android博客与学习网站-李仙鹏\" class=\"headerlink\" title=\"android博客与学习网站 - 李仙鹏\"></a>android博客与学习网站 - 李仙鹏</h4><ul>\n<li><a href=\"http://android-developers.blogspot.hk\" target=\"_blank\" rel=\"noopener\">Android官方开发博客</a>，并非<a href=\"http://developer.android.com/index.html\" target=\"_blank\" rel=\"noopener\">Android开发者官网</a>，官方会维护更新，非常适合Android开发者学习。</li>\n<li><a href=\"https://plus.google.com/communities/105153134372062985968\" target=\"_blank\" rel=\"noopener\">Android Development G+</a></li>\n<li><a href=\"http://www.curious-creature.com/category/android/\" target=\"_blank\" rel=\"noopener\">Romain Guy</a>(google android工程师)</li>\n<li><a href=\"http://www.trinea.cn\" target=\"_blank\" rel=\"noopener\">Trinea</a></li>\n<li><a href=\"http://www.codekk.com/open-source-project-analysis\" target=\"_blank\" rel=\"noopener\">android开源项目分析</a></li>\n</ul>\n<h4 id=\"博客框架与网站-amp-amp-博客推荐-杨志平\"><a href=\"#博客框架与网站-amp-amp-博客推荐-杨志平\" class=\"headerlink\" title=\"博客框架与网站&amp;&amp;博客推荐 - 杨志平\"></a>博客框架与网站&amp;&amp;博客推荐 - 杨志平</h4><h5 id=\"常见博客框架\"><a href=\"#常见博客框架\" class=\"headerlink\" title=\"常见博客框架\"></a>常见博客框架</h5><ul>\n<li><p><a href=\"https://ghost.org\" target=\"_blank\" rel=\"noopener\">Ghost</a> 优美简易（收费）</p>\n<ul>\n<li>范例见 <a href=\"http://onevcat.com\" target=\"_blank\" rel=\"noopener\">Onev博客</a></li>\n<li><a href=\"https://github.com/TryGhost/Ghost\" target=\"_blank\" rel=\"noopener\">开源代码</a></li>\n<li><a href=\"https://github.com/search?utf8=%E2%9C%93&amp;q=Ghost+theme&amp;type=Repositories&amp;ref=searchresults\" target=\"_blank\" rel=\"noopener\">开源主题样式</a></li>\n<li><a href=\"http://marketplace.ghost.org/\" target=\"_blank\" rel=\"noopener\">主题 - 官方</a></li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p><a href=\"http://octopress.org\" target=\"_blank\" rel=\"noopener\">Octopress</a> 免费，比较繁琐</p>\n<ul>\n<li>范例见 <a href=\"http://blog.devtang.com\" target=\"_blank\" rel=\"noopener\">唐巧博客</a></li>\n<li><a href=\"https://github.com/imathis/octopress\" target=\"_blank\" rel=\"noopener\">开源代码</a></li>\n<li><a href=\"https://github.com/search?utf8=%E2%9C%93&amp;q=Octopress+theme&amp;type=Repositories&amp;ref=searchresults\" target=\"_blank\" rel=\"noopener\">主题样式</a></li>\n</ul>\n</li>\n<li><p><a href=\"http://hexo.io\" target=\"_blank\" rel=\"noopener\">Hexo</a> 没用过</p>\n<ul>\n<li>范例见 <a href=\"http://onevcat.com\" target=\"_blank\" rel=\"noopener\">Onev博客</a></li>\n<li><a href=\"https://github.com/search?utf8=%E2%9C%93&amp;q=hexo+theme&amp;type=Repositories&amp;ref=searchresults\" target=\"_blank\" rel=\"noopener\">开源代码</a></li>\n<li><a href=\"http://hexo.io/themes/\" target=\"_blank\" rel=\"noopener\">主题样式 - 官方</a></li>\n<li><a href=\"https://github.com/search?utf8=%E2%9C%93&amp;q=hexo+theme&amp;type=Repositories&amp;ref=searchresults\" target=\"_blank\" rel=\"noopener\">开源主题样式</a></li>\n</ul>\n</li>\n</ul>\n<h5 id=\"常见iOS开发博客网站\"><a href=\"#常见iOS开发博客网站\" class=\"headerlink\" title=\"常见iOS开发博客网站\"></a>常见iOS开发博客网站</h5><ul>\n<li><p>国内</p>\n<ul>\n<li><a href=\"http://onevcat.com/\" target=\"_blank\" rel=\"noopener\">onev</a></li>\n<li><a href=\"http://blog.devtang.com/\" target=\"_blank\" rel=\"noopener\">唐巧</a></li>\n<li><a href=\"http://limboy.me/\" target=\"_blank\" rel=\"noopener\">limboy</a></li>\n<li><a href=\"http://objccn.io/\" target=\"_blank\" rel=\"noopener\">objc中国</a></li>\n<li><a href=\"http://nshipster.cn/\" target=\"_blank\" rel=\"noopener\">NSHipster中国</a></li>\n<li><a href=\"http://yulingtianxia.com/\" target=\"_blank\" rel=\"noopener\">玉令天下 </a></li>\n<li><a href=\"http://studentdeng.github.io/blog/archives/\" target=\"_blank\" rel=\"noopener\">不会开机的男孩 </a></li>\n</ul>\n</li>\n<li><p>国外</p>\n<ul>\n<li><a href=\"http://www.objc.io/\" target=\"_blank\" rel=\"noopener\">objc</a></li>\n<li><a href=\"https://maniacdev.com/\" target=\"_blank\" rel=\"noopener\">MainiacDev</a></li>\n<li><a href=\"http://www.raywenderlich.com/ios-tutorials\" target=\"_blank\" rel=\"noopener\">Ray Wenderlich</a></li>\n<li><a href=\"http://nshipster.com/\" target=\"_blank\" rel=\"noopener\">NSHipster</a></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Android博客分享-吴明\"><a href=\"#Android博客分享-吴明\" class=\"headerlink\" title=\"Android博客分享 - 吴明\"></a>Android博客分享 - 吴明</h4><ul>\n<li><p><a href=\"http://blog.daimajia.com\" target=\"_blank\" rel=\"noopener\">代码家</a></p>\n<ul>\n<li>最新好玩的android效果</li>\n<li>1到2周更新一次</li>\n<li>提供源码</li>\n</ul>\n</li>\n<li><p><a href=\"http://blog.csdn.net/guolin_blog/\" target=\"_blank\" rel=\"noopener\">郭霖博客</a></p>\n<ul>\n<li>资深Android开发工程师、架构师</li>\n<li>畅销技术书籍《第一行代码——Android》</li>\n<li>博客主要针对android的最新技术分享透彻逻辑性强</li>\n</ul>\n</li>\n<li><p><a href=\"http://hukai.me/android-training-course-in-chinese/index.html\" target=\"_blank\" rel=\"noopener\">android性能优化</a></p>\n<ul>\n<li>学习Android应用开发的绝佳资料</li>\n<li>Google Android团队在2012年的时候开设了Android Training板块</li>\n</ul>\n</li>\n<li><p><a href=\"http://www.2cto.com/kf/201406/307331.html\" target=\"_blank\" rel=\"noopener\">Android开发资源汇总</a></p>\n</li>\n</ul>\n<h4 id=\"博客工具与博客推荐-潘君\"><a href=\"#博客工具与博客推荐-潘君\" class=\"headerlink\" title=\"博客工具与博客推荐 - 潘君\"></a>博客工具与博客推荐 - 潘君</h4><ul>\n<li><p>博客工具Feedly</p>\n<ul>\n<li>优点<ul>\n<li>全平台</li>\n<li>可批量导入RSS订阅OPML文件(<a href=\"https://raw.githubusercontent.com/tangqiaoboy/iOSBlogCN/master/blogcn.opml\" target=\"_blank\" rel=\"noopener\">唐巧推荐博客OPML</a>)</li>\n<li>内置搜索功能，根据关键词搜索感兴趣的博客</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>博客推荐</p>\n<ul>\n<li><p><a href=\"http://limboy.me/\" target=\"_blank\" rel=\"noopener\">Limboy</a></p>\n<ul>\n<li>技术之余不乏鸡汤</li>\n<li>涉猎较广,不仅限iOS</li>\n<li>iOS相关类较为深入,很有借鉴意义</li>\n<li>优秀重点博文推荐-<a href=\"http://limboy.me/ios/2014/11/28/facebook-app-headers.html\" target=\"_blank\" rel=\"noopener\">读 Facebook App 头文件的一些收获</a><ul>\n<li>相关工具索引:<a href=\"http://stevenygard.com/projects/class-dump/\" target=\"_blank\" rel=\"noopener\">class-dump</a></li>\n<li>相关文章教程:<a href=\"http://itony.me/200.html\" target=\"_blank\" rel=\"noopener\">iOS 使用Class-dump分析App内部实现</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><a href=\"http://www.ruanyifeng.com/blog/\" target=\"_blank\" rel=\"noopener\">阮一峰的网络日志</a></p>\n<ul>\n<li>内容都较为浅显易懂,比较适合开拓眼界</li>\n<li>内容都较为与时俱进,都是当前较为流行的一些主题</li>\n<li>优秀重点博文推荐-<a href=\"http://www.ruanyifeng.com/blog/2015/03/react.html\" target=\"_blank\" rel=\"noopener\">React 入门实例教程</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"聊聊静态博客平台-曾铭\"><a href=\"#聊聊静态博客平台-曾铭\" class=\"headerlink\" title=\"聊聊静态博客平台 - 曾铭\"></a>聊聊静态博客平台 - 曾铭</h4><ul>\n<li>WordPress</li>\n<li>Blogger</li>\n<li>Tumblr</li>\n<li>Ghost (node.js) WordPress 替代</li>\n</ul>\n<h5 id=\"博客的需求：\"><a href=\"#博客的需求：\" class=\"headerlink\" title=\"博客的需求：\"></a>博客的需求：</h5><p>&gt;</p>\n<ul>\n<li>写文章：（markdown，draft，category，tag）</li>\n<li>交流：评论、社区</li>\n<li>好看：theme（排版、中文排版、代码）</li>\n<li>好玩：自定义</li>\n<li>域名</li>\n</ul>\n<h5 id=\"静态博客\"><a href=\"#静态博客\" class=\"headerlink\" title=\"静态博客\"></a>静态博客</h5><p>&gt;</p>\n<ul>\n<li>博客何必动态生成，静态页面即可</li>\n<li><p>评论用第三方：多说，Disqus</p>\n</li>\n<li><p>Jekyll （Github Pager）ruby</p>\n</li>\n<li>Octopress 基于 Jekyll</li>\n<li>Hexo (node.js)</li>\n</ul>\n<h5 id=\"非静态\"><a href=\"#非静态\" class=\"headerlink\" title=\"非静态\"></a>非静态</h5><p>&gt;</p>\n<ul>\n<li><p>我只是想『漂亮』的写文章</p>\n</li>\n<li><p>Scriptogr.am</p>\n<ul>\n<li>dropbox 同步</li>\n<li>自定义主题</li>\n</ul>\n</li>\n<li>FarBox<ul>\n<li>dropbox 同步</li>\n<li>自定义主题</li>\n<li>Mac 客户端</li>\n</ul>\n</li>\n<li>pancake.io</li>\n<li>Medium<ul>\n<li>有社区，大部分是设计师</li>\n<li>漂亮</li>\n<li>有 App</li>\n<li>不能导出 md</li>\n</ul>\n</li>\n<li>Logdown</li>\n<li><a href=\"https://www.zybuluo.com/mdeditor\" target=\"_blank\" rel=\"noopener\">作业部落</a></li>\n<li><a href=\"http://www.jianshu.com/\" target=\"_blank\" rel=\"noopener\">简书</a></li>\n</ul>\n<h5 id=\"大道无形\"><a href=\"#大道无形\" class=\"headerlink\" title=\"大道无形\"></a>大道无形</h5><p>&gt;</p>\n<ul>\n<li>写 ： 无论静态博客多好玩，多写点文字才是最重要的</li>\n<li><a href=\"http://mindhacks.cn/2009/02/15/why-you-should-start-blogging-now/\" target=\"_blank\" rel=\"noopener\">为什么你应该（从现在开始就）写博客</a></li>\n</ul>\n<h4 id=\"技术博客分享-张超耀\"><a href=\"#技术博客分享-张超耀\" class=\"headerlink\" title=\"技术博客分享 - 张超耀\"></a>技术博客分享 - 张超耀</h4><ul>\n<li><a href=\"http://objccn.io\" target=\"_blank\" rel=\"noopener\">objc中国</a><ul>\n<li><a href=\"http://onev.cat\" target=\"_blank\" rel=\"noopener\">onevcat</a> 创建，文章源自<a href=\"http://www.objc.io\" target=\"_blank\" rel=\"noopener\">objc.io</a>，由<a href=\"https://github.com/objccn\" target=\"_blank\" rel=\"noopener\">objc中国项目组</a> 整理维护</li>\n<li>为中国 <code>Objective-C</code> 社区带来最佳实践和先进技术.</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p><a href=\"http://www.devtang.com/blog/categories/ios/\" target=\"_blank\" rel=\"noopener\">唐巧的技术博客</a>(记录下自己学习的点滴)</p>\n<ul>\n<li>唐巧：猿题库iOS开发工程师，给InfoQ的「iOS 开发周报」供稿，并且转载到个人博客上。</li>\n</ul>\n</li>\n<li><p><a href=\"http://www.iteye.com\" target=\"_blank\" rel=\"noopener\">ITeye</a></p>\n<ul>\n<li><a href=\"http://baike.baidu.com/link?url=bKegOkXpVAHodrvY1dSVwb0m7w3lgHPS4sUfR6kFo27giN181V4BnRlpmHNR9fEbnuXa3BkINVZVMAWAPR94wK\" target=\"_blank\" rel=\"noopener\">ITeye起源</a>：ITeye即创办于2003年9月的javaEye，缘起是创始人范凯自己在学习和研究java的开源框架却发现没有一个讨论的地方，于是自己就办一个。</li>\n<li>一个优秀的Java学习交流分享平台。</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"android学习网站-王胜\"><a href=\"#android学习网站-王胜\" class=\"headerlink\" title=\"android学习网站 - 王胜\"></a>android学习网站 - 王胜</h3><ul>\n<li><a href=\"http://developer.android.com/index.html\" target=\"_blank\" rel=\"noopener\">Android官网</a><ul>\n<li>官方SDK</li>\n<li>官方API文档</li>\n<li>官方training教程</li>\n<li>官方Sample【1.x之后的Android Studio有直接导入Sample的功能】</li>\n</ul>\n</li>\n<li><a href=\"http://blog.csdn.net/singwhatiwanna/\" target=\"_blank\" rel=\"noopener\">任玉刚博客</a><br>专注Android底层实现机制解析</li>\n</ul>\n<h4 id=\"android博客与学习网站-李仙鹏\"><a href=\"#android博客与学习网站-李仙鹏\" class=\"headerlink\" title=\"android博客与学习网站 - 李仙鹏\"></a>android博客与学习网站 - 李仙鹏</h4><ul>\n<li><a href=\"http://android-developers.blogspot.hk\" target=\"_blank\" rel=\"noopener\">Android官方开发博客</a>，并非<a href=\"http://developer.android.com/index.html\" target=\"_blank\" rel=\"noopener\">Android开发者官网</a>，官方会维护更新，非常适合Android开发者学习。</li>\n<li><a href=\"https://plus.google.com/communities/105153134372062985968\" target=\"_blank\" rel=\"noopener\">Android Development G+</a></li>\n<li><a href=\"http://www.curious-creature.com/category/android/\" target=\"_blank\" rel=\"noopener\">Romain Guy</a>(google android工程师)</li>\n<li><a href=\"http://www.trinea.cn\" target=\"_blank\" rel=\"noopener\">Trinea</a></li>\n<li><a href=\"http://www.codekk.com/open-source-project-analysis\" target=\"_blank\" rel=\"noopener\">android开源项目分析</a></li>\n</ul>\n<h4 id=\"博客框架与网站-amp-amp-博客推荐-杨志平\"><a href=\"#博客框架与网站-amp-amp-博客推荐-杨志平\" class=\"headerlink\" title=\"博客框架与网站&amp;&amp;博客推荐 - 杨志平\"></a>博客框架与网站&amp;&amp;博客推荐 - 杨志平</h4><h5 id=\"常见博客框架\"><a href=\"#常见博客框架\" class=\"headerlink\" title=\"常见博客框架\"></a>常见博客框架</h5><ul>\n<li><p><a href=\"https://ghost.org\" target=\"_blank\" rel=\"noopener\">Ghost</a> 优美简易（收费）</p>\n<ul>\n<li>范例见 <a href=\"http://onevcat.com\" target=\"_blank\" rel=\"noopener\">Onev博客</a></li>\n<li><a href=\"https://github.com/TryGhost/Ghost\" target=\"_blank\" rel=\"noopener\">开源代码</a></li>\n<li><a href=\"https://github.com/search?utf8=%E2%9C%93&amp;q=Ghost+theme&amp;type=Repositories&amp;ref=searchresults\" target=\"_blank\" rel=\"noopener\">开源主题样式</a></li>\n<li><a href=\"http://marketplace.ghost.org/\" target=\"_blank\" rel=\"noopener\">主题 - 官方</a></li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p><a href=\"http://octopress.org\" target=\"_blank\" rel=\"noopener\">Octopress</a> 免费，比较繁琐</p>\n<ul>\n<li>范例见 <a href=\"http://blog.devtang.com\" target=\"_blank\" rel=\"noopener\">唐巧博客</a></li>\n<li><a href=\"https://github.com/imathis/octopress\" target=\"_blank\" rel=\"noopener\">开源代码</a></li>\n<li><a href=\"https://github.com/search?utf8=%E2%9C%93&amp;q=Octopress+theme&amp;type=Repositories&amp;ref=searchresults\" target=\"_blank\" rel=\"noopener\">主题样式</a></li>\n</ul>\n</li>\n<li><p><a href=\"http://hexo.io\" target=\"_blank\" rel=\"noopener\">Hexo</a> 没用过</p>\n<ul>\n<li>范例见 <a href=\"http://onevcat.com\" target=\"_blank\" rel=\"noopener\">Onev博客</a></li>\n<li><a href=\"https://github.com/search?utf8=%E2%9C%93&amp;q=hexo+theme&amp;type=Repositories&amp;ref=searchresults\" target=\"_blank\" rel=\"noopener\">开源代码</a></li>\n<li><a href=\"http://hexo.io/themes/\" target=\"_blank\" rel=\"noopener\">主题样式 - 官方</a></li>\n<li><a href=\"https://github.com/search?utf8=%E2%9C%93&amp;q=hexo+theme&amp;type=Repositories&amp;ref=searchresults\" target=\"_blank\" rel=\"noopener\">开源主题样式</a></li>\n</ul>\n</li>\n</ul>\n<h5 id=\"常见iOS开发博客网站\"><a href=\"#常见iOS开发博客网站\" class=\"headerlink\" title=\"常见iOS开发博客网站\"></a>常见iOS开发博客网站</h5><ul>\n<li><p>国内</p>\n<ul>\n<li><a href=\"http://onevcat.com/\" target=\"_blank\" rel=\"noopener\">onev</a></li>\n<li><a href=\"http://blog.devtang.com/\" target=\"_blank\" rel=\"noopener\">唐巧</a></li>\n<li><a href=\"http://limboy.me/\" target=\"_blank\" rel=\"noopener\">limboy</a></li>\n<li><a href=\"http://objccn.io/\" target=\"_blank\" rel=\"noopener\">objc中国</a></li>\n<li><a href=\"http://nshipster.cn/\" target=\"_blank\" rel=\"noopener\">NSHipster中国</a></li>\n<li><a href=\"http://yulingtianxia.com/\" target=\"_blank\" rel=\"noopener\">玉令天下 </a></li>\n<li><a href=\"http://studentdeng.github.io/blog/archives/\" target=\"_blank\" rel=\"noopener\">不会开机的男孩 </a></li>\n</ul>\n</li>\n<li><p>国外</p>\n<ul>\n<li><a href=\"http://www.objc.io/\" target=\"_blank\" rel=\"noopener\">objc</a></li>\n<li><a href=\"https://maniacdev.com/\" target=\"_blank\" rel=\"noopener\">MainiacDev</a></li>\n<li><a href=\"http://www.raywenderlich.com/ios-tutorials\" target=\"_blank\" rel=\"noopener\">Ray Wenderlich</a></li>\n<li><a href=\"http://nshipster.com/\" target=\"_blank\" rel=\"noopener\">NSHipster</a></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Android博客分享-吴明\"><a href=\"#Android博客分享-吴明\" class=\"headerlink\" title=\"Android博客分享 - 吴明\"></a>Android博客分享 - 吴明</h4><ul>\n<li><p><a href=\"http://blog.daimajia.com\" target=\"_blank\" rel=\"noopener\">代码家</a></p>\n<ul>\n<li>最新好玩的android效果</li>\n<li>1到2周更新一次</li>\n<li>提供源码</li>\n</ul>\n</li>\n<li><p><a href=\"http://blog.csdn.net/guolin_blog/\" target=\"_blank\" rel=\"noopener\">郭霖博客</a></p>\n<ul>\n<li>资深Android开发工程师、架构师</li>\n<li>畅销技术书籍《第一行代码——Android》</li>\n<li>博客主要针对android的最新技术分享透彻逻辑性强</li>\n</ul>\n</li>\n<li><p><a href=\"http://hukai.me/android-training-course-in-chinese/index.html\" target=\"_blank\" rel=\"noopener\">android性能优化</a></p>\n<ul>\n<li>学习Android应用开发的绝佳资料</li>\n<li>Google Android团队在2012年的时候开设了Android Training板块</li>\n</ul>\n</li>\n<li><p><a href=\"http://www.2cto.com/kf/201406/307331.html\" target=\"_blank\" rel=\"noopener\">Android开发资源汇总</a></p>\n</li>\n</ul>\n<h4 id=\"博客工具与博客推荐-潘君\"><a href=\"#博客工具与博客推荐-潘君\" class=\"headerlink\" title=\"博客工具与博客推荐 - 潘君\"></a>博客工具与博客推荐 - 潘君</h4><ul>\n<li><p>博客工具Feedly</p>\n<ul>\n<li>优点<ul>\n<li>全平台</li>\n<li>可批量导入RSS订阅OPML文件(<a href=\"https://raw.githubusercontent.com/tangqiaoboy/iOSBlogCN/master/blogcn.opml\" target=\"_blank\" rel=\"noopener\">唐巧推荐博客OPML</a>)</li>\n<li>内置搜索功能，根据关键词搜索感兴趣的博客</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>博客推荐</p>\n<ul>\n<li><p><a href=\"http://limboy.me/\" target=\"_blank\" rel=\"noopener\">Limboy</a></p>\n<ul>\n<li>技术之余不乏鸡汤</li>\n<li>涉猎较广,不仅限iOS</li>\n<li>iOS相关类较为深入,很有借鉴意义</li>\n<li>优秀重点博文推荐-<a href=\"http://limboy.me/ios/2014/11/28/facebook-app-headers.html\" target=\"_blank\" rel=\"noopener\">读 Facebook App 头文件的一些收获</a><ul>\n<li>相关工具索引:<a href=\"http://stevenygard.com/projects/class-dump/\" target=\"_blank\" rel=\"noopener\">class-dump</a></li>\n<li>相关文章教程:<a href=\"http://itony.me/200.html\" target=\"_blank\" rel=\"noopener\">iOS 使用Class-dump分析App内部实现</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><a href=\"http://www.ruanyifeng.com/blog/\" target=\"_blank\" rel=\"noopener\">阮一峰的网络日志</a></p>\n<ul>\n<li>内容都较为浅显易懂,比较适合开拓眼界</li>\n<li>内容都较为与时俱进,都是当前较为流行的一些主题</li>\n<li>优秀重点博文推荐-<a href=\"http://www.ruanyifeng.com/blog/2015/03/react.html\" target=\"_blank\" rel=\"noopener\">React 入门实例教程</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"聊聊静态博客平台-曾铭\"><a href=\"#聊聊静态博客平台-曾铭\" class=\"headerlink\" title=\"聊聊静态博客平台 - 曾铭\"></a>聊聊静态博客平台 - 曾铭</h4><ul>\n<li>WordPress</li>\n<li>Blogger</li>\n<li>Tumblr</li>\n<li>Ghost (node.js) WordPress 替代</li>\n</ul>\n<h5 id=\"博客的需求：\"><a href=\"#博客的需求：\" class=\"headerlink\" title=\"博客的需求：\"></a>博客的需求：</h5><p>&gt;</p>\n<ul>\n<li>写文章：（markdown，draft，category，tag）</li>\n<li>交流：评论、社区</li>\n<li>好看：theme（排版、中文排版、代码）</li>\n<li>好玩：自定义</li>\n<li>域名</li>\n</ul>\n<h5 id=\"静态博客\"><a href=\"#静态博客\" class=\"headerlink\" title=\"静态博客\"></a>静态博客</h5><p>&gt;</p>\n<ul>\n<li>博客何必动态生成，静态页面即可</li>\n<li><p>评论用第三方：多说，Disqus</p>\n</li>\n<li><p>Jekyll （Github Pager）ruby</p>\n</li>\n<li>Octopress 基于 Jekyll</li>\n<li>Hexo (node.js)</li>\n</ul>\n<h5 id=\"非静态\"><a href=\"#非静态\" class=\"headerlink\" title=\"非静态\"></a>非静态</h5><p>&gt;</p>\n<ul>\n<li><p>我只是想『漂亮』的写文章</p>\n</li>\n<li><p>Scriptogr.am</p>\n<ul>\n<li>dropbox 同步</li>\n<li>自定义主题</li>\n</ul>\n</li>\n<li>FarBox<ul>\n<li>dropbox 同步</li>\n<li>自定义主题</li>\n<li>Mac 客户端</li>\n</ul>\n</li>\n<li>pancake.io</li>\n<li>Medium<ul>\n<li>有社区，大部分是设计师</li>\n<li>漂亮</li>\n<li>有 App</li>\n<li>不能导出 md</li>\n</ul>\n</li>\n<li>Logdown</li>\n<li><a href=\"https://www.zybuluo.com/mdeditor\" target=\"_blank\" rel=\"noopener\">作业部落</a></li>\n<li><a href=\"http://www.jianshu.com/\" target=\"_blank\" rel=\"noopener\">简书</a></li>\n</ul>\n<h5 id=\"大道无形\"><a href=\"#大道无形\" class=\"headerlink\" title=\"大道无形\"></a>大道无形</h5><p>&gt;</p>\n<ul>\n<li>写 ： 无论静态博客多好玩，多写点文字才是最重要的</li>\n<li><a href=\"http://mindhacks.cn/2009/02/15/why-you-should-start-blogging-now/\" target=\"_blank\" rel=\"noopener\">为什么你应该（从现在开始就）写博客</a></li>\n</ul>\n<h4 id=\"技术博客分享-张超耀\"><a href=\"#技术博客分享-张超耀\" class=\"headerlink\" title=\"技术博客分享 - 张超耀\"></a>技术博客分享 - 张超耀</h4><ul>\n<li><a href=\"http://objccn.io\" target=\"_blank\" rel=\"noopener\">objc中国</a><ul>\n<li><a href=\"http://onev.cat\" target=\"_blank\" rel=\"noopener\">onevcat</a> 创建，文章源自<a href=\"http://www.objc.io\" target=\"_blank\" rel=\"noopener\">objc.io</a>，由<a href=\"https://github.com/objccn\" target=\"_blank\" rel=\"noopener\">objc中国项目组</a> 整理维护</li>\n<li>为中国 <code>Objective-C</code> 社区带来最佳实践和先进技术.</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p><a href=\"http://www.devtang.com/blog/categories/ios/\" target=\"_blank\" rel=\"noopener\">唐巧的技术博客</a>(记录下自己学习的点滴)</p>\n<ul>\n<li>唐巧：猿题库iOS开发工程师，给InfoQ的「iOS 开发周报」供稿，并且转载到个人博客上。</li>\n</ul>\n</li>\n<li><p><a href=\"http://www.iteye.com\" target=\"_blank\" rel=\"noopener\">ITeye</a></p>\n<ul>\n<li><a href=\"http://baike.baidu.com/link?url=bKegOkXpVAHodrvY1dSVwb0m7w3lgHPS4sUfR6kFo27giN181V4BnRlpmHNR9fEbnuXa3BkINVZVMAWAPR94wK\" target=\"_blank\" rel=\"noopener\">ITeye起源</a>：ITeye即创办于2003年9月的javaEye，缘起是创始人范凯自己在学习和研究java的开源框架却发现没有一个讨论的地方，于是自己就办一个。</li>\n<li>一个优秀的Java学习交流分享平台。</li>\n</ul>\n</li>\n</ul>\n"},{"title":"开源","date":"2015-06-12T23:04:29.000Z","_content":"\n## 开源\n\n#### 开源利弊浅谈 - 张超耀\n#### 开源？\n- 开源，（Open Source）全称为开放源代码。开源就是要用户利用源代码在其基础上修改和学习的。\n\n####  优势何在？\n- 优势1：花费很少（如果有的话），许可费用\n\t- 当然，这往往省去那些讨厌的维护费用。\n- 优势2：易于管理\n\t- 只要你想，你可以在尽可能多的地方安装开源软件。无需为许可证合规性计数、跟踪或监视。\n- 优势3 ：连续，实时改进\n\t- 因为每个人都可以访问源码，任何人都可以主动修改BUG，使其变得更好，而不必等待下一个版本。\n- 优势4：公司独立\n\t- 如果创建该软件的公司挂掉，代码仍然可以通过其用户社区继续存在和发展。\n- 优势5 ：实践的探索\n\t- 我们可以很容易地“亲身探索”源码，以便更好地了解产品并作出改善。\n\n#### 劣势显著\n\n- 缺点1 ：它不是完全免费\n\t- 开源软件可以涉及意料之外的实施、管理和支持成本。\n- 缺点2：学习曲线（技术支持）\n\t- 你可能在开源的产品上需要聘请专家，让自己加快速度。\n- 缺点3：迷茫的用户\n\t- 由于并行发展的努力在进行中，用户可能不知道哪个版本做什么或是否与你专有平台上的其他软件兼容。\n- 缺点4：孤立软件\n\t- 由于关键的程序员的斗争和退出，或他们失去兴趣转移到新的项目，使一些开源项目陷于停顿和死亡。\n- 缺点5：独立地（凭自己的力量）\n \t- 与商业产品不同，没有人在开源社区义务来帮助你，或回答你的任何问题。\n\n#### 开源，仁者见仁智者见智\n\n\n#### 与开源有关的小故事 - 曾铭\n\n- 比尔·盖茨\n\t- 软件私有，保护版权\n\t- 1976 年 《致计算机爱好者的公开信》\n- 理查德.斯托曼\n\t- Free Soft\n\t- GNU，GPL，Emacs，GCC\n\t- 推荐两本书：《大教堂与集市》《Just for Fun》\n\t- [HHKB](https://www.v2ex.com/t/45480) ；）\n- 思考\n\t- 开源软件和私有软件哪个质量更高？\n\t- 怎样参与开源？：\n\t\t- Github\n\t\t- 开源就是一种开放交流的态度\n\t\t- 不怕暴露自己的傻 X，（每个人都认为自己是对的，）万一对了呢 ；）\n- 最后再推荐一部纪录片：[互联网之子](http://v.youku.com/v_show/id_XNzYyMDg3MzYw.html)\n\n#### 我如何接触开源 - 潘君\n\n- github trending\n\t- 代码 trending\n\t\t- 寻找有潜力的开源项目\n\t- 开发者 trending\n\t\t- 好的开发者应该不止一个好软件 顺藤摸瓜比较方便\n\n- 苹果官方开源\n\t- [Apple Open Source](http://www.opensource.apple.com/)\n\t- 重点代码\n\t\t- [runtime](http://www.opensource.apple.com/source/objc4/objc4-437.1/runtime/)\n\n- 开源软件闲暇阅读工具\n\t- CodeNav - 移动端优秀的代码查看软件\n\t\t- 优点\n\t\t\t- 支持多种方式导入源码\n\t\t\t- 交互不错 各种操作都算是方便\n\t\t- 缺点\n\t\t\t- 大屏支持还有bug\n\t\t\t- 不支持swift语法高亮\n\n\n\n- 自用较多的开源软件\n\t- [WWDC app for OS X](https://github.com/insidegui/WWDC)\n\t- [eggscellent](https://github.com/monoclesociety/eggscellent)\n\t- [calibre](https://github.com/kovidgoyal/calibre)\n\n\n#### 参与开源软件的心得 - 王胜\n  - 参与方式：\n    - 泡开源官方网站论坛，并参与issue讨论\n    - 修改源码，生成patch文件，发给社区维护者\n    - 有了Git && Github后，可以fork分支，修改代码，发送pull request\n  - 参与过程情绪波动：\n    查看源码 -> 领悟学习 -> 发现问题 -> 动手解决 -> 跟社区提交者沟通纳入源码树 or 通过github发送pull request\n    -> 上游采用 -> 成就感十足。从而形成良性持续性参与感，并参与其中。\n  - 收获心得：\n    - 一次提交只做一件事\n    - 提交说明规范、简单、见名知意。后续参与者看提交树就能看到软件的演化历史\n    - 代码开源，足够多的眼睛，使bug无处可藏\n    - 开源导致世界范围内可见，代码的创意来自于全球智慧的汇聚\n\n#### OkHttp开源框架介绍 - 李仙鹏\n##### SPDY\n\nGoogle开发的基于TCP的应用层协议，用以最小化网络延迟，提升网络速度，优化用户的网络使用体验。SPDY并不是一种用于替代HTTP的协议，而是对HTTP协议的增强。\n> 新协议的功能:\n>\n> * 数据流的多路复用\n> * 请求优先级\n> * HTTP报头压缩。\n> * 服务器推送（即Server Push技术）\n\n谷歌表示，引入SPDY协议后，在实验室测试中页面加载速度比原先快64%。\n\n现在已经被Google弃用，推出新的基于SPDY实现的HTTP2.0。\n\n##### HTTP2.0\n\nHTTP也是基于TCP的应用层协议，大家熟知的为：\n\n* HTTP 0.9，只有基本的文本 GET 功能。\n* HTTP 1.0，完善的请求/响应模型，并将协议补充完整。\n* HTTP 1.1，在 1.0 基础上进行更新，增加了如 长久连接 keep-alive 与 chunked 等功能。\n\nHTTP 2.0在2013年8月推出，基于Google的SPDY开发。\n\n##### OkHTTP\n\n[OKHTTP](http://square.github.io/okhttp/)is an HTTP client that’s efficient by default:\n\n* HTTP/2 and SPDY support allows all requests to the same host to share a socket.\n* Connection pooling reduces request latency (if SPDY isn’t available).\n* Transparent GZIP shrinks download sizes.\n* Response caching avoids the network completely for repeat requests.\n\n> OkHttp supports Android 2.3 and above. For Java, the minimum requirement is 1.7.\n> You'll also need Okio, which OkHttp uses for fast I/O and resizable buffers.\n\n\n#### 如何推广自己的开源项目(github获取更多的star) - 杨志平\n\n##### 前言\n`你可能花费几天甚至几个月时间开源一个你写的代码，但是没有人去使用它，靠运气的话可能可以推广.\n现在我讲讲如何让人们关注我们的作品。该要点是打破下面的图片的循环`\n\n![图片一](https://d262ilb51hltx0.cloudfront.net/max/727/1*xBernzyrTjSbfMMQWdE0qQ.png)\n\n#### 六步（4-6是秘诀）\n1. Projects are Everything\n- Read and Research\n- Building the Repo\n- README 文件\n- 图解\n- 更新反馈\n\n#### 1.Projects are Everything\n开源代码就是给其他程序员解决问题或者节约时间的\n\n#### 2.Read and Research\n`很多问题都已经解决成千上万次了`\n你可以想一个你感兴趣的开源项目，上网搜索确认它的实现是不是已经有很多人实现了并有很多人已经使用它了，那就忘了这个想法。但是如果没有，或者解决方案不理想（可以通过issues查看他们的不足）你有时间的话就建一个和他们相识的开源项目，修复一些issues使用自己的文档（感觉有点无耻，但听说很有效）\n\n### 3.Building the Repo\n有一点就是，通常我们后面的repo的star增加速度比以前的repo要快挺多的，可能是以前的repo使得更多人认识你相信你。\n\n####4.README 文件(推荐布局方案)\n\n![图片2](https://d262ilb51hltx0.cloudfront.net/max/861/1*JK3G5F-iIO7JFwxN9Dnwrw.png)\n\n#### 5.图解（特效，一目了然）\n\n![Flipboard playing multiple GIFs](https://github.com/ZhipingYang/UUChatTableView/raw/master/Demo/UUChatTableViewTests/ChatTableView.gif)\n\n#### 6.更新反馈\n完成以上步骤，并不断更新开源库及时解决issues里面的bug就很有希望进入\nstar趋势\n![图片2](https://d262ilb51hltx0.cloudfront.net/max/1800/1*Yk2DM31wlKquLH7CIN5vkQ.png)\n贡献名人\n![图片2](https://d262ilb51hltx0.cloudfront.net/max/948/1*QFeal7p7uUS0As74S1tePA.png)\n\n\n#### 开源协议 - 吴明\n  - 无规矩不成方圆，开源协议\n\n \t- BSD开源协议：满足三个条件\n \t\t- 如果再发布的产品中包含源代码，则在源代码中必须带有原来代码中的BSD协议\n \t\t- 如果再发布的只是二进制类库/软件，则需要在类库/软件的文档和版权声明中包含原来代码中的BSD协议\n \t\t- 不可以用开源代码的作者/机构名字和原来产品的名字做市场推广\n\t- Apache Licence 2.0：(关心软件的专利问题，但同样希望宽松，选择这个协议)\n\t   - 需要给代码的用户一份Apache Licence\n\t   - 如果你修改了代码，需要再被修改的文件中说明。\n\t   - 在延伸的代码中（修改和有源代码衍生的代码中）需要带有原来代码中的协议，商标，专利声明和其他原来作者规定需要包含的说明\n\t   - 如果再发布的产品中包含一个Notice文件，则在Notice文件中需要带有Apache Licence。你可以在Notice中增加自己的许可，但不可以表现为对Apache Licence构成更改\n\n\t- GPL：(Linux)(希望代码使用者同样能把他们的贡献分享出来，那就选择GPL)\n\t\t- GPL协议和BSD, Apache Licence等鼓励代码重用的许可很不一样\n\t\t- 代码的开源/免费使用和引用/修改/衍生代码的开源/免费使用，但不允许修改后和衍生的代码做为闭源的商业软件发布和销售\n\t\t- 由于GPL严格要求使用了GPL类库的软件产品必须使用GPL协议，对于使用GPL协议的开源代码，商业软件或者对代码有保密要求的部门就不适合集成/采用作为类库和二次开发的基础。\n\n\t- MIT：(简单、宽松，\"为所欲为\",选择这个协议)\n\t\t- 类似BSD协议\n\t- Mozilla\n\n\t- LGPL\n\t  - LGPL是GPL的一个为主要为类库使用设计的开源协议。和GPL要求任何使用/修改/衍生之GPL类库的的软件必须采用GPL协议不同。LGPL允许商业软件通过类库引用(link)方式使用LGPL类库而不需要开源商业软件的代码。这使得采用LGPL协议的开源代码可以被商业软件作为类库引用并发布和销售。\n\n\t- 说了这么多最后一个[开源协议的选择](http://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html)\n\t- 其他\n\t\t- [github开源协议选择](http://choosealicense.com/)\n\t\t- [参考1](http://www.awflasher.com/blog/archives/939)\n\t\t- [参考2](http://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html)\n","source":"_posts/开源.md","raw":"title: 开源\ndate: 2015-06-12 23:04:29\ntags:\ncategories: 移动组周分享\n---\n\n## 开源\n\n#### 开源利弊浅谈 - 张超耀\n#### 开源？\n- 开源，（Open Source）全称为开放源代码。开源就是要用户利用源代码在其基础上修改和学习的。\n\n####  优势何在？\n- 优势1：花费很少（如果有的话），许可费用\n\t- 当然，这往往省去那些讨厌的维护费用。\n- 优势2：易于管理\n\t- 只要你想，你可以在尽可能多的地方安装开源软件。无需为许可证合规性计数、跟踪或监视。\n- 优势3 ：连续，实时改进\n\t- 因为每个人都可以访问源码，任何人都可以主动修改BUG，使其变得更好，而不必等待下一个版本。\n- 优势4：公司独立\n\t- 如果创建该软件的公司挂掉，代码仍然可以通过其用户社区继续存在和发展。\n- 优势5 ：实践的探索\n\t- 我们可以很容易地“亲身探索”源码，以便更好地了解产品并作出改善。\n\n#### 劣势显著\n\n- 缺点1 ：它不是完全免费\n\t- 开源软件可以涉及意料之外的实施、管理和支持成本。\n- 缺点2：学习曲线（技术支持）\n\t- 你可能在开源的产品上需要聘请专家，让自己加快速度。\n- 缺点3：迷茫的用户\n\t- 由于并行发展的努力在进行中，用户可能不知道哪个版本做什么或是否与你专有平台上的其他软件兼容。\n- 缺点4：孤立软件\n\t- 由于关键的程序员的斗争和退出，或他们失去兴趣转移到新的项目，使一些开源项目陷于停顿和死亡。\n- 缺点5：独立地（凭自己的力量）\n \t- 与商业产品不同，没有人在开源社区义务来帮助你，或回答你的任何问题。\n\n#### 开源，仁者见仁智者见智\n\n\n#### 与开源有关的小故事 - 曾铭\n\n- 比尔·盖茨\n\t- 软件私有，保护版权\n\t- 1976 年 《致计算机爱好者的公开信》\n- 理查德.斯托曼\n\t- Free Soft\n\t- GNU，GPL，Emacs，GCC\n\t- 推荐两本书：《大教堂与集市》《Just for Fun》\n\t- [HHKB](https://www.v2ex.com/t/45480) ；）\n- 思考\n\t- 开源软件和私有软件哪个质量更高？\n\t- 怎样参与开源？：\n\t\t- Github\n\t\t- 开源就是一种开放交流的态度\n\t\t- 不怕暴露自己的傻 X，（每个人都认为自己是对的，）万一对了呢 ；）\n- 最后再推荐一部纪录片：[互联网之子](http://v.youku.com/v_show/id_XNzYyMDg3MzYw.html)\n\n#### 我如何接触开源 - 潘君\n\n- github trending\n\t- 代码 trending\n\t\t- 寻找有潜力的开源项目\n\t- 开发者 trending\n\t\t- 好的开发者应该不止一个好软件 顺藤摸瓜比较方便\n\n- 苹果官方开源\n\t- [Apple Open Source](http://www.opensource.apple.com/)\n\t- 重点代码\n\t\t- [runtime](http://www.opensource.apple.com/source/objc4/objc4-437.1/runtime/)\n\n- 开源软件闲暇阅读工具\n\t- CodeNav - 移动端优秀的代码查看软件\n\t\t- 优点\n\t\t\t- 支持多种方式导入源码\n\t\t\t- 交互不错 各种操作都算是方便\n\t\t- 缺点\n\t\t\t- 大屏支持还有bug\n\t\t\t- 不支持swift语法高亮\n\n\n\n- 自用较多的开源软件\n\t- [WWDC app for OS X](https://github.com/insidegui/WWDC)\n\t- [eggscellent](https://github.com/monoclesociety/eggscellent)\n\t- [calibre](https://github.com/kovidgoyal/calibre)\n\n\n#### 参与开源软件的心得 - 王胜\n  - 参与方式：\n    - 泡开源官方网站论坛，并参与issue讨论\n    - 修改源码，生成patch文件，发给社区维护者\n    - 有了Git && Github后，可以fork分支，修改代码，发送pull request\n  - 参与过程情绪波动：\n    查看源码 -> 领悟学习 -> 发现问题 -> 动手解决 -> 跟社区提交者沟通纳入源码树 or 通过github发送pull request\n    -> 上游采用 -> 成就感十足。从而形成良性持续性参与感，并参与其中。\n  - 收获心得：\n    - 一次提交只做一件事\n    - 提交说明规范、简单、见名知意。后续参与者看提交树就能看到软件的演化历史\n    - 代码开源，足够多的眼睛，使bug无处可藏\n    - 开源导致世界范围内可见，代码的创意来自于全球智慧的汇聚\n\n#### OkHttp开源框架介绍 - 李仙鹏\n##### SPDY\n\nGoogle开发的基于TCP的应用层协议，用以最小化网络延迟，提升网络速度，优化用户的网络使用体验。SPDY并不是一种用于替代HTTP的协议，而是对HTTP协议的增强。\n> 新协议的功能:\n>\n> * 数据流的多路复用\n> * 请求优先级\n> * HTTP报头压缩。\n> * 服务器推送（即Server Push技术）\n\n谷歌表示，引入SPDY协议后，在实验室测试中页面加载速度比原先快64%。\n\n现在已经被Google弃用，推出新的基于SPDY实现的HTTP2.0。\n\n##### HTTP2.0\n\nHTTP也是基于TCP的应用层协议，大家熟知的为：\n\n* HTTP 0.9，只有基本的文本 GET 功能。\n* HTTP 1.0，完善的请求/响应模型，并将协议补充完整。\n* HTTP 1.1，在 1.0 基础上进行更新，增加了如 长久连接 keep-alive 与 chunked 等功能。\n\nHTTP 2.0在2013年8月推出，基于Google的SPDY开发。\n\n##### OkHTTP\n\n[OKHTTP](http://square.github.io/okhttp/)is an HTTP client that’s efficient by default:\n\n* HTTP/2 and SPDY support allows all requests to the same host to share a socket.\n* Connection pooling reduces request latency (if SPDY isn’t available).\n* Transparent GZIP shrinks download sizes.\n* Response caching avoids the network completely for repeat requests.\n\n> OkHttp supports Android 2.3 and above. For Java, the minimum requirement is 1.7.\n> You'll also need Okio, which OkHttp uses for fast I/O and resizable buffers.\n\n\n#### 如何推广自己的开源项目(github获取更多的star) - 杨志平\n\n##### 前言\n`你可能花费几天甚至几个月时间开源一个你写的代码，但是没有人去使用它，靠运气的话可能可以推广.\n现在我讲讲如何让人们关注我们的作品。该要点是打破下面的图片的循环`\n\n![图片一](https://d262ilb51hltx0.cloudfront.net/max/727/1*xBernzyrTjSbfMMQWdE0qQ.png)\n\n#### 六步（4-6是秘诀）\n1. Projects are Everything\n- Read and Research\n- Building the Repo\n- README 文件\n- 图解\n- 更新反馈\n\n#### 1.Projects are Everything\n开源代码就是给其他程序员解决问题或者节约时间的\n\n#### 2.Read and Research\n`很多问题都已经解决成千上万次了`\n你可以想一个你感兴趣的开源项目，上网搜索确认它的实现是不是已经有很多人实现了并有很多人已经使用它了，那就忘了这个想法。但是如果没有，或者解决方案不理想（可以通过issues查看他们的不足）你有时间的话就建一个和他们相识的开源项目，修复一些issues使用自己的文档（感觉有点无耻，但听说很有效）\n\n### 3.Building the Repo\n有一点就是，通常我们后面的repo的star增加速度比以前的repo要快挺多的，可能是以前的repo使得更多人认识你相信你。\n\n####4.README 文件(推荐布局方案)\n\n![图片2](https://d262ilb51hltx0.cloudfront.net/max/861/1*JK3G5F-iIO7JFwxN9Dnwrw.png)\n\n#### 5.图解（特效，一目了然）\n\n![Flipboard playing multiple GIFs](https://github.com/ZhipingYang/UUChatTableView/raw/master/Demo/UUChatTableViewTests/ChatTableView.gif)\n\n#### 6.更新反馈\n完成以上步骤，并不断更新开源库及时解决issues里面的bug就很有希望进入\nstar趋势\n![图片2](https://d262ilb51hltx0.cloudfront.net/max/1800/1*Yk2DM31wlKquLH7CIN5vkQ.png)\n贡献名人\n![图片2](https://d262ilb51hltx0.cloudfront.net/max/948/1*QFeal7p7uUS0As74S1tePA.png)\n\n\n#### 开源协议 - 吴明\n  - 无规矩不成方圆，开源协议\n\n \t- BSD开源协议：满足三个条件\n \t\t- 如果再发布的产品中包含源代码，则在源代码中必须带有原来代码中的BSD协议\n \t\t- 如果再发布的只是二进制类库/软件，则需要在类库/软件的文档和版权声明中包含原来代码中的BSD协议\n \t\t- 不可以用开源代码的作者/机构名字和原来产品的名字做市场推广\n\t- Apache Licence 2.0：(关心软件的专利问题，但同样希望宽松，选择这个协议)\n\t   - 需要给代码的用户一份Apache Licence\n\t   - 如果你修改了代码，需要再被修改的文件中说明。\n\t   - 在延伸的代码中（修改和有源代码衍生的代码中）需要带有原来代码中的协议，商标，专利声明和其他原来作者规定需要包含的说明\n\t   - 如果再发布的产品中包含一个Notice文件，则在Notice文件中需要带有Apache Licence。你可以在Notice中增加自己的许可，但不可以表现为对Apache Licence构成更改\n\n\t- GPL：(Linux)(希望代码使用者同样能把他们的贡献分享出来，那就选择GPL)\n\t\t- GPL协议和BSD, Apache Licence等鼓励代码重用的许可很不一样\n\t\t- 代码的开源/免费使用和引用/修改/衍生代码的开源/免费使用，但不允许修改后和衍生的代码做为闭源的商业软件发布和销售\n\t\t- 由于GPL严格要求使用了GPL类库的软件产品必须使用GPL协议，对于使用GPL协议的开源代码，商业软件或者对代码有保密要求的部门就不适合集成/采用作为类库和二次开发的基础。\n\n\t- MIT：(简单、宽松，\"为所欲为\",选择这个协议)\n\t\t- 类似BSD协议\n\t- Mozilla\n\n\t- LGPL\n\t  - LGPL是GPL的一个为主要为类库使用设计的开源协议。和GPL要求任何使用/修改/衍生之GPL类库的的软件必须采用GPL协议不同。LGPL允许商业软件通过类库引用(link)方式使用LGPL类库而不需要开源商业软件的代码。这使得采用LGPL协议的开源代码可以被商业软件作为类库引用并发布和销售。\n\n\t- 说了这么多最后一个[开源协议的选择](http://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html)\n\t- 其他\n\t\t- [github开源协议选择](http://choosealicense.com/)\n\t\t- [参考1](http://www.awflasher.com/blog/archives/939)\n\t\t- [参考2](http://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html)\n","slug":"开源","published":1,"updated":"2021-09-10T07:04:21.947Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cktfeap4a0029c2xxtnp36j6h","content":"<h2 id=\"开源\"><a href=\"#开源\" class=\"headerlink\" title=\"开源\"></a>开源</h2><h4 id=\"开源利弊浅谈-张超耀\"><a href=\"#开源利弊浅谈-张超耀\" class=\"headerlink\" title=\"开源利弊浅谈 - 张超耀\"></a>开源利弊浅谈 - 张超耀</h4><h4 id=\"开源？\"><a href=\"#开源？\" class=\"headerlink\" title=\"开源？\"></a>开源？</h4><ul>\n<li>开源，（Open Source）全称为开放源代码。开源就是要用户利用源代码在其基础上修改和学习的。</li>\n</ul>\n<h4 id=\"优势何在？\"><a href=\"#优势何在？\" class=\"headerlink\" title=\"优势何在？\"></a>优势何在？</h4><ul>\n<li>优势1：花费很少（如果有的话），许可费用<ul>\n<li>当然，这往往省去那些讨厌的维护费用。</li>\n</ul>\n</li>\n<li>优势2：易于管理<ul>\n<li>只要你想，你可以在尽可能多的地方安装开源软件。无需为许可证合规性计数、跟踪或监视。</li>\n</ul>\n</li>\n<li>优势3 ：连续，实时改进<ul>\n<li>因为每个人都可以访问源码，任何人都可以主动修改BUG，使其变得更好，而不必等待下一个版本。</li>\n</ul>\n</li>\n<li>优势4：公司独立<ul>\n<li>如果创建该软件的公司挂掉，代码仍然可以通过其用户社区继续存在和发展。</li>\n</ul>\n</li>\n<li>优势5 ：实践的探索<ul>\n<li>我们可以很容易地“亲身探索”源码，以便更好地了解产品并作出改善。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"劣势显著\"><a href=\"#劣势显著\" class=\"headerlink\" title=\"劣势显著\"></a>劣势显著</h4><ul>\n<li>缺点1 ：它不是完全免费<ul>\n<li>开源软件可以涉及意料之外的实施、管理和支持成本。</li>\n</ul>\n</li>\n<li>缺点2：学习曲线（技术支持）<ul>\n<li>你可能在开源的产品上需要聘请专家，让自己加快速度。</li>\n</ul>\n</li>\n<li>缺点3：迷茫的用户<ul>\n<li>由于并行发展的努力在进行中，用户可能不知道哪个版本做什么或是否与你专有平台上的其他软件兼容。</li>\n</ul>\n</li>\n<li>缺点4：孤立软件<ul>\n<li>由于关键的程序员的斗争和退出，或他们失去兴趣转移到新的项目，使一些开源项目陷于停顿和死亡。</li>\n</ul>\n</li>\n<li>缺点5：独立地（凭自己的力量）<ul>\n<li>与商业产品不同，没有人在开源社区义务来帮助你，或回答你的任何问题。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"开源，仁者见仁智者见智\"><a href=\"#开源，仁者见仁智者见智\" class=\"headerlink\" title=\"开源，仁者见仁智者见智\"></a>开源，仁者见仁智者见智</h4><h4 id=\"与开源有关的小故事-曾铭\"><a href=\"#与开源有关的小故事-曾铭\" class=\"headerlink\" title=\"与开源有关的小故事 - 曾铭\"></a>与开源有关的小故事 - 曾铭</h4><ul>\n<li>比尔·盖茨<ul>\n<li>软件私有，保护版权</li>\n<li>1976 年 《致计算机爱好者的公开信》</li>\n</ul>\n</li>\n<li>理查德.斯托曼<ul>\n<li>Free Soft</li>\n<li>GNU，GPL，Emacs，GCC</li>\n<li>推荐两本书：《大教堂与集市》《Just for Fun》</li>\n<li><a href=\"https://www.v2ex.com/t/45480\" target=\"_blank\" rel=\"noopener\">HHKB</a> ；）</li>\n</ul>\n</li>\n<li>思考<ul>\n<li>开源软件和私有软件哪个质量更高？</li>\n<li>怎样参与开源？：<ul>\n<li>Github</li>\n<li>开源就是一种开放交流的态度</li>\n<li>不怕暴露自己的傻 X，（每个人都认为自己是对的，）万一对了呢 ；）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>最后再推荐一部纪录片：<a href=\"http://v.youku.com/v_show/id_XNzYyMDg3MzYw.html\" target=\"_blank\" rel=\"noopener\">互联网之子</a></li>\n</ul>\n<h4 id=\"我如何接触开源-潘君\"><a href=\"#我如何接触开源-潘君\" class=\"headerlink\" title=\"我如何接触开源 - 潘君\"></a>我如何接触开源 - 潘君</h4><ul>\n<li><p>github trending</p>\n<ul>\n<li>代码 trending<ul>\n<li>寻找有潜力的开源项目</li>\n</ul>\n</li>\n<li>开发者 trending<ul>\n<li>好的开发者应该不止一个好软件 顺藤摸瓜比较方便</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>苹果官方开源</p>\n<ul>\n<li><a href=\"http://www.opensource.apple.com/\" target=\"_blank\" rel=\"noopener\">Apple Open Source</a></li>\n<li>重点代码<ul>\n<li><a href=\"http://www.opensource.apple.com/source/objc4/objc4-437.1/runtime/\" target=\"_blank\" rel=\"noopener\">runtime</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>开源软件闲暇阅读工具</p>\n<ul>\n<li>CodeNav - 移动端优秀的代码查看软件<ul>\n<li>优点<ul>\n<li>支持多种方式导入源码</li>\n<li>交互不错 各种操作都算是方便</li>\n</ul>\n</li>\n<li>缺点<ul>\n<li>大屏支持还有bug</li>\n<li>不支持swift语法高亮</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>自用较多的开源软件<ul>\n<li><a href=\"https://github.com/insidegui/WWDC\" target=\"_blank\" rel=\"noopener\">WWDC app for OS X</a></li>\n<li><a href=\"https://github.com/monoclesociety/eggscellent\" target=\"_blank\" rel=\"noopener\">eggscellent</a></li>\n<li><a href=\"https://github.com/kovidgoyal/calibre\" target=\"_blank\" rel=\"noopener\">calibre</a></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"参与开源软件的心得-王胜\"><a href=\"#参与开源软件的心得-王胜\" class=\"headerlink\" title=\"参与开源软件的心得 - 王胜\"></a>参与开源软件的心得 - 王胜</h4><ul>\n<li>参与方式：<ul>\n<li>泡开源官方网站论坛，并参与issue讨论</li>\n<li>修改源码，生成patch文件，发给社区维护者</li>\n<li>有了Git &amp;&amp; Github后，可以fork分支，修改代码，发送pull request</li>\n</ul>\n</li>\n<li>参与过程情绪波动：<br>查看源码 -&gt; 领悟学习 -&gt; 发现问题 -&gt; 动手解决 -&gt; 跟社区提交者沟通纳入源码树 or 通过github发送pull request<br>-&gt; 上游采用 -&gt; 成就感十足。从而形成良性持续性参与感，并参与其中。</li>\n<li>收获心得：<ul>\n<li>一次提交只做一件事</li>\n<li>提交说明规范、简单、见名知意。后续参与者看提交树就能看到软件的演化历史</li>\n<li>代码开源，足够多的眼睛，使bug无处可藏</li>\n<li>开源导致世界范围内可见，代码的创意来自于全球智慧的汇聚</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"OkHttp开源框架介绍-李仙鹏\"><a href=\"#OkHttp开源框架介绍-李仙鹏\" class=\"headerlink\" title=\"OkHttp开源框架介绍 - 李仙鹏\"></a>OkHttp开源框架介绍 - 李仙鹏</h4><h5 id=\"SPDY\"><a href=\"#SPDY\" class=\"headerlink\" title=\"SPDY\"></a>SPDY</h5><p>Google开发的基于TCP的应用层协议，用以最小化网络延迟，提升网络速度，优化用户的网络使用体验。SPDY并不是一种用于替代HTTP的协议，而是对HTTP协议的增强。</p>\n<blockquote>\n<p>新协议的功能:</p>\n<ul>\n<li>数据流的多路复用</li>\n<li>请求优先级</li>\n<li>HTTP报头压缩。</li>\n<li>服务器推送（即Server Push技术）</li>\n</ul>\n</blockquote>\n<p>谷歌表示，引入SPDY协议后，在实验室测试中页面加载速度比原先快64%。</p>\n<p>现在已经被Google弃用，推出新的基于SPDY实现的HTTP2.0。</p>\n<h5 id=\"HTTP2-0\"><a href=\"#HTTP2-0\" class=\"headerlink\" title=\"HTTP2.0\"></a>HTTP2.0</h5><p>HTTP也是基于TCP的应用层协议，大家熟知的为：</p>\n<ul>\n<li>HTTP 0.9，只有基本的文本 GET 功能。</li>\n<li>HTTP 1.0，完善的请求/响应模型，并将协议补充完整。</li>\n<li>HTTP 1.1，在 1.0 基础上进行更新，增加了如 长久连接 keep-alive 与 chunked 等功能。</li>\n</ul>\n<p>HTTP 2.0在2013年8月推出，基于Google的SPDY开发。</p>\n<h5 id=\"OkHTTP\"><a href=\"#OkHTTP\" class=\"headerlink\" title=\"OkHTTP\"></a>OkHTTP</h5><p><a href=\"http://square.github.io/okhttp/\" target=\"_blank\" rel=\"noopener\">OKHTTP</a>is an HTTP client that’s efficient by default:</p>\n<ul>\n<li>HTTP/2 and SPDY support allows all requests to the same host to share a socket.</li>\n<li>Connection pooling reduces request latency (if SPDY isn’t available).</li>\n<li>Transparent GZIP shrinks download sizes.</li>\n<li>Response caching avoids the network completely for repeat requests.</li>\n</ul>\n<blockquote>\n<p>OkHttp supports Android 2.3 and above. For Java, the minimum requirement is 1.7.<br>You’ll also need Okio, which OkHttp uses for fast I/O and resizable buffers.</p>\n</blockquote>\n<h4 id=\"如何推广自己的开源项目-github获取更多的star-杨志平\"><a href=\"#如何推广自己的开源项目-github获取更多的star-杨志平\" class=\"headerlink\" title=\"如何推广自己的开源项目(github获取更多的star) - 杨志平\"></a>如何推广自己的开源项目(github获取更多的star) - 杨志平</h4><h5 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h5><p><code>你可能花费几天甚至几个月时间开源一个你写的代码，但是没有人去使用它，靠运气的话可能可以推广.\n现在我讲讲如何让人们关注我们的作品。该要点是打破下面的图片的循环</code></p>\n<p><img src=\"https://d262ilb51hltx0.cloudfront.net/max/727/1*xBernzyrTjSbfMMQWdE0qQ.png\" alt=\"图片一\"></p>\n<h4 id=\"六步（4-6是秘诀）\"><a href=\"#六步（4-6是秘诀）\" class=\"headerlink\" title=\"六步（4-6是秘诀）\"></a>六步（4-6是秘诀）</h4><ol>\n<li>Projects are Everything</li>\n</ol>\n<ul>\n<li>Read and Research</li>\n<li>Building the Repo</li>\n<li>README 文件</li>\n<li>图解</li>\n<li>更新反馈</li>\n</ul>\n<h4 id=\"1-Projects-are-Everything\"><a href=\"#1-Projects-are-Everything\" class=\"headerlink\" title=\"1.Projects are Everything\"></a>1.Projects are Everything</h4><p>开源代码就是给其他程序员解决问题或者节约时间的</p>\n<h4 id=\"2-Read-and-Research\"><a href=\"#2-Read-and-Research\" class=\"headerlink\" title=\"2.Read and Research\"></a>2.Read and Research</h4><p><code>很多问题都已经解决成千上万次了</code><br>你可以想一个你感兴趣的开源项目，上网搜索确认它的实现是不是已经有很多人实现了并有很多人已经使用它了，那就忘了这个想法。但是如果没有，或者解决方案不理想（可以通过issues查看他们的不足）你有时间的话就建一个和他们相识的开源项目，修复一些issues使用自己的文档（感觉有点无耻，但听说很有效）</p>\n<h3 id=\"3-Building-the-Repo\"><a href=\"#3-Building-the-Repo\" class=\"headerlink\" title=\"3.Building the Repo\"></a>3.Building the Repo</h3><p>有一点就是，通常我们后面的repo的star增加速度比以前的repo要快挺多的，可能是以前的repo使得更多人认识你相信你。</p>\n<p>####4.README 文件(推荐布局方案)</p>\n<p><img src=\"https://d262ilb51hltx0.cloudfront.net/max/861/1*JK3G5F-iIO7JFwxN9Dnwrw.png\" alt=\"图片2\"></p>\n<h4 id=\"5-图解（特效，一目了然）\"><a href=\"#5-图解（特效，一目了然）\" class=\"headerlink\" title=\"5.图解（特效，一目了然）\"></a>5.图解（特效，一目了然）</h4><p><img src=\"https://github.com/ZhipingYang/UUChatTableView/raw/master/Demo/UUChatTableViewTests/ChatTableView.gif\" alt=\"Flipboard playing multiple GIFs\"></p>\n<h4 id=\"6-更新反馈\"><a href=\"#6-更新反馈\" class=\"headerlink\" title=\"6.更新反馈\"></a>6.更新反馈</h4><p>完成以上步骤，并不断更新开源库及时解决issues里面的bug就很有希望进入<br>star趋势<br><img src=\"https://d262ilb51hltx0.cloudfront.net/max/1800/1*Yk2DM31wlKquLH7CIN5vkQ.png\" alt=\"图片2\"><br>贡献名人<br><img src=\"https://d262ilb51hltx0.cloudfront.net/max/948/1*QFeal7p7uUS0As74S1tePA.png\" alt=\"图片2\"></p>\n<h4 id=\"开源协议-吴明\"><a href=\"#开源协议-吴明\" class=\"headerlink\" title=\"开源协议 - 吴明\"></a>开源协议 - 吴明</h4><ul>\n<li><p>无规矩不成方圆，开源协议</p>\n<ul>\n<li>BSD开源协议：满足三个条件<ul>\n<li>如果再发布的产品中包含源代码，则在源代码中必须带有原来代码中的BSD协议</li>\n<li>如果再发布的只是二进制类库/软件，则需要在类库/软件的文档和版权声明中包含原来代码中的BSD协议</li>\n<li>不可以用开源代码的作者/机构名字和原来产品的名字做市场推广<ul>\n<li>Apache Licence 2.0：(关心软件的专利问题，但同样希望宽松，选择这个协议)</li>\n<li>需要给代码的用户一份Apache Licence</li>\n<li>如果你修改了代码，需要再被修改的文件中说明。</li>\n<li>在延伸的代码中（修改和有源代码衍生的代码中）需要带有原来代码中的协议，商标，专利声明和其他原来作者规定需要包含的说明</li>\n<li>如果再发布的产品中包含一个Notice文件，则在Notice文件中需要带有Apache Licence。你可以在Notice中增加自己的许可，但不可以表现为对Apache Licence构成更改</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>GPL：(Linux)(希望代码使用者同样能把他们的贡献分享出来，那就选择GPL)</p>\n<ul>\n<li>GPL协议和BSD, Apache Licence等鼓励代码重用的许可很不一样</li>\n<li>代码的开源/免费使用和引用/修改/衍生代码的开源/免费使用，但不允许修改后和衍生的代码做为闭源的商业软件发布和销售</li>\n<li>由于GPL严格要求使用了GPL类库的软件产品必须使用GPL协议，对于使用GPL协议的开源代码，商业软件或者对代码有保密要求的部门就不适合集成/采用作为类库和二次开发的基础。</li>\n</ul>\n</li>\n<li><p>MIT：(简单、宽松，”为所欲为”,选择这个协议)</p>\n<ul>\n<li>类似BSD协议</li>\n</ul>\n</li>\n<li><p>Mozilla</p>\n</li>\n<li><p>LGPL</p>\n<ul>\n<li>LGPL是GPL的一个为主要为类库使用设计的开源协议。和GPL要求任何使用/修改/衍生之GPL类库的的软件必须采用GPL协议不同。LGPL允许商业软件通过类库引用(link)方式使用LGPL类库而不需要开源商业软件的代码。这使得采用LGPL协议的开源代码可以被商业软件作为类库引用并发布和销售。</li>\n</ul>\n</li>\n<li><p>说了这么多最后一个<a href=\"http://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html\" target=\"_blank\" rel=\"noopener\">开源协议的选择</a></p>\n</li>\n<li>其他<ul>\n<li><a href=\"http://choosealicense.com/\" target=\"_blank\" rel=\"noopener\">github开源协议选择</a></li>\n<li><a href=\"http://www.awflasher.com/blog/archives/939\" target=\"_blank\" rel=\"noopener\">参考1</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html\" target=\"_blank\" rel=\"noopener\">参考2</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"开源\"><a href=\"#开源\" class=\"headerlink\" title=\"开源\"></a>开源</h2><h4 id=\"开源利弊浅谈-张超耀\"><a href=\"#开源利弊浅谈-张超耀\" class=\"headerlink\" title=\"开源利弊浅谈 - 张超耀\"></a>开源利弊浅谈 - 张超耀</h4><h4 id=\"开源？\"><a href=\"#开源？\" class=\"headerlink\" title=\"开源？\"></a>开源？</h4><ul>\n<li>开源，（Open Source）全称为开放源代码。开源就是要用户利用源代码在其基础上修改和学习的。</li>\n</ul>\n<h4 id=\"优势何在？\"><a href=\"#优势何在？\" class=\"headerlink\" title=\"优势何在？\"></a>优势何在？</h4><ul>\n<li>优势1：花费很少（如果有的话），许可费用<ul>\n<li>当然，这往往省去那些讨厌的维护费用。</li>\n</ul>\n</li>\n<li>优势2：易于管理<ul>\n<li>只要你想，你可以在尽可能多的地方安装开源软件。无需为许可证合规性计数、跟踪或监视。</li>\n</ul>\n</li>\n<li>优势3 ：连续，实时改进<ul>\n<li>因为每个人都可以访问源码，任何人都可以主动修改BUG，使其变得更好，而不必等待下一个版本。</li>\n</ul>\n</li>\n<li>优势4：公司独立<ul>\n<li>如果创建该软件的公司挂掉，代码仍然可以通过其用户社区继续存在和发展。</li>\n</ul>\n</li>\n<li>优势5 ：实践的探索<ul>\n<li>我们可以很容易地“亲身探索”源码，以便更好地了解产品并作出改善。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"劣势显著\"><a href=\"#劣势显著\" class=\"headerlink\" title=\"劣势显著\"></a>劣势显著</h4><ul>\n<li>缺点1 ：它不是完全免费<ul>\n<li>开源软件可以涉及意料之外的实施、管理和支持成本。</li>\n</ul>\n</li>\n<li>缺点2：学习曲线（技术支持）<ul>\n<li>你可能在开源的产品上需要聘请专家，让自己加快速度。</li>\n</ul>\n</li>\n<li>缺点3：迷茫的用户<ul>\n<li>由于并行发展的努力在进行中，用户可能不知道哪个版本做什么或是否与你专有平台上的其他软件兼容。</li>\n</ul>\n</li>\n<li>缺点4：孤立软件<ul>\n<li>由于关键的程序员的斗争和退出，或他们失去兴趣转移到新的项目，使一些开源项目陷于停顿和死亡。</li>\n</ul>\n</li>\n<li>缺点5：独立地（凭自己的力量）<ul>\n<li>与商业产品不同，没有人在开源社区义务来帮助你，或回答你的任何问题。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"开源，仁者见仁智者见智\"><a href=\"#开源，仁者见仁智者见智\" class=\"headerlink\" title=\"开源，仁者见仁智者见智\"></a>开源，仁者见仁智者见智</h4><h4 id=\"与开源有关的小故事-曾铭\"><a href=\"#与开源有关的小故事-曾铭\" class=\"headerlink\" title=\"与开源有关的小故事 - 曾铭\"></a>与开源有关的小故事 - 曾铭</h4><ul>\n<li>比尔·盖茨<ul>\n<li>软件私有，保护版权</li>\n<li>1976 年 《致计算机爱好者的公开信》</li>\n</ul>\n</li>\n<li>理查德.斯托曼<ul>\n<li>Free Soft</li>\n<li>GNU，GPL，Emacs，GCC</li>\n<li>推荐两本书：《大教堂与集市》《Just for Fun》</li>\n<li><a href=\"https://www.v2ex.com/t/45480\" target=\"_blank\" rel=\"noopener\">HHKB</a> ；）</li>\n</ul>\n</li>\n<li>思考<ul>\n<li>开源软件和私有软件哪个质量更高？</li>\n<li>怎样参与开源？：<ul>\n<li>Github</li>\n<li>开源就是一种开放交流的态度</li>\n<li>不怕暴露自己的傻 X，（每个人都认为自己是对的，）万一对了呢 ；）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>最后再推荐一部纪录片：<a href=\"http://v.youku.com/v_show/id_XNzYyMDg3MzYw.html\" target=\"_blank\" rel=\"noopener\">互联网之子</a></li>\n</ul>\n<h4 id=\"我如何接触开源-潘君\"><a href=\"#我如何接触开源-潘君\" class=\"headerlink\" title=\"我如何接触开源 - 潘君\"></a>我如何接触开源 - 潘君</h4><ul>\n<li><p>github trending</p>\n<ul>\n<li>代码 trending<ul>\n<li>寻找有潜力的开源项目</li>\n</ul>\n</li>\n<li>开发者 trending<ul>\n<li>好的开发者应该不止一个好软件 顺藤摸瓜比较方便</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>苹果官方开源</p>\n<ul>\n<li><a href=\"http://www.opensource.apple.com/\" target=\"_blank\" rel=\"noopener\">Apple Open Source</a></li>\n<li>重点代码<ul>\n<li><a href=\"http://www.opensource.apple.com/source/objc4/objc4-437.1/runtime/\" target=\"_blank\" rel=\"noopener\">runtime</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>开源软件闲暇阅读工具</p>\n<ul>\n<li>CodeNav - 移动端优秀的代码查看软件<ul>\n<li>优点<ul>\n<li>支持多种方式导入源码</li>\n<li>交互不错 各种操作都算是方便</li>\n</ul>\n</li>\n<li>缺点<ul>\n<li>大屏支持还有bug</li>\n<li>不支持swift语法高亮</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>自用较多的开源软件<ul>\n<li><a href=\"https://github.com/insidegui/WWDC\" target=\"_blank\" rel=\"noopener\">WWDC app for OS X</a></li>\n<li><a href=\"https://github.com/monoclesociety/eggscellent\" target=\"_blank\" rel=\"noopener\">eggscellent</a></li>\n<li><a href=\"https://github.com/kovidgoyal/calibre\" target=\"_blank\" rel=\"noopener\">calibre</a></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"参与开源软件的心得-王胜\"><a href=\"#参与开源软件的心得-王胜\" class=\"headerlink\" title=\"参与开源软件的心得 - 王胜\"></a>参与开源软件的心得 - 王胜</h4><ul>\n<li>参与方式：<ul>\n<li>泡开源官方网站论坛，并参与issue讨论</li>\n<li>修改源码，生成patch文件，发给社区维护者</li>\n<li>有了Git &amp;&amp; Github后，可以fork分支，修改代码，发送pull request</li>\n</ul>\n</li>\n<li>参与过程情绪波动：<br>查看源码 -&gt; 领悟学习 -&gt; 发现问题 -&gt; 动手解决 -&gt; 跟社区提交者沟通纳入源码树 or 通过github发送pull request<br>-&gt; 上游采用 -&gt; 成就感十足。从而形成良性持续性参与感，并参与其中。</li>\n<li>收获心得：<ul>\n<li>一次提交只做一件事</li>\n<li>提交说明规范、简单、见名知意。后续参与者看提交树就能看到软件的演化历史</li>\n<li>代码开源，足够多的眼睛，使bug无处可藏</li>\n<li>开源导致世界范围内可见，代码的创意来自于全球智慧的汇聚</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"OkHttp开源框架介绍-李仙鹏\"><a href=\"#OkHttp开源框架介绍-李仙鹏\" class=\"headerlink\" title=\"OkHttp开源框架介绍 - 李仙鹏\"></a>OkHttp开源框架介绍 - 李仙鹏</h4><h5 id=\"SPDY\"><a href=\"#SPDY\" class=\"headerlink\" title=\"SPDY\"></a>SPDY</h5><p>Google开发的基于TCP的应用层协议，用以最小化网络延迟，提升网络速度，优化用户的网络使用体验。SPDY并不是一种用于替代HTTP的协议，而是对HTTP协议的增强。</p>\n<blockquote>\n<p>新协议的功能:</p>\n<ul>\n<li>数据流的多路复用</li>\n<li>请求优先级</li>\n<li>HTTP报头压缩。</li>\n<li>服务器推送（即Server Push技术）</li>\n</ul>\n</blockquote>\n<p>谷歌表示，引入SPDY协议后，在实验室测试中页面加载速度比原先快64%。</p>\n<p>现在已经被Google弃用，推出新的基于SPDY实现的HTTP2.0。</p>\n<h5 id=\"HTTP2-0\"><a href=\"#HTTP2-0\" class=\"headerlink\" title=\"HTTP2.0\"></a>HTTP2.0</h5><p>HTTP也是基于TCP的应用层协议，大家熟知的为：</p>\n<ul>\n<li>HTTP 0.9，只有基本的文本 GET 功能。</li>\n<li>HTTP 1.0，完善的请求/响应模型，并将协议补充完整。</li>\n<li>HTTP 1.1，在 1.0 基础上进行更新，增加了如 长久连接 keep-alive 与 chunked 等功能。</li>\n</ul>\n<p>HTTP 2.0在2013年8月推出，基于Google的SPDY开发。</p>\n<h5 id=\"OkHTTP\"><a href=\"#OkHTTP\" class=\"headerlink\" title=\"OkHTTP\"></a>OkHTTP</h5><p><a href=\"http://square.github.io/okhttp/\" target=\"_blank\" rel=\"noopener\">OKHTTP</a>is an HTTP client that’s efficient by default:</p>\n<ul>\n<li>HTTP/2 and SPDY support allows all requests to the same host to share a socket.</li>\n<li>Connection pooling reduces request latency (if SPDY isn’t available).</li>\n<li>Transparent GZIP shrinks download sizes.</li>\n<li>Response caching avoids the network completely for repeat requests.</li>\n</ul>\n<blockquote>\n<p>OkHttp supports Android 2.3 and above. For Java, the minimum requirement is 1.7.<br>You’ll also need Okio, which OkHttp uses for fast I/O and resizable buffers.</p>\n</blockquote>\n<h4 id=\"如何推广自己的开源项目-github获取更多的star-杨志平\"><a href=\"#如何推广自己的开源项目-github获取更多的star-杨志平\" class=\"headerlink\" title=\"如何推广自己的开源项目(github获取更多的star) - 杨志平\"></a>如何推广自己的开源项目(github获取更多的star) - 杨志平</h4><h5 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h5><p><code>你可能花费几天甚至几个月时间开源一个你写的代码，但是没有人去使用它，靠运气的话可能可以推广.\n现在我讲讲如何让人们关注我们的作品。该要点是打破下面的图片的循环</code></p>\n<p><img src=\"https://d262ilb51hltx0.cloudfront.net/max/727/1*xBernzyrTjSbfMMQWdE0qQ.png\" alt=\"图片一\"></p>\n<h4 id=\"六步（4-6是秘诀）\"><a href=\"#六步（4-6是秘诀）\" class=\"headerlink\" title=\"六步（4-6是秘诀）\"></a>六步（4-6是秘诀）</h4><ol>\n<li>Projects are Everything</li>\n</ol>\n<ul>\n<li>Read and Research</li>\n<li>Building the Repo</li>\n<li>README 文件</li>\n<li>图解</li>\n<li>更新反馈</li>\n</ul>\n<h4 id=\"1-Projects-are-Everything\"><a href=\"#1-Projects-are-Everything\" class=\"headerlink\" title=\"1.Projects are Everything\"></a>1.Projects are Everything</h4><p>开源代码就是给其他程序员解决问题或者节约时间的</p>\n<h4 id=\"2-Read-and-Research\"><a href=\"#2-Read-and-Research\" class=\"headerlink\" title=\"2.Read and Research\"></a>2.Read and Research</h4><p><code>很多问题都已经解决成千上万次了</code><br>你可以想一个你感兴趣的开源项目，上网搜索确认它的实现是不是已经有很多人实现了并有很多人已经使用它了，那就忘了这个想法。但是如果没有，或者解决方案不理想（可以通过issues查看他们的不足）你有时间的话就建一个和他们相识的开源项目，修复一些issues使用自己的文档（感觉有点无耻，但听说很有效）</p>\n<h3 id=\"3-Building-the-Repo\"><a href=\"#3-Building-the-Repo\" class=\"headerlink\" title=\"3.Building the Repo\"></a>3.Building the Repo</h3><p>有一点就是，通常我们后面的repo的star增加速度比以前的repo要快挺多的，可能是以前的repo使得更多人认识你相信你。</p>\n<p>####4.README 文件(推荐布局方案)</p>\n<p><img src=\"https://d262ilb51hltx0.cloudfront.net/max/861/1*JK3G5F-iIO7JFwxN9Dnwrw.png\" alt=\"图片2\"></p>\n<h4 id=\"5-图解（特效，一目了然）\"><a href=\"#5-图解（特效，一目了然）\" class=\"headerlink\" title=\"5.图解（特效，一目了然）\"></a>5.图解（特效，一目了然）</h4><p><img src=\"https://github.com/ZhipingYang/UUChatTableView/raw/master/Demo/UUChatTableViewTests/ChatTableView.gif\" alt=\"Flipboard playing multiple GIFs\"></p>\n<h4 id=\"6-更新反馈\"><a href=\"#6-更新反馈\" class=\"headerlink\" title=\"6.更新反馈\"></a>6.更新反馈</h4><p>完成以上步骤，并不断更新开源库及时解决issues里面的bug就很有希望进入<br>star趋势<br><img src=\"https://d262ilb51hltx0.cloudfront.net/max/1800/1*Yk2DM31wlKquLH7CIN5vkQ.png\" alt=\"图片2\"><br>贡献名人<br><img src=\"https://d262ilb51hltx0.cloudfront.net/max/948/1*QFeal7p7uUS0As74S1tePA.png\" alt=\"图片2\"></p>\n<h4 id=\"开源协议-吴明\"><a href=\"#开源协议-吴明\" class=\"headerlink\" title=\"开源协议 - 吴明\"></a>开源协议 - 吴明</h4><ul>\n<li><p>无规矩不成方圆，开源协议</p>\n<ul>\n<li>BSD开源协议：满足三个条件<ul>\n<li>如果再发布的产品中包含源代码，则在源代码中必须带有原来代码中的BSD协议</li>\n<li>如果再发布的只是二进制类库/软件，则需要在类库/软件的文档和版权声明中包含原来代码中的BSD协议</li>\n<li>不可以用开源代码的作者/机构名字和原来产品的名字做市场推广<ul>\n<li>Apache Licence 2.0：(关心软件的专利问题，但同样希望宽松，选择这个协议)</li>\n<li>需要给代码的用户一份Apache Licence</li>\n<li>如果你修改了代码，需要再被修改的文件中说明。</li>\n<li>在延伸的代码中（修改和有源代码衍生的代码中）需要带有原来代码中的协议，商标，专利声明和其他原来作者规定需要包含的说明</li>\n<li>如果再发布的产品中包含一个Notice文件，则在Notice文件中需要带有Apache Licence。你可以在Notice中增加自己的许可，但不可以表现为对Apache Licence构成更改</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>GPL：(Linux)(希望代码使用者同样能把他们的贡献分享出来，那就选择GPL)</p>\n<ul>\n<li>GPL协议和BSD, Apache Licence等鼓励代码重用的许可很不一样</li>\n<li>代码的开源/免费使用和引用/修改/衍生代码的开源/免费使用，但不允许修改后和衍生的代码做为闭源的商业软件发布和销售</li>\n<li>由于GPL严格要求使用了GPL类库的软件产品必须使用GPL协议，对于使用GPL协议的开源代码，商业软件或者对代码有保密要求的部门就不适合集成/采用作为类库和二次开发的基础。</li>\n</ul>\n</li>\n<li><p>MIT：(简单、宽松，”为所欲为”,选择这个协议)</p>\n<ul>\n<li>类似BSD协议</li>\n</ul>\n</li>\n<li><p>Mozilla</p>\n</li>\n<li><p>LGPL</p>\n<ul>\n<li>LGPL是GPL的一个为主要为类库使用设计的开源协议。和GPL要求任何使用/修改/衍生之GPL类库的的软件必须采用GPL协议不同。LGPL允许商业软件通过类库引用(link)方式使用LGPL类库而不需要开源商业软件的代码。这使得采用LGPL协议的开源代码可以被商业软件作为类库引用并发布和销售。</li>\n</ul>\n</li>\n<li><p>说了这么多最后一个<a href=\"http://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html\" target=\"_blank\" rel=\"noopener\">开源协议的选择</a></p>\n</li>\n<li>其他<ul>\n<li><a href=\"http://choosealicense.com/\" target=\"_blank\" rel=\"noopener\">github开源协议选择</a></li>\n<li><a href=\"http://www.awflasher.com/blog/archives/939\" target=\"_blank\" rel=\"noopener\">参考1</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html\" target=\"_blank\" rel=\"noopener\">参考2</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n"},{"title":"微信公众号开发","date":"2015-07-10T15:51:00.000Z","_content":"\n## 对于微信公众号开发的疑问\n\n- 微信公众点与自己服务器配对流程\n- 本地如何调试\n- 微信整体流程中用到的一些特殊协议?\n- openId/unionId 哪里查看\n- access_token 为什么要有时间限制 为什么是2小时\n- 网页授权如何做的?能取到哪些信息?\n- 参加活动不关注 能拿到多少信息\n- 菜单type类型\n- 有哪些好的第三方开发工具包\n- 所有的活动行为全部调一个url 有没有好的分发解决方案\n\n\n## 公众号查询通讯录的实现 - 曾铭\n\n### 思路\n- 通讯录表 -> 后台数据库\n- 用户关注公众号\n- 用户发消息（姓名）给公众号\n- 微信后台转发此消息给网站后台 post XML\n- 后台根据此消息（姓名）查询数据库，得到此人具体数据，组合 XML 返回给微信后台\n- 微信后台把具体数据展示给用户\n\n### 实现\n- 通讯录表 xls -> csv -> 导入到 LeanCloud 数据库\n- 基于 express (node.js web 框架)，建立 51offer_wechat.avosapps.com/contact_bot 站点；\n- 微信公众号后台配置开发者后台 URL，处理后台网址 get 请求，完成微信对开发者后台的验证\n- 处理网址 post 请求，完成接受消息，查询数据库，返回用户信息工作。具体参考：[这里](https://github.com/51offer/wechat_bot/commit/25d457c7430d88167d62b053a5d072d588c9c95b)\n\n### 总结\n- node.js (express) 处理网络请求的确精简方便\n- 微信公众号的所有信息都转发到一个接口，后续处理类型多时要设计合理的分发机制\n- 微信接口为什么用 XML 而不是 json 啊，这点不熟悉占用不少时间\n- 做这个很有意思，推荐大家多玩玩~\n\n## 商户端APP集成微信扫描支付 - 王胜\n\n### 准备工作\n\n* APP端微信支付SDK\n  [[Android]](https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&t=resource/res_list&verify=1&id=open1419317784&token=&lang=zh_CN) | [[iOS]](https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&t=resource/res_list&verify=1&id=open1419317782&token=&lang=zh_CN)\n* 服务端微信支付SDK\n  [[JAVA]](https://pay.weixin.qq.com/wiki/doc/api/download/wxpay_scanpay_java_sdk_proj-master.zip) |\n  [[PHP]](https://pay.weixin.qq.com/wiki/doc/api/download/WxpayAPI_php_v3.zip)\n* 服务端暴露notify接口\n* push通道\n\n### 支付流程\n\n1. 用户在APP端浏览商品\n2. 加入购物车\n3. 结算\n4. 调用提交订单接口\n5. 提交订单接口返回预支付链接(**预支付链接可根据服务端微信支付sdk生成**)\n6. APP根据链接生成二维码\n7. 用户拿起手机扫描支付\n8. 微信调用第三方开发者服务端暴露的notify接口\n9. 第三方服务端在收到notify接口调用时，更新订单库里订单状态，同时调用push通道告诉APP支付成功\n10. APP收到push命令后进行页面跳转\n\n\n\n## 微信分享 - 吴明\n- 微信工作原理\n  - ![Alt text](http://img.blog.csdn.net/20140823103621745?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvR29vZFNob3Q=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n- 接口：\n    - 你需要触发什么事件\n    - 微信事件触发会回调哪里接口\n- 微信服务：\n  - 订阅号：\n  - [服务号](https://mp.weixin.qq.com)\n     - [微信公众测试账号](http://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login)\n     - [微信公众平台接口调试工具](http://mp.weixin.qq.com/debug)\n  - 企业号\n     - [微信企业号](https://qy.weixin.qq.com)\n     - [微信企业号申请体验号](https://qy.weixin.qq.com/try)\n     - [iwork365企业号体验](http://www.iwork365.com/experience)\n  - 微购物\n - 微信公众号自定义菜单开发\n      - 接口文档\n            - [获取access token](http://mp.weixin.qq.com/wiki/11/0e4b294685f817b95cbed85ba5e82b8f.html)\n            - [自定义菜单创建接口](http://mp.weixin.qq.com/wiki/13/43de8269be54a0a6f64413e4dfa94f39.html)\n            - 以下操作都是在[微信公众平台接口调试工具](http://mp.weixin.qq.com/debug)调试方法\n      - 步骤1：调用“获取access token”接口,传入你申请的测试微信公众号的appid和secret获取access_token\n      - 步骤2：调用“自定义菜单创建接口”，传入上面生成的access_token和“自定义菜单json数据\"如下\n\n```\n{\n    \"button\": [\n        {\n            \"type\": \"view\",\n            \"name\": \"51offer\",\n            \"url\": \"http://www.51offer.com/\"\n        },\n        {\n            \"name\": \"移动\",\n            \"sub_button\": [\n                {\n                    \"type\": \"view\",\n                    \"name\": \"blog\",\n                    \"url\": \"http://51offer.github.io/\"\n                },\n                {\n                    \"type\": \"view\",\n                    \"name\": \"github\",\n                    \"url\": \"https://github.com/51offer/public-docs/wiki\"\n                }\n            ]\n        },\n        {\n            \"type\": \"click\",\n            \"name\": \"我\",\n            \"key\": \"me\"\n        }\n    ]\n}\n```\n\n- 推荐：公众号：招商信用卡\n","source":"_posts/微信公众号开发.md","raw":"title: 微信公众号开发\ndate: 2015-07-10 15:51\ntags:\ncategories: 移动组周分享\n---\n\n## 对于微信公众号开发的疑问\n\n- 微信公众点与自己服务器配对流程\n- 本地如何调试\n- 微信整体流程中用到的一些特殊协议?\n- openId/unionId 哪里查看\n- access_token 为什么要有时间限制 为什么是2小时\n- 网页授权如何做的?能取到哪些信息?\n- 参加活动不关注 能拿到多少信息\n- 菜单type类型\n- 有哪些好的第三方开发工具包\n- 所有的活动行为全部调一个url 有没有好的分发解决方案\n\n\n## 公众号查询通讯录的实现 - 曾铭\n\n### 思路\n- 通讯录表 -> 后台数据库\n- 用户关注公众号\n- 用户发消息（姓名）给公众号\n- 微信后台转发此消息给网站后台 post XML\n- 后台根据此消息（姓名）查询数据库，得到此人具体数据，组合 XML 返回给微信后台\n- 微信后台把具体数据展示给用户\n\n### 实现\n- 通讯录表 xls -> csv -> 导入到 LeanCloud 数据库\n- 基于 express (node.js web 框架)，建立 51offer_wechat.avosapps.com/contact_bot 站点；\n- 微信公众号后台配置开发者后台 URL，处理后台网址 get 请求，完成微信对开发者后台的验证\n- 处理网址 post 请求，完成接受消息，查询数据库，返回用户信息工作。具体参考：[这里](https://github.com/51offer/wechat_bot/commit/25d457c7430d88167d62b053a5d072d588c9c95b)\n\n### 总结\n- node.js (express) 处理网络请求的确精简方便\n- 微信公众号的所有信息都转发到一个接口，后续处理类型多时要设计合理的分发机制\n- 微信接口为什么用 XML 而不是 json 啊，这点不熟悉占用不少时间\n- 做这个很有意思，推荐大家多玩玩~\n\n## 商户端APP集成微信扫描支付 - 王胜\n\n### 准备工作\n\n* APP端微信支付SDK\n  [[Android]](https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&t=resource/res_list&verify=1&id=open1419317784&token=&lang=zh_CN) | [[iOS]](https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&t=resource/res_list&verify=1&id=open1419317782&token=&lang=zh_CN)\n* 服务端微信支付SDK\n  [[JAVA]](https://pay.weixin.qq.com/wiki/doc/api/download/wxpay_scanpay_java_sdk_proj-master.zip) |\n  [[PHP]](https://pay.weixin.qq.com/wiki/doc/api/download/WxpayAPI_php_v3.zip)\n* 服务端暴露notify接口\n* push通道\n\n### 支付流程\n\n1. 用户在APP端浏览商品\n2. 加入购物车\n3. 结算\n4. 调用提交订单接口\n5. 提交订单接口返回预支付链接(**预支付链接可根据服务端微信支付sdk生成**)\n6. APP根据链接生成二维码\n7. 用户拿起手机扫描支付\n8. 微信调用第三方开发者服务端暴露的notify接口\n9. 第三方服务端在收到notify接口调用时，更新订单库里订单状态，同时调用push通道告诉APP支付成功\n10. APP收到push命令后进行页面跳转\n\n\n\n## 微信分享 - 吴明\n- 微信工作原理\n  - ![Alt text](http://img.blog.csdn.net/20140823103621745?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvR29vZFNob3Q=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n- 接口：\n    - 你需要触发什么事件\n    - 微信事件触发会回调哪里接口\n- 微信服务：\n  - 订阅号：\n  - [服务号](https://mp.weixin.qq.com)\n     - [微信公众测试账号](http://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login)\n     - [微信公众平台接口调试工具](http://mp.weixin.qq.com/debug)\n  - 企业号\n     - [微信企业号](https://qy.weixin.qq.com)\n     - [微信企业号申请体验号](https://qy.weixin.qq.com/try)\n     - [iwork365企业号体验](http://www.iwork365.com/experience)\n  - 微购物\n - 微信公众号自定义菜单开发\n      - 接口文档\n            - [获取access token](http://mp.weixin.qq.com/wiki/11/0e4b294685f817b95cbed85ba5e82b8f.html)\n            - [自定义菜单创建接口](http://mp.weixin.qq.com/wiki/13/43de8269be54a0a6f64413e4dfa94f39.html)\n            - 以下操作都是在[微信公众平台接口调试工具](http://mp.weixin.qq.com/debug)调试方法\n      - 步骤1：调用“获取access token”接口,传入你申请的测试微信公众号的appid和secret获取access_token\n      - 步骤2：调用“自定义菜单创建接口”，传入上面生成的access_token和“自定义菜单json数据\"如下\n\n```\n{\n    \"button\": [\n        {\n            \"type\": \"view\",\n            \"name\": \"51offer\",\n            \"url\": \"http://www.51offer.com/\"\n        },\n        {\n            \"name\": \"移动\",\n            \"sub_button\": [\n                {\n                    \"type\": \"view\",\n                    \"name\": \"blog\",\n                    \"url\": \"http://51offer.github.io/\"\n                },\n                {\n                    \"type\": \"view\",\n                    \"name\": \"github\",\n                    \"url\": \"https://github.com/51offer/public-docs/wiki\"\n                }\n            ]\n        },\n        {\n            \"type\": \"click\",\n            \"name\": \"我\",\n            \"key\": \"me\"\n        }\n    ]\n}\n```\n\n- 推荐：公众号：招商信用卡\n","slug":"微信公众号开发","published":1,"updated":"2021-09-10T07:04:21.947Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cktfeap4b002cc2xxs2yyc287","content":"<h2 id=\"对于微信公众号开发的疑问\"><a href=\"#对于微信公众号开发的疑问\" class=\"headerlink\" title=\"对于微信公众号开发的疑问\"></a>对于微信公众号开发的疑问</h2><ul>\n<li>微信公众点与自己服务器配对流程</li>\n<li>本地如何调试</li>\n<li>微信整体流程中用到的一些特殊协议?</li>\n<li>openId/unionId 哪里查看</li>\n<li>access_token 为什么要有时间限制 为什么是2小时</li>\n<li>网页授权如何做的?能取到哪些信息?</li>\n<li>参加活动不关注 能拿到多少信息</li>\n<li>菜单type类型</li>\n<li>有哪些好的第三方开发工具包</li>\n<li>所有的活动行为全部调一个url 有没有好的分发解决方案</li>\n</ul>\n<h2 id=\"公众号查询通讯录的实现-曾铭\"><a href=\"#公众号查询通讯录的实现-曾铭\" class=\"headerlink\" title=\"公众号查询通讯录的实现 - 曾铭\"></a>公众号查询通讯录的实现 - 曾铭</h2><h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><ul>\n<li>通讯录表 -&gt; 后台数据库</li>\n<li>用户关注公众号</li>\n<li>用户发消息（姓名）给公众号</li>\n<li>微信后台转发此消息给网站后台 post XML</li>\n<li>后台根据此消息（姓名）查询数据库，得到此人具体数据，组合 XML 返回给微信后台</li>\n<li>微信后台把具体数据展示给用户</li>\n</ul>\n<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><ul>\n<li>通讯录表 xls -&gt; csv -&gt; 导入到 LeanCloud 数据库</li>\n<li>基于 express (node.js web 框架)，建立 51offer_wechat.avosapps.com/contact_bot 站点；</li>\n<li>微信公众号后台配置开发者后台 URL，处理后台网址 get 请求，完成微信对开发者后台的验证</li>\n<li>处理网址 post 请求，完成接受消息，查询数据库，返回用户信息工作。具体参考：<a href=\"https://github.com/51offer/wechat_bot/commit/25d457c7430d88167d62b053a5d072d588c9c95b\" target=\"_blank\" rel=\"noopener\">这里</a></li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li>node.js (express) 处理网络请求的确精简方便</li>\n<li>微信公众号的所有信息都转发到一个接口，后续处理类型多时要设计合理的分发机制</li>\n<li>微信接口为什么用 XML 而不是 json 啊，这点不熟悉占用不少时间</li>\n<li>做这个很有意思，推荐大家多玩玩~</li>\n</ul>\n<h2 id=\"商户端APP集成微信扫描支付-王胜\"><a href=\"#商户端APP集成微信扫描支付-王胜\" class=\"headerlink\" title=\"商户端APP集成微信扫描支付 - 王胜\"></a>商户端APP集成微信扫描支付 - 王胜</h2><h3 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h3><ul>\n<li>APP端微信支付SDK<br><a href=\"https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&amp;t=resource/res_list&amp;verify=1&amp;id=open1419317784&amp;token=&amp;lang=zh_CN\" target=\"_blank\" rel=\"noopener\">[Android]</a> | <a href=\"https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&amp;t=resource/res_list&amp;verify=1&amp;id=open1419317782&amp;token=&amp;lang=zh_CN\" target=\"_blank\" rel=\"noopener\">[iOS]</a></li>\n<li>服务端微信支付SDK<br><a href=\"https://pay.weixin.qq.com/wiki/doc/api/download/wxpay_scanpay_java_sdk_proj-master.zip\" target=\"_blank\" rel=\"noopener\">[JAVA]</a> |<br><a href=\"https://pay.weixin.qq.com/wiki/doc/api/download/WxpayAPI_php_v3.zip\" target=\"_blank\" rel=\"noopener\">[PHP]</a></li>\n<li>服务端暴露notify接口</li>\n<li>push通道</li>\n</ul>\n<h3 id=\"支付流程\"><a href=\"#支付流程\" class=\"headerlink\" title=\"支付流程\"></a>支付流程</h3><ol>\n<li>用户在APP端浏览商品</li>\n<li>加入购物车</li>\n<li>结算</li>\n<li>调用提交订单接口</li>\n<li>提交订单接口返回预支付链接(<strong>预支付链接可根据服务端微信支付sdk生成</strong>)</li>\n<li>APP根据链接生成二维码</li>\n<li>用户拿起手机扫描支付</li>\n<li>微信调用第三方开发者服务端暴露的notify接口</li>\n<li>第三方服务端在收到notify接口调用时，更新订单库里订单状态，同时调用push通道告诉APP支付成功</li>\n<li>APP收到push命令后进行页面跳转</li>\n</ol>\n<h2 id=\"微信分享-吴明\"><a href=\"#微信分享-吴明\" class=\"headerlink\" title=\"微信分享 - 吴明\"></a>微信分享 - 吴明</h2><ul>\n<li>微信工作原理<ul>\n<li><img src=\"http://img.blog.csdn.net/20140823103621745?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvR29vZFNob3Q=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"Alt text\"></li>\n</ul>\n</li>\n<li>接口：<ul>\n<li>你需要触发什么事件</li>\n<li>微信事件触发会回调哪里接口</li>\n</ul>\n</li>\n<li>微信服务：<ul>\n<li>订阅号：</li>\n<li><a href=\"https://mp.weixin.qq.com\" target=\"_blank\" rel=\"noopener\">服务号</a><ul>\n<li><a href=\"http://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login\" target=\"_blank\" rel=\"noopener\">微信公众测试账号</a></li>\n<li><a href=\"http://mp.weixin.qq.com/debug\" target=\"_blank\" rel=\"noopener\">微信公众平台接口调试工具</a></li>\n</ul>\n</li>\n<li>企业号<ul>\n<li><a href=\"https://qy.weixin.qq.com\" target=\"_blank\" rel=\"noopener\">微信企业号</a></li>\n<li><a href=\"https://qy.weixin.qq.com/try\" target=\"_blank\" rel=\"noopener\">微信企业号申请体验号</a></li>\n<li><a href=\"http://www.iwork365.com/experience\" target=\"_blank\" rel=\"noopener\">iwork365企业号体验</a></li>\n</ul>\n</li>\n<li>微购物</li>\n<li>微信公众号自定义菜单开发<ul>\n<li>接口文档<pre><code>- [获取access token](http://mp.weixin.qq.com/wiki/11/0e4b294685f817b95cbed85ba5e82b8f.html)\n- [自定义菜单创建接口](http://mp.weixin.qq.com/wiki/13/43de8269be54a0a6f64413e4dfa94f39.html)\n- 以下操作都是在[微信公众平台接口调试工具](http://mp.weixin.qq.com/debug)调试方法\n</code></pre></li>\n<li>步骤1：调用“获取access token”接口,传入你申请的测试微信公众号的appid和secret获取access_token</li>\n<li>步骤2：调用“自定义菜单创建接口”，传入上面生成的access_token和“自定义菜单json数据”如下</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<pre><code>{\n    &quot;button&quot;: [\n        {\n            &quot;type&quot;: &quot;view&quot;,\n            &quot;name&quot;: &quot;51offer&quot;,\n            &quot;url&quot;: &quot;http://www.51offer.com/&quot;\n        },\n        {\n            &quot;name&quot;: &quot;移动&quot;,\n            &quot;sub_button&quot;: [\n                {\n                    &quot;type&quot;: &quot;view&quot;,\n                    &quot;name&quot;: &quot;blog&quot;,\n                    &quot;url&quot;: &quot;http://51offer.github.io/&quot;\n                },\n                {\n                    &quot;type&quot;: &quot;view&quot;,\n                    &quot;name&quot;: &quot;github&quot;,\n                    &quot;url&quot;: &quot;https://github.com/51offer/public-docs/wiki&quot;\n                }\n            ]\n        },\n        {\n            &quot;type&quot;: &quot;click&quot;,\n            &quot;name&quot;: &quot;我&quot;,\n            &quot;key&quot;: &quot;me&quot;\n        }\n    ]\n}\n</code></pre><ul>\n<li>推荐：公众号：招商信用卡</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"对于微信公众号开发的疑问\"><a href=\"#对于微信公众号开发的疑问\" class=\"headerlink\" title=\"对于微信公众号开发的疑问\"></a>对于微信公众号开发的疑问</h2><ul>\n<li>微信公众点与自己服务器配对流程</li>\n<li>本地如何调试</li>\n<li>微信整体流程中用到的一些特殊协议?</li>\n<li>openId/unionId 哪里查看</li>\n<li>access_token 为什么要有时间限制 为什么是2小时</li>\n<li>网页授权如何做的?能取到哪些信息?</li>\n<li>参加活动不关注 能拿到多少信息</li>\n<li>菜单type类型</li>\n<li>有哪些好的第三方开发工具包</li>\n<li>所有的活动行为全部调一个url 有没有好的分发解决方案</li>\n</ul>\n<h2 id=\"公众号查询通讯录的实现-曾铭\"><a href=\"#公众号查询通讯录的实现-曾铭\" class=\"headerlink\" title=\"公众号查询通讯录的实现 - 曾铭\"></a>公众号查询通讯录的实现 - 曾铭</h2><h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><ul>\n<li>通讯录表 -&gt; 后台数据库</li>\n<li>用户关注公众号</li>\n<li>用户发消息（姓名）给公众号</li>\n<li>微信后台转发此消息给网站后台 post XML</li>\n<li>后台根据此消息（姓名）查询数据库，得到此人具体数据，组合 XML 返回给微信后台</li>\n<li>微信后台把具体数据展示给用户</li>\n</ul>\n<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><ul>\n<li>通讯录表 xls -&gt; csv -&gt; 导入到 LeanCloud 数据库</li>\n<li>基于 express (node.js web 框架)，建立 51offer_wechat.avosapps.com/contact_bot 站点；</li>\n<li>微信公众号后台配置开发者后台 URL，处理后台网址 get 请求，完成微信对开发者后台的验证</li>\n<li>处理网址 post 请求，完成接受消息，查询数据库，返回用户信息工作。具体参考：<a href=\"https://github.com/51offer/wechat_bot/commit/25d457c7430d88167d62b053a5d072d588c9c95b\" target=\"_blank\" rel=\"noopener\">这里</a></li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li>node.js (express) 处理网络请求的确精简方便</li>\n<li>微信公众号的所有信息都转发到一个接口，后续处理类型多时要设计合理的分发机制</li>\n<li>微信接口为什么用 XML 而不是 json 啊，这点不熟悉占用不少时间</li>\n<li>做这个很有意思，推荐大家多玩玩~</li>\n</ul>\n<h2 id=\"商户端APP集成微信扫描支付-王胜\"><a href=\"#商户端APP集成微信扫描支付-王胜\" class=\"headerlink\" title=\"商户端APP集成微信扫描支付 - 王胜\"></a>商户端APP集成微信扫描支付 - 王胜</h2><h3 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h3><ul>\n<li>APP端微信支付SDK<br><a href=\"https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&amp;t=resource/res_list&amp;verify=1&amp;id=open1419317784&amp;token=&amp;lang=zh_CN\" target=\"_blank\" rel=\"noopener\">[Android]</a> | <a href=\"https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&amp;t=resource/res_list&amp;verify=1&amp;id=open1419317782&amp;token=&amp;lang=zh_CN\" target=\"_blank\" rel=\"noopener\">[iOS]</a></li>\n<li>服务端微信支付SDK<br><a href=\"https://pay.weixin.qq.com/wiki/doc/api/download/wxpay_scanpay_java_sdk_proj-master.zip\" target=\"_blank\" rel=\"noopener\">[JAVA]</a> |<br><a href=\"https://pay.weixin.qq.com/wiki/doc/api/download/WxpayAPI_php_v3.zip\" target=\"_blank\" rel=\"noopener\">[PHP]</a></li>\n<li>服务端暴露notify接口</li>\n<li>push通道</li>\n</ul>\n<h3 id=\"支付流程\"><a href=\"#支付流程\" class=\"headerlink\" title=\"支付流程\"></a>支付流程</h3><ol>\n<li>用户在APP端浏览商品</li>\n<li>加入购物车</li>\n<li>结算</li>\n<li>调用提交订单接口</li>\n<li>提交订单接口返回预支付链接(<strong>预支付链接可根据服务端微信支付sdk生成</strong>)</li>\n<li>APP根据链接生成二维码</li>\n<li>用户拿起手机扫描支付</li>\n<li>微信调用第三方开发者服务端暴露的notify接口</li>\n<li>第三方服务端在收到notify接口调用时，更新订单库里订单状态，同时调用push通道告诉APP支付成功</li>\n<li>APP收到push命令后进行页面跳转</li>\n</ol>\n<h2 id=\"微信分享-吴明\"><a href=\"#微信分享-吴明\" class=\"headerlink\" title=\"微信分享 - 吴明\"></a>微信分享 - 吴明</h2><ul>\n<li>微信工作原理<ul>\n<li><img src=\"http://img.blog.csdn.net/20140823103621745?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvR29vZFNob3Q=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"Alt text\"></li>\n</ul>\n</li>\n<li>接口：<ul>\n<li>你需要触发什么事件</li>\n<li>微信事件触发会回调哪里接口</li>\n</ul>\n</li>\n<li>微信服务：<ul>\n<li>订阅号：</li>\n<li><a href=\"https://mp.weixin.qq.com\" target=\"_blank\" rel=\"noopener\">服务号</a><ul>\n<li><a href=\"http://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login\" target=\"_blank\" rel=\"noopener\">微信公众测试账号</a></li>\n<li><a href=\"http://mp.weixin.qq.com/debug\" target=\"_blank\" rel=\"noopener\">微信公众平台接口调试工具</a></li>\n</ul>\n</li>\n<li>企业号<ul>\n<li><a href=\"https://qy.weixin.qq.com\" target=\"_blank\" rel=\"noopener\">微信企业号</a></li>\n<li><a href=\"https://qy.weixin.qq.com/try\" target=\"_blank\" rel=\"noopener\">微信企业号申请体验号</a></li>\n<li><a href=\"http://www.iwork365.com/experience\" target=\"_blank\" rel=\"noopener\">iwork365企业号体验</a></li>\n</ul>\n</li>\n<li>微购物</li>\n<li>微信公众号自定义菜单开发<ul>\n<li>接口文档<pre><code>- [获取access token](http://mp.weixin.qq.com/wiki/11/0e4b294685f817b95cbed85ba5e82b8f.html)\n- [自定义菜单创建接口](http://mp.weixin.qq.com/wiki/13/43de8269be54a0a6f64413e4dfa94f39.html)\n- 以下操作都是在[微信公众平台接口调试工具](http://mp.weixin.qq.com/debug)调试方法\n</code></pre></li>\n<li>步骤1：调用“获取access token”接口,传入你申请的测试微信公众号的appid和secret获取access_token</li>\n<li>步骤2：调用“自定义菜单创建接口”，传入上面生成的access_token和“自定义菜单json数据”如下</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<pre><code>{\n    &quot;button&quot;: [\n        {\n            &quot;type&quot;: &quot;view&quot;,\n            &quot;name&quot;: &quot;51offer&quot;,\n            &quot;url&quot;: &quot;http://www.51offer.com/&quot;\n        },\n        {\n            &quot;name&quot;: &quot;移动&quot;,\n            &quot;sub_button&quot;: [\n                {\n                    &quot;type&quot;: &quot;view&quot;,\n                    &quot;name&quot;: &quot;blog&quot;,\n                    &quot;url&quot;: &quot;http://51offer.github.io/&quot;\n                },\n                {\n                    &quot;type&quot;: &quot;view&quot;,\n                    &quot;name&quot;: &quot;github&quot;,\n                    &quot;url&quot;: &quot;https://github.com/51offer/public-docs/wiki&quot;\n                }\n            ]\n        },\n        {\n            &quot;type&quot;: &quot;click&quot;,\n            &quot;name&quot;: &quot;我&quot;,\n            &quot;key&quot;: &quot;me&quot;\n        }\n    ]\n}\n</code></pre><ul>\n<li>推荐：公众号：招商信用卡</li>\n</ul>\n"},{"title":"《爱的五种能力》","date":"2018-05-18T15:47:29.000Z","_content":"\n\n![婚姻](https://upload-images.jianshu.io/upload_images/1534431-3d4f8c42a02709af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n俗话说的好“相爱容易相处难”，“家家有本难念的经”，说的大都是婚后生活夫妻之间的相处问题。本书作者认为为什么夫妻相处有问题是因为缺少“爱的五种能力”：\n- 情绪管理\n- 述情\n- 共情\n- 允许\n- 影响\n\n#### 爱的能力之一 “情绪管理”： ﻿\n首选是“情绪管理”，每个人要管理好自己的情绪，才有能力去爱别人。不能管理好自己情绪的人，常常让与自己相爱的人痛苦，容易错失爱的机会，甚至会伤害人。 ﻿想要爱情幸福，家庭和睦，两人就要都经常强调“爱”和“情”。一个人在强调“爱”，另一个人在强调“理”--“应该”，两人显然不在一个频道沟通，是爱人之间产生矛盾或吵架的主要原因。我们首选要理清两个概念：\n- 控制情绪是当有了情绪后把它强压在心里，不去表达，也不释放，也就是我们常说的“忍”。但“忍”字头上一把刀，忍久了，要么伤害自己，身体生病，或心理出问题；要么，积累到一定的程度受不了，爆发，对关系的伤害更大。 ﻿\n- 情绪管理是使自己根本就少起或不起情绪，整个人更加平和，更多的时候处于一种平静的状态，不情绪化，这样人就会能更多感受幸福，也能更好与人相处。 ﻿\n\n###### 那我们如何情绪管理？\n- 情绪管理方法一：保持客观 ﻿，我们必须学会管理因假设而起的情绪，让自己可以更加平静地去享受生活，而不是经常编个故事气自己。对于这种假设情绪我们可以无为或者验证假设是否成立。\n- 情绪管理方法二：避免条件反射情绪，我们必须有效避免对方说了一句或者一个动作而导致你情绪失控。\n- 情绪管理方法三：放下因自己对和错标准而起的情绪，用心去感受对方的心，感受一下对方做这个事情时内在的感受是什么？爱人的开心快乐，有时比自己的正确可能还要重要，因为人们找爱人，不是为了正确的，而是为了开心快乐、幸福﻿。\n\n#### 爱的能力之二 “述情”： ﻿﻿\n﻿是指用不伤害关系的方式表达自己的需求、想法和感受。人们在表达和沟通上常犯的错误是要么有了情绪或需求不说，闷在心里，隐忍，等到忍不住了就爆发了，要么常常用指责和抱怨的方式表达和沟通。隐忍伤自己，指责和抱怨伤害对方。而述情是情感关系里最合适的，不伤害任何人的沟通方式。 ﻿﻿作者提供几种述情方法：\n- 基本功一：分清是不是事实 ，这就是述情的基本功，能够在分清事实是什么，然后在述情的时候，说出的话里用事实，而不是自己的主观想象和假设。 \n能保持客观，清楚地知道事实和假设之间的区别既然是述情的基本功，也就需要经常练习的，练习的方法倒也简单，就是当你尝试对一件事情做出描述时，就问自己，我说的是事实吗？ \n- 基本功二：准确描述感受 ，所以，述情时要遵循一个原则：关系越远，用词“颗粒度”越粗；关系越近，用词“颗粒度”越细。 \n述情的几个注意事项： \n1．越述情问题越多 \n2．述情后对方没有变化 \n3．失语期 \n- 六句话练成述情高手 \n述情是用不伤害关系的方式表达出自己真实的需求、感受和想法，情感关系里只要使用这样的方式去跟对方沟通，就不会轻易伤害到两人的关系，却可以达到有效沟通的目的。 \n  - 句型一：当你心情不好的时候直接告诉对方。 \n  - 句型二：当对方令你感受不好（或好）时，告诉对方你的感受！ \n  - 句型三：告诉对方你的需求，而不是解决方案。\n  - 句型四：说出你喜欢的，而不是你不喜欢的。 \n  - 句型五：使用“可以”“能帮我”替代命令\n  - 句型六：说出“我希望”，不说“你应该”。 \n\n#### 爱的能力之三 “共情”： ﻿﻿\n理解并支持对方、善解人意。这几乎是所有人都希望爱人能具备的能力，可惜很多人都没有。大家基本都是习惯了讲道理、教育对方、给建议，而不知道很多时候对方需要的其实是共情。 ﻿﻿善解人意的能力其实就可以理解为共情的能力，就是经常可以理解到对方的内心感受。特别是当对方内心有不好的感受时，善解人意的人会让爱人感觉到自己被理解，这等于在内心给了对方接纳和认可，使其感受到来自爱人的支持\n我将在下面的共情的四个步骤里详细地描述这个内容。 \n- 第一步：接受对方的负面情绪 ，并开始关注这个人的情绪。\n- 第二步：引导对方分享他内在的感受和外在发生的事情。\n- 第三步：肯定对方情绪的逻辑。\n- 第四步：启发 ，\n  - 第一步：启发对方理解他人，或从另外的角度看问题。 \n  - 启发的第二步：是引导对方去关注未来、关注解决方案。 \n\n启发就是这样做的，整个过程中都是提问，并不给答案，而是促使对方自己去思考问题，进而使用他的智慧去解决问题。\n\n#### 爱的能力之四 “允许”： ﻿﻿\n尊重差异、允许成长。爱人之间吵架，发生分歧，很多时候都是因为不允许所导致的，不允许对方跟自己不一样，不允许对方有些特点，不接纳真实的对方，想要控制对方或改变对方。这会让双方都痛苦，有了允许的能力，才能给对方做真实自己的机会和空间。 ﻿﻿允许的意思是说，我不需要去判断这些事情是对的还是错的，也不需要把这些事情装到自己的心里去，我只是允许这些事情以它本来的面目存在，不去做抗争，臣服于宇宙和自然的规律中。在这个大的规律中，她是大的，我是小的，我允许她的存在。 越是强大的人越能允许别人贬低自己、否定自己。相反，越是弱小的人越做不到允许别人贬低自己、否定自己。 \n- 可以经常做这个练习，刻意回想过去的一些事情，发现内心还有一些不允许时对自己说：“我允许！” \n\n#### 爱的能力之五“影响”： ﻿﻿\n每个人都会变，在爱情关系里的人们更是会因为对方而变，可以说一个人找了不同的爱人就会变成不同的人。有可能越变越完整，也有可能越变问题越严重，那么，自己怎么做，对方就会变得越来越完整呢？对方就能成长得更好呢？这就是影响的能力，让对方成长的能力。 \n- ﻿﻿鼓励好的方面，不责备坏得方面，让对方勇于尝试！\n- 驯兽师训练动物的过程使用的就是影响的方法，当动物们做得不好时不惩罚，是本书讲的前一种影响的方法：允许，给动物们一个成长的机会；而当动物们做得好时奖励就是本书要讲的影响的第二种方法：强化。这些方法用在动物身上和用在人的身上同样有效果，因为人也是动物，只不过是高级动物。\n\n\n### 其他\n#### 婆媳关系为什么就那么难处理呢？ ﻿\n媳妇和婆婆两人本来就没有血缘关系，又没有深厚的感情，有的只是因为婚姻关系和亲子关系的对接而应该遵守的道德约束，还有因为争夺来自同一个男人的爱而产生的矛盾，所以，婆婆和媳妇两人关系不好也是正常的。\n#### 情绪词\n- 颗粒度粗的情绪词：心情好、舒服、不舒服、难过、不开心等。 \n以下情绪词汇，都是相对精确的情绪词汇，属于颗粒度细的情绪词： \n高兴、自豪、开心、自信、感激、快乐、愉悦、温暖、喜悦、愉快、幸福、满足、欣慰、惬意、爱、喜欢、感动、兴奋、充实、平静、放松、温暖、踏实、祥和； \n伤心、尴尬、担心、焦虑、害怕、紧张、沮丧、迷茫、惊恐、内疚、失落、无助、无奈、失望、绝望、伤感、凄凉、苦闷、疲惫、悲伤、愤怒、生气、恨、厌恶、厌烦、惊讶、困惑、孤独、寂寞、郁闷、羞愧、遗憾、嫉妒、后悔，等等。 \n\n","source":"_posts/爱的五种能力.md","raw":"title: 《爱的五种能力》\ndate: 2018-05-18 15:47:29\ntags:\ncategories: 其他，读书\n---\n\n\n![婚姻](https://upload-images.jianshu.io/upload_images/1534431-3d4f8c42a02709af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n俗话说的好“相爱容易相处难”，“家家有本难念的经”，说的大都是婚后生活夫妻之间的相处问题。本书作者认为为什么夫妻相处有问题是因为缺少“爱的五种能力”：\n- 情绪管理\n- 述情\n- 共情\n- 允许\n- 影响\n\n#### 爱的能力之一 “情绪管理”： ﻿\n首选是“情绪管理”，每个人要管理好自己的情绪，才有能力去爱别人。不能管理好自己情绪的人，常常让与自己相爱的人痛苦，容易错失爱的机会，甚至会伤害人。 ﻿想要爱情幸福，家庭和睦，两人就要都经常强调“爱”和“情”。一个人在强调“爱”，另一个人在强调“理”--“应该”，两人显然不在一个频道沟通，是爱人之间产生矛盾或吵架的主要原因。我们首选要理清两个概念：\n- 控制情绪是当有了情绪后把它强压在心里，不去表达，也不释放，也就是我们常说的“忍”。但“忍”字头上一把刀，忍久了，要么伤害自己，身体生病，或心理出问题；要么，积累到一定的程度受不了，爆发，对关系的伤害更大。 ﻿\n- 情绪管理是使自己根本就少起或不起情绪，整个人更加平和，更多的时候处于一种平静的状态，不情绪化，这样人就会能更多感受幸福，也能更好与人相处。 ﻿\n\n###### 那我们如何情绪管理？\n- 情绪管理方法一：保持客观 ﻿，我们必须学会管理因假设而起的情绪，让自己可以更加平静地去享受生活，而不是经常编个故事气自己。对于这种假设情绪我们可以无为或者验证假设是否成立。\n- 情绪管理方法二：避免条件反射情绪，我们必须有效避免对方说了一句或者一个动作而导致你情绪失控。\n- 情绪管理方法三：放下因自己对和错标准而起的情绪，用心去感受对方的心，感受一下对方做这个事情时内在的感受是什么？爱人的开心快乐，有时比自己的正确可能还要重要，因为人们找爱人，不是为了正确的，而是为了开心快乐、幸福﻿。\n\n#### 爱的能力之二 “述情”： ﻿﻿\n﻿是指用不伤害关系的方式表达自己的需求、想法和感受。人们在表达和沟通上常犯的错误是要么有了情绪或需求不说，闷在心里，隐忍，等到忍不住了就爆发了，要么常常用指责和抱怨的方式表达和沟通。隐忍伤自己，指责和抱怨伤害对方。而述情是情感关系里最合适的，不伤害任何人的沟通方式。 ﻿﻿作者提供几种述情方法：\n- 基本功一：分清是不是事实 ，这就是述情的基本功，能够在分清事实是什么，然后在述情的时候，说出的话里用事实，而不是自己的主观想象和假设。 \n能保持客观，清楚地知道事实和假设之间的区别既然是述情的基本功，也就需要经常练习的，练习的方法倒也简单，就是当你尝试对一件事情做出描述时，就问自己，我说的是事实吗？ \n- 基本功二：准确描述感受 ，所以，述情时要遵循一个原则：关系越远，用词“颗粒度”越粗；关系越近，用词“颗粒度”越细。 \n述情的几个注意事项： \n1．越述情问题越多 \n2．述情后对方没有变化 \n3．失语期 \n- 六句话练成述情高手 \n述情是用不伤害关系的方式表达出自己真实的需求、感受和想法，情感关系里只要使用这样的方式去跟对方沟通，就不会轻易伤害到两人的关系，却可以达到有效沟通的目的。 \n  - 句型一：当你心情不好的时候直接告诉对方。 \n  - 句型二：当对方令你感受不好（或好）时，告诉对方你的感受！ \n  - 句型三：告诉对方你的需求，而不是解决方案。\n  - 句型四：说出你喜欢的，而不是你不喜欢的。 \n  - 句型五：使用“可以”“能帮我”替代命令\n  - 句型六：说出“我希望”，不说“你应该”。 \n\n#### 爱的能力之三 “共情”： ﻿﻿\n理解并支持对方、善解人意。这几乎是所有人都希望爱人能具备的能力，可惜很多人都没有。大家基本都是习惯了讲道理、教育对方、给建议，而不知道很多时候对方需要的其实是共情。 ﻿﻿善解人意的能力其实就可以理解为共情的能力，就是经常可以理解到对方的内心感受。特别是当对方内心有不好的感受时，善解人意的人会让爱人感觉到自己被理解，这等于在内心给了对方接纳和认可，使其感受到来自爱人的支持\n我将在下面的共情的四个步骤里详细地描述这个内容。 \n- 第一步：接受对方的负面情绪 ，并开始关注这个人的情绪。\n- 第二步：引导对方分享他内在的感受和外在发生的事情。\n- 第三步：肯定对方情绪的逻辑。\n- 第四步：启发 ，\n  - 第一步：启发对方理解他人，或从另外的角度看问题。 \n  - 启发的第二步：是引导对方去关注未来、关注解决方案。 \n\n启发就是这样做的，整个过程中都是提问，并不给答案，而是促使对方自己去思考问题，进而使用他的智慧去解决问题。\n\n#### 爱的能力之四 “允许”： ﻿﻿\n尊重差异、允许成长。爱人之间吵架，发生分歧，很多时候都是因为不允许所导致的，不允许对方跟自己不一样，不允许对方有些特点，不接纳真实的对方，想要控制对方或改变对方。这会让双方都痛苦，有了允许的能力，才能给对方做真实自己的机会和空间。 ﻿﻿允许的意思是说，我不需要去判断这些事情是对的还是错的，也不需要把这些事情装到自己的心里去，我只是允许这些事情以它本来的面目存在，不去做抗争，臣服于宇宙和自然的规律中。在这个大的规律中，她是大的，我是小的，我允许她的存在。 越是强大的人越能允许别人贬低自己、否定自己。相反，越是弱小的人越做不到允许别人贬低自己、否定自己。 \n- 可以经常做这个练习，刻意回想过去的一些事情，发现内心还有一些不允许时对自己说：“我允许！” \n\n#### 爱的能力之五“影响”： ﻿﻿\n每个人都会变，在爱情关系里的人们更是会因为对方而变，可以说一个人找了不同的爱人就会变成不同的人。有可能越变越完整，也有可能越变问题越严重，那么，自己怎么做，对方就会变得越来越完整呢？对方就能成长得更好呢？这就是影响的能力，让对方成长的能力。 \n- ﻿﻿鼓励好的方面，不责备坏得方面，让对方勇于尝试！\n- 驯兽师训练动物的过程使用的就是影响的方法，当动物们做得不好时不惩罚，是本书讲的前一种影响的方法：允许，给动物们一个成长的机会；而当动物们做得好时奖励就是本书要讲的影响的第二种方法：强化。这些方法用在动物身上和用在人的身上同样有效果，因为人也是动物，只不过是高级动物。\n\n\n### 其他\n#### 婆媳关系为什么就那么难处理呢？ ﻿\n媳妇和婆婆两人本来就没有血缘关系，又没有深厚的感情，有的只是因为婚姻关系和亲子关系的对接而应该遵守的道德约束，还有因为争夺来自同一个男人的爱而产生的矛盾，所以，婆婆和媳妇两人关系不好也是正常的。\n#### 情绪词\n- 颗粒度粗的情绪词：心情好、舒服、不舒服、难过、不开心等。 \n以下情绪词汇，都是相对精确的情绪词汇，属于颗粒度细的情绪词： \n高兴、自豪、开心、自信、感激、快乐、愉悦、温暖、喜悦、愉快、幸福、满足、欣慰、惬意、爱、喜欢、感动、兴奋、充实、平静、放松、温暖、踏实、祥和； \n伤心、尴尬、担心、焦虑、害怕、紧张、沮丧、迷茫、惊恐、内疚、失落、无助、无奈、失望、绝望、伤感、凄凉、苦闷、疲惫、悲伤、愤怒、生气、恨、厌恶、厌烦、惊讶、困惑、孤独、寂寞、郁闷、羞愧、遗憾、嫉妒、后悔，等等。 \n\n","slug":"爱的五种能力","published":1,"updated":"2021-09-10T07:04:21.947Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cktfeap4c002fc2xx2fwo6oxd","content":"<p><img src=\"https://upload-images.jianshu.io/upload_images/1534431-3d4f8c42a02709af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"婚姻\"></p>\n<p>俗话说的好“相爱容易相处难”，“家家有本难念的经”，说的大都是婚后生活夫妻之间的相处问题。本书作者认为为什么夫妻相处有问题是因为缺少“爱的五种能力”：</p>\n<ul>\n<li>情绪管理</li>\n<li>述情</li>\n<li>共情</li>\n<li>允许</li>\n<li>影响</li>\n</ul>\n<h4 id=\"爱的能力之一-“情绪管理”：\"><a href=\"#爱的能力之一-“情绪管理”：\" class=\"headerlink\" title=\"爱的能力之一 “情绪管理”： ﻿\"></a>爱的能力之一 “情绪管理”： ﻿</h4><p>首选是“情绪管理”，每个人要管理好自己的情绪，才有能力去爱别人。不能管理好自己情绪的人，常常让与自己相爱的人痛苦，容易错失爱的机会，甚至会伤害人。 ﻿想要爱情幸福，家庭和睦，两人就要都经常强调“爱”和“情”。一个人在强调“爱”，另一个人在强调“理”–“应该”，两人显然不在一个频道沟通，是爱人之间产生矛盾或吵架的主要原因。我们首选要理清两个概念：</p>\n<ul>\n<li>控制情绪是当有了情绪后把它强压在心里，不去表达，也不释放，也就是我们常说的“忍”。但“忍”字头上一把刀，忍久了，要么伤害自己，身体生病，或心理出问题；要么，积累到一定的程度受不了，爆发，对关系的伤害更大。 ﻿</li>\n<li>情绪管理是使自己根本就少起或不起情绪，整个人更加平和，更多的时候处于一种平静的状态，不情绪化，这样人就会能更多感受幸福，也能更好与人相处。 ﻿</li>\n</ul>\n<h6 id=\"那我们如何情绪管理？\"><a href=\"#那我们如何情绪管理？\" class=\"headerlink\" title=\"那我们如何情绪管理？\"></a>那我们如何情绪管理？</h6><ul>\n<li>情绪管理方法一：保持客观 ﻿，我们必须学会管理因假设而起的情绪，让自己可以更加平静地去享受生活，而不是经常编个故事气自己。对于这种假设情绪我们可以无为或者验证假设是否成立。</li>\n<li>情绪管理方法二：避免条件反射情绪，我们必须有效避免对方说了一句或者一个动作而导致你情绪失控。</li>\n<li>情绪管理方法三：放下因自己对和错标准而起的情绪，用心去感受对方的心，感受一下对方做这个事情时内在的感受是什么？爱人的开心快乐，有时比自己的正确可能还要重要，因为人们找爱人，不是为了正确的，而是为了开心快乐、幸福﻿。</li>\n</ul>\n<h4 id=\"爱的能力之二-“述情”：\"><a href=\"#爱的能力之二-“述情”：\" class=\"headerlink\" title=\"爱的能力之二 “述情”： ﻿﻿\"></a>爱的能力之二 “述情”： ﻿﻿</h4><p>﻿是指用不伤害关系的方式表达自己的需求、想法和感受。人们在表达和沟通上常犯的错误是要么有了情绪或需求不说，闷在心里，隐忍，等到忍不住了就爆发了，要么常常用指责和抱怨的方式表达和沟通。隐忍伤自己，指责和抱怨伤害对方。而述情是情感关系里最合适的，不伤害任何人的沟通方式。 ﻿﻿作者提供几种述情方法：</p>\n<ul>\n<li>基本功一：分清是不是事实 ，这就是述情的基本功，能够在分清事实是什么，然后在述情的时候，说出的话里用事实，而不是自己的主观想象和假设。<br>能保持客观，清楚地知道事实和假设之间的区别既然是述情的基本功，也就需要经常练习的，练习的方法倒也简单，就是当你尝试对一件事情做出描述时，就问自己，我说的是事实吗？ </li>\n<li>基本功二：准确描述感受 ，所以，述情时要遵循一个原则：关系越远，用词“颗粒度”越粗；关系越近，用词“颗粒度”越细。<br>述情的几个注意事项：<br>1．越述情问题越多<br>2．述情后对方没有变化<br>3．失语期 </li>\n<li>六句话练成述情高手<br>述情是用不伤害关系的方式表达出自己真实的需求、感受和想法，情感关系里只要使用这样的方式去跟对方沟通，就不会轻易伤害到两人的关系，却可以达到有效沟通的目的。 <ul>\n<li>句型一：当你心情不好的时候直接告诉对方。 </li>\n<li>句型二：当对方令你感受不好（或好）时，告诉对方你的感受！ </li>\n<li>句型三：告诉对方你的需求，而不是解决方案。</li>\n<li>句型四：说出你喜欢的，而不是你不喜欢的。 </li>\n<li>句型五：使用“可以”“能帮我”替代命令</li>\n<li>句型六：说出“我希望”，不说“你应该”。 </li>\n</ul>\n</li>\n</ul>\n<h4 id=\"爱的能力之三-“共情”：\"><a href=\"#爱的能力之三-“共情”：\" class=\"headerlink\" title=\"爱的能力之三 “共情”： ﻿﻿\"></a>爱的能力之三 “共情”： ﻿﻿</h4><p>理解并支持对方、善解人意。这几乎是所有人都希望爱人能具备的能力，可惜很多人都没有。大家基本都是习惯了讲道理、教育对方、给建议，而不知道很多时候对方需要的其实是共情。 ﻿﻿善解人意的能力其实就可以理解为共情的能力，就是经常可以理解到对方的内心感受。特别是当对方内心有不好的感受时，善解人意的人会让爱人感觉到自己被理解，这等于在内心给了对方接纳和认可，使其感受到来自爱人的支持<br>我将在下面的共情的四个步骤里详细地描述这个内容。 </p>\n<ul>\n<li>第一步：接受对方的负面情绪 ，并开始关注这个人的情绪。</li>\n<li>第二步：引导对方分享他内在的感受和外在发生的事情。</li>\n<li>第三步：肯定对方情绪的逻辑。</li>\n<li>第四步：启发 ，<ul>\n<li>第一步：启发对方理解他人，或从另外的角度看问题。 </li>\n<li>启发的第二步：是引导对方去关注未来、关注解决方案。 </li>\n</ul>\n</li>\n</ul>\n<p>启发就是这样做的，整个过程中都是提问，并不给答案，而是促使对方自己去思考问题，进而使用他的智慧去解决问题。</p>\n<h4 id=\"爱的能力之四-“允许”：\"><a href=\"#爱的能力之四-“允许”：\" class=\"headerlink\" title=\"爱的能力之四 “允许”： ﻿﻿\"></a>爱的能力之四 “允许”： ﻿﻿</h4><p>尊重差异、允许成长。爱人之间吵架，发生分歧，很多时候都是因为不允许所导致的，不允许对方跟自己不一样，不允许对方有些特点，不接纳真实的对方，想要控制对方或改变对方。这会让双方都痛苦，有了允许的能力，才能给对方做真实自己的机会和空间。 ﻿﻿允许的意思是说，我不需要去判断这些事情是对的还是错的，也不需要把这些事情装到自己的心里去，我只是允许这些事情以它本来的面目存在，不去做抗争，臣服于宇宙和自然的规律中。在这个大的规律中，她是大的，我是小的，我允许她的存在。 越是强大的人越能允许别人贬低自己、否定自己。相反，越是弱小的人越做不到允许别人贬低自己、否定自己。 </p>\n<ul>\n<li>可以经常做这个练习，刻意回想过去的一些事情，发现内心还有一些不允许时对自己说：“我允许！” </li>\n</ul>\n<h4 id=\"爱的能力之五“影响”：\"><a href=\"#爱的能力之五“影响”：\" class=\"headerlink\" title=\"爱的能力之五“影响”： ﻿﻿\"></a>爱的能力之五“影响”： ﻿﻿</h4><p>每个人都会变，在爱情关系里的人们更是会因为对方而变，可以说一个人找了不同的爱人就会变成不同的人。有可能越变越完整，也有可能越变问题越严重，那么，自己怎么做，对方就会变得越来越完整呢？对方就能成长得更好呢？这就是影响的能力，让对方成长的能力。 </p>\n<ul>\n<li>﻿﻿鼓励好的方面，不责备坏得方面，让对方勇于尝试！</li>\n<li>驯兽师训练动物的过程使用的就是影响的方法，当动物们做得不好时不惩罚，是本书讲的前一种影响的方法：允许，给动物们一个成长的机会；而当动物们做得好时奖励就是本书要讲的影响的第二种方法：强化。这些方法用在动物身上和用在人的身上同样有效果，因为人也是动物，只不过是高级动物。</li>\n</ul>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><h4 id=\"婆媳关系为什么就那么难处理呢？\"><a href=\"#婆媳关系为什么就那么难处理呢？\" class=\"headerlink\" title=\"婆媳关系为什么就那么难处理呢？ ﻿\"></a>婆媳关系为什么就那么难处理呢？ ﻿</h4><p>媳妇和婆婆两人本来就没有血缘关系，又没有深厚的感情，有的只是因为婚姻关系和亲子关系的对接而应该遵守的道德约束，还有因为争夺来自同一个男人的爱而产生的矛盾，所以，婆婆和媳妇两人关系不好也是正常的。</p>\n<h4 id=\"情绪词\"><a href=\"#情绪词\" class=\"headerlink\" title=\"情绪词\"></a>情绪词</h4><ul>\n<li>颗粒度粗的情绪词：心情好、舒服、不舒服、难过、不开心等。<br>以下情绪词汇，都是相对精确的情绪词汇，属于颗粒度细的情绪词：<br>高兴、自豪、开心、自信、感激、快乐、愉悦、温暖、喜悦、愉快、幸福、满足、欣慰、惬意、爱、喜欢、感动、兴奋、充实、平静、放松、温暖、踏实、祥和；<br>伤心、尴尬、担心、焦虑、害怕、紧张、沮丧、迷茫、惊恐、内疚、失落、无助、无奈、失望、绝望、伤感、凄凉、苦闷、疲惫、悲伤、愤怒、生气、恨、厌恶、厌烦、惊讶、困惑、孤独、寂寞、郁闷、羞愧、遗憾、嫉妒、后悔，等等。 </li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"https://upload-images.jianshu.io/upload_images/1534431-3d4f8c42a02709af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"婚姻\"></p>\n<p>俗话说的好“相爱容易相处难”，“家家有本难念的经”，说的大都是婚后生活夫妻之间的相处问题。本书作者认为为什么夫妻相处有问题是因为缺少“爱的五种能力”：</p>\n<ul>\n<li>情绪管理</li>\n<li>述情</li>\n<li>共情</li>\n<li>允许</li>\n<li>影响</li>\n</ul>\n<h4 id=\"爱的能力之一-“情绪管理”：\"><a href=\"#爱的能力之一-“情绪管理”：\" class=\"headerlink\" title=\"爱的能力之一 “情绪管理”： ﻿\"></a>爱的能力之一 “情绪管理”： ﻿</h4><p>首选是“情绪管理”，每个人要管理好自己的情绪，才有能力去爱别人。不能管理好自己情绪的人，常常让与自己相爱的人痛苦，容易错失爱的机会，甚至会伤害人。 ﻿想要爱情幸福，家庭和睦，两人就要都经常强调“爱”和“情”。一个人在强调“爱”，另一个人在强调“理”–“应该”，两人显然不在一个频道沟通，是爱人之间产生矛盾或吵架的主要原因。我们首选要理清两个概念：</p>\n<ul>\n<li>控制情绪是当有了情绪后把它强压在心里，不去表达，也不释放，也就是我们常说的“忍”。但“忍”字头上一把刀，忍久了，要么伤害自己，身体生病，或心理出问题；要么，积累到一定的程度受不了，爆发，对关系的伤害更大。 ﻿</li>\n<li>情绪管理是使自己根本就少起或不起情绪，整个人更加平和，更多的时候处于一种平静的状态，不情绪化，这样人就会能更多感受幸福，也能更好与人相处。 ﻿</li>\n</ul>\n<h6 id=\"那我们如何情绪管理？\"><a href=\"#那我们如何情绪管理？\" class=\"headerlink\" title=\"那我们如何情绪管理？\"></a>那我们如何情绪管理？</h6><ul>\n<li>情绪管理方法一：保持客观 ﻿，我们必须学会管理因假设而起的情绪，让自己可以更加平静地去享受生活，而不是经常编个故事气自己。对于这种假设情绪我们可以无为或者验证假设是否成立。</li>\n<li>情绪管理方法二：避免条件反射情绪，我们必须有效避免对方说了一句或者一个动作而导致你情绪失控。</li>\n<li>情绪管理方法三：放下因自己对和错标准而起的情绪，用心去感受对方的心，感受一下对方做这个事情时内在的感受是什么？爱人的开心快乐，有时比自己的正确可能还要重要，因为人们找爱人，不是为了正确的，而是为了开心快乐、幸福﻿。</li>\n</ul>\n<h4 id=\"爱的能力之二-“述情”：\"><a href=\"#爱的能力之二-“述情”：\" class=\"headerlink\" title=\"爱的能力之二 “述情”： ﻿﻿\"></a>爱的能力之二 “述情”： ﻿﻿</h4><p>﻿是指用不伤害关系的方式表达自己的需求、想法和感受。人们在表达和沟通上常犯的错误是要么有了情绪或需求不说，闷在心里，隐忍，等到忍不住了就爆发了，要么常常用指责和抱怨的方式表达和沟通。隐忍伤自己，指责和抱怨伤害对方。而述情是情感关系里最合适的，不伤害任何人的沟通方式。 ﻿﻿作者提供几种述情方法：</p>\n<ul>\n<li>基本功一：分清是不是事实 ，这就是述情的基本功，能够在分清事实是什么，然后在述情的时候，说出的话里用事实，而不是自己的主观想象和假设。<br>能保持客观，清楚地知道事实和假设之间的区别既然是述情的基本功，也就需要经常练习的，练习的方法倒也简单，就是当你尝试对一件事情做出描述时，就问自己，我说的是事实吗？ </li>\n<li>基本功二：准确描述感受 ，所以，述情时要遵循一个原则：关系越远，用词“颗粒度”越粗；关系越近，用词“颗粒度”越细。<br>述情的几个注意事项：<br>1．越述情问题越多<br>2．述情后对方没有变化<br>3．失语期 </li>\n<li>六句话练成述情高手<br>述情是用不伤害关系的方式表达出自己真实的需求、感受和想法，情感关系里只要使用这样的方式去跟对方沟通，就不会轻易伤害到两人的关系，却可以达到有效沟通的目的。 <ul>\n<li>句型一：当你心情不好的时候直接告诉对方。 </li>\n<li>句型二：当对方令你感受不好（或好）时，告诉对方你的感受！ </li>\n<li>句型三：告诉对方你的需求，而不是解决方案。</li>\n<li>句型四：说出你喜欢的，而不是你不喜欢的。 </li>\n<li>句型五：使用“可以”“能帮我”替代命令</li>\n<li>句型六：说出“我希望”，不说“你应该”。 </li>\n</ul>\n</li>\n</ul>\n<h4 id=\"爱的能力之三-“共情”：\"><a href=\"#爱的能力之三-“共情”：\" class=\"headerlink\" title=\"爱的能力之三 “共情”： ﻿﻿\"></a>爱的能力之三 “共情”： ﻿﻿</h4><p>理解并支持对方、善解人意。这几乎是所有人都希望爱人能具备的能力，可惜很多人都没有。大家基本都是习惯了讲道理、教育对方、给建议，而不知道很多时候对方需要的其实是共情。 ﻿﻿善解人意的能力其实就可以理解为共情的能力，就是经常可以理解到对方的内心感受。特别是当对方内心有不好的感受时，善解人意的人会让爱人感觉到自己被理解，这等于在内心给了对方接纳和认可，使其感受到来自爱人的支持<br>我将在下面的共情的四个步骤里详细地描述这个内容。 </p>\n<ul>\n<li>第一步：接受对方的负面情绪 ，并开始关注这个人的情绪。</li>\n<li>第二步：引导对方分享他内在的感受和外在发生的事情。</li>\n<li>第三步：肯定对方情绪的逻辑。</li>\n<li>第四步：启发 ，<ul>\n<li>第一步：启发对方理解他人，或从另外的角度看问题。 </li>\n<li>启发的第二步：是引导对方去关注未来、关注解决方案。 </li>\n</ul>\n</li>\n</ul>\n<p>启发就是这样做的，整个过程中都是提问，并不给答案，而是促使对方自己去思考问题，进而使用他的智慧去解决问题。</p>\n<h4 id=\"爱的能力之四-“允许”：\"><a href=\"#爱的能力之四-“允许”：\" class=\"headerlink\" title=\"爱的能力之四 “允许”： ﻿﻿\"></a>爱的能力之四 “允许”： ﻿﻿</h4><p>尊重差异、允许成长。爱人之间吵架，发生分歧，很多时候都是因为不允许所导致的，不允许对方跟自己不一样，不允许对方有些特点，不接纳真实的对方，想要控制对方或改变对方。这会让双方都痛苦，有了允许的能力，才能给对方做真实自己的机会和空间。 ﻿﻿允许的意思是说，我不需要去判断这些事情是对的还是错的，也不需要把这些事情装到自己的心里去，我只是允许这些事情以它本来的面目存在，不去做抗争，臣服于宇宙和自然的规律中。在这个大的规律中，她是大的，我是小的，我允许她的存在。 越是强大的人越能允许别人贬低自己、否定自己。相反，越是弱小的人越做不到允许别人贬低自己、否定自己。 </p>\n<ul>\n<li>可以经常做这个练习，刻意回想过去的一些事情，发现内心还有一些不允许时对自己说：“我允许！” </li>\n</ul>\n<h4 id=\"爱的能力之五“影响”：\"><a href=\"#爱的能力之五“影响”：\" class=\"headerlink\" title=\"爱的能力之五“影响”： ﻿﻿\"></a>爱的能力之五“影响”： ﻿﻿</h4><p>每个人都会变，在爱情关系里的人们更是会因为对方而变，可以说一个人找了不同的爱人就会变成不同的人。有可能越变越完整，也有可能越变问题越严重，那么，自己怎么做，对方就会变得越来越完整呢？对方就能成长得更好呢？这就是影响的能力，让对方成长的能力。 </p>\n<ul>\n<li>﻿﻿鼓励好的方面，不责备坏得方面，让对方勇于尝试！</li>\n<li>驯兽师训练动物的过程使用的就是影响的方法，当动物们做得不好时不惩罚，是本书讲的前一种影响的方法：允许，给动物们一个成长的机会；而当动物们做得好时奖励就是本书要讲的影响的第二种方法：强化。这些方法用在动物身上和用在人的身上同样有效果，因为人也是动物，只不过是高级动物。</li>\n</ul>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><h4 id=\"婆媳关系为什么就那么难处理呢？\"><a href=\"#婆媳关系为什么就那么难处理呢？\" class=\"headerlink\" title=\"婆媳关系为什么就那么难处理呢？ ﻿\"></a>婆媳关系为什么就那么难处理呢？ ﻿</h4><p>媳妇和婆婆两人本来就没有血缘关系，又没有深厚的感情，有的只是因为婚姻关系和亲子关系的对接而应该遵守的道德约束，还有因为争夺来自同一个男人的爱而产生的矛盾，所以，婆婆和媳妇两人关系不好也是正常的。</p>\n<h4 id=\"情绪词\"><a href=\"#情绪词\" class=\"headerlink\" title=\"情绪词\"></a>情绪词</h4><ul>\n<li>颗粒度粗的情绪词：心情好、舒服、不舒服、难过、不开心等。<br>以下情绪词汇，都是相对精确的情绪词汇，属于颗粒度细的情绪词：<br>高兴、自豪、开心、自信、感激、快乐、愉悦、温暖、喜悦、愉快、幸福、满足、欣慰、惬意、爱、喜欢、感动、兴奋、充实、平静、放松、温暖、踏实、祥和；<br>伤心、尴尬、担心、焦虑、害怕、紧张、沮丧、迷茫、惊恐、内疚、失落、无助、无奈、失望、绝望、伤感、凄凉、苦闷、疲惫、悲伤、愤怒、生气、恨、厌恶、厌烦、惊讶、困惑、孤独、寂寞、郁闷、羞愧、遗憾、嫉妒、后悔，等等。 </li>\n</ul>\n"},{"title":"知其所以然(10分钟解释一个和开发相关的原理)","date":"2015-07-07T23:04:29.000Z","_content":"\n\n\n### WEB 登录『原理』 - 曾铭\n\n\n#### Session & cookie\n\n- HTTP 是无状态协议\n- Session 服务器端简单存储\n- cookie 客户端简单存储（注意：在请求头中）\n\n#### 密码如何存储\n\n- 明文存储\n- md5 碰撞库破解  md5(pwd)\n- md5+salt   md5(pwd+salt)  salt  pwd\n- sha1……都能用，千万不要自己实现散列算法\n\n#### 一个登录的过程\n\n- 明文密码\n- session_id, access_token, token\n- 第三方登录：OAuth2, OpenID\n\n----\n\n### iBeacon - 潘君\n\n- BLE\n    - RSSI(Received Signal Strength Indicator)\n    - 唯一标识码\n    - 例:[ 防丢器](http://detail.tmall.com/item.htm?spm=a1z10.1-b.w4004-3501608320.8.8JO7JE&id=22152768901)\n\n- [应用场景](http://www.brtbeacon.com/home/industry_solution.shtml)\n    - 配合微信摇一摇\n    - 商城导购\n    - 地下停车库导航\n\n- [室内定位](https://github.com/ibip/ibip_document/wiki/%E5%AE%A4%E5%86%85%E5%AE%9A%E4%BD%8D%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84)\n    - 标签定位\n    - 三角定位\n    - 指纹定位\n\n----\n### andoid虚拟机 - 吴明\n- 系统框架对比android vs ios\n- [ios系统框架](http://blog.csdn.net/xyz_lmn/article/details/8907502)\n-  [android系统框架](http://www.cnblogs.com/royenhome/archive/2010/04/24/1719293.html)\n-  Dalvik虚拟机\n\t- Dalvik虚拟机是Android程序的虚拟机，是Android中Java程序的运行基础。其指令集基于寄存器架构，执行其特有的文件格式——dex字节码来完成对象生命周期管理、堆栈管理、线程管理、安全异常管理、垃圾回收等重要功能。它的核心内容是实现库（libdvm.so），大体由C语言实现。依赖于Linux内核的一部分功能——线程机制、内存管理机制，能高效使用内存，并在低速CPU上表现出的高性能。每一个Android应用在底层都会对应一个独立的Dalvik虚拟机实例，其代码在虚拟机的解释下得以执行。\n\n- Android系统是以Linux系统为底层构建的，Android系统是开源(源代码公开)的，Android系统势必会适配到不同硬件配置的设备上，因此谷歌为了降低应用的开发难度在Linux底层之上构筑了一个名为“Dalvik”的虚拟机。\n- 一个应用，一个虚拟机实例，一个进程！！！\n- [android虚拟机详细](http://blog.csdn.net/andyxm/article/details/6126907/)\n\n- 其他：\n\t- ART模式:Android4.4中新加入的ART模式，该模式的完整名称是Androidruntime.\n\t- ART：Android 4.4开始推出的新的运行环境，在APP安装的时候使用dex2oat工具直接把DEX文件转换为机器码文件，运行的时候以机器码方式运行，可以充分利用系统性能；此外，改进的内存回收机制使得ART运行模式下的内存回收速度只有Dalvik运行时模式下的50%，也能够提升系统运行速度。\n\n----\n\n### Android的Message Pool是个什么鬼(源码角度分析) - 李仙鹏\n\nAndroid中，我们在线程之间通信传递通常采用Android的消息机制，而这机制传递的正是Message。\n\n通常，我们使用[Message.obtain()](http://developer.android.com/reference/android/os/Message.html#obtain())和[Handler.obtainMessage()](http://developer.android.com/reference/android/os/Handler.html#obtainMessage())从Message Pool中获取Message，避免直接构造Message。\n\n#### Message.obtain()源码\n\n```\n    /**\n     * Return a new Message instance from the global pool. Allows us to\n     * avoid allocating new objects in many cases.\n     */\n    public static Message obtain() {\n        synchronized (sPoolSync) {\n            if (sPool != null) {\n                Message m = sPool;\n                sPool = m.next;\n                m.next = null;\n                m.flags = 0; // clear in-use flag\n                sPoolSize--;\n                return m;\n            }\n        }\n        return new Message();\n    }\n\n```\n从代码片中，可以看到Message是直接由sPool赋值的。\n\n#### Handler.obtain()源码\n\n```\n    /**\n     * Returns a new {@link android.os.Message Message} from the global message pool. More efficient than\n     * creating and allocating new instances. The retrieved message has its handler set to this instance (Message.target == this).\n     *  If you don't want that facility, just call Message.obtain() instead.\n     */\n    public final Message obtainMessage()\n    {\n        return Message.obtain(this);\n    }\n\n```\nHandler.obtain()最终还是调用Message.obtain()来获取的。\n\n#### Message Pool相关源码分析\n\n##### Message Pool数据结构\n\n```\n    // sometimes we store linked lists of these things\n    /*package*/ Message next;\n\n    private static final Object sPoolSync = new Object();\n    private static Message sPool;\n    private static int sPoolSize = 0;\n\n    private static final int MAX_POOL_SIZE = 50;\n\n    private static boolean gCheckRecycle = true;\n```\n从代码中可以很明确的看到，Message Pool的数据结构实际就是一个链表。sPool就是一个全局的消息池，sPoolSize记录链表长度，MAX_POOL_SIZE表示链表的最大长度为50。\n\n##### Message Pool如何存放Message\n\n```\n    /** @hide */\n    public static void updateCheckRecycle(int targetSdkVersion) {\n        if (targetSdkVersion < Build.VERSION_CODES.LOLLIPOP) {\n            gCheckRecycle = false;\n        }\n    }\n\n    /**\n     * Return a Message instance to the global pool.\n     * <p>\n     * You MUST NOT touch the Message after calling this function because it has\n     * effectively been freed.  It is an error to recycle a message that is currently\n     * enqueued or that is in the process of being delivered to a Handler.\n     * </p>\n     */\n    public void recycle() {\n        if (isInUse()) {\n            if (gCheckRecycle) {\n                throw new IllegalStateException(\"This message cannot be recycled because it \"\n                        + \"is still in use.\");\n            }\n            return;\n        }\n        recycleUnchecked();\n    }\n\n    /**\n     * Recycles a Message that may be in-use.\n     * Used internally by the MessageQueue and Looper when disposing of queued Messages.\n     */\n    void recycleUnchecked() {\n        // Mark the message as in use while it remains in the recycled object pool.\n        // Clear out all other details.\n        flags = FLAG_IN_USE;\n        what = 0;\n        arg1 = 0;\n        arg2 = 0;\n        obj = null;\n        replyTo = null;\n        sendingUid = -1;\n        when = 0;\n        target = null;\n        callback = null;\n        data = null;\n\n        synchronized (sPoolSync) {\n            if (sPoolSize < MAX_POOL_SIZE) {\n                next = sPool;\n                sPool = this;\n                sPoolSize++;\n            }\n        }\n    }\n```\n从代码分析上看，消息池存放的核心方法就是上面的recycleUnchecked()方法：\n\n> 1、将待回收的Message对象字段置空（避免因Message过大，使静态的消息池内存泄漏）。\n>\n> 2、以内置锁对方式（线程安全），判断当前线程池的大小是否小于50。若小于50，直接将mesaage插入到消息池链表尾部；若大于等于50，则直接丢弃掉，交由GC管理。\n\n\n---\n\n### [消费者心理学：三个趣味经济学原理](http://i.wshang.com/Post/Default/Index/pid/32949.html) -- 张超耀\n- 价格越低为什么不但不好卖，反而价格越高越好卖\n- 为什么大手大脚的浪费反而可以拯救经济？\n- 为什么免费未必就是最好的\n\n这些经济学原理背后又有哪些逻辑在支撑，让我去探讨一下这些好玩的经济学吧。\n\n#### 价格越高越好卖——虚荣效应\n\n- 富人们一般不喜欢大众模仿他们的消费行为，这种情况就叫做虚荣效应(snob effect)。虚荣效应具体是指购买商品的时候追求与众不同的个性的现象。\n\n- 虚荣效应主要有以下两种表现。\n\n\t- 高档商品刚上市的时候迅速购买。这是因为，在这一瞬间并不是每个人都能享受到消费高档商品的荣誉。\n\n\t- 不论之前如何热情赞美的商品，一旦其市场占有率达到一般大众都可以消费的水平就不再继续购买。这是因为人人都能购买使用的商品既不会让人感到荣誉，也不会有高档的感觉。\n\n#### 大手大脚的浪费能拯救经济——节约悖论\n\n- 我们都知道，如果消费超过收入，就没有余钱可以储蓄，也就无法积累资金，最终只能过贫穷的生活。所以，为了成为富人我们会努力工作，有时候也会变成小气鬼，为了能储蓄更多钱而努力。\n\n- 这个原理对于个人是适用的，但是对于国家整体经济是否也适用呢？如果所有国民都变成小气鬼，这个国家真的能够变得更加富强吗？答案是否定的，尤其是在经济不景气的时候。让我们看看其原因何在。\n\n- 一旦经济进入不景气，基于对未来的担忧，人们会选择更多的储蓄进而减少消费。可是如果所有人都减少消费的话，企业的销售额就会降低，库存就会增加。随之而来的是企业只能降低生产减少雇用，而企业员工的收入就会减少。那么，对未来的担忧就会强化，人们会更加坚定地减少消费增加储蓄，于是整体经济就会陷入愈发不景气的恶性循环中。\n\n#### 免费未必就好——免费经济学\n\n- “世上没有免费的午餐”是1976年获得诺贝尔经济学奖的着名经济学家米尔顿弗里德曼(Milton Friedman)常说的一句话。\n\n- 有的信息粗看之下似乎是免费的，实际上经过了解后发现并不是免费的意思；或者可以解释为免费后面隐藏着某种诱饵，还可以理解为不要期待不付出代价的免费东西。就像“免费的奶酪只存在于捕鼠器上”的俄罗斯谚语一样，对免费的东西保持警惕是亘古不变的道理。\n\n- 看看我们周围，就能发现很多免费营销，地铁站前的免费报纸就是其中一种。曾经威胁到日报和体育报纸的免费报纸因为有很多读者，所以可以从广告收入上获得高收益。人气差的免费报纸会因为得不到足够的广告收入而被淘汰，这样的话，幸存下来的免费报纸就可以逐步占据更加有利的位置。越是资金实力雄厚的公司，在这种免费竞争中能够生存下来的概率就越大。因此，消费者也可能会面临因为垄断招致的损失。\n\n- 免费经济市场的另一个弊端就是对资源的浪费。以免费报纸为例，因为免费派发给消费者，所以新闻纸会被大量浪费掉。大量生产大量消费的体制会导致能源的过度使用而招致地球变暖势头的加速。”\n\n\n----\n### Icon制作 - 杨志平\n\n<img width=\"487\" alt=\"qq20150707-6 2x\" src=\"https://cloud.githubusercontent.com/assets/9360037/8542711/2952b918-24ca-11e5-8dda-f42e42f57e72.png\">\n<img width=\"568\" alt=\"qq20150707-11 2x\" src=\"https://cloud.githubusercontent.com/assets/9360037/8542720/2987624e-24ca-11e5-8380-658f9fc08f24.png\">\n\n####51offer的Icon的流程\n<img width=\"491\" alt=\"qq20150707-1 2x\" src=\"https://cloud.githubusercontent.com/assets/9360037/8542715/29552c5c-24ca-11e5-9849-bd352ede57f4.png\">\n<img width=\"497\" alt=\"qq20150707-2 2x\" src=\"https://cloud.githubusercontent.com/assets/9360037/8542712/2952ba3a-24ca-11e5-85b7-0149e855e0cd.png\">\n<img width=\"493\" alt=\"qq20150707-3 2x\" src=\"https://cloud.githubusercontent.com/assets/9360037/8542713/2952e118-24ca-11e5-9128-f30ac093e8f4.png\">\n<img width=\"493\" alt=\"qq20150707-4 2x\" src=\"https://cloud.githubusercontent.com/assets/9360037/8542716/29557bf8-24ca-11e5-8869-afc7972ac5bf.png\">\n<img width=\"492\" alt=\"qq20150707-5 2x\" src=\"https://cloud.githubusercontent.com/assets/9360037/8542714/2952e884-24ca-11e5-8ade-4f3a69c19df4.png\">\n\n\n#### 另一个Icon的制作的流程\n\n<img width=\"589\" alt=\"qq20150707-7 2x\" src=\"https://cloud.githubusercontent.com/assets/9360037/8542721/29879a5c-24ca-11e5-85a0-535bf058fa62.png\">\n<img width=\"573\" alt=\"qq20150707-8 2x\" src=\"https://cloud.githubusercontent.com/assets/9360037/8542718/29855f58-24ca-11e5-83b2-e5d4e679f543.png\">\n<img width=\"586\" alt=\"qq20150707-9 2x\" src=\"https://cloud.githubusercontent.com/assets/9360037/8542717/29851a3e-24ca-11e5-8eab-3d5703d032ea.png\">\n<img width=\"578\" alt=\"qq20150707-10 2x\" src=\"https://cloud.githubusercontent.com/assets/9360037/8542719/2986620e-24ca-11e5-9686-6fad2780ab63.png\">\n\n\n### Android 动画制作 - 王胜\n\n#### View Animation\n- AlphaAnimation 淡入淡出效果\n- TranslateAnimation 移动效果\n- ScaleAnimation 缩放效果\n- RotateAnimation 旋转效果\n\n原理：提供动画的起始和结束状态信息，中间的状态根据上述类里差值器算法填充\n[[示例参考]](http://www.cnblogs.com/angeldevil/archive/2011/12/02/2271096.html)\n\n#### Property Animation\nView Animation动画比较简单，一般都是单个因素的变化，如果牵扯到复杂的动画，就显得力不从心。因此，Android 3.0 引入了属性动画。注：可通过[[NineOldAndroids]](http://nineoldandroids.com/)项目在3.0之前的系统中使用Property Animation\n\n原理：暴露出差值算法的回调方法，有工程师自己发挥想象，造出奇妙的动画效果。\n[[示例参考]](http://www.cnblogs.com/angeldevil/archive/2011/12/02/2271096.html)\n\n#### Drawable Animation\n##### 逐帧动画\n原理：提供动画每个帧上的图片资源，顺序播放\n[[示例参考]](http://www.cnblogs.com/angeldevil/archive/2011/12/02/2271096.html)\n\n##### ClipDrawable 剪切动画\n原理：提供一个背景图片，前景图片是一个ClipDrawable对象。通过线程操作ClipDrawable的剪切进度。\n\n实例：\n\n- ClipDrawable 定义xml文件\n\n~~~XML\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<clip xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:clipOrientation=\"vertical\"\n    android:drawable=\"@drawable/loading_progress\"\n    android:gravity=\"bottom\">\n</clip>\n~~~\n\n- 组件引用\n\n~~~ XML\n<ImageView\n        android:id=\"@+id/iv\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:scaleType=\"centerInside\"\n        android:paddingTop=\"5dp\"\n        android:paddingLeft=\"5dp\"\n        android:background=\"@drawable/loading_bg\"\n        android:src=\"@drawable/clip_loading\"/>\n~~~\n\n- 线程动态改变剪切进度\n\n``` Java\nprivate Handler handler = new Handler() {\n\t@Override\n    public void handleMessage(Message msg) {\n\t    // 如果消息是本程序发送的\n        if (msg.what == MSG_WHAT) {\n            mClipDrawable.setLevel(mProgress);\n        }\n    }\n};\n.......\nRunnable mRunnable = new Runnable() {\n\t@Override\n    public void run() {\n        isRunning = true;\n        while (isRunning) {\n            handler.sendEmptyMessage(MSG_WHAT);\n            if (mProgress > MAX_PROGRESS) {\n                mProgress = 0;\n            }\n            mProgress += 100;\n            try {\n                Thread.sleep(18);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n};\n```\n","source":"_posts/知其所以然.md","raw":"title: 知其所以然(10分钟解释一个和开发相关的原理)\ndate: 2015-07-07 23:04:29\ntags:\ncategories: 移动组周分享\n---\n\n\n\n### WEB 登录『原理』 - 曾铭\n\n\n#### Session & cookie\n\n- HTTP 是无状态协议\n- Session 服务器端简单存储\n- cookie 客户端简单存储（注意：在请求头中）\n\n#### 密码如何存储\n\n- 明文存储\n- md5 碰撞库破解  md5(pwd)\n- md5+salt   md5(pwd+salt)  salt  pwd\n- sha1……都能用，千万不要自己实现散列算法\n\n#### 一个登录的过程\n\n- 明文密码\n- session_id, access_token, token\n- 第三方登录：OAuth2, OpenID\n\n----\n\n### iBeacon - 潘君\n\n- BLE\n    - RSSI(Received Signal Strength Indicator)\n    - 唯一标识码\n    - 例:[ 防丢器](http://detail.tmall.com/item.htm?spm=a1z10.1-b.w4004-3501608320.8.8JO7JE&id=22152768901)\n\n- [应用场景](http://www.brtbeacon.com/home/industry_solution.shtml)\n    - 配合微信摇一摇\n    - 商城导购\n    - 地下停车库导航\n\n- [室内定位](https://github.com/ibip/ibip_document/wiki/%E5%AE%A4%E5%86%85%E5%AE%9A%E4%BD%8D%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84)\n    - 标签定位\n    - 三角定位\n    - 指纹定位\n\n----\n### andoid虚拟机 - 吴明\n- 系统框架对比android vs ios\n- [ios系统框架](http://blog.csdn.net/xyz_lmn/article/details/8907502)\n-  [android系统框架](http://www.cnblogs.com/royenhome/archive/2010/04/24/1719293.html)\n-  Dalvik虚拟机\n\t- Dalvik虚拟机是Android程序的虚拟机，是Android中Java程序的运行基础。其指令集基于寄存器架构，执行其特有的文件格式——dex字节码来完成对象生命周期管理、堆栈管理、线程管理、安全异常管理、垃圾回收等重要功能。它的核心内容是实现库（libdvm.so），大体由C语言实现。依赖于Linux内核的一部分功能——线程机制、内存管理机制，能高效使用内存，并在低速CPU上表现出的高性能。每一个Android应用在底层都会对应一个独立的Dalvik虚拟机实例，其代码在虚拟机的解释下得以执行。\n\n- Android系统是以Linux系统为底层构建的，Android系统是开源(源代码公开)的，Android系统势必会适配到不同硬件配置的设备上，因此谷歌为了降低应用的开发难度在Linux底层之上构筑了一个名为“Dalvik”的虚拟机。\n- 一个应用，一个虚拟机实例，一个进程！！！\n- [android虚拟机详细](http://blog.csdn.net/andyxm/article/details/6126907/)\n\n- 其他：\n\t- ART模式:Android4.4中新加入的ART模式，该模式的完整名称是Androidruntime.\n\t- ART：Android 4.4开始推出的新的运行环境，在APP安装的时候使用dex2oat工具直接把DEX文件转换为机器码文件，运行的时候以机器码方式运行，可以充分利用系统性能；此外，改进的内存回收机制使得ART运行模式下的内存回收速度只有Dalvik运行时模式下的50%，也能够提升系统运行速度。\n\n----\n\n### Android的Message Pool是个什么鬼(源码角度分析) - 李仙鹏\n\nAndroid中，我们在线程之间通信传递通常采用Android的消息机制，而这机制传递的正是Message。\n\n通常，我们使用[Message.obtain()](http://developer.android.com/reference/android/os/Message.html#obtain())和[Handler.obtainMessage()](http://developer.android.com/reference/android/os/Handler.html#obtainMessage())从Message Pool中获取Message，避免直接构造Message。\n\n#### Message.obtain()源码\n\n```\n    /**\n     * Return a new Message instance from the global pool. Allows us to\n     * avoid allocating new objects in many cases.\n     */\n    public static Message obtain() {\n        synchronized (sPoolSync) {\n            if (sPool != null) {\n                Message m = sPool;\n                sPool = m.next;\n                m.next = null;\n                m.flags = 0; // clear in-use flag\n                sPoolSize--;\n                return m;\n            }\n        }\n        return new Message();\n    }\n\n```\n从代码片中，可以看到Message是直接由sPool赋值的。\n\n#### Handler.obtain()源码\n\n```\n    /**\n     * Returns a new {@link android.os.Message Message} from the global message pool. More efficient than\n     * creating and allocating new instances. The retrieved message has its handler set to this instance (Message.target == this).\n     *  If you don't want that facility, just call Message.obtain() instead.\n     */\n    public final Message obtainMessage()\n    {\n        return Message.obtain(this);\n    }\n\n```\nHandler.obtain()最终还是调用Message.obtain()来获取的。\n\n#### Message Pool相关源码分析\n\n##### Message Pool数据结构\n\n```\n    // sometimes we store linked lists of these things\n    /*package*/ Message next;\n\n    private static final Object sPoolSync = new Object();\n    private static Message sPool;\n    private static int sPoolSize = 0;\n\n    private static final int MAX_POOL_SIZE = 50;\n\n    private static boolean gCheckRecycle = true;\n```\n从代码中可以很明确的看到，Message Pool的数据结构实际就是一个链表。sPool就是一个全局的消息池，sPoolSize记录链表长度，MAX_POOL_SIZE表示链表的最大长度为50。\n\n##### Message Pool如何存放Message\n\n```\n    /** @hide */\n    public static void updateCheckRecycle(int targetSdkVersion) {\n        if (targetSdkVersion < Build.VERSION_CODES.LOLLIPOP) {\n            gCheckRecycle = false;\n        }\n    }\n\n    /**\n     * Return a Message instance to the global pool.\n     * <p>\n     * You MUST NOT touch the Message after calling this function because it has\n     * effectively been freed.  It is an error to recycle a message that is currently\n     * enqueued or that is in the process of being delivered to a Handler.\n     * </p>\n     */\n    public void recycle() {\n        if (isInUse()) {\n            if (gCheckRecycle) {\n                throw new IllegalStateException(\"This message cannot be recycled because it \"\n                        + \"is still in use.\");\n            }\n            return;\n        }\n        recycleUnchecked();\n    }\n\n    /**\n     * Recycles a Message that may be in-use.\n     * Used internally by the MessageQueue and Looper when disposing of queued Messages.\n     */\n    void recycleUnchecked() {\n        // Mark the message as in use while it remains in the recycled object pool.\n        // Clear out all other details.\n        flags = FLAG_IN_USE;\n        what = 0;\n        arg1 = 0;\n        arg2 = 0;\n        obj = null;\n        replyTo = null;\n        sendingUid = -1;\n        when = 0;\n        target = null;\n        callback = null;\n        data = null;\n\n        synchronized (sPoolSync) {\n            if (sPoolSize < MAX_POOL_SIZE) {\n                next = sPool;\n                sPool = this;\n                sPoolSize++;\n            }\n        }\n    }\n```\n从代码分析上看，消息池存放的核心方法就是上面的recycleUnchecked()方法：\n\n> 1、将待回收的Message对象字段置空（避免因Message过大，使静态的消息池内存泄漏）。\n>\n> 2、以内置锁对方式（线程安全），判断当前线程池的大小是否小于50。若小于50，直接将mesaage插入到消息池链表尾部；若大于等于50，则直接丢弃掉，交由GC管理。\n\n\n---\n\n### [消费者心理学：三个趣味经济学原理](http://i.wshang.com/Post/Default/Index/pid/32949.html) -- 张超耀\n- 价格越低为什么不但不好卖，反而价格越高越好卖\n- 为什么大手大脚的浪费反而可以拯救经济？\n- 为什么免费未必就是最好的\n\n这些经济学原理背后又有哪些逻辑在支撑，让我去探讨一下这些好玩的经济学吧。\n\n#### 价格越高越好卖——虚荣效应\n\n- 富人们一般不喜欢大众模仿他们的消费行为，这种情况就叫做虚荣效应(snob effect)。虚荣效应具体是指购买商品的时候追求与众不同的个性的现象。\n\n- 虚荣效应主要有以下两种表现。\n\n\t- 高档商品刚上市的时候迅速购买。这是因为，在这一瞬间并不是每个人都能享受到消费高档商品的荣誉。\n\n\t- 不论之前如何热情赞美的商品，一旦其市场占有率达到一般大众都可以消费的水平就不再继续购买。这是因为人人都能购买使用的商品既不会让人感到荣誉，也不会有高档的感觉。\n\n#### 大手大脚的浪费能拯救经济——节约悖论\n\n- 我们都知道，如果消费超过收入，就没有余钱可以储蓄，也就无法积累资金，最终只能过贫穷的生活。所以，为了成为富人我们会努力工作，有时候也会变成小气鬼，为了能储蓄更多钱而努力。\n\n- 这个原理对于个人是适用的，但是对于国家整体经济是否也适用呢？如果所有国民都变成小气鬼，这个国家真的能够变得更加富强吗？答案是否定的，尤其是在经济不景气的时候。让我们看看其原因何在。\n\n- 一旦经济进入不景气，基于对未来的担忧，人们会选择更多的储蓄进而减少消费。可是如果所有人都减少消费的话，企业的销售额就会降低，库存就会增加。随之而来的是企业只能降低生产减少雇用，而企业员工的收入就会减少。那么，对未来的担忧就会强化，人们会更加坚定地减少消费增加储蓄，于是整体经济就会陷入愈发不景气的恶性循环中。\n\n#### 免费未必就好——免费经济学\n\n- “世上没有免费的午餐”是1976年获得诺贝尔经济学奖的着名经济学家米尔顿弗里德曼(Milton Friedman)常说的一句话。\n\n- 有的信息粗看之下似乎是免费的，实际上经过了解后发现并不是免费的意思；或者可以解释为免费后面隐藏着某种诱饵，还可以理解为不要期待不付出代价的免费东西。就像“免费的奶酪只存在于捕鼠器上”的俄罗斯谚语一样，对免费的东西保持警惕是亘古不变的道理。\n\n- 看看我们周围，就能发现很多免费营销，地铁站前的免费报纸就是其中一种。曾经威胁到日报和体育报纸的免费报纸因为有很多读者，所以可以从广告收入上获得高收益。人气差的免费报纸会因为得不到足够的广告收入而被淘汰，这样的话，幸存下来的免费报纸就可以逐步占据更加有利的位置。越是资金实力雄厚的公司，在这种免费竞争中能够生存下来的概率就越大。因此，消费者也可能会面临因为垄断招致的损失。\n\n- 免费经济市场的另一个弊端就是对资源的浪费。以免费报纸为例，因为免费派发给消费者，所以新闻纸会被大量浪费掉。大量生产大量消费的体制会导致能源的过度使用而招致地球变暖势头的加速。”\n\n\n----\n### Icon制作 - 杨志平\n\n<img width=\"487\" alt=\"qq20150707-6 2x\" src=\"https://cloud.githubusercontent.com/assets/9360037/8542711/2952b918-24ca-11e5-8dda-f42e42f57e72.png\">\n<img width=\"568\" alt=\"qq20150707-11 2x\" src=\"https://cloud.githubusercontent.com/assets/9360037/8542720/2987624e-24ca-11e5-8380-658f9fc08f24.png\">\n\n####51offer的Icon的流程\n<img width=\"491\" alt=\"qq20150707-1 2x\" src=\"https://cloud.githubusercontent.com/assets/9360037/8542715/29552c5c-24ca-11e5-9849-bd352ede57f4.png\">\n<img width=\"497\" alt=\"qq20150707-2 2x\" src=\"https://cloud.githubusercontent.com/assets/9360037/8542712/2952ba3a-24ca-11e5-85b7-0149e855e0cd.png\">\n<img width=\"493\" alt=\"qq20150707-3 2x\" src=\"https://cloud.githubusercontent.com/assets/9360037/8542713/2952e118-24ca-11e5-9128-f30ac093e8f4.png\">\n<img width=\"493\" alt=\"qq20150707-4 2x\" src=\"https://cloud.githubusercontent.com/assets/9360037/8542716/29557bf8-24ca-11e5-8869-afc7972ac5bf.png\">\n<img width=\"492\" alt=\"qq20150707-5 2x\" src=\"https://cloud.githubusercontent.com/assets/9360037/8542714/2952e884-24ca-11e5-8ade-4f3a69c19df4.png\">\n\n\n#### 另一个Icon的制作的流程\n\n<img width=\"589\" alt=\"qq20150707-7 2x\" src=\"https://cloud.githubusercontent.com/assets/9360037/8542721/29879a5c-24ca-11e5-85a0-535bf058fa62.png\">\n<img width=\"573\" alt=\"qq20150707-8 2x\" src=\"https://cloud.githubusercontent.com/assets/9360037/8542718/29855f58-24ca-11e5-83b2-e5d4e679f543.png\">\n<img width=\"586\" alt=\"qq20150707-9 2x\" src=\"https://cloud.githubusercontent.com/assets/9360037/8542717/29851a3e-24ca-11e5-8eab-3d5703d032ea.png\">\n<img width=\"578\" alt=\"qq20150707-10 2x\" src=\"https://cloud.githubusercontent.com/assets/9360037/8542719/2986620e-24ca-11e5-9686-6fad2780ab63.png\">\n\n\n### Android 动画制作 - 王胜\n\n#### View Animation\n- AlphaAnimation 淡入淡出效果\n- TranslateAnimation 移动效果\n- ScaleAnimation 缩放效果\n- RotateAnimation 旋转效果\n\n原理：提供动画的起始和结束状态信息，中间的状态根据上述类里差值器算法填充\n[[示例参考]](http://www.cnblogs.com/angeldevil/archive/2011/12/02/2271096.html)\n\n#### Property Animation\nView Animation动画比较简单，一般都是单个因素的变化，如果牵扯到复杂的动画，就显得力不从心。因此，Android 3.0 引入了属性动画。注：可通过[[NineOldAndroids]](http://nineoldandroids.com/)项目在3.0之前的系统中使用Property Animation\n\n原理：暴露出差值算法的回调方法，有工程师自己发挥想象，造出奇妙的动画效果。\n[[示例参考]](http://www.cnblogs.com/angeldevil/archive/2011/12/02/2271096.html)\n\n#### Drawable Animation\n##### 逐帧动画\n原理：提供动画每个帧上的图片资源，顺序播放\n[[示例参考]](http://www.cnblogs.com/angeldevil/archive/2011/12/02/2271096.html)\n\n##### ClipDrawable 剪切动画\n原理：提供一个背景图片，前景图片是一个ClipDrawable对象。通过线程操作ClipDrawable的剪切进度。\n\n实例：\n\n- ClipDrawable 定义xml文件\n\n~~~XML\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<clip xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:clipOrientation=\"vertical\"\n    android:drawable=\"@drawable/loading_progress\"\n    android:gravity=\"bottom\">\n</clip>\n~~~\n\n- 组件引用\n\n~~~ XML\n<ImageView\n        android:id=\"@+id/iv\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:scaleType=\"centerInside\"\n        android:paddingTop=\"5dp\"\n        android:paddingLeft=\"5dp\"\n        android:background=\"@drawable/loading_bg\"\n        android:src=\"@drawable/clip_loading\"/>\n~~~\n\n- 线程动态改变剪切进度\n\n``` Java\nprivate Handler handler = new Handler() {\n\t@Override\n    public void handleMessage(Message msg) {\n\t    // 如果消息是本程序发送的\n        if (msg.what == MSG_WHAT) {\n            mClipDrawable.setLevel(mProgress);\n        }\n    }\n};\n.......\nRunnable mRunnable = new Runnable() {\n\t@Override\n    public void run() {\n        isRunning = true;\n        while (isRunning) {\n            handler.sendEmptyMessage(MSG_WHAT);\n            if (mProgress > MAX_PROGRESS) {\n                mProgress = 0;\n            }\n            mProgress += 100;\n            try {\n                Thread.sleep(18);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n};\n```\n","slug":"知其所以然","published":1,"updated":"2021-09-10T07:04:21.947Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cktfeap4d002hc2xxrykmzra5","content":"<h3 id=\"WEB-登录『原理』-曾铭\"><a href=\"#WEB-登录『原理』-曾铭\" class=\"headerlink\" title=\"WEB 登录『原理』 - 曾铭\"></a>WEB 登录『原理』 - 曾铭</h3><h4 id=\"Session-amp-cookie\"><a href=\"#Session-amp-cookie\" class=\"headerlink\" title=\"Session &amp; cookie\"></a>Session &amp; cookie</h4><ul>\n<li>HTTP 是无状态协议</li>\n<li>Session 服务器端简单存储</li>\n<li>cookie 客户端简单存储（注意：在请求头中）</li>\n</ul>\n<h4 id=\"密码如何存储\"><a href=\"#密码如何存储\" class=\"headerlink\" title=\"密码如何存储\"></a>密码如何存储</h4><ul>\n<li>明文存储</li>\n<li>md5 碰撞库破解  md5(pwd)</li>\n<li>md5+salt   md5(pwd+salt)  salt  pwd</li>\n<li>sha1……都能用，千万不要自己实现散列算法</li>\n</ul>\n<h4 id=\"一个登录的过程\"><a href=\"#一个登录的过程\" class=\"headerlink\" title=\"一个登录的过程\"></a>一个登录的过程</h4><ul>\n<li>明文密码</li>\n<li>session_id, access_token, token</li>\n<li>第三方登录：OAuth2, OpenID</li>\n</ul>\n<hr>\n<h3 id=\"iBeacon-潘君\"><a href=\"#iBeacon-潘君\" class=\"headerlink\" title=\"iBeacon - 潘君\"></a>iBeacon - 潘君</h3><ul>\n<li><p>BLE</p>\n<ul>\n<li>RSSI(Received Signal Strength Indicator)</li>\n<li>唯一标识码</li>\n<li>例:<a href=\"http://detail.tmall.com/item.htm?spm=a1z10.1-b.w4004-3501608320.8.8JO7JE&amp;id=22152768901\" target=\"_blank\" rel=\"noopener\"> 防丢器</a></li>\n</ul>\n</li>\n<li><p><a href=\"http://www.brtbeacon.com/home/industry_solution.shtml\" target=\"_blank\" rel=\"noopener\">应用场景</a></p>\n<ul>\n<li>配合微信摇一摇</li>\n<li>商城导购</li>\n<li>地下停车库导航</li>\n</ul>\n</li>\n<li><p><a href=\"https://github.com/ibip/ibip_document/wiki/%E5%AE%A4%E5%86%85%E5%AE%9A%E4%BD%8D%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84\" target=\"_blank\" rel=\"noopener\">室内定位</a></p>\n<ul>\n<li>标签定位</li>\n<li>三角定位</li>\n<li>指纹定位</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"andoid虚拟机-吴明\"><a href=\"#andoid虚拟机-吴明\" class=\"headerlink\" title=\"andoid虚拟机 - 吴明\"></a>andoid虚拟机 - 吴明</h3><ul>\n<li>系统框架对比android vs ios</li>\n<li><a href=\"http://blog.csdn.net/xyz_lmn/article/details/8907502\" target=\"_blank\" rel=\"noopener\">ios系统框架</a></li>\n<li><a href=\"http://www.cnblogs.com/royenhome/archive/2010/04/24/1719293.html\" target=\"_blank\" rel=\"noopener\">android系统框架</a></li>\n<li><p>Dalvik虚拟机</p>\n<ul>\n<li>Dalvik虚拟机是Android程序的虚拟机，是Android中Java程序的运行基础。其指令集基于寄存器架构，执行其特有的文件格式——dex字节码来完成对象生命周期管理、堆栈管理、线程管理、安全异常管理、垃圾回收等重要功能。它的核心内容是实现库（libdvm.so），大体由C语言实现。依赖于Linux内核的一部分功能——线程机制、内存管理机制，能高效使用内存，并在低速CPU上表现出的高性能。每一个Android应用在底层都会对应一个独立的Dalvik虚拟机实例，其代码在虚拟机的解释下得以执行。</li>\n</ul>\n</li>\n<li><p>Android系统是以Linux系统为底层构建的，Android系统是开源(源代码公开)的，Android系统势必会适配到不同硬件配置的设备上，因此谷歌为了降低应用的开发难度在Linux底层之上构筑了一个名为“Dalvik”的虚拟机。</p>\n</li>\n<li>一个应用，一个虚拟机实例，一个进程！！！</li>\n<li><p><a href=\"http://blog.csdn.net/andyxm/article/details/6126907/\" target=\"_blank\" rel=\"noopener\">android虚拟机详细</a></p>\n</li>\n<li><p>其他：</p>\n<ul>\n<li>ART模式:Android4.4中新加入的ART模式，该模式的完整名称是Androidruntime.</li>\n<li>ART：Android 4.4开始推出的新的运行环境，在APP安装的时候使用dex2oat工具直接把DEX文件转换为机器码文件，运行的时候以机器码方式运行，可以充分利用系统性能；此外，改进的内存回收机制使得ART运行模式下的内存回收速度只有Dalvik运行时模式下的50%，也能够提升系统运行速度。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"Android的Message-Pool是个什么鬼-源码角度分析-李仙鹏\"><a href=\"#Android的Message-Pool是个什么鬼-源码角度分析-李仙鹏\" class=\"headerlink\" title=\"Android的Message Pool是个什么鬼(源码角度分析) - 李仙鹏\"></a>Android的Message Pool是个什么鬼(源码角度分析) - 李仙鹏</h3><p>Android中，我们在线程之间通信传递通常采用Android的消息机制，而这机制传递的正是Message。</p>\n<p>通常，我们使用<a href=\"http://developer.android.com/reference/android/os/Message.html#obtain(\" target=\"_blank\" rel=\"noopener\">Message.obtain()</a>)和<a href=\"http://developer.android.com/reference/android/os/Handler.html#obtainMessage(\" target=\"_blank\" rel=\"noopener\">Handler.obtainMessage()</a>)从Message Pool中获取Message，避免直接构造Message。</p>\n<h4 id=\"Message-obtain-源码\"><a href=\"#Message-obtain-源码\" class=\"headerlink\" title=\"Message.obtain()源码\"></a>Message.obtain()源码</h4><pre><code>    /**\n     * Return a new Message instance from the global pool. Allows us to\n     * avoid allocating new objects in many cases.\n     */\n    public static Message obtain() {\n        synchronized (sPoolSync) {\n            if (sPool != null) {\n                Message m = sPool;\n                sPool = m.next;\n                m.next = null;\n                m.flags = 0; // clear in-use flag\n                sPoolSize--;\n                return m;\n            }\n        }\n        return new Message();\n    }\n</code></pre><p>从代码片中，可以看到Message是直接由sPool赋值的。</p>\n<h4 id=\"Handler-obtain-源码\"><a href=\"#Handler-obtain-源码\" class=\"headerlink\" title=\"Handler.obtain()源码\"></a>Handler.obtain()源码</h4><pre><code>    /**\n     * Returns a new {@link android.os.Message Message} from the global message pool. More efficient than\n     * creating and allocating new instances. The retrieved message has its handler set to this instance (Message.target == this).\n     *  If you don&#39;t want that facility, just call Message.obtain() instead.\n     */\n    public final Message obtainMessage()\n    {\n        return Message.obtain(this);\n    }\n</code></pre><p>Handler.obtain()最终还是调用Message.obtain()来获取的。</p>\n<h4 id=\"Message-Pool相关源码分析\"><a href=\"#Message-Pool相关源码分析\" class=\"headerlink\" title=\"Message Pool相关源码分析\"></a>Message Pool相关源码分析</h4><h5 id=\"Message-Pool数据结构\"><a href=\"#Message-Pool数据结构\" class=\"headerlink\" title=\"Message Pool数据结构\"></a>Message Pool数据结构</h5><pre><code>    // sometimes we store linked lists of these things\n    /*package*/ Message next;\n\n    private static final Object sPoolSync = new Object();\n    private static Message sPool;\n    private static int sPoolSize = 0;\n\n    private static final int MAX_POOL_SIZE = 50;\n\n    private static boolean gCheckRecycle = true;\n</code></pre><p>从代码中可以很明确的看到，Message Pool的数据结构实际就是一个链表。sPool就是一个全局的消息池，sPoolSize记录链表长度，MAX_POOL_SIZE表示链表的最大长度为50。</p>\n<h5 id=\"Message-Pool如何存放Message\"><a href=\"#Message-Pool如何存放Message\" class=\"headerlink\" title=\"Message Pool如何存放Message\"></a>Message Pool如何存放Message</h5><pre><code>    /** @hide */\n    public static void updateCheckRecycle(int targetSdkVersion) {\n        if (targetSdkVersion &lt; Build.VERSION_CODES.LOLLIPOP) {\n            gCheckRecycle = false;\n        }\n    }\n\n    /**\n     * Return a Message instance to the global pool.\n     * &lt;p&gt;\n     * You MUST NOT touch the Message after calling this function because it has\n     * effectively been freed.  It is an error to recycle a message that is currently\n     * enqueued or that is in the process of being delivered to a Handler.\n     * &lt;/p&gt;\n     */\n    public void recycle() {\n        if (isInUse()) {\n            if (gCheckRecycle) {\n                throw new IllegalStateException(&quot;This message cannot be recycled because it &quot;\n                        + &quot;is still in use.&quot;);\n            }\n            return;\n        }\n        recycleUnchecked();\n    }\n\n    /**\n     * Recycles a Message that may be in-use.\n     * Used internally by the MessageQueue and Looper when disposing of queued Messages.\n     */\n    void recycleUnchecked() {\n        // Mark the message as in use while it remains in the recycled object pool.\n        // Clear out all other details.\n        flags = FLAG_IN_USE;\n        what = 0;\n        arg1 = 0;\n        arg2 = 0;\n        obj = null;\n        replyTo = null;\n        sendingUid = -1;\n        when = 0;\n        target = null;\n        callback = null;\n        data = null;\n\n        synchronized (sPoolSync) {\n            if (sPoolSize &lt; MAX_POOL_SIZE) {\n                next = sPool;\n                sPool = this;\n                sPoolSize++;\n            }\n        }\n    }\n</code></pre><p>从代码分析上看，消息池存放的核心方法就是上面的recycleUnchecked()方法：</p>\n<blockquote>\n<p>1、将待回收的Message对象字段置空（避免因Message过大，使静态的消息池内存泄漏）。</p>\n<p>2、以内置锁对方式（线程安全），判断当前线程池的大小是否小于50。若小于50，直接将mesaage插入到消息池链表尾部；若大于等于50，则直接丢弃掉，交由GC管理。</p>\n</blockquote>\n<hr>\n<h3 id=\"消费者心理学：三个趣味经济学原理-–-张超耀\"><a href=\"#消费者心理学：三个趣味经济学原理-–-张超耀\" class=\"headerlink\" title=\"消费者心理学：三个趣味经济学原理 – 张超耀\"></a><a href=\"http://i.wshang.com/Post/Default/Index/pid/32949.html\" target=\"_blank\" rel=\"noopener\">消费者心理学：三个趣味经济学原理</a> – 张超耀</h3><ul>\n<li>价格越低为什么不但不好卖，反而价格越高越好卖</li>\n<li>为什么大手大脚的浪费反而可以拯救经济？</li>\n<li>为什么免费未必就是最好的</li>\n</ul>\n<p>这些经济学原理背后又有哪些逻辑在支撑，让我去探讨一下这些好玩的经济学吧。</p>\n<h4 id=\"价格越高越好卖——虚荣效应\"><a href=\"#价格越高越好卖——虚荣效应\" class=\"headerlink\" title=\"价格越高越好卖——虚荣效应\"></a>价格越高越好卖——虚荣效应</h4><ul>\n<li><p>富人们一般不喜欢大众模仿他们的消费行为，这种情况就叫做虚荣效应(snob effect)。虚荣效应具体是指购买商品的时候追求与众不同的个性的现象。</p>\n</li>\n<li><p>虚荣效应主要有以下两种表现。</p>\n<ul>\n<li><p>高档商品刚上市的时候迅速购买。这是因为，在这一瞬间并不是每个人都能享受到消费高档商品的荣誉。</p>\n</li>\n<li><p>不论之前如何热情赞美的商品，一旦其市场占有率达到一般大众都可以消费的水平就不再继续购买。这是因为人人都能购买使用的商品既不会让人感到荣誉，也不会有高档的感觉。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"大手大脚的浪费能拯救经济——节约悖论\"><a href=\"#大手大脚的浪费能拯救经济——节约悖论\" class=\"headerlink\" title=\"大手大脚的浪费能拯救经济——节约悖论\"></a>大手大脚的浪费能拯救经济——节约悖论</h4><ul>\n<li><p>我们都知道，如果消费超过收入，就没有余钱可以储蓄，也就无法积累资金，最终只能过贫穷的生活。所以，为了成为富人我们会努力工作，有时候也会变成小气鬼，为了能储蓄更多钱而努力。</p>\n</li>\n<li><p>这个原理对于个人是适用的，但是对于国家整体经济是否也适用呢？如果所有国民都变成小气鬼，这个国家真的能够变得更加富强吗？答案是否定的，尤其是在经济不景气的时候。让我们看看其原因何在。</p>\n</li>\n<li><p>一旦经济进入不景气，基于对未来的担忧，人们会选择更多的储蓄进而减少消费。可是如果所有人都减少消费的话，企业的销售额就会降低，库存就会增加。随之而来的是企业只能降低生产减少雇用，而企业员工的收入就会减少。那么，对未来的担忧就会强化，人们会更加坚定地减少消费增加储蓄，于是整体经济就会陷入愈发不景气的恶性循环中。</p>\n</li>\n</ul>\n<h4 id=\"免费未必就好——免费经济学\"><a href=\"#免费未必就好——免费经济学\" class=\"headerlink\" title=\"免费未必就好——免费经济学\"></a>免费未必就好——免费经济学</h4><ul>\n<li><p>“世上没有免费的午餐”是1976年获得诺贝尔经济学奖的着名经济学家米尔顿弗里德曼(Milton Friedman)常说的一句话。</p>\n</li>\n<li><p>有的信息粗看之下似乎是免费的，实际上经过了解后发现并不是免费的意思；或者可以解释为免费后面隐藏着某种诱饵，还可以理解为不要期待不付出代价的免费东西。就像“免费的奶酪只存在于捕鼠器上”的俄罗斯谚语一样，对免费的东西保持警惕是亘古不变的道理。</p>\n</li>\n<li><p>看看我们周围，就能发现很多免费营销，地铁站前的免费报纸就是其中一种。曾经威胁到日报和体育报纸的免费报纸因为有很多读者，所以可以从广告收入上获得高收益。人气差的免费报纸会因为得不到足够的广告收入而被淘汰，这样的话，幸存下来的免费报纸就可以逐步占据更加有利的位置。越是资金实力雄厚的公司，在这种免费竞争中能够生存下来的概率就越大。因此，消费者也可能会面临因为垄断招致的损失。</p>\n</li>\n<li><p>免费经济市场的另一个弊端就是对资源的浪费。以免费报纸为例，因为免费派发给消费者，所以新闻纸会被大量浪费掉。大量生产大量消费的体制会导致能源的过度使用而招致地球变暖势头的加速。”</p>\n</li>\n</ul>\n<hr>\n<h3 id=\"Icon制作-杨志平\"><a href=\"#Icon制作-杨志平\" class=\"headerlink\" title=\"Icon制作 - 杨志平\"></a>Icon制作 - 杨志平</h3><p><img width=\"487\" alt=\"qq20150707-6 2x\" src=\"https://cloud.githubusercontent.com/assets/9360037/8542711/2952b918-24ca-11e5-8dda-f42e42f57e72.png\"><br><img width=\"568\" alt=\"qq20150707-11 2x\" src=\"https://cloud.githubusercontent.com/assets/9360037/8542720/2987624e-24ca-11e5-8380-658f9fc08f24.png\"></p>\n<p>####51offer的Icon的流程<br><img width=\"491\" alt=\"qq20150707-1 2x\" src=\"https://cloud.githubusercontent.com/assets/9360037/8542715/29552c5c-24ca-11e5-9849-bd352ede57f4.png\"><br><img width=\"497\" alt=\"qq20150707-2 2x\" src=\"https://cloud.githubusercontent.com/assets/9360037/8542712/2952ba3a-24ca-11e5-85b7-0149e855e0cd.png\"><br><img width=\"493\" alt=\"qq20150707-3 2x\" src=\"https://cloud.githubusercontent.com/assets/9360037/8542713/2952e118-24ca-11e5-9128-f30ac093e8f4.png\"><br><img width=\"493\" alt=\"qq20150707-4 2x\" src=\"https://cloud.githubusercontent.com/assets/9360037/8542716/29557bf8-24ca-11e5-8869-afc7972ac5bf.png\"><br><img width=\"492\" alt=\"qq20150707-5 2x\" src=\"https://cloud.githubusercontent.com/assets/9360037/8542714/2952e884-24ca-11e5-8ade-4f3a69c19df4.png\"></p>\n<h4 id=\"另一个Icon的制作的流程\"><a href=\"#另一个Icon的制作的流程\" class=\"headerlink\" title=\"另一个Icon的制作的流程\"></a>另一个Icon的制作的流程</h4><p><img width=\"589\" alt=\"qq20150707-7 2x\" src=\"https://cloud.githubusercontent.com/assets/9360037/8542721/29879a5c-24ca-11e5-85a0-535bf058fa62.png\"><br><img width=\"573\" alt=\"qq20150707-8 2x\" src=\"https://cloud.githubusercontent.com/assets/9360037/8542718/29855f58-24ca-11e5-83b2-e5d4e679f543.png\"><br><img width=\"586\" alt=\"qq20150707-9 2x\" src=\"https://cloud.githubusercontent.com/assets/9360037/8542717/29851a3e-24ca-11e5-8eab-3d5703d032ea.png\"><br><img width=\"578\" alt=\"qq20150707-10 2x\" src=\"https://cloud.githubusercontent.com/assets/9360037/8542719/2986620e-24ca-11e5-9686-6fad2780ab63.png\"></p>\n<h3 id=\"Android-动画制作-王胜\"><a href=\"#Android-动画制作-王胜\" class=\"headerlink\" title=\"Android 动画制作 - 王胜\"></a>Android 动画制作 - 王胜</h3><h4 id=\"View-Animation\"><a href=\"#View-Animation\" class=\"headerlink\" title=\"View Animation\"></a>View Animation</h4><ul>\n<li>AlphaAnimation 淡入淡出效果</li>\n<li>TranslateAnimation 移动效果</li>\n<li>ScaleAnimation 缩放效果</li>\n<li>RotateAnimation 旋转效果</li>\n</ul>\n<p>原理：提供动画的起始和结束状态信息，中间的状态根据上述类里差值器算法填充<br><a href=\"http://www.cnblogs.com/angeldevil/archive/2011/12/02/2271096.html\" target=\"_blank\" rel=\"noopener\">[示例参考]</a></p>\n<h4 id=\"Property-Animation\"><a href=\"#Property-Animation\" class=\"headerlink\" title=\"Property Animation\"></a>Property Animation</h4><p>View Animation动画比较简单，一般都是单个因素的变化，如果牵扯到复杂的动画，就显得力不从心。因此，Android 3.0 引入了属性动画。注：可通过<a href=\"http://nineoldandroids.com/\" target=\"_blank\" rel=\"noopener\">[NineOldAndroids]</a>项目在3.0之前的系统中使用Property Animation</p>\n<p>原理：暴露出差值算法的回调方法，有工程师自己发挥想象，造出奇妙的动画效果。<br><a href=\"http://www.cnblogs.com/angeldevil/archive/2011/12/02/2271096.html\" target=\"_blank\" rel=\"noopener\">[示例参考]</a></p>\n<h4 id=\"Drawable-Animation\"><a href=\"#Drawable-Animation\" class=\"headerlink\" title=\"Drawable Animation\"></a>Drawable Animation</h4><h5 id=\"逐帧动画\"><a href=\"#逐帧动画\" class=\"headerlink\" title=\"逐帧动画\"></a>逐帧动画</h5><p>原理：提供动画每个帧上的图片资源，顺序播放<br><a href=\"http://www.cnblogs.com/angeldevil/archive/2011/12/02/2271096.html\" target=\"_blank\" rel=\"noopener\">[示例参考]</a></p>\n<h5 id=\"ClipDrawable-剪切动画\"><a href=\"#ClipDrawable-剪切动画\" class=\"headerlink\" title=\"ClipDrawable 剪切动画\"></a>ClipDrawable 剪切动画</h5><p>原理：提供一个背景图片，前景图片是一个ClipDrawable对象。通过线程操作ClipDrawable的剪切进度。</p>\n<p>实例：</p>\n<ul>\n<li>ClipDrawable 定义xml文件</li>\n</ul>\n<pre><code class=\"XML\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;clip xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n    android:clipOrientation=&quot;vertical&quot;\n    android:drawable=&quot;@drawable/loading_progress&quot;\n    android:gravity=&quot;bottom&quot;&gt;\n&lt;/clip&gt;\n</code></pre>\n<ul>\n<li>组件引用</li>\n</ul>\n<pre><code class=\"XML\">&lt;ImageView\n        android:id=&quot;@+id/iv&quot;\n        android:layout_width=&quot;wrap_content&quot;\n        android:layout_height=&quot;wrap_content&quot;\n        android:scaleType=&quot;centerInside&quot;\n        android:paddingTop=&quot;5dp&quot;\n        android:paddingLeft=&quot;5dp&quot;\n        android:background=&quot;@drawable/loading_bg&quot;\n        android:src=&quot;@drawable/clip_loading&quot;/&gt;\n</code></pre>\n<ul>\n<li>线程动态改变剪切进度</li>\n</ul>\n<pre><code class=\"Java\">private Handler handler = new Handler() {\n    @Override\n    public void handleMessage(Message msg) {\n        // 如果消息是本程序发送的\n        if (msg.what == MSG_WHAT) {\n            mClipDrawable.setLevel(mProgress);\n        }\n    }\n};\n.......\nRunnable mRunnable = new Runnable() {\n    @Override\n    public void run() {\n        isRunning = true;\n        while (isRunning) {\n            handler.sendEmptyMessage(MSG_WHAT);\n            if (mProgress &gt; MAX_PROGRESS) {\n                mProgress = 0;\n            }\n            mProgress += 100;\n            try {\n                Thread.sleep(18);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n};\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"WEB-登录『原理』-曾铭\"><a href=\"#WEB-登录『原理』-曾铭\" class=\"headerlink\" title=\"WEB 登录『原理』 - 曾铭\"></a>WEB 登录『原理』 - 曾铭</h3><h4 id=\"Session-amp-cookie\"><a href=\"#Session-amp-cookie\" class=\"headerlink\" title=\"Session &amp; cookie\"></a>Session &amp; cookie</h4><ul>\n<li>HTTP 是无状态协议</li>\n<li>Session 服务器端简单存储</li>\n<li>cookie 客户端简单存储（注意：在请求头中）</li>\n</ul>\n<h4 id=\"密码如何存储\"><a href=\"#密码如何存储\" class=\"headerlink\" title=\"密码如何存储\"></a>密码如何存储</h4><ul>\n<li>明文存储</li>\n<li>md5 碰撞库破解  md5(pwd)</li>\n<li>md5+salt   md5(pwd+salt)  salt  pwd</li>\n<li>sha1……都能用，千万不要自己实现散列算法</li>\n</ul>\n<h4 id=\"一个登录的过程\"><a href=\"#一个登录的过程\" class=\"headerlink\" title=\"一个登录的过程\"></a>一个登录的过程</h4><ul>\n<li>明文密码</li>\n<li>session_id, access_token, token</li>\n<li>第三方登录：OAuth2, OpenID</li>\n</ul>\n<hr>\n<h3 id=\"iBeacon-潘君\"><a href=\"#iBeacon-潘君\" class=\"headerlink\" title=\"iBeacon - 潘君\"></a>iBeacon - 潘君</h3><ul>\n<li><p>BLE</p>\n<ul>\n<li>RSSI(Received Signal Strength Indicator)</li>\n<li>唯一标识码</li>\n<li>例:<a href=\"http://detail.tmall.com/item.htm?spm=a1z10.1-b.w4004-3501608320.8.8JO7JE&amp;id=22152768901\" target=\"_blank\" rel=\"noopener\"> 防丢器</a></li>\n</ul>\n</li>\n<li><p><a href=\"http://www.brtbeacon.com/home/industry_solution.shtml\" target=\"_blank\" rel=\"noopener\">应用场景</a></p>\n<ul>\n<li>配合微信摇一摇</li>\n<li>商城导购</li>\n<li>地下停车库导航</li>\n</ul>\n</li>\n<li><p><a href=\"https://github.com/ibip/ibip_document/wiki/%E5%AE%A4%E5%86%85%E5%AE%9A%E4%BD%8D%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84\" target=\"_blank\" rel=\"noopener\">室内定位</a></p>\n<ul>\n<li>标签定位</li>\n<li>三角定位</li>\n<li>指纹定位</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"andoid虚拟机-吴明\"><a href=\"#andoid虚拟机-吴明\" class=\"headerlink\" title=\"andoid虚拟机 - 吴明\"></a>andoid虚拟机 - 吴明</h3><ul>\n<li>系统框架对比android vs ios</li>\n<li><a href=\"http://blog.csdn.net/xyz_lmn/article/details/8907502\" target=\"_blank\" rel=\"noopener\">ios系统框架</a></li>\n<li><a href=\"http://www.cnblogs.com/royenhome/archive/2010/04/24/1719293.html\" target=\"_blank\" rel=\"noopener\">android系统框架</a></li>\n<li><p>Dalvik虚拟机</p>\n<ul>\n<li>Dalvik虚拟机是Android程序的虚拟机，是Android中Java程序的运行基础。其指令集基于寄存器架构，执行其特有的文件格式——dex字节码来完成对象生命周期管理、堆栈管理、线程管理、安全异常管理、垃圾回收等重要功能。它的核心内容是实现库（libdvm.so），大体由C语言实现。依赖于Linux内核的一部分功能——线程机制、内存管理机制，能高效使用内存，并在低速CPU上表现出的高性能。每一个Android应用在底层都会对应一个独立的Dalvik虚拟机实例，其代码在虚拟机的解释下得以执行。</li>\n</ul>\n</li>\n<li><p>Android系统是以Linux系统为底层构建的，Android系统是开源(源代码公开)的，Android系统势必会适配到不同硬件配置的设备上，因此谷歌为了降低应用的开发难度在Linux底层之上构筑了一个名为“Dalvik”的虚拟机。</p>\n</li>\n<li>一个应用，一个虚拟机实例，一个进程！！！</li>\n<li><p><a href=\"http://blog.csdn.net/andyxm/article/details/6126907/\" target=\"_blank\" rel=\"noopener\">android虚拟机详细</a></p>\n</li>\n<li><p>其他：</p>\n<ul>\n<li>ART模式:Android4.4中新加入的ART模式，该模式的完整名称是Androidruntime.</li>\n<li>ART：Android 4.4开始推出的新的运行环境，在APP安装的时候使用dex2oat工具直接把DEX文件转换为机器码文件，运行的时候以机器码方式运行，可以充分利用系统性能；此外，改进的内存回收机制使得ART运行模式下的内存回收速度只有Dalvik运行时模式下的50%，也能够提升系统运行速度。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"Android的Message-Pool是个什么鬼-源码角度分析-李仙鹏\"><a href=\"#Android的Message-Pool是个什么鬼-源码角度分析-李仙鹏\" class=\"headerlink\" title=\"Android的Message Pool是个什么鬼(源码角度分析) - 李仙鹏\"></a>Android的Message Pool是个什么鬼(源码角度分析) - 李仙鹏</h3><p>Android中，我们在线程之间通信传递通常采用Android的消息机制，而这机制传递的正是Message。</p>\n<p>通常，我们使用<a href=\"http://developer.android.com/reference/android/os/Message.html#obtain(\" target=\"_blank\" rel=\"noopener\">Message.obtain()</a>)和<a href=\"http://developer.android.com/reference/android/os/Handler.html#obtainMessage(\" target=\"_blank\" rel=\"noopener\">Handler.obtainMessage()</a>)从Message Pool中获取Message，避免直接构造Message。</p>\n<h4 id=\"Message-obtain-源码\"><a href=\"#Message-obtain-源码\" class=\"headerlink\" title=\"Message.obtain()源码\"></a>Message.obtain()源码</h4><pre><code>    /**\n     * Return a new Message instance from the global pool. Allows us to\n     * avoid allocating new objects in many cases.\n     */\n    public static Message obtain() {\n        synchronized (sPoolSync) {\n            if (sPool != null) {\n                Message m = sPool;\n                sPool = m.next;\n                m.next = null;\n                m.flags = 0; // clear in-use flag\n                sPoolSize--;\n                return m;\n            }\n        }\n        return new Message();\n    }\n</code></pre><p>从代码片中，可以看到Message是直接由sPool赋值的。</p>\n<h4 id=\"Handler-obtain-源码\"><a href=\"#Handler-obtain-源码\" class=\"headerlink\" title=\"Handler.obtain()源码\"></a>Handler.obtain()源码</h4><pre><code>    /**\n     * Returns a new {@link android.os.Message Message} from the global message pool. More efficient than\n     * creating and allocating new instances. The retrieved message has its handler set to this instance (Message.target == this).\n     *  If you don&#39;t want that facility, just call Message.obtain() instead.\n     */\n    public final Message obtainMessage()\n    {\n        return Message.obtain(this);\n    }\n</code></pre><p>Handler.obtain()最终还是调用Message.obtain()来获取的。</p>\n<h4 id=\"Message-Pool相关源码分析\"><a href=\"#Message-Pool相关源码分析\" class=\"headerlink\" title=\"Message Pool相关源码分析\"></a>Message Pool相关源码分析</h4><h5 id=\"Message-Pool数据结构\"><a href=\"#Message-Pool数据结构\" class=\"headerlink\" title=\"Message Pool数据结构\"></a>Message Pool数据结构</h5><pre><code>    // sometimes we store linked lists of these things\n    /*package*/ Message next;\n\n    private static final Object sPoolSync = new Object();\n    private static Message sPool;\n    private static int sPoolSize = 0;\n\n    private static final int MAX_POOL_SIZE = 50;\n\n    private static boolean gCheckRecycle = true;\n</code></pre><p>从代码中可以很明确的看到，Message Pool的数据结构实际就是一个链表。sPool就是一个全局的消息池，sPoolSize记录链表长度，MAX_POOL_SIZE表示链表的最大长度为50。</p>\n<h5 id=\"Message-Pool如何存放Message\"><a href=\"#Message-Pool如何存放Message\" class=\"headerlink\" title=\"Message Pool如何存放Message\"></a>Message Pool如何存放Message</h5><pre><code>    /** @hide */\n    public static void updateCheckRecycle(int targetSdkVersion) {\n        if (targetSdkVersion &lt; Build.VERSION_CODES.LOLLIPOP) {\n            gCheckRecycle = false;\n        }\n    }\n\n    /**\n     * Return a Message instance to the global pool.\n     * &lt;p&gt;\n     * You MUST NOT touch the Message after calling this function because it has\n     * effectively been freed.  It is an error to recycle a message that is currently\n     * enqueued or that is in the process of being delivered to a Handler.\n     * &lt;/p&gt;\n     */\n    public void recycle() {\n        if (isInUse()) {\n            if (gCheckRecycle) {\n                throw new IllegalStateException(&quot;This message cannot be recycled because it &quot;\n                        + &quot;is still in use.&quot;);\n            }\n            return;\n        }\n        recycleUnchecked();\n    }\n\n    /**\n     * Recycles a Message that may be in-use.\n     * Used internally by the MessageQueue and Looper when disposing of queued Messages.\n     */\n    void recycleUnchecked() {\n        // Mark the message as in use while it remains in the recycled object pool.\n        // Clear out all other details.\n        flags = FLAG_IN_USE;\n        what = 0;\n        arg1 = 0;\n        arg2 = 0;\n        obj = null;\n        replyTo = null;\n        sendingUid = -1;\n        when = 0;\n        target = null;\n        callback = null;\n        data = null;\n\n        synchronized (sPoolSync) {\n            if (sPoolSize &lt; MAX_POOL_SIZE) {\n                next = sPool;\n                sPool = this;\n                sPoolSize++;\n            }\n        }\n    }\n</code></pre><p>从代码分析上看，消息池存放的核心方法就是上面的recycleUnchecked()方法：</p>\n<blockquote>\n<p>1、将待回收的Message对象字段置空（避免因Message过大，使静态的消息池内存泄漏）。</p>\n<p>2、以内置锁对方式（线程安全），判断当前线程池的大小是否小于50。若小于50，直接将mesaage插入到消息池链表尾部；若大于等于50，则直接丢弃掉，交由GC管理。</p>\n</blockquote>\n<hr>\n<h3 id=\"消费者心理学：三个趣味经济学原理-–-张超耀\"><a href=\"#消费者心理学：三个趣味经济学原理-–-张超耀\" class=\"headerlink\" title=\"消费者心理学：三个趣味经济学原理 – 张超耀\"></a><a href=\"http://i.wshang.com/Post/Default/Index/pid/32949.html\" target=\"_blank\" rel=\"noopener\">消费者心理学：三个趣味经济学原理</a> – 张超耀</h3><ul>\n<li>价格越低为什么不但不好卖，反而价格越高越好卖</li>\n<li>为什么大手大脚的浪费反而可以拯救经济？</li>\n<li>为什么免费未必就是最好的</li>\n</ul>\n<p>这些经济学原理背后又有哪些逻辑在支撑，让我去探讨一下这些好玩的经济学吧。</p>\n<h4 id=\"价格越高越好卖——虚荣效应\"><a href=\"#价格越高越好卖——虚荣效应\" class=\"headerlink\" title=\"价格越高越好卖——虚荣效应\"></a>价格越高越好卖——虚荣效应</h4><ul>\n<li><p>富人们一般不喜欢大众模仿他们的消费行为，这种情况就叫做虚荣效应(snob effect)。虚荣效应具体是指购买商品的时候追求与众不同的个性的现象。</p>\n</li>\n<li><p>虚荣效应主要有以下两种表现。</p>\n<ul>\n<li><p>高档商品刚上市的时候迅速购买。这是因为，在这一瞬间并不是每个人都能享受到消费高档商品的荣誉。</p>\n</li>\n<li><p>不论之前如何热情赞美的商品，一旦其市场占有率达到一般大众都可以消费的水平就不再继续购买。这是因为人人都能购买使用的商品既不会让人感到荣誉，也不会有高档的感觉。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"大手大脚的浪费能拯救经济——节约悖论\"><a href=\"#大手大脚的浪费能拯救经济——节约悖论\" class=\"headerlink\" title=\"大手大脚的浪费能拯救经济——节约悖论\"></a>大手大脚的浪费能拯救经济——节约悖论</h4><ul>\n<li><p>我们都知道，如果消费超过收入，就没有余钱可以储蓄，也就无法积累资金，最终只能过贫穷的生活。所以，为了成为富人我们会努力工作，有时候也会变成小气鬼，为了能储蓄更多钱而努力。</p>\n</li>\n<li><p>这个原理对于个人是适用的，但是对于国家整体经济是否也适用呢？如果所有国民都变成小气鬼，这个国家真的能够变得更加富强吗？答案是否定的，尤其是在经济不景气的时候。让我们看看其原因何在。</p>\n</li>\n<li><p>一旦经济进入不景气，基于对未来的担忧，人们会选择更多的储蓄进而减少消费。可是如果所有人都减少消费的话，企业的销售额就会降低，库存就会增加。随之而来的是企业只能降低生产减少雇用，而企业员工的收入就会减少。那么，对未来的担忧就会强化，人们会更加坚定地减少消费增加储蓄，于是整体经济就会陷入愈发不景气的恶性循环中。</p>\n</li>\n</ul>\n<h4 id=\"免费未必就好——免费经济学\"><a href=\"#免费未必就好——免费经济学\" class=\"headerlink\" title=\"免费未必就好——免费经济学\"></a>免费未必就好——免费经济学</h4><ul>\n<li><p>“世上没有免费的午餐”是1976年获得诺贝尔经济学奖的着名经济学家米尔顿弗里德曼(Milton Friedman)常说的一句话。</p>\n</li>\n<li><p>有的信息粗看之下似乎是免费的，实际上经过了解后发现并不是免费的意思；或者可以解释为免费后面隐藏着某种诱饵，还可以理解为不要期待不付出代价的免费东西。就像“免费的奶酪只存在于捕鼠器上”的俄罗斯谚语一样，对免费的东西保持警惕是亘古不变的道理。</p>\n</li>\n<li><p>看看我们周围，就能发现很多免费营销，地铁站前的免费报纸就是其中一种。曾经威胁到日报和体育报纸的免费报纸因为有很多读者，所以可以从广告收入上获得高收益。人气差的免费报纸会因为得不到足够的广告收入而被淘汰，这样的话，幸存下来的免费报纸就可以逐步占据更加有利的位置。越是资金实力雄厚的公司，在这种免费竞争中能够生存下来的概率就越大。因此，消费者也可能会面临因为垄断招致的损失。</p>\n</li>\n<li><p>免费经济市场的另一个弊端就是对资源的浪费。以免费报纸为例，因为免费派发给消费者，所以新闻纸会被大量浪费掉。大量生产大量消费的体制会导致能源的过度使用而招致地球变暖势头的加速。”</p>\n</li>\n</ul>\n<hr>\n<h3 id=\"Icon制作-杨志平\"><a href=\"#Icon制作-杨志平\" class=\"headerlink\" title=\"Icon制作 - 杨志平\"></a>Icon制作 - 杨志平</h3><p><img width=\"487\" alt=\"qq20150707-6 2x\" src=\"https://cloud.githubusercontent.com/assets/9360037/8542711/2952b918-24ca-11e5-8dda-f42e42f57e72.png\"><br><img width=\"568\" alt=\"qq20150707-11 2x\" src=\"https://cloud.githubusercontent.com/assets/9360037/8542720/2987624e-24ca-11e5-8380-658f9fc08f24.png\"></p>\n<p>####51offer的Icon的流程<br><img width=\"491\" alt=\"qq20150707-1 2x\" src=\"https://cloud.githubusercontent.com/assets/9360037/8542715/29552c5c-24ca-11e5-9849-bd352ede57f4.png\"><br><img width=\"497\" alt=\"qq20150707-2 2x\" src=\"https://cloud.githubusercontent.com/assets/9360037/8542712/2952ba3a-24ca-11e5-85b7-0149e855e0cd.png\"><br><img width=\"493\" alt=\"qq20150707-3 2x\" src=\"https://cloud.githubusercontent.com/assets/9360037/8542713/2952e118-24ca-11e5-9128-f30ac093e8f4.png\"><br><img width=\"493\" alt=\"qq20150707-4 2x\" src=\"https://cloud.githubusercontent.com/assets/9360037/8542716/29557bf8-24ca-11e5-8869-afc7972ac5bf.png\"><br><img width=\"492\" alt=\"qq20150707-5 2x\" src=\"https://cloud.githubusercontent.com/assets/9360037/8542714/2952e884-24ca-11e5-8ade-4f3a69c19df4.png\"></p>\n<h4 id=\"另一个Icon的制作的流程\"><a href=\"#另一个Icon的制作的流程\" class=\"headerlink\" title=\"另一个Icon的制作的流程\"></a>另一个Icon的制作的流程</h4><p><img width=\"589\" alt=\"qq20150707-7 2x\" src=\"https://cloud.githubusercontent.com/assets/9360037/8542721/29879a5c-24ca-11e5-85a0-535bf058fa62.png\"><br><img width=\"573\" alt=\"qq20150707-8 2x\" src=\"https://cloud.githubusercontent.com/assets/9360037/8542718/29855f58-24ca-11e5-83b2-e5d4e679f543.png\"><br><img width=\"586\" alt=\"qq20150707-9 2x\" src=\"https://cloud.githubusercontent.com/assets/9360037/8542717/29851a3e-24ca-11e5-8eab-3d5703d032ea.png\"><br><img width=\"578\" alt=\"qq20150707-10 2x\" src=\"https://cloud.githubusercontent.com/assets/9360037/8542719/2986620e-24ca-11e5-9686-6fad2780ab63.png\"></p>\n<h3 id=\"Android-动画制作-王胜\"><a href=\"#Android-动画制作-王胜\" class=\"headerlink\" title=\"Android 动画制作 - 王胜\"></a>Android 动画制作 - 王胜</h3><h4 id=\"View-Animation\"><a href=\"#View-Animation\" class=\"headerlink\" title=\"View Animation\"></a>View Animation</h4><ul>\n<li>AlphaAnimation 淡入淡出效果</li>\n<li>TranslateAnimation 移动效果</li>\n<li>ScaleAnimation 缩放效果</li>\n<li>RotateAnimation 旋转效果</li>\n</ul>\n<p>原理：提供动画的起始和结束状态信息，中间的状态根据上述类里差值器算法填充<br><a href=\"http://www.cnblogs.com/angeldevil/archive/2011/12/02/2271096.html\" target=\"_blank\" rel=\"noopener\">[示例参考]</a></p>\n<h4 id=\"Property-Animation\"><a href=\"#Property-Animation\" class=\"headerlink\" title=\"Property Animation\"></a>Property Animation</h4><p>View Animation动画比较简单，一般都是单个因素的变化，如果牵扯到复杂的动画，就显得力不从心。因此，Android 3.0 引入了属性动画。注：可通过<a href=\"http://nineoldandroids.com/\" target=\"_blank\" rel=\"noopener\">[NineOldAndroids]</a>项目在3.0之前的系统中使用Property Animation</p>\n<p>原理：暴露出差值算法的回调方法，有工程师自己发挥想象，造出奇妙的动画效果。<br><a href=\"http://www.cnblogs.com/angeldevil/archive/2011/12/02/2271096.html\" target=\"_blank\" rel=\"noopener\">[示例参考]</a></p>\n<h4 id=\"Drawable-Animation\"><a href=\"#Drawable-Animation\" class=\"headerlink\" title=\"Drawable Animation\"></a>Drawable Animation</h4><h5 id=\"逐帧动画\"><a href=\"#逐帧动画\" class=\"headerlink\" title=\"逐帧动画\"></a>逐帧动画</h5><p>原理：提供动画每个帧上的图片资源，顺序播放<br><a href=\"http://www.cnblogs.com/angeldevil/archive/2011/12/02/2271096.html\" target=\"_blank\" rel=\"noopener\">[示例参考]</a></p>\n<h5 id=\"ClipDrawable-剪切动画\"><a href=\"#ClipDrawable-剪切动画\" class=\"headerlink\" title=\"ClipDrawable 剪切动画\"></a>ClipDrawable 剪切动画</h5><p>原理：提供一个背景图片，前景图片是一个ClipDrawable对象。通过线程操作ClipDrawable的剪切进度。</p>\n<p>实例：</p>\n<ul>\n<li>ClipDrawable 定义xml文件</li>\n</ul>\n<pre><code class=\"XML\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;clip xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n    android:clipOrientation=&quot;vertical&quot;\n    android:drawable=&quot;@drawable/loading_progress&quot;\n    android:gravity=&quot;bottom&quot;&gt;\n&lt;/clip&gt;\n</code></pre>\n<ul>\n<li>组件引用</li>\n</ul>\n<pre><code class=\"XML\">&lt;ImageView\n        android:id=&quot;@+id/iv&quot;\n        android:layout_width=&quot;wrap_content&quot;\n        android:layout_height=&quot;wrap_content&quot;\n        android:scaleType=&quot;centerInside&quot;\n        android:paddingTop=&quot;5dp&quot;\n        android:paddingLeft=&quot;5dp&quot;\n        android:background=&quot;@drawable/loading_bg&quot;\n        android:src=&quot;@drawable/clip_loading&quot;/&gt;\n</code></pre>\n<ul>\n<li>线程动态改变剪切进度</li>\n</ul>\n<pre><code class=\"Java\">private Handler handler = new Handler() {\n    @Override\n    public void handleMessage(Message msg) {\n        // 如果消息是本程序发送的\n        if (msg.what == MSG_WHAT) {\n            mClipDrawable.setLevel(mProgress);\n        }\n    }\n};\n.......\nRunnable mRunnable = new Runnable() {\n    @Override\n    public void run() {\n        isRunning = true;\n        while (isRunning) {\n            handler.sendEmptyMessage(MSG_WHAT);\n            if (mProgress &gt; MAX_PROGRESS) {\n                mProgress = 0;\n            }\n            mProgress += 100;\n            try {\n                Thread.sleep(18);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n};\n</code></pre>\n"},{"title":"研发路上的那些事儿","date":"2015-07-16T16:56:00.000Z","_content":"\n## 心酸研发路 - 杨志平\n\n- 大版本发布周期过长（原因：团队专业有限，探索前进，频繁修改），导致没有什么机会思考、设计，人也拖的身心疲惫\n- 引入架构思想，软件质量提高。后期频繁加入改动，冲淡架构\n- 老板干涉过多 导致：压力过大 质量无法保证\n- 老板高度重视UI\n\n## 研发路上的那些事儿 - 张超耀\n\n- 没有专业的移动端团队人员\n- 产品研发没有系统流程，走一步算一步\n- 需求人人可以改\n- 忙的时候忙的要死，闲的时候闲的蛋疼\n\n## 研发之路上的坑 - 潘君\n\n### 盲目相信自己,不合理的压缩周期\n\t\n在开发周期过程中,过分相信努力的作用,以为团队只要努努力,可以爆发一个超越平时的战斗力.\n\n在预估周期的过程中,过分考虑老板的感受,不合理的压缩周期,不断的向需求妥协,导致后期死的非常难看.\n\n一方面自己的预估承诺没有兑现.另一方面团队本身也精疲力尽.\n\t\n### 好事多磨,鸡血不能多打\n\t\n一个好的项目不是短期可以做出来的,是必须慢慢打磨,而过分相信一个突击开发周期能够做出一个好产品是过于乐观的.\n\n好事多磨,好的东西需要一个相对合理的周期.这个周期可能比较长,所以在较长的一段时间内要做的是保证团队的舒适度,而不是一味的打鸡血鼓励.\n\n鸡血是一种需要正向循环的方式.如果没有一个好的反馈,鸡血的功效性就会越来越弱,最后反而会有逆效果.\n\n## 高层强插改需求 - 吴明\n\n- 背景\n\t- 原公司移动开发中，在一项目层层过滤确定产品后，开发人员并已经开发了一段时间后，公司老板或者其他高层介入修改需求，延长开发时间。\n- 缺点：\n  1. 开发时间浪费，花费时间做无用功\n  2. 高层施压不利于下层产品开发，及产品迭代\n  3. 项目延期打击开发团队人员士气和积极性\n  4. 项目接近上线更改需求，严重影响开发人员心情，及代码编写质量\n- 后期流程改进\n  1. 从项目入口抓起：所有指定项目必须经该项目需求方，产品，开发等直接最高领导确定，并且不更改需求下，开发人员才开发项目。\n  2. 项目分阶段给高层领导汇报，把控项目质量。\n  3. 高层需要项目后期改需求，只能下个版本迭代，本项目不予以改需求。\n\n## 参与创业的辛酸史 - 郁兵生\n\n- 初创团队，没日没夜加班搞项目\n- 初创团队，不了解情况，项目周期把握不清。赶时间攒代码。\n\n## 大众【设计占整个研发的重头】- 顾鹏凌\n\n- 完善的管理体\n- 细控的研发流程\n- 设计阶段作为重头，精雕细琢，避免后期遇到问题需要大改动\n\n## 杂乱的管理  - 吴强\n\n- 初创团队，相关人员不完备\n- 产品经理只做了原型的工作，没有把控住需求的变更\n- 一人多职，多项目参与\n- 空降产品经理，做事一意孤行，跟团队不和\n\n## 51offer的原始状态 - 庄丰洲\n\n- 没有移动端团队人员和移动端研发规范流程\n- 是个人都可以提需求\n\n## 工作感悟－李仙鹏\n\n- 团队结构：\n> 崇尚扁平化的互联网公司，员工之间没有非常明县的上下级关系。\n\n- 需求把控：\n> 需求不明确、中途变更、压榨开发都TMD是耍流氓\n> \n> 1. 一个好的项目需求，应该在kick off前全面规划产品，产品和设计明确需求并且画押签字，中途不得变更。当临时提出需求变更时，技术应该敢于把画押字据拿出来并且提出拒绝——把变更需求留在下一版本迭代。\n> \n> 2. 不应该为了迎合进度而倒推时间压榨开发，这样做出来的东西很可能会是漏洞百出的\n\n## [Better](http://www.iambetter.cn/) 的一路走来 - 王胜\n\n### 第一个版本历时4个月的天天加班\n\n- 评估开发时间时，仅有原型；设计稿一出，开发人员瞬间觉得工作量要直线上升。\n- 按照一个有经验的工程师估出时间，然后上面说再调一个人，时间周期按照除以2来算。掉入《人月计划》中所说的坑。\n- 新组建的团队，缺少默契，需要磨合。【包括客户端之间，客户端与API之间，客户端与UI之间】\n- 临近上线，上面对体验要求无止境，导致细节调整没完没了\n\n### 一起努力，挺过4个月\n\n- 打过鸡血\n- 慢慢地团队之间有了默契\n- 制定上线体验阀值，不能无止境提出体验调整的需求\n\n### 后续版本的研发\n\n- 严格按照Scrum流程迭代开发版本，目前2周一迭代\n- Sprint确定需求后，不能强制加入新的需求\n- 特例的需求要插入Sprint，那么就顺延Sprint的周期\n\n## 工作经历的一些片段 - 曾铭\n\n### 文化\n\n- （敏感信息）略\n\n### 好的\n\n- 工程师主导的开发流程：产品做调研，提目标，开发参与设计 feature 包揽实现、测试、验证\n- 牛人不少：一流的人招一流的人，二流的人招三流的人\n- 优秀工具的使用 （工具绝非一蹴而就， svn -> git，）\n- 对代码的极致追求 （代码行数、朝歌->镐京、Hackathon：一夜实现客户端聊天）\n- 相对优秀的办公环境 （畅通的网络等）\n\n# 不好的\n\n- 目标不明确 (对商家态度的摇摆)\n- 不接地气（商业化不成功）\n- 理想主义者的碰撞, 无妥协\n- 急躁（寻求改变的高期望）\n- 压力大\n\n### 以上不针对具体公司\n","source":"_posts/研发路上的那些事儿.md","raw":"title: 研发路上的那些事儿\ndate: 2015-07-16 16:56:00\ntags:\n- 研发杂谈\n\ncategories: 移动组周分享\n\n---\n\n## 心酸研发路 - 杨志平\n\n- 大版本发布周期过长（原因：团队专业有限，探索前进，频繁修改），导致没有什么机会思考、设计，人也拖的身心疲惫\n- 引入架构思想，软件质量提高。后期频繁加入改动，冲淡架构\n- 老板干涉过多 导致：压力过大 质量无法保证\n- 老板高度重视UI\n\n## 研发路上的那些事儿 - 张超耀\n\n- 没有专业的移动端团队人员\n- 产品研发没有系统流程，走一步算一步\n- 需求人人可以改\n- 忙的时候忙的要死，闲的时候闲的蛋疼\n\n## 研发之路上的坑 - 潘君\n\n### 盲目相信自己,不合理的压缩周期\n\t\n在开发周期过程中,过分相信努力的作用,以为团队只要努努力,可以爆发一个超越平时的战斗力.\n\n在预估周期的过程中,过分考虑老板的感受,不合理的压缩周期,不断的向需求妥协,导致后期死的非常难看.\n\n一方面自己的预估承诺没有兑现.另一方面团队本身也精疲力尽.\n\t\n### 好事多磨,鸡血不能多打\n\t\n一个好的项目不是短期可以做出来的,是必须慢慢打磨,而过分相信一个突击开发周期能够做出一个好产品是过于乐观的.\n\n好事多磨,好的东西需要一个相对合理的周期.这个周期可能比较长,所以在较长的一段时间内要做的是保证团队的舒适度,而不是一味的打鸡血鼓励.\n\n鸡血是一种需要正向循环的方式.如果没有一个好的反馈,鸡血的功效性就会越来越弱,最后反而会有逆效果.\n\n## 高层强插改需求 - 吴明\n\n- 背景\n\t- 原公司移动开发中，在一项目层层过滤确定产品后，开发人员并已经开发了一段时间后，公司老板或者其他高层介入修改需求，延长开发时间。\n- 缺点：\n  1. 开发时间浪费，花费时间做无用功\n  2. 高层施压不利于下层产品开发，及产品迭代\n  3. 项目延期打击开发团队人员士气和积极性\n  4. 项目接近上线更改需求，严重影响开发人员心情，及代码编写质量\n- 后期流程改进\n  1. 从项目入口抓起：所有指定项目必须经该项目需求方，产品，开发等直接最高领导确定，并且不更改需求下，开发人员才开发项目。\n  2. 项目分阶段给高层领导汇报，把控项目质量。\n  3. 高层需要项目后期改需求，只能下个版本迭代，本项目不予以改需求。\n\n## 参与创业的辛酸史 - 郁兵生\n\n- 初创团队，没日没夜加班搞项目\n- 初创团队，不了解情况，项目周期把握不清。赶时间攒代码。\n\n## 大众【设计占整个研发的重头】- 顾鹏凌\n\n- 完善的管理体\n- 细控的研发流程\n- 设计阶段作为重头，精雕细琢，避免后期遇到问题需要大改动\n\n## 杂乱的管理  - 吴强\n\n- 初创团队，相关人员不完备\n- 产品经理只做了原型的工作，没有把控住需求的变更\n- 一人多职，多项目参与\n- 空降产品经理，做事一意孤行，跟团队不和\n\n## 51offer的原始状态 - 庄丰洲\n\n- 没有移动端团队人员和移动端研发规范流程\n- 是个人都可以提需求\n\n## 工作感悟－李仙鹏\n\n- 团队结构：\n> 崇尚扁平化的互联网公司，员工之间没有非常明县的上下级关系。\n\n- 需求把控：\n> 需求不明确、中途变更、压榨开发都TMD是耍流氓\n> \n> 1. 一个好的项目需求，应该在kick off前全面规划产品，产品和设计明确需求并且画押签字，中途不得变更。当临时提出需求变更时，技术应该敢于把画押字据拿出来并且提出拒绝——把变更需求留在下一版本迭代。\n> \n> 2. 不应该为了迎合进度而倒推时间压榨开发，这样做出来的东西很可能会是漏洞百出的\n\n## [Better](http://www.iambetter.cn/) 的一路走来 - 王胜\n\n### 第一个版本历时4个月的天天加班\n\n- 评估开发时间时，仅有原型；设计稿一出，开发人员瞬间觉得工作量要直线上升。\n- 按照一个有经验的工程师估出时间，然后上面说再调一个人，时间周期按照除以2来算。掉入《人月计划》中所说的坑。\n- 新组建的团队，缺少默契，需要磨合。【包括客户端之间，客户端与API之间，客户端与UI之间】\n- 临近上线，上面对体验要求无止境，导致细节调整没完没了\n\n### 一起努力，挺过4个月\n\n- 打过鸡血\n- 慢慢地团队之间有了默契\n- 制定上线体验阀值，不能无止境提出体验调整的需求\n\n### 后续版本的研发\n\n- 严格按照Scrum流程迭代开发版本，目前2周一迭代\n- Sprint确定需求后，不能强制加入新的需求\n- 特例的需求要插入Sprint，那么就顺延Sprint的周期\n\n## 工作经历的一些片段 - 曾铭\n\n### 文化\n\n- （敏感信息）略\n\n### 好的\n\n- 工程师主导的开发流程：产品做调研，提目标，开发参与设计 feature 包揽实现、测试、验证\n- 牛人不少：一流的人招一流的人，二流的人招三流的人\n- 优秀工具的使用 （工具绝非一蹴而就， svn -> git，）\n- 对代码的极致追求 （代码行数、朝歌->镐京、Hackathon：一夜实现客户端聊天）\n- 相对优秀的办公环境 （畅通的网络等）\n\n# 不好的\n\n- 目标不明确 (对商家态度的摇摆)\n- 不接地气（商业化不成功）\n- 理想主义者的碰撞, 无妥协\n- 急躁（寻求改变的高期望）\n- 压力大\n\n### 以上不针对具体公司\n","slug":"研发路上的那些事儿","published":1,"updated":"2021-09-10T07:04:21.948Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cktfeap4f002kc2xxstyy197h","content":"<h2 id=\"心酸研发路-杨志平\"><a href=\"#心酸研发路-杨志平\" class=\"headerlink\" title=\"心酸研发路 - 杨志平\"></a>心酸研发路 - 杨志平</h2><ul>\n<li>大版本发布周期过长（原因：团队专业有限，探索前进，频繁修改），导致没有什么机会思考、设计，人也拖的身心疲惫</li>\n<li>引入架构思想，软件质量提高。后期频繁加入改动，冲淡架构</li>\n<li>老板干涉过多 导致：压力过大 质量无法保证</li>\n<li>老板高度重视UI</li>\n</ul>\n<h2 id=\"研发路上的那些事儿-张超耀\"><a href=\"#研发路上的那些事儿-张超耀\" class=\"headerlink\" title=\"研发路上的那些事儿 - 张超耀\"></a>研发路上的那些事儿 - 张超耀</h2><ul>\n<li>没有专业的移动端团队人员</li>\n<li>产品研发没有系统流程，走一步算一步</li>\n<li>需求人人可以改</li>\n<li>忙的时候忙的要死，闲的时候闲的蛋疼</li>\n</ul>\n<h2 id=\"研发之路上的坑-潘君\"><a href=\"#研发之路上的坑-潘君\" class=\"headerlink\" title=\"研发之路上的坑 - 潘君\"></a>研发之路上的坑 - 潘君</h2><h3 id=\"盲目相信自己-不合理的压缩周期\"><a href=\"#盲目相信自己-不合理的压缩周期\" class=\"headerlink\" title=\"盲目相信自己,不合理的压缩周期\"></a>盲目相信自己,不合理的压缩周期</h3><p>在开发周期过程中,过分相信努力的作用,以为团队只要努努力,可以爆发一个超越平时的战斗力.</p>\n<p>在预估周期的过程中,过分考虑老板的感受,不合理的压缩周期,不断的向需求妥协,导致后期死的非常难看.</p>\n<p>一方面自己的预估承诺没有兑现.另一方面团队本身也精疲力尽.</p>\n<h3 id=\"好事多磨-鸡血不能多打\"><a href=\"#好事多磨-鸡血不能多打\" class=\"headerlink\" title=\"好事多磨,鸡血不能多打\"></a>好事多磨,鸡血不能多打</h3><p>一个好的项目不是短期可以做出来的,是必须慢慢打磨,而过分相信一个突击开发周期能够做出一个好产品是过于乐观的.</p>\n<p>好事多磨,好的东西需要一个相对合理的周期.这个周期可能比较长,所以在较长的一段时间内要做的是保证团队的舒适度,而不是一味的打鸡血鼓励.</p>\n<p>鸡血是一种需要正向循环的方式.如果没有一个好的反馈,鸡血的功效性就会越来越弱,最后反而会有逆效果.</p>\n<h2 id=\"高层强插改需求-吴明\"><a href=\"#高层强插改需求-吴明\" class=\"headerlink\" title=\"高层强插改需求 - 吴明\"></a>高层强插改需求 - 吴明</h2><ul>\n<li>背景<ul>\n<li>原公司移动开发中，在一项目层层过滤确定产品后，开发人员并已经开发了一段时间后，公司老板或者其他高层介入修改需求，延长开发时间。</li>\n</ul>\n</li>\n<li>缺点：<ol>\n<li>开发时间浪费，花费时间做无用功</li>\n<li>高层施压不利于下层产品开发，及产品迭代</li>\n<li>项目延期打击开发团队人员士气和积极性</li>\n<li>项目接近上线更改需求，严重影响开发人员心情，及代码编写质量</li>\n</ol>\n</li>\n<li>后期流程改进<ol>\n<li>从项目入口抓起：所有指定项目必须经该项目需求方，产品，开发等直接最高领导确定，并且不更改需求下，开发人员才开发项目。</li>\n<li>项目分阶段给高层领导汇报，把控项目质量。</li>\n<li>高层需要项目后期改需求，只能下个版本迭代，本项目不予以改需求。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"参与创业的辛酸史-郁兵生\"><a href=\"#参与创业的辛酸史-郁兵生\" class=\"headerlink\" title=\"参与创业的辛酸史 - 郁兵生\"></a>参与创业的辛酸史 - 郁兵生</h2><ul>\n<li>初创团队，没日没夜加班搞项目</li>\n<li>初创团队，不了解情况，项目周期把握不清。赶时间攒代码。</li>\n</ul>\n<h2 id=\"大众【设计占整个研发的重头】-顾鹏凌\"><a href=\"#大众【设计占整个研发的重头】-顾鹏凌\" class=\"headerlink\" title=\"大众【设计占整个研发的重头】- 顾鹏凌\"></a>大众【设计占整个研发的重头】- 顾鹏凌</h2><ul>\n<li>完善的管理体</li>\n<li>细控的研发流程</li>\n<li>设计阶段作为重头，精雕细琢，避免后期遇到问题需要大改动</li>\n</ul>\n<h2 id=\"杂乱的管理-吴强\"><a href=\"#杂乱的管理-吴强\" class=\"headerlink\" title=\"杂乱的管理  - 吴强\"></a>杂乱的管理  - 吴强</h2><ul>\n<li>初创团队，相关人员不完备</li>\n<li>产品经理只做了原型的工作，没有把控住需求的变更</li>\n<li>一人多职，多项目参与</li>\n<li>空降产品经理，做事一意孤行，跟团队不和</li>\n</ul>\n<h2 id=\"51offer的原始状态-庄丰洲\"><a href=\"#51offer的原始状态-庄丰洲\" class=\"headerlink\" title=\"51offer的原始状态 - 庄丰洲\"></a>51offer的原始状态 - 庄丰洲</h2><ul>\n<li>没有移动端团队人员和移动端研发规范流程</li>\n<li>是个人都可以提需求</li>\n</ul>\n<h2 id=\"工作感悟－李仙鹏\"><a href=\"#工作感悟－李仙鹏\" class=\"headerlink\" title=\"工作感悟－李仙鹏\"></a>工作感悟－李仙鹏</h2><ul>\n<li><p>团队结构：</p>\n<blockquote>\n<p>崇尚扁平化的互联网公司，员工之间没有非常明县的上下级关系。</p>\n</blockquote>\n</li>\n<li><p>需求把控：</p>\n<blockquote>\n<p>需求不明确、中途变更、压榨开发都TMD是耍流氓</p>\n<ol>\n<li><p>一个好的项目需求，应该在kick off前全面规划产品，产品和设计明确需求并且画押签字，中途不得变更。当临时提出需求变更时，技术应该敢于把画押字据拿出来并且提出拒绝——把变更需求留在下一版本迭代。</p>\n</li>\n<li><p>不应该为了迎合进度而倒推时间压榨开发，这样做出来的东西很可能会是漏洞百出的</p>\n</li>\n</ol>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"Better-的一路走来-王胜\"><a href=\"#Better-的一路走来-王胜\" class=\"headerlink\" title=\"Better 的一路走来 - 王胜\"></a><a href=\"http://www.iambetter.cn/\" target=\"_blank\" rel=\"noopener\">Better</a> 的一路走来 - 王胜</h2><h3 id=\"第一个版本历时4个月的天天加班\"><a href=\"#第一个版本历时4个月的天天加班\" class=\"headerlink\" title=\"第一个版本历时4个月的天天加班\"></a>第一个版本历时4个月的天天加班</h3><ul>\n<li>评估开发时间时，仅有原型；设计稿一出，开发人员瞬间觉得工作量要直线上升。</li>\n<li>按照一个有经验的工程师估出时间，然后上面说再调一个人，时间周期按照除以2来算。掉入《人月计划》中所说的坑。</li>\n<li>新组建的团队，缺少默契，需要磨合。【包括客户端之间，客户端与API之间，客户端与UI之间】</li>\n<li>临近上线，上面对体验要求无止境，导致细节调整没完没了</li>\n</ul>\n<h3 id=\"一起努力，挺过4个月\"><a href=\"#一起努力，挺过4个月\" class=\"headerlink\" title=\"一起努力，挺过4个月\"></a>一起努力，挺过4个月</h3><ul>\n<li>打过鸡血</li>\n<li>慢慢地团队之间有了默契</li>\n<li>制定上线体验阀值，不能无止境提出体验调整的需求</li>\n</ul>\n<h3 id=\"后续版本的研发\"><a href=\"#后续版本的研发\" class=\"headerlink\" title=\"后续版本的研发\"></a>后续版本的研发</h3><ul>\n<li>严格按照Scrum流程迭代开发版本，目前2周一迭代</li>\n<li>Sprint确定需求后，不能强制加入新的需求</li>\n<li>特例的需求要插入Sprint，那么就顺延Sprint的周期</li>\n</ul>\n<h2 id=\"工作经历的一些片段-曾铭\"><a href=\"#工作经历的一些片段-曾铭\" class=\"headerlink\" title=\"工作经历的一些片段 - 曾铭\"></a>工作经历的一些片段 - 曾铭</h2><h3 id=\"文化\"><a href=\"#文化\" class=\"headerlink\" title=\"文化\"></a>文化</h3><ul>\n<li>（敏感信息）略</li>\n</ul>\n<h3 id=\"好的\"><a href=\"#好的\" class=\"headerlink\" title=\"好的\"></a>好的</h3><ul>\n<li>工程师主导的开发流程：产品做调研，提目标，开发参与设计 feature 包揽实现、测试、验证</li>\n<li>牛人不少：一流的人招一流的人，二流的人招三流的人</li>\n<li>优秀工具的使用 （工具绝非一蹴而就， svn -&gt; git，）</li>\n<li>对代码的极致追求 （代码行数、朝歌-&gt;镐京、Hackathon：一夜实现客户端聊天）</li>\n<li>相对优秀的办公环境 （畅通的网络等）</li>\n</ul>\n<h1 id=\"不好的\"><a href=\"#不好的\" class=\"headerlink\" title=\"不好的\"></a>不好的</h1><ul>\n<li>目标不明确 (对商家态度的摇摆)</li>\n<li>不接地气（商业化不成功）</li>\n<li>理想主义者的碰撞, 无妥协</li>\n<li>急躁（寻求改变的高期望）</li>\n<li>压力大</li>\n</ul>\n<h3 id=\"以上不针对具体公司\"><a href=\"#以上不针对具体公司\" class=\"headerlink\" title=\"以上不针对具体公司\"></a>以上不针对具体公司</h3>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"心酸研发路-杨志平\"><a href=\"#心酸研发路-杨志平\" class=\"headerlink\" title=\"心酸研发路 - 杨志平\"></a>心酸研发路 - 杨志平</h2><ul>\n<li>大版本发布周期过长（原因：团队专业有限，探索前进，频繁修改），导致没有什么机会思考、设计，人也拖的身心疲惫</li>\n<li>引入架构思想，软件质量提高。后期频繁加入改动，冲淡架构</li>\n<li>老板干涉过多 导致：压力过大 质量无法保证</li>\n<li>老板高度重视UI</li>\n</ul>\n<h2 id=\"研发路上的那些事儿-张超耀\"><a href=\"#研发路上的那些事儿-张超耀\" class=\"headerlink\" title=\"研发路上的那些事儿 - 张超耀\"></a>研发路上的那些事儿 - 张超耀</h2><ul>\n<li>没有专业的移动端团队人员</li>\n<li>产品研发没有系统流程，走一步算一步</li>\n<li>需求人人可以改</li>\n<li>忙的时候忙的要死，闲的时候闲的蛋疼</li>\n</ul>\n<h2 id=\"研发之路上的坑-潘君\"><a href=\"#研发之路上的坑-潘君\" class=\"headerlink\" title=\"研发之路上的坑 - 潘君\"></a>研发之路上的坑 - 潘君</h2><h3 id=\"盲目相信自己-不合理的压缩周期\"><a href=\"#盲目相信自己-不合理的压缩周期\" class=\"headerlink\" title=\"盲目相信自己,不合理的压缩周期\"></a>盲目相信自己,不合理的压缩周期</h3><p>在开发周期过程中,过分相信努力的作用,以为团队只要努努力,可以爆发一个超越平时的战斗力.</p>\n<p>在预估周期的过程中,过分考虑老板的感受,不合理的压缩周期,不断的向需求妥协,导致后期死的非常难看.</p>\n<p>一方面自己的预估承诺没有兑现.另一方面团队本身也精疲力尽.</p>\n<h3 id=\"好事多磨-鸡血不能多打\"><a href=\"#好事多磨-鸡血不能多打\" class=\"headerlink\" title=\"好事多磨,鸡血不能多打\"></a>好事多磨,鸡血不能多打</h3><p>一个好的项目不是短期可以做出来的,是必须慢慢打磨,而过分相信一个突击开发周期能够做出一个好产品是过于乐观的.</p>\n<p>好事多磨,好的东西需要一个相对合理的周期.这个周期可能比较长,所以在较长的一段时间内要做的是保证团队的舒适度,而不是一味的打鸡血鼓励.</p>\n<p>鸡血是一种需要正向循环的方式.如果没有一个好的反馈,鸡血的功效性就会越来越弱,最后反而会有逆效果.</p>\n<h2 id=\"高层强插改需求-吴明\"><a href=\"#高层强插改需求-吴明\" class=\"headerlink\" title=\"高层强插改需求 - 吴明\"></a>高层强插改需求 - 吴明</h2><ul>\n<li>背景<ul>\n<li>原公司移动开发中，在一项目层层过滤确定产品后，开发人员并已经开发了一段时间后，公司老板或者其他高层介入修改需求，延长开发时间。</li>\n</ul>\n</li>\n<li>缺点：<ol>\n<li>开发时间浪费，花费时间做无用功</li>\n<li>高层施压不利于下层产品开发，及产品迭代</li>\n<li>项目延期打击开发团队人员士气和积极性</li>\n<li>项目接近上线更改需求，严重影响开发人员心情，及代码编写质量</li>\n</ol>\n</li>\n<li>后期流程改进<ol>\n<li>从项目入口抓起：所有指定项目必须经该项目需求方，产品，开发等直接最高领导确定，并且不更改需求下，开发人员才开发项目。</li>\n<li>项目分阶段给高层领导汇报，把控项目质量。</li>\n<li>高层需要项目后期改需求，只能下个版本迭代，本项目不予以改需求。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"参与创业的辛酸史-郁兵生\"><a href=\"#参与创业的辛酸史-郁兵生\" class=\"headerlink\" title=\"参与创业的辛酸史 - 郁兵生\"></a>参与创业的辛酸史 - 郁兵生</h2><ul>\n<li>初创团队，没日没夜加班搞项目</li>\n<li>初创团队，不了解情况，项目周期把握不清。赶时间攒代码。</li>\n</ul>\n<h2 id=\"大众【设计占整个研发的重头】-顾鹏凌\"><a href=\"#大众【设计占整个研发的重头】-顾鹏凌\" class=\"headerlink\" title=\"大众【设计占整个研发的重头】- 顾鹏凌\"></a>大众【设计占整个研发的重头】- 顾鹏凌</h2><ul>\n<li>完善的管理体</li>\n<li>细控的研发流程</li>\n<li>设计阶段作为重头，精雕细琢，避免后期遇到问题需要大改动</li>\n</ul>\n<h2 id=\"杂乱的管理-吴强\"><a href=\"#杂乱的管理-吴强\" class=\"headerlink\" title=\"杂乱的管理  - 吴强\"></a>杂乱的管理  - 吴强</h2><ul>\n<li>初创团队，相关人员不完备</li>\n<li>产品经理只做了原型的工作，没有把控住需求的变更</li>\n<li>一人多职，多项目参与</li>\n<li>空降产品经理，做事一意孤行，跟团队不和</li>\n</ul>\n<h2 id=\"51offer的原始状态-庄丰洲\"><a href=\"#51offer的原始状态-庄丰洲\" class=\"headerlink\" title=\"51offer的原始状态 - 庄丰洲\"></a>51offer的原始状态 - 庄丰洲</h2><ul>\n<li>没有移动端团队人员和移动端研发规范流程</li>\n<li>是个人都可以提需求</li>\n</ul>\n<h2 id=\"工作感悟－李仙鹏\"><a href=\"#工作感悟－李仙鹏\" class=\"headerlink\" title=\"工作感悟－李仙鹏\"></a>工作感悟－李仙鹏</h2><ul>\n<li><p>团队结构：</p>\n<blockquote>\n<p>崇尚扁平化的互联网公司，员工之间没有非常明县的上下级关系。</p>\n</blockquote>\n</li>\n<li><p>需求把控：</p>\n<blockquote>\n<p>需求不明确、中途变更、压榨开发都TMD是耍流氓</p>\n<ol>\n<li><p>一个好的项目需求，应该在kick off前全面规划产品，产品和设计明确需求并且画押签字，中途不得变更。当临时提出需求变更时，技术应该敢于把画押字据拿出来并且提出拒绝——把变更需求留在下一版本迭代。</p>\n</li>\n<li><p>不应该为了迎合进度而倒推时间压榨开发，这样做出来的东西很可能会是漏洞百出的</p>\n</li>\n</ol>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"Better-的一路走来-王胜\"><a href=\"#Better-的一路走来-王胜\" class=\"headerlink\" title=\"Better 的一路走来 - 王胜\"></a><a href=\"http://www.iambetter.cn/\" target=\"_blank\" rel=\"noopener\">Better</a> 的一路走来 - 王胜</h2><h3 id=\"第一个版本历时4个月的天天加班\"><a href=\"#第一个版本历时4个月的天天加班\" class=\"headerlink\" title=\"第一个版本历时4个月的天天加班\"></a>第一个版本历时4个月的天天加班</h3><ul>\n<li>评估开发时间时，仅有原型；设计稿一出，开发人员瞬间觉得工作量要直线上升。</li>\n<li>按照一个有经验的工程师估出时间，然后上面说再调一个人，时间周期按照除以2来算。掉入《人月计划》中所说的坑。</li>\n<li>新组建的团队，缺少默契，需要磨合。【包括客户端之间，客户端与API之间，客户端与UI之间】</li>\n<li>临近上线，上面对体验要求无止境，导致细节调整没完没了</li>\n</ul>\n<h3 id=\"一起努力，挺过4个月\"><a href=\"#一起努力，挺过4个月\" class=\"headerlink\" title=\"一起努力，挺过4个月\"></a>一起努力，挺过4个月</h3><ul>\n<li>打过鸡血</li>\n<li>慢慢地团队之间有了默契</li>\n<li>制定上线体验阀值，不能无止境提出体验调整的需求</li>\n</ul>\n<h3 id=\"后续版本的研发\"><a href=\"#后续版本的研发\" class=\"headerlink\" title=\"后续版本的研发\"></a>后续版本的研发</h3><ul>\n<li>严格按照Scrum流程迭代开发版本，目前2周一迭代</li>\n<li>Sprint确定需求后，不能强制加入新的需求</li>\n<li>特例的需求要插入Sprint，那么就顺延Sprint的周期</li>\n</ul>\n<h2 id=\"工作经历的一些片段-曾铭\"><a href=\"#工作经历的一些片段-曾铭\" class=\"headerlink\" title=\"工作经历的一些片段 - 曾铭\"></a>工作经历的一些片段 - 曾铭</h2><h3 id=\"文化\"><a href=\"#文化\" class=\"headerlink\" title=\"文化\"></a>文化</h3><ul>\n<li>（敏感信息）略</li>\n</ul>\n<h3 id=\"好的\"><a href=\"#好的\" class=\"headerlink\" title=\"好的\"></a>好的</h3><ul>\n<li>工程师主导的开发流程：产品做调研，提目标，开发参与设计 feature 包揽实现、测试、验证</li>\n<li>牛人不少：一流的人招一流的人，二流的人招三流的人</li>\n<li>优秀工具的使用 （工具绝非一蹴而就， svn -&gt; git，）</li>\n<li>对代码的极致追求 （代码行数、朝歌-&gt;镐京、Hackathon：一夜实现客户端聊天）</li>\n<li>相对优秀的办公环境 （畅通的网络等）</li>\n</ul>\n<h1 id=\"不好的\"><a href=\"#不好的\" class=\"headerlink\" title=\"不好的\"></a>不好的</h1><ul>\n<li>目标不明确 (对商家态度的摇摆)</li>\n<li>不接地气（商业化不成功）</li>\n<li>理想主义者的碰撞, 无妥协</li>\n<li>急躁（寻求改变的高期望）</li>\n<li>压力大</li>\n</ul>\n<h3 id=\"以上不针对具体公司\"><a href=\"#以上不针对具体公司\" class=\"headerlink\" title=\"以上不针对具体公司\"></a>以上不针对具体公司</h3>"},{"title":"周精益分享 - 程序员装逼指南","date":"2015-10-30T10:30:00.000Z","_content":"\n\n\n## 『图像和滤镜』\n\n@(Share)[UIImage]\n\n[toc]\n\n### 图像\n#### 常见的图像格式\n- png（Portable Network Graphic）便携式网络图形格式\n- tiff、tif（Tagged Image File Format）标记图像文件格式\n- jpg、jpeg（Joint Photographic Experts Group）联合摄影专家组\n- gif（Graphic Interchange Format）图形交换格式\n\n#### 图像实例化\n- imageNamed:\n> 使用频率高，内存缓存优化\n\n- imageWithContentsOfFile:\n> 单次使用，暂时不清楚如何支持ImageAssert下的图片路径\n\n- imageWithData:\n> 本地或网络的文件数据加载\n\n- imageWithCGImage:\n> 绘制生成图，代码如下\n\n```\n\t// 旧图局部裁剪\n    CGImageRef myImageRef = [oldImage CGImageRef];\n    CGRect subRect = CGRectMake(20, 20, 100, 100);\n    CGImageRef cgCrop = CGImageCreateWithImageInRect(myImageRef, subRect);\n    UIImage *imageCrop = [UIImage imageWithCGImage:cgCrop];\n```\n\n#### 显示图像\n> 屏幕的缩放因子，导致我们需要@2x及@3x图，对视图截图操作也同样需要针对Retina及plus优化\n```\n- (UIImage*)screenShotBy:(UIImageView*)imagView\n{\n//  UIGraphicsBeginImageContext(imagView.bounds.size);\n// 2表示Retina，3表示plus分辨率，1正常，0则是当前设备的缩放因子\n// YES 表示不包含图像的alpha通道\n\tUIGraphicsBeginImageContextWithOptions((imagView.bounds.size), YES, 2);\n\t[imagView.layer renderInContext:UIGraphicsGetCurrentContext()];\n\tUIImage*image = UIGraphicsGetImageFromCurrentImageContext();\n\tUIGraphicsEndImageContext();\n\treturn image;\n}\n```\n##### contentModel\n\n*图像内容展现方式*\n\n- UIViewContentModelScaleToFill（默认）\n- UIViewContentModelScaleAspectFill（下拉放大）\n- UIViewContentModelScaleAspectFit\n- UIViewContentModelCenter （一些停靠模式）\n- UIViewContentModelTop/Bottom\n- UIViewContentModelLeft/Right\n\n##### 拉伸属性\n`代码`\n```\n// 方法一\nimage=[oldIconImage stretchableImageWithLeftCapWidth:10 topCapHeight:12];\n\n// 方法二\nimage = [oldIconImage resizableImageWithCapInsets:UIEdgeInsetsMake(17, 17, 17, 25)];\n```\n`ImageAssert`\n\n![Alt text](./1446137205500.png)\n使用slicing，小变大无视差\n![Alt text](./1446137161636.png)\n\n---\n### 图像选择器\n\n#### 系统自带\n\n#### 自定义\n\n---\n### 滤镜\n\n### 人脸识别\n\n## 聊聊 QCon2015 - 曾铭\n\n### pure-native 移动跨平台架构设计与实战\nby 赵世婚\n\n#### 好处\n\n- 重复逻辑：网络层、账户逻辑\n- 性能（网络压缩、打破内存限制）\n- 多一层封装应对业务变动\n\n#### 坏处\n- 跨平台开发代码生成\n- 调试：异常捕获\n\n#### 总结：\n- 学不来：人员构成决定技术选型，技术选型决定依赖人员 {:&.rollIn}\n- 分层来应对业务变动（横向分层和纵向分层）\n\n\n### JavaScript - The World’s Best Programming Language\nby Hax\n\n#### JavaScript 最好 ？\n\n- 语言简陋：弱类型、标准库、面向对象、模块、异步 {:&.rollIn}\n- 编程时注意：好的范式、不好的范式\n\n#### 不过\n\n- npm 飞速发展的 packages 数量 {:&.rollIn}\n- ECMAScript 6，语言特性问题完美解决 (c)\n- Babel 6to5 (python)\n\t- most hard to upgrade -> always use latest feature!\n- 最快的动态语言，还会更快 (ruby)\n- JS as a Platform：中间语言 (c#, java）\n- 生态系统：浏览器、node.js、公司、社区\n\n#### 总结：\n\n- js 是现阶段发展最快的语言 {:&.rollIn}\n- 前端前途无量！\n\n### react\n\n\n#### jQuery\n\n- DOM 操作\n- 组件散乱，社区力量难以聚合\n\n\n#### AngularJS\n\n- 绑定 数据与数据、数据与视图之间的关系\n- npm\n\n#### React\n\n- 用 js 写界面……（似乎是一种倒退）\n- 还整个 JSX 让界面好写一点\n- React Native\n\n#### 总结\n\n- 前端风起云涌 {:&.rollIn}\n- 小扎灭我客户端之心不死\n\n### 总的总结\n\n- 拥抱变化\n- 最差也可以变最好，关键要敢于拥抱变化\n- 技术紧迫感：勇于尝试新东西\n- 业务紧迫感：技术改变留学\n\n### 推荐：\n\n- JavaScript - The World’s Best Programming Language\n- pure-native移动跨平台架构设计与实战\n- 注重实效的性能\n- ReactJS 实战\n- ELE.ME是如何运行的\n\n\n## Android 6.0运行权限 - 王胜\n\n### 一般权限和危险权限\n\nAndroid 6.0以前，所有的权限在应用安装或者更新时自动完成授权。如果用户想安装这个App，必需接受所有的权限申请。为了保护用户的隐私，Android M特意调整了Android的授权架构。将应用权限分为一般(Normal)和危险(Dangerous)两种级别的权限:\n\n- 一般权限不会直接危害用户的隐私。如果你的App在manifest列出一般权限，那么系统会自动授予这些权限。\n\n- 危险权限可以访问用户的隐私数据。 如果你的App在manifest列出一般权限，那么系统会自动授予这些权限。如果列出危险权限，需要通过用户显示交互通过你的应用权限申请。\n\n### 权限组\n\nAnroid系统里所有的危险权限都拥有所归属的权限组。如果设备运行在Android6.0(API level 23)，并且App的targetSdkVersion是23或者更高，当App请求危险权限时将会有以下表现：\n\n- 如果App请求manifest里声明的危险权限，并且App当前还没有获取任何权限组里的权限，系统将弹出一个描述App想要访问权限的对话框。但是对话框不会描述该权限属于哪个权限组。例如：App请求权限 **READ_CONTACTS**  ，系统对话框只显示App需要访问设备的联系人。如果用户授权通过，系统仅仅给App需要的权限。\n\n- 如果App请求manifest里声明的危险权限，并且App已经用户该危险权限所在的权限组的权限，系统则直接授予此次请求的权限，而不需要用户手动交互。例如：如果App已经有先前的 **READ_CONTACTS** 权限，那么再请求 **WRITE_CONTACTS** 权限，系统则直接授予。\n\n> 任何权限都有所归属的权限组，包括一般权限和App自定义的权限。然而，权限组只影响那些危险权限相关的用户体验。你可以忽略一般权限的权限组。\n\n**危险权限和权限组**\n\n|权限组|权限|\n|:-:|:-:|\n|CALENDAR| <ul><li>READ\\_CALENDAR</li><li>WRITE\\_CALENDAR</li></ul>|\n|CAMERA| <ul><li>CAMERA</li></ul>|\n|CONTACTS| <ul><li>READ\\_CONTACTS</li><li> WRITE\\_CONTACTS</li><li>GET\\_ACCOUNTS</li></ui>|\n|LOCATION| <ul><li>ACCESS\\_FINE\\_LOCATION</li><li> ACCESS\\_COARSE\\_LOCATION</li></ul>|\n|MICROPHONE| <ul><li>RECORD_AUDIO</li></ul>|\n|PHONE| <ul><li>READ\\_PHONE\\_STATE</li><li>CALL\\_PHONE</li><li>READ\\_CALL\\_LOG</li><li>WRITE\\_CALL\\_LOG</li><li> ADD\\_VOICEMAIL</li><li>USE\\_SIP</li><li> PROCESS\\_OUTGOING\\_CALLS</li></ul>|\n|SENSORS| <ul><li>BODY\\_SENSORS</li></ul> |\n|SMS| <ul><li>SEND\\_SMS</li><li>RECEIVE\\_SMS</li><li> READ\\_SMS</li><li>RECEIVE\\_WAP\\_PUSH</li><li>RECEIVE\\_MMS</li></ul>|\n|STORAGE| <ul><li>READ\\_EXTERNAL\\_STORAGE</li><li> WRITE\\_EXTERNAL\\_STORAGE</li></ul> |\n\n### 权限检测\n\nAndroid的所有版本里，都需要将所需的一般权限和危险权限都声明在App的manifest里。然而这些声明在不同的系统版本和App的target SDK Level会有不同的影响:\n\n- 如果设备运行在Android 5.1或者更低，或者你的App target SDK是22或者更低：如果你在manifest里声明了危险权限，用户则不得不在安装App时给予授权；如果他们不授权，系统将不会安装此App。\n\n- 如果设备运行在Android 6.0或者更高，或者你的App target SDK是23或者更高：App不仅需要在manifest里声明危险权限，而且App在运行时还需要在每次需要危险权限时发起请求。用户可以接受也可以拒绝权限申请，App也需要在用户拒绝危险权限申请时能长长运行。\n\n> 注意：此处的权限处理只有App的target API level 23或者更高，而且运行在Android 6.0 (API level 23)或者更高的设备上才会如此。如果设备的中App的targetSdkVersion 是 22或者更低，系统则在安装或者更新App时自动授予危险权限。\n\n[The Android Support Library](http://developer.android.com/tools/support-library/index.html)能很好地处理检测、请求和权限。Android 6.0 (API level 23) framework也提供了类似的方法。然而，使用support库能更简单一些，因为你不需要在调用方法之前检测android系统的版本。 \n\n### 发起权限申请请求\n\n``` Java\n// Here, this Activity is the current activity\nif (ContextCompat.checkSelfPermission(thisActivity,\n                Manifest.permission.READ_CONTACTS)\n        != PackageManager.PERMISSION_GRANTED) {\n\n    // Should we show an explanation?\n    if (ActivityCompat.shouldShowRequestPermissionRationale(thisActivity,\n            Manifest.permission.READ_CONTACTS)) {\n\n        // Show an expanation to the user *asynchronously* -- don't block\n        // this thread waiting for the user's response! After the user\n        // sees the explanation, try again to request the permission.\n\n    } else {\n\n        // No explanation needed, we can request the permission.\n\n        ActivityCompat.requestPermissions(thisActivity,\n                new String[]{Manifest.permission.READ_CONTACTS},\n                MY_PERMISSIONS_REQUEST_READ_CONTACTS);\n\n        // MY_PERMISSIONS_REQUEST_READ_CONTACTS is an\n        // app-defined int constant. The callback method gets the\n        // result of the request.\n    }\n}\n```\n\n### 处理权限请求结果\n\n``` Java\n@Override\npublic void onRequestPermissionsResult(int requestCode,\n        String permissions[], int[] grantResults) {\n    switch (requestCode) {\n        case MY_PERMISSIONS_REQUEST_READ_CONTACTS: {\n            // If request is cancelled, the result arrays are empty.\n            if (grantResults.length > 0\n                && grantResults[0] == PackageManager.PERMISSION_GRANTED) {\n\n                // permission was granted, yay! Do the\n                // contacts-related task you need to do.\n\n            } else {\n\n                // permission denied, boo! Disable the\n                // functionality that depends on this permission.\n            }\n            return;\n        }\n\n        // other 'case' lines to check for other\n        // permissions this app might request\n    }\n}\n```\n\n> 注意：每次需要权限时，都需要显示请求调用，即使你已经获得的同权限组的其他权限。另外，权限分组处理的机制在将来的Android发型版本中有可能更改。因此你的App不应该依赖所需的权限在或者不在同一个权限组里。\n\n参考：\n\n- [Requesting Permissions at Run Time](http://developer.android.com/training/permissions/requesting.html)\n- [Permissions Best Practices](http://developer.android.com/training/permissions/best-practices.html)\n\n\n##Swift Access Control - 潘君\n(未完待续)\n\n- 三个级别\n\t- Public\n\t- Internal\n\t- Private\n\t\n\t大部分默认是internal\n\n- 可应用于\n\t- Module\n\t\t- application\n\t\t- framework\n\t- source file\n\t\t- properties\n\t\t- types\n\t\t- functions\n\t\t- and so on（苹果文档这个太二了）\n\n- 准则\n\t- public变量不能定义为internal或者private的类型\n\t- 函数的访问权限不能高于参数和返回值\n\n- 应用场景\n\t- Single-Target Apps    Internal\n\t- Frameworks  Public\n\t- Unit Test Targets      @testable![Alt text](./1446175520419.png)\n\n\n- 会级联影响 例如修饰了type 同时也会影响type的members\n```\npublic class SomePublicClass {          // explicitly public class\n    public var somePublicProperty = 0    // explicitly public class member\n    var someInternalProperty = 0         // implicitly internal class member\n    private func somePrivateMethod() {}  // explicitly private class member\n}\n \nclass SomeInternalClass {               // implicitly internal class\n    var someInternalProperty = 0         // implicitly internal class member\n    private func somePrivateMethod() {}  // explicitly private class member\n}\n \nprivate class SomePrivateClass {        // explicitly private class\n    var somePrivateProperty = 0          // implicitly private class member\n    func somePrivateMethod() {}          // implicitly private class member\n}\n\n\n```\n\n- Function\n\t\n- Tuple\n\t- 取元素中访问level最小的为准\n\t- 例如 （PrivateClass, InternalClass） 则取private\n\n- Enumeration \n\t- 一样\n\n- class\n```\npublic class A {\n    private func someMethod() {}\n}\n \ninternal class B: A {\n    override internal func someMethod() {}\n}\n```\n","source":"_posts/程序员装逼指南.md","raw":"title: 周精益分享 - 程序员装逼指南\ndate: 2015-10-30  10:30:00\ntags:\ncategories: 移动组周分享\n---\n\n\n\n## 『图像和滤镜』\n\n@(Share)[UIImage]\n\n[toc]\n\n### 图像\n#### 常见的图像格式\n- png（Portable Network Graphic）便携式网络图形格式\n- tiff、tif（Tagged Image File Format）标记图像文件格式\n- jpg、jpeg（Joint Photographic Experts Group）联合摄影专家组\n- gif（Graphic Interchange Format）图形交换格式\n\n#### 图像实例化\n- imageNamed:\n> 使用频率高，内存缓存优化\n\n- imageWithContentsOfFile:\n> 单次使用，暂时不清楚如何支持ImageAssert下的图片路径\n\n- imageWithData:\n> 本地或网络的文件数据加载\n\n- imageWithCGImage:\n> 绘制生成图，代码如下\n\n```\n\t// 旧图局部裁剪\n    CGImageRef myImageRef = [oldImage CGImageRef];\n    CGRect subRect = CGRectMake(20, 20, 100, 100);\n    CGImageRef cgCrop = CGImageCreateWithImageInRect(myImageRef, subRect);\n    UIImage *imageCrop = [UIImage imageWithCGImage:cgCrop];\n```\n\n#### 显示图像\n> 屏幕的缩放因子，导致我们需要@2x及@3x图，对视图截图操作也同样需要针对Retina及plus优化\n```\n- (UIImage*)screenShotBy:(UIImageView*)imagView\n{\n//  UIGraphicsBeginImageContext(imagView.bounds.size);\n// 2表示Retina，3表示plus分辨率，1正常，0则是当前设备的缩放因子\n// YES 表示不包含图像的alpha通道\n\tUIGraphicsBeginImageContextWithOptions((imagView.bounds.size), YES, 2);\n\t[imagView.layer renderInContext:UIGraphicsGetCurrentContext()];\n\tUIImage*image = UIGraphicsGetImageFromCurrentImageContext();\n\tUIGraphicsEndImageContext();\n\treturn image;\n}\n```\n##### contentModel\n\n*图像内容展现方式*\n\n- UIViewContentModelScaleToFill（默认）\n- UIViewContentModelScaleAspectFill（下拉放大）\n- UIViewContentModelScaleAspectFit\n- UIViewContentModelCenter （一些停靠模式）\n- UIViewContentModelTop/Bottom\n- UIViewContentModelLeft/Right\n\n##### 拉伸属性\n`代码`\n```\n// 方法一\nimage=[oldIconImage stretchableImageWithLeftCapWidth:10 topCapHeight:12];\n\n// 方法二\nimage = [oldIconImage resizableImageWithCapInsets:UIEdgeInsetsMake(17, 17, 17, 25)];\n```\n`ImageAssert`\n\n![Alt text](./1446137205500.png)\n使用slicing，小变大无视差\n![Alt text](./1446137161636.png)\n\n---\n### 图像选择器\n\n#### 系统自带\n\n#### 自定义\n\n---\n### 滤镜\n\n### 人脸识别\n\n## 聊聊 QCon2015 - 曾铭\n\n### pure-native 移动跨平台架构设计与实战\nby 赵世婚\n\n#### 好处\n\n- 重复逻辑：网络层、账户逻辑\n- 性能（网络压缩、打破内存限制）\n- 多一层封装应对业务变动\n\n#### 坏处\n- 跨平台开发代码生成\n- 调试：异常捕获\n\n#### 总结：\n- 学不来：人员构成决定技术选型，技术选型决定依赖人员 {:&.rollIn}\n- 分层来应对业务变动（横向分层和纵向分层）\n\n\n### JavaScript - The World’s Best Programming Language\nby Hax\n\n#### JavaScript 最好 ？\n\n- 语言简陋：弱类型、标准库、面向对象、模块、异步 {:&.rollIn}\n- 编程时注意：好的范式、不好的范式\n\n#### 不过\n\n- npm 飞速发展的 packages 数量 {:&.rollIn}\n- ECMAScript 6，语言特性问题完美解决 (c)\n- Babel 6to5 (python)\n\t- most hard to upgrade -> always use latest feature!\n- 最快的动态语言，还会更快 (ruby)\n- JS as a Platform：中间语言 (c#, java）\n- 生态系统：浏览器、node.js、公司、社区\n\n#### 总结：\n\n- js 是现阶段发展最快的语言 {:&.rollIn}\n- 前端前途无量！\n\n### react\n\n\n#### jQuery\n\n- DOM 操作\n- 组件散乱，社区力量难以聚合\n\n\n#### AngularJS\n\n- 绑定 数据与数据、数据与视图之间的关系\n- npm\n\n#### React\n\n- 用 js 写界面……（似乎是一种倒退）\n- 还整个 JSX 让界面好写一点\n- React Native\n\n#### 总结\n\n- 前端风起云涌 {:&.rollIn}\n- 小扎灭我客户端之心不死\n\n### 总的总结\n\n- 拥抱变化\n- 最差也可以变最好，关键要敢于拥抱变化\n- 技术紧迫感：勇于尝试新东西\n- 业务紧迫感：技术改变留学\n\n### 推荐：\n\n- JavaScript - The World’s Best Programming Language\n- pure-native移动跨平台架构设计与实战\n- 注重实效的性能\n- ReactJS 实战\n- ELE.ME是如何运行的\n\n\n## Android 6.0运行权限 - 王胜\n\n### 一般权限和危险权限\n\nAndroid 6.0以前，所有的权限在应用安装或者更新时自动完成授权。如果用户想安装这个App，必需接受所有的权限申请。为了保护用户的隐私，Android M特意调整了Android的授权架构。将应用权限分为一般(Normal)和危险(Dangerous)两种级别的权限:\n\n- 一般权限不会直接危害用户的隐私。如果你的App在manifest列出一般权限，那么系统会自动授予这些权限。\n\n- 危险权限可以访问用户的隐私数据。 如果你的App在manifest列出一般权限，那么系统会自动授予这些权限。如果列出危险权限，需要通过用户显示交互通过你的应用权限申请。\n\n### 权限组\n\nAnroid系统里所有的危险权限都拥有所归属的权限组。如果设备运行在Android6.0(API level 23)，并且App的targetSdkVersion是23或者更高，当App请求危险权限时将会有以下表现：\n\n- 如果App请求manifest里声明的危险权限，并且App当前还没有获取任何权限组里的权限，系统将弹出一个描述App想要访问权限的对话框。但是对话框不会描述该权限属于哪个权限组。例如：App请求权限 **READ_CONTACTS**  ，系统对话框只显示App需要访问设备的联系人。如果用户授权通过，系统仅仅给App需要的权限。\n\n- 如果App请求manifest里声明的危险权限，并且App已经用户该危险权限所在的权限组的权限，系统则直接授予此次请求的权限，而不需要用户手动交互。例如：如果App已经有先前的 **READ_CONTACTS** 权限，那么再请求 **WRITE_CONTACTS** 权限，系统则直接授予。\n\n> 任何权限都有所归属的权限组，包括一般权限和App自定义的权限。然而，权限组只影响那些危险权限相关的用户体验。你可以忽略一般权限的权限组。\n\n**危险权限和权限组**\n\n|权限组|权限|\n|:-:|:-:|\n|CALENDAR| <ul><li>READ\\_CALENDAR</li><li>WRITE\\_CALENDAR</li></ul>|\n|CAMERA| <ul><li>CAMERA</li></ul>|\n|CONTACTS| <ul><li>READ\\_CONTACTS</li><li> WRITE\\_CONTACTS</li><li>GET\\_ACCOUNTS</li></ui>|\n|LOCATION| <ul><li>ACCESS\\_FINE\\_LOCATION</li><li> ACCESS\\_COARSE\\_LOCATION</li></ul>|\n|MICROPHONE| <ul><li>RECORD_AUDIO</li></ul>|\n|PHONE| <ul><li>READ\\_PHONE\\_STATE</li><li>CALL\\_PHONE</li><li>READ\\_CALL\\_LOG</li><li>WRITE\\_CALL\\_LOG</li><li> ADD\\_VOICEMAIL</li><li>USE\\_SIP</li><li> PROCESS\\_OUTGOING\\_CALLS</li></ul>|\n|SENSORS| <ul><li>BODY\\_SENSORS</li></ul> |\n|SMS| <ul><li>SEND\\_SMS</li><li>RECEIVE\\_SMS</li><li> READ\\_SMS</li><li>RECEIVE\\_WAP\\_PUSH</li><li>RECEIVE\\_MMS</li></ul>|\n|STORAGE| <ul><li>READ\\_EXTERNAL\\_STORAGE</li><li> WRITE\\_EXTERNAL\\_STORAGE</li></ul> |\n\n### 权限检测\n\nAndroid的所有版本里，都需要将所需的一般权限和危险权限都声明在App的manifest里。然而这些声明在不同的系统版本和App的target SDK Level会有不同的影响:\n\n- 如果设备运行在Android 5.1或者更低，或者你的App target SDK是22或者更低：如果你在manifest里声明了危险权限，用户则不得不在安装App时给予授权；如果他们不授权，系统将不会安装此App。\n\n- 如果设备运行在Android 6.0或者更高，或者你的App target SDK是23或者更高：App不仅需要在manifest里声明危险权限，而且App在运行时还需要在每次需要危险权限时发起请求。用户可以接受也可以拒绝权限申请，App也需要在用户拒绝危险权限申请时能长长运行。\n\n> 注意：此处的权限处理只有App的target API level 23或者更高，而且运行在Android 6.0 (API level 23)或者更高的设备上才会如此。如果设备的中App的targetSdkVersion 是 22或者更低，系统则在安装或者更新App时自动授予危险权限。\n\n[The Android Support Library](http://developer.android.com/tools/support-library/index.html)能很好地处理检测、请求和权限。Android 6.0 (API level 23) framework也提供了类似的方法。然而，使用support库能更简单一些，因为你不需要在调用方法之前检测android系统的版本。 \n\n### 发起权限申请请求\n\n``` Java\n// Here, this Activity is the current activity\nif (ContextCompat.checkSelfPermission(thisActivity,\n                Manifest.permission.READ_CONTACTS)\n        != PackageManager.PERMISSION_GRANTED) {\n\n    // Should we show an explanation?\n    if (ActivityCompat.shouldShowRequestPermissionRationale(thisActivity,\n            Manifest.permission.READ_CONTACTS)) {\n\n        // Show an expanation to the user *asynchronously* -- don't block\n        // this thread waiting for the user's response! After the user\n        // sees the explanation, try again to request the permission.\n\n    } else {\n\n        // No explanation needed, we can request the permission.\n\n        ActivityCompat.requestPermissions(thisActivity,\n                new String[]{Manifest.permission.READ_CONTACTS},\n                MY_PERMISSIONS_REQUEST_READ_CONTACTS);\n\n        // MY_PERMISSIONS_REQUEST_READ_CONTACTS is an\n        // app-defined int constant. The callback method gets the\n        // result of the request.\n    }\n}\n```\n\n### 处理权限请求结果\n\n``` Java\n@Override\npublic void onRequestPermissionsResult(int requestCode,\n        String permissions[], int[] grantResults) {\n    switch (requestCode) {\n        case MY_PERMISSIONS_REQUEST_READ_CONTACTS: {\n            // If request is cancelled, the result arrays are empty.\n            if (grantResults.length > 0\n                && grantResults[0] == PackageManager.PERMISSION_GRANTED) {\n\n                // permission was granted, yay! Do the\n                // contacts-related task you need to do.\n\n            } else {\n\n                // permission denied, boo! Disable the\n                // functionality that depends on this permission.\n            }\n            return;\n        }\n\n        // other 'case' lines to check for other\n        // permissions this app might request\n    }\n}\n```\n\n> 注意：每次需要权限时，都需要显示请求调用，即使你已经获得的同权限组的其他权限。另外，权限分组处理的机制在将来的Android发型版本中有可能更改。因此你的App不应该依赖所需的权限在或者不在同一个权限组里。\n\n参考：\n\n- [Requesting Permissions at Run Time](http://developer.android.com/training/permissions/requesting.html)\n- [Permissions Best Practices](http://developer.android.com/training/permissions/best-practices.html)\n\n\n##Swift Access Control - 潘君\n(未完待续)\n\n- 三个级别\n\t- Public\n\t- Internal\n\t- Private\n\t\n\t大部分默认是internal\n\n- 可应用于\n\t- Module\n\t\t- application\n\t\t- framework\n\t- source file\n\t\t- properties\n\t\t- types\n\t\t- functions\n\t\t- and so on（苹果文档这个太二了）\n\n- 准则\n\t- public变量不能定义为internal或者private的类型\n\t- 函数的访问权限不能高于参数和返回值\n\n- 应用场景\n\t- Single-Target Apps    Internal\n\t- Frameworks  Public\n\t- Unit Test Targets      @testable![Alt text](./1446175520419.png)\n\n\n- 会级联影响 例如修饰了type 同时也会影响type的members\n```\npublic class SomePublicClass {          // explicitly public class\n    public var somePublicProperty = 0    // explicitly public class member\n    var someInternalProperty = 0         // implicitly internal class member\n    private func somePrivateMethod() {}  // explicitly private class member\n}\n \nclass SomeInternalClass {               // implicitly internal class\n    var someInternalProperty = 0         // implicitly internal class member\n    private func somePrivateMethod() {}  // explicitly private class member\n}\n \nprivate class SomePrivateClass {        // explicitly private class\n    var somePrivateProperty = 0          // implicitly private class member\n    func somePrivateMethod() {}          // implicitly private class member\n}\n\n\n```\n\n- Function\n\t\n- Tuple\n\t- 取元素中访问level最小的为准\n\t- 例如 （PrivateClass, InternalClass） 则取private\n\n- Enumeration \n\t- 一样\n\n- class\n```\npublic class A {\n    private func someMethod() {}\n}\n \ninternal class B: A {\n    override internal func someMethod() {}\n}\n```\n","slug":"程序员装逼指南","published":1,"updated":"2021-09-10T07:04:21.948Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cktfeap4g002nc2xxwxwhx8g6","content":"<h2 id=\"『图像和滤镜』\"><a href=\"#『图像和滤镜』\" class=\"headerlink\" title=\"『图像和滤镜』\"></a>『图像和滤镜』</h2><p>@(Share)[UIImage]</p>\n<p>[toc]</p>\n<h3 id=\"图像\"><a href=\"#图像\" class=\"headerlink\" title=\"图像\"></a>图像</h3><h4 id=\"常见的图像格式\"><a href=\"#常见的图像格式\" class=\"headerlink\" title=\"常见的图像格式\"></a>常见的图像格式</h4><ul>\n<li>png（Portable Network Graphic）便携式网络图形格式</li>\n<li>tiff、tif（Tagged Image File Format）标记图像文件格式</li>\n<li>jpg、jpeg（Joint Photographic Experts Group）联合摄影专家组</li>\n<li>gif（Graphic Interchange Format）图形交换格式</li>\n</ul>\n<h4 id=\"图像实例化\"><a href=\"#图像实例化\" class=\"headerlink\" title=\"图像实例化\"></a>图像实例化</h4><ul>\n<li><p>imageNamed:</p>\n<blockquote>\n<p>使用频率高，内存缓存优化</p>\n</blockquote>\n</li>\n<li><p>imageWithContentsOfFile:</p>\n<blockquote>\n<p>单次使用，暂时不清楚如何支持ImageAssert下的图片路径</p>\n</blockquote>\n</li>\n<li><p>imageWithData:</p>\n<blockquote>\n<p>本地或网络的文件数据加载</p>\n</blockquote>\n</li>\n<li><p>imageWithCGImage:</p>\n<blockquote>\n<p>绘制生成图，代码如下</p>\n</blockquote>\n</li>\n</ul>\n<pre><code>    // 旧图局部裁剪\n    CGImageRef myImageRef = [oldImage CGImageRef];\n    CGRect subRect = CGRectMake(20, 20, 100, 100);\n    CGImageRef cgCrop = CGImageCreateWithImageInRect(myImageRef, subRect);\n    UIImage *imageCrop = [UIImage imageWithCGImage:cgCrop];\n</code></pre><h4 id=\"显示图像\"><a href=\"#显示图像\" class=\"headerlink\" title=\"显示图像\"></a>显示图像</h4><blockquote>\n<p>屏幕的缩放因子，导致我们需要@2x及@3x图，对视图截图操作也同样需要针对Retina及plus优化</p>\n<pre><code>- (UIImage*)screenShotBy:(UIImageView*)imagView\n{\n//  UIGraphicsBeginImageContext(imagView.bounds.size);\n// 2表示Retina，3表示plus分辨率，1正常，0则是当前设备的缩放因子\n// YES 表示不包含图像的alpha通道\n    UIGraphicsBeginImageContextWithOptions((imagView.bounds.size), YES, 2);\n    [imagView.layer renderInContext:UIGraphicsGetCurrentContext()];\n    UIImage*image = UIGraphicsGetImageFromCurrentImageContext();\n    UIGraphicsEndImageContext();\n    return image;\n}\n</code></pre><h5 id=\"contentModel\"><a href=\"#contentModel\" class=\"headerlink\" title=\"contentModel\"></a>contentModel</h5></blockquote>\n<p><em>图像内容展现方式</em></p>\n<ul>\n<li>UIViewContentModelScaleToFill（默认）</li>\n<li>UIViewContentModelScaleAspectFill（下拉放大）</li>\n<li>UIViewContentModelScaleAspectFit</li>\n<li>UIViewContentModelCenter （一些停靠模式）</li>\n<li>UIViewContentModelTop/Bottom</li>\n<li>UIViewContentModelLeft/Right</li>\n</ul>\n<h5 id=\"拉伸属性\"><a href=\"#拉伸属性\" class=\"headerlink\" title=\"拉伸属性\"></a>拉伸属性</h5><p><code>代码</code></p>\n<pre><code>// 方法一\nimage=[oldIconImage stretchableImageWithLeftCapWidth:10 topCapHeight:12];\n\n// 方法二\nimage = [oldIconImage resizableImageWithCapInsets:UIEdgeInsetsMake(17, 17, 17, 25)];\n</code></pre><p><code>ImageAssert</code></p>\n<p><img src=\"./1446137205500.png\" alt=\"Alt text\"><br>使用slicing，小变大无视差<br><img src=\"./1446137161636.png\" alt=\"Alt text\"></p>\n<hr>\n<h3 id=\"图像选择器\"><a href=\"#图像选择器\" class=\"headerlink\" title=\"图像选择器\"></a>图像选择器</h3><h4 id=\"系统自带\"><a href=\"#系统自带\" class=\"headerlink\" title=\"系统自带\"></a>系统自带</h4><h4 id=\"自定义\"><a href=\"#自定义\" class=\"headerlink\" title=\"自定义\"></a>自定义</h4><hr>\n<h3 id=\"滤镜\"><a href=\"#滤镜\" class=\"headerlink\" title=\"滤镜\"></a>滤镜</h3><h3 id=\"人脸识别\"><a href=\"#人脸识别\" class=\"headerlink\" title=\"人脸识别\"></a>人脸识别</h3><h2 id=\"聊聊-QCon2015-曾铭\"><a href=\"#聊聊-QCon2015-曾铭\" class=\"headerlink\" title=\"聊聊 QCon2015 - 曾铭\"></a>聊聊 QCon2015 - 曾铭</h2><h3 id=\"pure-native-移动跨平台架构设计与实战\"><a href=\"#pure-native-移动跨平台架构设计与实战\" class=\"headerlink\" title=\"pure-native 移动跨平台架构设计与实战\"></a>pure-native 移动跨平台架构设计与实战</h3><p>by 赵世婚</p>\n<h4 id=\"好处\"><a href=\"#好处\" class=\"headerlink\" title=\"好处\"></a>好处</h4><ul>\n<li>重复逻辑：网络层、账户逻辑</li>\n<li>性能（网络压缩、打破内存限制）</li>\n<li>多一层封装应对业务变动</li>\n</ul>\n<h4 id=\"坏处\"><a href=\"#坏处\" class=\"headerlink\" title=\"坏处\"></a>坏处</h4><ul>\n<li>跨平台开发代码生成</li>\n<li>调试：异常捕获</li>\n</ul>\n<h4 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h4><ul>\n<li>学不来：人员构成决定技术选型，技术选型决定依赖人员 {:&amp;.rollIn}</li>\n<li>分层来应对业务变动（横向分层和纵向分层）</li>\n</ul>\n<h3 id=\"JavaScript-The-World’s-Best-Programming-Language\"><a href=\"#JavaScript-The-World’s-Best-Programming-Language\" class=\"headerlink\" title=\"JavaScript - The World’s Best Programming Language\"></a>JavaScript - The World’s Best Programming Language</h3><p>by Hax</p>\n<h4 id=\"JavaScript-最好-？\"><a href=\"#JavaScript-最好-？\" class=\"headerlink\" title=\"JavaScript 最好 ？\"></a>JavaScript 最好 ？</h4><ul>\n<li>语言简陋：弱类型、标准库、面向对象、模块、异步 {:&amp;.rollIn}</li>\n<li>编程时注意：好的范式、不好的范式</li>\n</ul>\n<h4 id=\"不过\"><a href=\"#不过\" class=\"headerlink\" title=\"不过\"></a>不过</h4><ul>\n<li>npm 飞速发展的 packages 数量 {:&amp;.rollIn}</li>\n<li>ECMAScript 6，语言特性问题完美解决 (c)</li>\n<li>Babel 6to5 (python)<ul>\n<li>most hard to upgrade -&gt; always use latest feature!</li>\n</ul>\n</li>\n<li>最快的动态语言，还会更快 (ruby)</li>\n<li>JS as a Platform：中间语言 (c#, java）</li>\n<li>生态系统：浏览器、node.js、公司、社区</li>\n</ul>\n<h4 id=\"总结：-1\"><a href=\"#总结：-1\" class=\"headerlink\" title=\"总结：\"></a>总结：</h4><ul>\n<li>js 是现阶段发展最快的语言 {:&amp;.rollIn}</li>\n<li>前端前途无量！</li>\n</ul>\n<h3 id=\"react\"><a href=\"#react\" class=\"headerlink\" title=\"react\"></a>react</h3><h4 id=\"jQuery\"><a href=\"#jQuery\" class=\"headerlink\" title=\"jQuery\"></a>jQuery</h4><ul>\n<li>DOM 操作</li>\n<li>组件散乱，社区力量难以聚合</li>\n</ul>\n<h4 id=\"AngularJS\"><a href=\"#AngularJS\" class=\"headerlink\" title=\"AngularJS\"></a>AngularJS</h4><ul>\n<li>绑定 数据与数据、数据与视图之间的关系</li>\n<li>npm</li>\n</ul>\n<h4 id=\"React\"><a href=\"#React\" class=\"headerlink\" title=\"React\"></a>React</h4><ul>\n<li>用 js 写界面……（似乎是一种倒退）</li>\n<li>还整个 JSX 让界面好写一点</li>\n<li>React Native</li>\n</ul>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><ul>\n<li>前端风起云涌 {:&amp;.rollIn}</li>\n<li>小扎灭我客户端之心不死</li>\n</ul>\n<h3 id=\"总的总结\"><a href=\"#总的总结\" class=\"headerlink\" title=\"总的总结\"></a>总的总结</h3><ul>\n<li>拥抱变化</li>\n<li>最差也可以变最好，关键要敢于拥抱变化</li>\n<li>技术紧迫感：勇于尝试新东西</li>\n<li>业务紧迫感：技术改变留学</li>\n</ul>\n<h3 id=\"推荐：\"><a href=\"#推荐：\" class=\"headerlink\" title=\"推荐：\"></a>推荐：</h3><ul>\n<li>JavaScript - The World’s Best Programming Language</li>\n<li>pure-native移动跨平台架构设计与实战</li>\n<li>注重实效的性能</li>\n<li>ReactJS 实战</li>\n<li>ELE.ME是如何运行的</li>\n</ul>\n<h2 id=\"Android-6-0运行权限-王胜\"><a href=\"#Android-6-0运行权限-王胜\" class=\"headerlink\" title=\"Android 6.0运行权限 - 王胜\"></a>Android 6.0运行权限 - 王胜</h2><h3 id=\"一般权限和危险权限\"><a href=\"#一般权限和危险权限\" class=\"headerlink\" title=\"一般权限和危险权限\"></a>一般权限和危险权限</h3><p>Android 6.0以前，所有的权限在应用安装或者更新时自动完成授权。如果用户想安装这个App，必需接受所有的权限申请。为了保护用户的隐私，Android M特意调整了Android的授权架构。将应用权限分为一般(Normal)和危险(Dangerous)两种级别的权限:</p>\n<ul>\n<li><p>一般权限不会直接危害用户的隐私。如果你的App在manifest列出一般权限，那么系统会自动授予这些权限。</p>\n</li>\n<li><p>危险权限可以访问用户的隐私数据。 如果你的App在manifest列出一般权限，那么系统会自动授予这些权限。如果列出危险权限，需要通过用户显示交互通过你的应用权限申请。</p>\n</li>\n</ul>\n<h3 id=\"权限组\"><a href=\"#权限组\" class=\"headerlink\" title=\"权限组\"></a>权限组</h3><p>Anroid系统里所有的危险权限都拥有所归属的权限组。如果设备运行在Android6.0(API level 23)，并且App的targetSdkVersion是23或者更高，当App请求危险权限时将会有以下表现：</p>\n<ul>\n<li><p>如果App请求manifest里声明的危险权限，并且App当前还没有获取任何权限组里的权限，系统将弹出一个描述App想要访问权限的对话框。但是对话框不会描述该权限属于哪个权限组。例如：App请求权限 <strong>READ_CONTACTS</strong>  ，系统对话框只显示App需要访问设备的联系人。如果用户授权通过，系统仅仅给App需要的权限。</p>\n</li>\n<li><p>如果App请求manifest里声明的危险权限，并且App已经用户该危险权限所在的权限组的权限，系统则直接授予此次请求的权限，而不需要用户手动交互。例如：如果App已经有先前的 <strong>READ_CONTACTS</strong> 权限，那么再请求 <strong>WRITE_CONTACTS</strong> 权限，系统则直接授予。</p>\n</li>\n</ul>\n<blockquote>\n<p>任何权限都有所归属的权限组，包括一般权限和App自定义的权限。然而，权限组只影响那些危险权限相关的用户体验。你可以忽略一般权限的权限组。</p>\n</blockquote>\n<p><strong>危险权限和权限组</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">权限组</th>\n<th style=\"text-align:center\">权限</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">CALENDAR</td>\n<td style=\"text-align:center\"><ul><li>READ_CALENDAR</li><li>WRITE_CALENDAR</li></ul></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">CAMERA</td>\n<td style=\"text-align:center\"><ul><li>CAMERA</li></ul></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">CONTACTS</td>\n<td style=\"text-align:center\"><ul><li>READ_CONTACTS</li><li> WRITE_CONTACTS</li><li>GET_ACCOUNTS</li></ul></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">LOCATION</td>\n<td style=\"text-align:center\"><ul><li>ACCESS_FINE_LOCATION</li><li> ACCESS_COARSE_LOCATION</li></ul></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">MICROPHONE</td>\n<td style=\"text-align:center\"><ul><li>RECORD_AUDIO</li></ul></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">PHONE</td>\n<td style=\"text-align:center\"><ul><li>READ_PHONE_STATE</li><li>CALL_PHONE</li><li>READ_CALL_LOG</li><li>WRITE_CALL_LOG</li><li> ADD_VOICEMAIL</li><li>USE_SIP</li><li> PROCESS_OUTGOING_CALLS</li></ul></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">SENSORS</td>\n<td style=\"text-align:center\"><ul><li>BODY_SENSORS</li></ul></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">SMS</td>\n<td style=\"text-align:center\"><ul><li>SEND_SMS</li><li>RECEIVE_SMS</li><li> READ_SMS</li><li>RECEIVE_WAP_PUSH</li><li>RECEIVE_MMS</li></ul></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">STORAGE</td>\n<td style=\"text-align:center\"><ul><li>READ_EXTERNAL_STORAGE</li><li> WRITE_EXTERNAL_STORAGE</li></ul></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"权限检测\"><a href=\"#权限检测\" class=\"headerlink\" title=\"权限检测\"></a>权限检测</h3><p>Android的所有版本里，都需要将所需的一般权限和危险权限都声明在App的manifest里。然而这些声明在不同的系统版本和App的target SDK Level会有不同的影响:</p>\n<ul>\n<li><p>如果设备运行在Android 5.1或者更低，或者你的App target SDK是22或者更低：如果你在manifest里声明了危险权限，用户则不得不在安装App时给予授权；如果他们不授权，系统将不会安装此App。</p>\n</li>\n<li><p>如果设备运行在Android 6.0或者更高，或者你的App target SDK是23或者更高：App不仅需要在manifest里声明危险权限，而且App在运行时还需要在每次需要危险权限时发起请求。用户可以接受也可以拒绝权限申请，App也需要在用户拒绝危险权限申请时能长长运行。</p>\n</li>\n</ul>\n<blockquote>\n<p>注意：此处的权限处理只有App的target API level 23或者更高，而且运行在Android 6.0 (API level 23)或者更高的设备上才会如此。如果设备的中App的targetSdkVersion 是 22或者更低，系统则在安装或者更新App时自动授予危险权限。</p>\n</blockquote>\n<p><a href=\"http://developer.android.com/tools/support-library/index.html\" target=\"_blank\" rel=\"noopener\">The Android Support Library</a>能很好地处理检测、请求和权限。Android 6.0 (API level 23) framework也提供了类似的方法。然而，使用support库能更简单一些，因为你不需要在调用方法之前检测android系统的版本。 </p>\n<h3 id=\"发起权限申请请求\"><a href=\"#发起权限申请请求\" class=\"headerlink\" title=\"发起权限申请请求\"></a>发起权限申请请求</h3><pre><code class=\"Java\">// Here, this Activity is the current activity\nif (ContextCompat.checkSelfPermission(thisActivity,\n                Manifest.permission.READ_CONTACTS)\n        != PackageManager.PERMISSION_GRANTED) {\n\n    // Should we show an explanation?\n    if (ActivityCompat.shouldShowRequestPermissionRationale(thisActivity,\n            Manifest.permission.READ_CONTACTS)) {\n\n        // Show an expanation to the user *asynchronously* -- don&#39;t block\n        // this thread waiting for the user&#39;s response! After the user\n        // sees the explanation, try again to request the permission.\n\n    } else {\n\n        // No explanation needed, we can request the permission.\n\n        ActivityCompat.requestPermissions(thisActivity,\n                new String[]{Manifest.permission.READ_CONTACTS},\n                MY_PERMISSIONS_REQUEST_READ_CONTACTS);\n\n        // MY_PERMISSIONS_REQUEST_READ_CONTACTS is an\n        // app-defined int constant. The callback method gets the\n        // result of the request.\n    }\n}\n</code></pre>\n<h3 id=\"处理权限请求结果\"><a href=\"#处理权限请求结果\" class=\"headerlink\" title=\"处理权限请求结果\"></a>处理权限请求结果</h3><pre><code class=\"Java\">@Override\npublic void onRequestPermissionsResult(int requestCode,\n        String permissions[], int[] grantResults) {\n    switch (requestCode) {\n        case MY_PERMISSIONS_REQUEST_READ_CONTACTS: {\n            // If request is cancelled, the result arrays are empty.\n            if (grantResults.length &gt; 0\n                &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) {\n\n                // permission was granted, yay! Do the\n                // contacts-related task you need to do.\n\n            } else {\n\n                // permission denied, boo! Disable the\n                // functionality that depends on this permission.\n            }\n            return;\n        }\n\n        // other &#39;case&#39; lines to check for other\n        // permissions this app might request\n    }\n}\n</code></pre>\n<blockquote>\n<p>注意：每次需要权限时，都需要显示请求调用，即使你已经获得的同权限组的其他权限。另外，权限分组处理的机制在将来的Android发型版本中有可能更改。因此你的App不应该依赖所需的权限在或者不在同一个权限组里。</p>\n</blockquote>\n<p>参考：</p>\n<ul>\n<li><a href=\"http://developer.android.com/training/permissions/requesting.html\" target=\"_blank\" rel=\"noopener\">Requesting Permissions at Run Time</a></li>\n<li><a href=\"http://developer.android.com/training/permissions/best-practices.html\" target=\"_blank\" rel=\"noopener\">Permissions Best Practices</a></li>\n</ul>\n<p>##Swift Access Control - 潘君<br>(未完待续)</p>\n<ul>\n<li><p>三个级别</p>\n<ul>\n<li>Public</li>\n<li>Internal</li>\n<li><p>Private</p>\n<p>大部分默认是internal</p>\n</li>\n</ul>\n</li>\n<li><p>可应用于</p>\n<ul>\n<li>Module<ul>\n<li>application</li>\n<li>framework</li>\n</ul>\n</li>\n<li>source file<ul>\n<li>properties</li>\n<li>types</li>\n<li>functions</li>\n<li>and so on（苹果文档这个太二了）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>准则</p>\n<ul>\n<li>public变量不能定义为internal或者private的类型</li>\n<li>函数的访问权限不能高于参数和返回值</li>\n</ul>\n</li>\n<li><p>应用场景</p>\n<ul>\n<li>Single-Target Apps    Internal</li>\n<li>Frameworks  Public</li>\n<li>Unit Test Targets      @testable<img src=\"./1446175520419.png\" alt=\"Alt text\"></li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>会级联影响 例如修饰了type 同时也会影响type的members<br>```<br>public class SomePublicClass {          // explicitly public class<br>  public var somePublicProperty = 0    // explicitly public class member<br>  var someInternalProperty = 0         // implicitly internal class member<br>  private func somePrivateMethod() {}  // explicitly private class member<br>}</li>\n</ul>\n<p>class SomeInternalClass {               // implicitly internal class<br>    var someInternalProperty = 0         // implicitly internal class member<br>    private func somePrivateMethod() {}  // explicitly private class member<br>}</p>\n<p>private class SomePrivateClass {        // explicitly private class<br>    var somePrivateProperty = 0          // implicitly private class member<br>    func somePrivateMethod() {}          // implicitly private class member<br>}</p>\n<pre><code>\n- Function\n\n- Tuple\n    - 取元素中访问level最小的为准\n    - 例如 （PrivateClass, InternalClass） 则取private\n\n- Enumeration \n    - 一样\n\n- class\n</code></pre><p>public class A {<br>    private func someMethod() {}<br>}</p>\n<p>internal class B: A {<br>    override internal func someMethod() {}<br>}<br>```</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"『图像和滤镜』\"><a href=\"#『图像和滤镜』\" class=\"headerlink\" title=\"『图像和滤镜』\"></a>『图像和滤镜』</h2><p>@(Share)[UIImage]</p>\n<p>[toc]</p>\n<h3 id=\"图像\"><a href=\"#图像\" class=\"headerlink\" title=\"图像\"></a>图像</h3><h4 id=\"常见的图像格式\"><a href=\"#常见的图像格式\" class=\"headerlink\" title=\"常见的图像格式\"></a>常见的图像格式</h4><ul>\n<li>png（Portable Network Graphic）便携式网络图形格式</li>\n<li>tiff、tif（Tagged Image File Format）标记图像文件格式</li>\n<li>jpg、jpeg（Joint Photographic Experts Group）联合摄影专家组</li>\n<li>gif（Graphic Interchange Format）图形交换格式</li>\n</ul>\n<h4 id=\"图像实例化\"><a href=\"#图像实例化\" class=\"headerlink\" title=\"图像实例化\"></a>图像实例化</h4><ul>\n<li><p>imageNamed:</p>\n<blockquote>\n<p>使用频率高，内存缓存优化</p>\n</blockquote>\n</li>\n<li><p>imageWithContentsOfFile:</p>\n<blockquote>\n<p>单次使用，暂时不清楚如何支持ImageAssert下的图片路径</p>\n</blockquote>\n</li>\n<li><p>imageWithData:</p>\n<blockquote>\n<p>本地或网络的文件数据加载</p>\n</blockquote>\n</li>\n<li><p>imageWithCGImage:</p>\n<blockquote>\n<p>绘制生成图，代码如下</p>\n</blockquote>\n</li>\n</ul>\n<pre><code>    // 旧图局部裁剪\n    CGImageRef myImageRef = [oldImage CGImageRef];\n    CGRect subRect = CGRectMake(20, 20, 100, 100);\n    CGImageRef cgCrop = CGImageCreateWithImageInRect(myImageRef, subRect);\n    UIImage *imageCrop = [UIImage imageWithCGImage:cgCrop];\n</code></pre><h4 id=\"显示图像\"><a href=\"#显示图像\" class=\"headerlink\" title=\"显示图像\"></a>显示图像</h4><blockquote>\n<p>屏幕的缩放因子，导致我们需要@2x及@3x图，对视图截图操作也同样需要针对Retina及plus优化</p>\n<pre><code>- (UIImage*)screenShotBy:(UIImageView*)imagView\n{\n//  UIGraphicsBeginImageContext(imagView.bounds.size);\n// 2表示Retina，3表示plus分辨率，1正常，0则是当前设备的缩放因子\n// YES 表示不包含图像的alpha通道\n    UIGraphicsBeginImageContextWithOptions((imagView.bounds.size), YES, 2);\n    [imagView.layer renderInContext:UIGraphicsGetCurrentContext()];\n    UIImage*image = UIGraphicsGetImageFromCurrentImageContext();\n    UIGraphicsEndImageContext();\n    return image;\n}\n</code></pre><h5 id=\"contentModel\"><a href=\"#contentModel\" class=\"headerlink\" title=\"contentModel\"></a>contentModel</h5></blockquote>\n<p><em>图像内容展现方式</em></p>\n<ul>\n<li>UIViewContentModelScaleToFill（默认）</li>\n<li>UIViewContentModelScaleAspectFill（下拉放大）</li>\n<li>UIViewContentModelScaleAspectFit</li>\n<li>UIViewContentModelCenter （一些停靠模式）</li>\n<li>UIViewContentModelTop/Bottom</li>\n<li>UIViewContentModelLeft/Right</li>\n</ul>\n<h5 id=\"拉伸属性\"><a href=\"#拉伸属性\" class=\"headerlink\" title=\"拉伸属性\"></a>拉伸属性</h5><p><code>代码</code></p>\n<pre><code>// 方法一\nimage=[oldIconImage stretchableImageWithLeftCapWidth:10 topCapHeight:12];\n\n// 方法二\nimage = [oldIconImage resizableImageWithCapInsets:UIEdgeInsetsMake(17, 17, 17, 25)];\n</code></pre><p><code>ImageAssert</code></p>\n<p><img src=\"./1446137205500.png\" alt=\"Alt text\"><br>使用slicing，小变大无视差<br><img src=\"./1446137161636.png\" alt=\"Alt text\"></p>\n<hr>\n<h3 id=\"图像选择器\"><a href=\"#图像选择器\" class=\"headerlink\" title=\"图像选择器\"></a>图像选择器</h3><h4 id=\"系统自带\"><a href=\"#系统自带\" class=\"headerlink\" title=\"系统自带\"></a>系统自带</h4><h4 id=\"自定义\"><a href=\"#自定义\" class=\"headerlink\" title=\"自定义\"></a>自定义</h4><hr>\n<h3 id=\"滤镜\"><a href=\"#滤镜\" class=\"headerlink\" title=\"滤镜\"></a>滤镜</h3><h3 id=\"人脸识别\"><a href=\"#人脸识别\" class=\"headerlink\" title=\"人脸识别\"></a>人脸识别</h3><h2 id=\"聊聊-QCon2015-曾铭\"><a href=\"#聊聊-QCon2015-曾铭\" class=\"headerlink\" title=\"聊聊 QCon2015 - 曾铭\"></a>聊聊 QCon2015 - 曾铭</h2><h3 id=\"pure-native-移动跨平台架构设计与实战\"><a href=\"#pure-native-移动跨平台架构设计与实战\" class=\"headerlink\" title=\"pure-native 移动跨平台架构设计与实战\"></a>pure-native 移动跨平台架构设计与实战</h3><p>by 赵世婚</p>\n<h4 id=\"好处\"><a href=\"#好处\" class=\"headerlink\" title=\"好处\"></a>好处</h4><ul>\n<li>重复逻辑：网络层、账户逻辑</li>\n<li>性能（网络压缩、打破内存限制）</li>\n<li>多一层封装应对业务变动</li>\n</ul>\n<h4 id=\"坏处\"><a href=\"#坏处\" class=\"headerlink\" title=\"坏处\"></a>坏处</h4><ul>\n<li>跨平台开发代码生成</li>\n<li>调试：异常捕获</li>\n</ul>\n<h4 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h4><ul>\n<li>学不来：人员构成决定技术选型，技术选型决定依赖人员 {:&amp;.rollIn}</li>\n<li>分层来应对业务变动（横向分层和纵向分层）</li>\n</ul>\n<h3 id=\"JavaScript-The-World’s-Best-Programming-Language\"><a href=\"#JavaScript-The-World’s-Best-Programming-Language\" class=\"headerlink\" title=\"JavaScript - The World’s Best Programming Language\"></a>JavaScript - The World’s Best Programming Language</h3><p>by Hax</p>\n<h4 id=\"JavaScript-最好-？\"><a href=\"#JavaScript-最好-？\" class=\"headerlink\" title=\"JavaScript 最好 ？\"></a>JavaScript 最好 ？</h4><ul>\n<li>语言简陋：弱类型、标准库、面向对象、模块、异步 {:&amp;.rollIn}</li>\n<li>编程时注意：好的范式、不好的范式</li>\n</ul>\n<h4 id=\"不过\"><a href=\"#不过\" class=\"headerlink\" title=\"不过\"></a>不过</h4><ul>\n<li>npm 飞速发展的 packages 数量 {:&amp;.rollIn}</li>\n<li>ECMAScript 6，语言特性问题完美解决 (c)</li>\n<li>Babel 6to5 (python)<ul>\n<li>most hard to upgrade -&gt; always use latest feature!</li>\n</ul>\n</li>\n<li>最快的动态语言，还会更快 (ruby)</li>\n<li>JS as a Platform：中间语言 (c#, java）</li>\n<li>生态系统：浏览器、node.js、公司、社区</li>\n</ul>\n<h4 id=\"总结：-1\"><a href=\"#总结：-1\" class=\"headerlink\" title=\"总结：\"></a>总结：</h4><ul>\n<li>js 是现阶段发展最快的语言 {:&amp;.rollIn}</li>\n<li>前端前途无量！</li>\n</ul>\n<h3 id=\"react\"><a href=\"#react\" class=\"headerlink\" title=\"react\"></a>react</h3><h4 id=\"jQuery\"><a href=\"#jQuery\" class=\"headerlink\" title=\"jQuery\"></a>jQuery</h4><ul>\n<li>DOM 操作</li>\n<li>组件散乱，社区力量难以聚合</li>\n</ul>\n<h4 id=\"AngularJS\"><a href=\"#AngularJS\" class=\"headerlink\" title=\"AngularJS\"></a>AngularJS</h4><ul>\n<li>绑定 数据与数据、数据与视图之间的关系</li>\n<li>npm</li>\n</ul>\n<h4 id=\"React\"><a href=\"#React\" class=\"headerlink\" title=\"React\"></a>React</h4><ul>\n<li>用 js 写界面……（似乎是一种倒退）</li>\n<li>还整个 JSX 让界面好写一点</li>\n<li>React Native</li>\n</ul>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><ul>\n<li>前端风起云涌 {:&amp;.rollIn}</li>\n<li>小扎灭我客户端之心不死</li>\n</ul>\n<h3 id=\"总的总结\"><a href=\"#总的总结\" class=\"headerlink\" title=\"总的总结\"></a>总的总结</h3><ul>\n<li>拥抱变化</li>\n<li>最差也可以变最好，关键要敢于拥抱变化</li>\n<li>技术紧迫感：勇于尝试新东西</li>\n<li>业务紧迫感：技术改变留学</li>\n</ul>\n<h3 id=\"推荐：\"><a href=\"#推荐：\" class=\"headerlink\" title=\"推荐：\"></a>推荐：</h3><ul>\n<li>JavaScript - The World’s Best Programming Language</li>\n<li>pure-native移动跨平台架构设计与实战</li>\n<li>注重实效的性能</li>\n<li>ReactJS 实战</li>\n<li>ELE.ME是如何运行的</li>\n</ul>\n<h2 id=\"Android-6-0运行权限-王胜\"><a href=\"#Android-6-0运行权限-王胜\" class=\"headerlink\" title=\"Android 6.0运行权限 - 王胜\"></a>Android 6.0运行权限 - 王胜</h2><h3 id=\"一般权限和危险权限\"><a href=\"#一般权限和危险权限\" class=\"headerlink\" title=\"一般权限和危险权限\"></a>一般权限和危险权限</h3><p>Android 6.0以前，所有的权限在应用安装或者更新时自动完成授权。如果用户想安装这个App，必需接受所有的权限申请。为了保护用户的隐私，Android M特意调整了Android的授权架构。将应用权限分为一般(Normal)和危险(Dangerous)两种级别的权限:</p>\n<ul>\n<li><p>一般权限不会直接危害用户的隐私。如果你的App在manifest列出一般权限，那么系统会自动授予这些权限。</p>\n</li>\n<li><p>危险权限可以访问用户的隐私数据。 如果你的App在manifest列出一般权限，那么系统会自动授予这些权限。如果列出危险权限，需要通过用户显示交互通过你的应用权限申请。</p>\n</li>\n</ul>\n<h3 id=\"权限组\"><a href=\"#权限组\" class=\"headerlink\" title=\"权限组\"></a>权限组</h3><p>Anroid系统里所有的危险权限都拥有所归属的权限组。如果设备运行在Android6.0(API level 23)，并且App的targetSdkVersion是23或者更高，当App请求危险权限时将会有以下表现：</p>\n<ul>\n<li><p>如果App请求manifest里声明的危险权限，并且App当前还没有获取任何权限组里的权限，系统将弹出一个描述App想要访问权限的对话框。但是对话框不会描述该权限属于哪个权限组。例如：App请求权限 <strong>READ_CONTACTS</strong>  ，系统对话框只显示App需要访问设备的联系人。如果用户授权通过，系统仅仅给App需要的权限。</p>\n</li>\n<li><p>如果App请求manifest里声明的危险权限，并且App已经用户该危险权限所在的权限组的权限，系统则直接授予此次请求的权限，而不需要用户手动交互。例如：如果App已经有先前的 <strong>READ_CONTACTS</strong> 权限，那么再请求 <strong>WRITE_CONTACTS</strong> 权限，系统则直接授予。</p>\n</li>\n</ul>\n<blockquote>\n<p>任何权限都有所归属的权限组，包括一般权限和App自定义的权限。然而，权限组只影响那些危险权限相关的用户体验。你可以忽略一般权限的权限组。</p>\n</blockquote>\n<p><strong>危险权限和权限组</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">权限组</th>\n<th style=\"text-align:center\">权限</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">CALENDAR</td>\n<td style=\"text-align:center\"><ul><li>READ_CALENDAR</li><li>WRITE_CALENDAR</li></ul></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">CAMERA</td>\n<td style=\"text-align:center\"><ul><li>CAMERA</li></ul></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">CONTACTS</td>\n<td style=\"text-align:center\"><ul><li>READ_CONTACTS</li><li> WRITE_CONTACTS</li><li>GET_ACCOUNTS</li></ul></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">LOCATION</td>\n<td style=\"text-align:center\"><ul><li>ACCESS_FINE_LOCATION</li><li> ACCESS_COARSE_LOCATION</li></ul></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">MICROPHONE</td>\n<td style=\"text-align:center\"><ul><li>RECORD_AUDIO</li></ul></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">PHONE</td>\n<td style=\"text-align:center\"><ul><li>READ_PHONE_STATE</li><li>CALL_PHONE</li><li>READ_CALL_LOG</li><li>WRITE_CALL_LOG</li><li> ADD_VOICEMAIL</li><li>USE_SIP</li><li> PROCESS_OUTGOING_CALLS</li></ul></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">SENSORS</td>\n<td style=\"text-align:center\"><ul><li>BODY_SENSORS</li></ul></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">SMS</td>\n<td style=\"text-align:center\"><ul><li>SEND_SMS</li><li>RECEIVE_SMS</li><li> READ_SMS</li><li>RECEIVE_WAP_PUSH</li><li>RECEIVE_MMS</li></ul></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">STORAGE</td>\n<td style=\"text-align:center\"><ul><li>READ_EXTERNAL_STORAGE</li><li> WRITE_EXTERNAL_STORAGE</li></ul></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"权限检测\"><a href=\"#权限检测\" class=\"headerlink\" title=\"权限检测\"></a>权限检测</h3><p>Android的所有版本里，都需要将所需的一般权限和危险权限都声明在App的manifest里。然而这些声明在不同的系统版本和App的target SDK Level会有不同的影响:</p>\n<ul>\n<li><p>如果设备运行在Android 5.1或者更低，或者你的App target SDK是22或者更低：如果你在manifest里声明了危险权限，用户则不得不在安装App时给予授权；如果他们不授权，系统将不会安装此App。</p>\n</li>\n<li><p>如果设备运行在Android 6.0或者更高，或者你的App target SDK是23或者更高：App不仅需要在manifest里声明危险权限，而且App在运行时还需要在每次需要危险权限时发起请求。用户可以接受也可以拒绝权限申请，App也需要在用户拒绝危险权限申请时能长长运行。</p>\n</li>\n</ul>\n<blockquote>\n<p>注意：此处的权限处理只有App的target API level 23或者更高，而且运行在Android 6.0 (API level 23)或者更高的设备上才会如此。如果设备的中App的targetSdkVersion 是 22或者更低，系统则在安装或者更新App时自动授予危险权限。</p>\n</blockquote>\n<p><a href=\"http://developer.android.com/tools/support-library/index.html\" target=\"_blank\" rel=\"noopener\">The Android Support Library</a>能很好地处理检测、请求和权限。Android 6.0 (API level 23) framework也提供了类似的方法。然而，使用support库能更简单一些，因为你不需要在调用方法之前检测android系统的版本。 </p>\n<h3 id=\"发起权限申请请求\"><a href=\"#发起权限申请请求\" class=\"headerlink\" title=\"发起权限申请请求\"></a>发起权限申请请求</h3><pre><code class=\"Java\">// Here, this Activity is the current activity\nif (ContextCompat.checkSelfPermission(thisActivity,\n                Manifest.permission.READ_CONTACTS)\n        != PackageManager.PERMISSION_GRANTED) {\n\n    // Should we show an explanation?\n    if (ActivityCompat.shouldShowRequestPermissionRationale(thisActivity,\n            Manifest.permission.READ_CONTACTS)) {\n\n        // Show an expanation to the user *asynchronously* -- don&#39;t block\n        // this thread waiting for the user&#39;s response! After the user\n        // sees the explanation, try again to request the permission.\n\n    } else {\n\n        // No explanation needed, we can request the permission.\n\n        ActivityCompat.requestPermissions(thisActivity,\n                new String[]{Manifest.permission.READ_CONTACTS},\n                MY_PERMISSIONS_REQUEST_READ_CONTACTS);\n\n        // MY_PERMISSIONS_REQUEST_READ_CONTACTS is an\n        // app-defined int constant. The callback method gets the\n        // result of the request.\n    }\n}\n</code></pre>\n<h3 id=\"处理权限请求结果\"><a href=\"#处理权限请求结果\" class=\"headerlink\" title=\"处理权限请求结果\"></a>处理权限请求结果</h3><pre><code class=\"Java\">@Override\npublic void onRequestPermissionsResult(int requestCode,\n        String permissions[], int[] grantResults) {\n    switch (requestCode) {\n        case MY_PERMISSIONS_REQUEST_READ_CONTACTS: {\n            // If request is cancelled, the result arrays are empty.\n            if (grantResults.length &gt; 0\n                &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) {\n\n                // permission was granted, yay! Do the\n                // contacts-related task you need to do.\n\n            } else {\n\n                // permission denied, boo! Disable the\n                // functionality that depends on this permission.\n            }\n            return;\n        }\n\n        // other &#39;case&#39; lines to check for other\n        // permissions this app might request\n    }\n}\n</code></pre>\n<blockquote>\n<p>注意：每次需要权限时，都需要显示请求调用，即使你已经获得的同权限组的其他权限。另外，权限分组处理的机制在将来的Android发型版本中有可能更改。因此你的App不应该依赖所需的权限在或者不在同一个权限组里。</p>\n</blockquote>\n<p>参考：</p>\n<ul>\n<li><a href=\"http://developer.android.com/training/permissions/requesting.html\" target=\"_blank\" rel=\"noopener\">Requesting Permissions at Run Time</a></li>\n<li><a href=\"http://developer.android.com/training/permissions/best-practices.html\" target=\"_blank\" rel=\"noopener\">Permissions Best Practices</a></li>\n</ul>\n<p>##Swift Access Control - 潘君<br>(未完待续)</p>\n<ul>\n<li><p>三个级别</p>\n<ul>\n<li>Public</li>\n<li>Internal</li>\n<li><p>Private</p>\n<p>大部分默认是internal</p>\n</li>\n</ul>\n</li>\n<li><p>可应用于</p>\n<ul>\n<li>Module<ul>\n<li>application</li>\n<li>framework</li>\n</ul>\n</li>\n<li>source file<ul>\n<li>properties</li>\n<li>types</li>\n<li>functions</li>\n<li>and so on（苹果文档这个太二了）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>准则</p>\n<ul>\n<li>public变量不能定义为internal或者private的类型</li>\n<li>函数的访问权限不能高于参数和返回值</li>\n</ul>\n</li>\n<li><p>应用场景</p>\n<ul>\n<li>Single-Target Apps    Internal</li>\n<li>Frameworks  Public</li>\n<li>Unit Test Targets      @testable<img src=\"./1446175520419.png\" alt=\"Alt text\"></li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>会级联影响 例如修饰了type 同时也会影响type的members<br>```<br>public class SomePublicClass {          // explicitly public class<br>  public var somePublicProperty = 0    // explicitly public class member<br>  var someInternalProperty = 0         // implicitly internal class member<br>  private func somePrivateMethod() {}  // explicitly private class member<br>}</li>\n</ul>\n<p>class SomeInternalClass {               // implicitly internal class<br>    var someInternalProperty = 0         // implicitly internal class member<br>    private func somePrivateMethod() {}  // explicitly private class member<br>}</p>\n<p>private class SomePrivateClass {        // explicitly private class<br>    var somePrivateProperty = 0          // implicitly private class member<br>    func somePrivateMethod() {}          // implicitly private class member<br>}</p>\n<pre><code>\n- Function\n\n- Tuple\n    - 取元素中访问level最小的为准\n    - 例如 （PrivateClass, InternalClass） 则取private\n\n- Enumeration \n    - 一样\n\n- class\n</code></pre><p>public class A {<br>    private func someMethod() {}<br>}</p>\n<p>internal class B: A {<br>    override internal func someMethod() {}<br>}<br>```</p>\n"},{"title":"扯扯线程并发和同步的那些事","date":"2015-06-26T23:04:29.000Z","_content":"\n\n## 扯扯线程并发和同步的那些事 2015.6.26\n\n### 线程基础的那些事——李仙鹏\n\n#### 线程\n\n线程俗称为轻量级进程。在现代OS中，通常以线程作为基本的调度单位。线程会共享进程范围内的资源，例如内存句柄和文件句柄，但每个线程又有各自的程序计数器、栈以及局部变量等。因此，再配合多核CPU，多个线程方可被并发执行。\n\n##### 线程的上下文切换\n\n如果当前运行线程数与CPU核数相同，那么这些线程将不会被系统调度出去。\n\n但是，如果可运行的线程数量大于CPU核数，那么系统会通过上下文切换，将某个正在运行的线程调度出来，从而使其他线程能够获得CPU的时间片，从而得到运行。\n\n**上下文切换需要一定的开销：**\n\n1. 系统和应用程序都使用一组相同的CPU，线程调度需要访问系统资源。系统代码消耗越多的CPU时间，分配到应用程序的可用CPU时间就越少。\n2. 上下文切换会导致处理器的一些缓存缺失\n\n> 线程的以上特性，促使了现代编程的并发和同步问题：\n>\n> * 安全性问题。安全性的含义是“永远不会发生糟糕的事情”\n> * 活跃性问题。活跃性关注的目标为“某件正确的事情最终会发生”\n> * 性能问题。性能关注的点事“正确的事情尽快发生”\n\n#### 超线程（Hyper-Threading）\n\n为何我们会经常听到宣传说：四核八线程并行（如I5处理器）、八核十六线程并行（如I7）。原因是，这些CPU使用了超线程技术。超线程最早由因特尔研发，并在奔腾四处理器将技术主流化。\n\n超线程技术是在CPU内部仅复制必要的资源、让CPU模拟成两个线程；也就是一个实体核心，两个逻辑线程，在一单位时间内处理两个线程的工作，模拟实体双核心、双线程运作。\n\n虽然采用超线程技术能同时执行两个线程，但它并不象两个真正的CPU那样，每个CPU都具有独立的资源。当两个线程都同时需要某一个资源时，其中一个要暂时停止，并让出资源，直到这些资源闲置后才能继续。因此超线程的性能并不等于两颗CPU的性能。\n\n#### GUI为什么都是单线程\n\n许多人曾经尝试过编写多线程的GUI来处理事件，但最终都由于竞态条件和死锁导致的稳定性而重回到单线程的事件队列模型：使用UI线程从队列中抽取事件，并将事件分发给事件处理器（消费者）。\n\n另一个重要原因是MVC会导致多线程的GUI因为不一致的锁定顺序而发生死锁。\n![MVC模式图](http://www.51cto.com/files/uploadimg/20061010/1202170.gif)\n\n#### 推荐两本书\n\n> **值得一看：**\n\n> * [深入理解计算机系统](http://book.douban.com/subject/5333562/)\n> * [Java并发编程实战](http://book.douban.com/subject/10484692/)\n\n### JAVA多线程中的单例——贾学涛\n\n#### 常见单利模写法\n\n\n\tpublic class Singleton {  \n\n\t\tprivate static Singleton mInstance；\n\n\t\tprivate Singleton(){\n\t\t}\n\n\t\tpublic static Singleton getInstance(){\n\t\t\tif (mInstance == null) {\n\t\t\t\tmInstance = new Singleton();\n\t\t\t}\n\t\t\treturn mInstance;\n\t\t}\n\t}\n\n* 缺点：非线程安全的，在多线程并发的情况下容易出现多个实例存在的情况\n\n#### 改为线程安全的单例模式\n通过添加synchronized关键字  \n\n\tpublic class Singleton {  \n\n\t\tprivate static Singleton mInstance；\n\n\t\tprivate Singleton(){\n\t\t}\n\n\t\tpublic static synchronized Singleton getInstance(){\n\t\t\tif (mInstance == null) {\n\t\t\t\tmInstance = new Singleton();\n\t\t\t}\n\t\t\treturn mInstance;\n\t\t}\n\t}\n\n* 缺点：每次都要进行同步检查，实际上需要检查的时机是在首次创建实例的时候。\n\n#### 改为双重检查锁单例模式\n\n\tpublic class Singleton {  \n\n\t\tprivate static Singleton mInstance；\n\n\t\tprivate Singleton(){\n\t\t}\n\n\t\tpublic static Singleton getInstance(){\n\t\t\tif (mInstance == null) {          //Single Checked\n\t\t\t\tsynchronized(Singleton.class) {\n\t\t\t\t\tif (mInstance == null) {        //Double Checked\n\t\t\t\t\t\tmInstance = new Singleton();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn mInstance;\n\t\t}\n\t}\n\n* instance = new Singleton()这句，并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情  \n\n\t> 1.给 instance 分配内存  \n\t> 2.调用 Singleton 的构造函数来初始化成员变量  \n\t> 3.将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了）  \n\n\t但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的.可能会出现第一次检测是mInstance为非null时，有可能实例还未创建。所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。\n\n#### 为实例变量增加volatile关键字\n\n\tpublic class Singleton {  \n\n\t\tprivate volatile static Singleton mInstance；    // 增加volatile关键字\n\n\t\tprivate Singleton(){\n\t\t}\n\n\t\tpublic static Singleton getInstance(){\n\t\t\tif (mInstance == null) {          //Single Checked\n\t\t\t\tsynchronized(Singleton.class) {\n\t\t\t\t\tif (mInstance == null) {        //Double Checked\n\t\t\t\t\t\tmInstance = new Singleton();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn mInstance;\n\t\t}\n\t}\n\n* 使用 volatile 的主要原因是其另一个特性：禁止指令重排序优化。也就是说，在 volatile 变量的赋值操作后面会有一个内存屏障，读操作不会被重排序到内存屏障之前\n\n* Java 5 以前的版本使用了 volatile 的双检锁还是有问题的。其原因是 Java 5 以前的 JMM （Java 内存模型）是存在缺陷的，即时将变量声明成 volatile 也不能完全避免重排序\n\n\n#### 饿汉加载单例模式\n\n\tpublic class Singleton {  \n\n\t\tprivate static Singleton mInstance ＝ new Singleton()；\n\n\t\tprivate Singleton(){\n\t\t}\n\n\t\tpublic static Singleton getInstance(){\n\t\t\treturn mInstance;\n\t\t}\n\t}\n\n变种的饿汉加载单例模式\n\n\tpublic class Singleton {\n\n\t\tprivate static Singleton mInstance；\n\n\t\tstatic {\n\t\t\tmInstance = new Singleton();\n\t\t}\n\n\t\tprivate Singleton(){\n\t\t}\n\n\t\tpublic static Singleton getInstance(){\n\t\t\treturn mInstance;\n\t\t}\n\t}\n\n* 缺点：在类被加载的时候就会去创建实例，牺牲空间来保证时间，与之前的单例模式相反，懒汉加载是牺牲时间，来保证空间，在需要的时候再去创建实例。\n\n#### 通过静态内部类来创建单例\n\n\tpublic class Singleton {\n\n\t\tprivate Singleton(){\n\t\t}\n\n\t\tpublic static Singleton getInstance(){\n\t\t\treturn InnerClass.mInstance;\n\t\t}\n\n\t\tprivate staitc class InnerClass{\n\t\t\tpublic static Singleton mInstance = new Singleton();\n\t\t}\n\t}\n* 与前者一样，通过classloader机制来保证线程安全，区别是，前者当Singleton类被加载时，就会创建实例，而后者是在需要调用getInstance的时候去加载内部类的时候，来创建实例。\n\n#### 通过枚举来创建单例\n\n\tpublic enum Singleton {\n\t\tINSTANCE;\n\t}\n\n访问实例对象 Singleton.INSTANCE\n\n*默认枚举实例的创建是线程安全的，但是在枚举中的其他任何方法由程序员自己负责。\n\n### 为什么要有线程同步之喂金鱼问题——曾铭\n\n#### 喂金鱼问题\n- 金鱼一天不吃会饿死，一天吃两次会撑死；\n- 张三、李四，每天每人分别会去执行这件事一次；\n\n#### 方案 1\n\n两人执行一致\n\n```\nif (noFeed) {\n\tfeed fish\n}\n```\n\n张三  \t\t\t\t| 李四\n--- \t\t\t\t| ---\nif (noFeed) {\t\t| .\n. \t\t\t\t\t| if (noFeed) {\n.\t\t\t\t\t| feed fish\nfeed fish\t\t\t| .\nfish died\t\t\t| .\n\n##### 结论\n- feed fish 时间越长，鱼被撑死可能性越大\n- 没解决问题\n\n#### 方案 2\n\n两人执行一致\n\n```\nif (noNote) {\n\tleave note\n\n\tif (noFeed) {\n\t\tfeed fish\n\t}\n\n\tremove note\n}\n```\n\n张三  \t\t\t\t| 李四\n--- \t\t\t\t| ---\nif (noNote) {\t\t| .\n. \t\t\t\t\t| if (noNote) {\n.\t\t\t\t\t| leave note\nleave note\t\t\t| .\nif (noFeed) {\t\t| .\n. \t\t\t\t\t| if (noFeed) {\n.\t\t\t\t\t| feed fish\nfeed fish\t\t\t| .\nfish died\t\t\t| .\n\n##### 结论\n- noNote, noFeed 按特定顺序执行才会出问题\n- noNote 多了一层保护，如果 leave note 时间很短，出问题可能性很小\n- 没解决问题\n\n\n#### 方案 3\n\n张三执行\n\n```\nleave note3\n\nif (noNote4) {\n\tif (noFeed) {\n\t\tfeed fish\n\t}\n}\n\nremove note3\n```\n\n李四执行\n\n```\nleave note4\n\nif (noNote3) {\n\tif (noFeed) {\n\t\tfeed fish\n\t}\n}\n\nremove note4\n```\n\n张三  | 李四\n--- | ---\nleave note3\t\t| .\n. \t\t\t\t\t| leave note4\n.\t\t\t\t\t| if (noNote3) {\nif (noNote4) {\t| .\nremove note3\t| .\n. \t\t\t\t\t| remove note4\n...\t\t\t\t\t| ...\nfish died\t\t\t| .\n\n##### 结论\n- 不会被撑死了，可能会被饿死……\n- 没解决问题\n\n#### 方案 4\n\n张三执行\n\n```\nleave note3\n\nwhile (noNote4)\n{\n\tsleep (1)\n}\n\nif (noFeed) {\n\tfeed fish\n}\n\nremove note3\n```\n\n李四执行\n\n```\nleave note4\n\nif (noNote3) {\n\tif (noFeed) {\n\t\tfeed fish\n\t}\n}\n\nremove note4\n```\n\n##### 结论\n- 的确解决了问题\n- 能优化么？\n\t- 程序不不对称\n\t- 循环等待的浪费\n\n#### 方案 5\n\n两人执行一致\n\n```\nlock()\n\nif (noFeed) {\n\tfeed fish\n}\n\nunlock()\n\n```\n\n##### 总结\n- 能解决问题\n- 程序对称\n- 持有锁需要等待，未解决浪费问题\n\t- 生产者与消费者问题\n\n#### END\n\n**全部内容来自[《计算机的心智·操作系统之哲学原理》——\u0004邹恒明](http://book.douban.com/subject/3670621/) 第七章**\n\n### iOS并发相关的概念介绍——潘君\n@(归纳中)[iOS]\n\n#### 基础概念\n#####竞态条件\n竞态条件（race condition），从多进程间通信的角度来讲，是指两个或多个进程对共享的数据进行读或写的操作时，最终的结果取决于这些进程的执行顺序。\n竞态条件（race condition）是指设备或系统出现不恰当的执行时序，而得到不正确的结果。\n\n注: `atomic` 可以解决竞态竞争 但是无法保证类是`线程安全`的\n\n#### iOS中的相关概念\n#####atomic属性\n\n> property 修饰符\n\n加了atomic后生成的setter,类似如下代码:\n\n```\n- (void)setProp:(NSString *)newValue {\n    [_prop lock];\n    _prop = newValue;\n    [_prop unlock];\n}\n```\n\n\n#####@synchronized指令\n\n> 引用自[@synchronized(id anObject) ｛｝定义和使用](http://www.xuebuyuan.com/1682784.html)\n> 1.作用：创建了一个互斥锁，它的作用和其他语言中的互斥锁作用一样\n\n> 2.解释：这个是OBC中的一个锁定令牌，防止｛｝里的内容在同一时间内被其他线程访问，起到了线程保护的作用\n\n> 3.使用范围：一般在单例模式或者操作类的static变量的时候使用，即共用的变量的时候\n\n> 4.外延：这个令牌隐式的包含了异常处理，如果你不想使用的话，就使用锁吧\n\n> 5.它的参数是id类型，如果用\n> @synchronized(1) {\n> }\n> 编译器提示\n> @synchronzied requires an Objective-C object type.\n> 也就是说需要一个objective C的对象类型。\n\n```\n@synchronized(id anObject){\n\t // test code\n}\n```\n\n#####NSLock\n\n使用样例:\n\n```\n//主线程中\nTestObj *obj = [[TestObj alloc] init];\nNSLock *lock = [[NSLock alloc] init];\n\n//线程1\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n    [lock lock];\n    [obj method1];\n    sleep(10);\n    [lock unlock];\n});\n\n//线程2\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n    sleep(1);//以保证让线程2的代码后执行\n    [lock lock];\n    [obj method2];\n    [lock unlock];\n});\n```\n\n\n###[iOS多线程](https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/Introduction/Introduction.html) - 杨志平\n\n####简介\n\niOS有三种多线程编程的技术，分别是：\n\n- #### NSThread\n- #### Cocoa NSOperation\n- #### GCD ***（全称：Grand Central Dispatch）***\n\n>  *这三种编程方式从上到下，抽象度层次是从低到高的，抽象度越高的使用越简单，也是Apple最推荐使用的*\n\n\n#### 三种方式的介绍：\n##### NSThread - [文档](https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Reference/Foundation/Classes/NSThread_Class/)\n> 优点：NSThread 比其他两个轻量级\n> 缺点：需要自己管理线程的生命周期，线程同步。线程同步对数据的加锁会有一定的系统开销\n\n##### NSOperation - [文档](https://developer.apple.com/library/mac/documentation/Cocoa/Reference/NSOperation_class/)\n> 优点：不需要关心线程管理，数据同步的事情，可以把精力放在自己需要执行的操作上。\n>创建NSOperation子类的对象，把对象添加到NSOperationQueue队列里执行。\n\n##### GCD - [文档](https://developer.apple.com/library/prerelease/ios/documentation/Performance/Reference/GCD_libdispatch_Ref/index.html)\n> Grand Central Dispatch (GCD)是Apple开发的一个多核编程的解决方法。在iOS4.0开始之后才能使用。GCD是一个替代诸如NSThread, NSOperationQueue, NSInvocationOperation等技术的很高效和强大的技术。\n\n\n>GCD的底层依然是用线程实现，不过这样可以让程序员不用关注实现的细节。\n\n\n#### 创建线程的开销 - [查看文档](https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/CreatingThreads/CreatingThreads.html)\nItem | Approximate cost | Notes\n----- | ----- | -----\nKernel data structures   |  Approximately 1 KB  |  This memory is used to store the thread data structures and attributes, much of which is allocated as wired memory and therefore cannot be paged to disk.\nStack space | 512 KB (secondary threads)  8 MB (OS X main thread)  1 MB (iOS main thread) | The minimum allowed stack size for secondary threads is 16 KB and the stack size must be a multiple of 4 KB. The space for this memory is set aside in your process space at thread creation time, but the actual pages associated with that memory are not created until they are needed.\nCreation time | Approximately 90 microseconds | This value reflects the time between the initial call to create the thread and the time at which the thread’s entry point routine began executing. The figures were determined by analyzing the mean and median values generated during thread creation on an Intel-based iMac with a 2 GHz Core Duo processor and 1 GB of RAM running OS X v10.5.\n\n\n#### 替代线程的一些技术\n\nItem | Approximate cost\n----- | -----\nOperation objects | Introduced in OS X v10.5, an operation object is a wrapper for a task that would normally be executed on a secondary thread. This wrapper hides the thread management aspects of performing the task, leaving you free to focus on the task itself. You typically use these objects in conjunction with an operation queue object, which actually manages the execution of the operation objects on one or more threads.For more information on how to use operation objects, see [Concurrency Programming Guide](https://developer.apple.com/library/mac/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008091).\nGrand Central Dispatch (GCD) | Introduced in Mac OS x v10.6, Grand Central Dispatch is another alternative to threads that lets you focus on the tasks you need to perform rather than on thread management. With GCD, you define the task you want to perform and add it to a work queue, which handles the scheduling of your task on an appropriate thread. Work queues take into account the number of available cores and the current load to execute your tasks more efficiently than you could do yourself using threads.For information on how to use GCD and work queues, see [Concurrency Programming Guide](https://developer.apple.com/library/mac/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008091)\nIdle-time notifications | For tasks that are relatively short and very low priority, idle time notifications let you perform the task at a time when your application is not as busy. Cocoa provides support for idle-time notifications using the NSNotificationQueue object. To request an idle-time notification, post a notification to the default [NSNotificationQueue](https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSNotificationQueue_Class/index.html#//apple_ref/occ/cl/NSNotificationQueue) object using the [NSPostWhenIdle](https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSNotificationQueue_Class/index.html#//apple_ref/c/econst/NSPostWhenIdle) option. The queue delays the delivery of your notification object until the run loop becomes idle. For more information, see [Notification Programming Topics](https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Notifications/Introduction/introNotifications.html#//apple_ref/doc/uid/10000043i).\nAsynchronous functions | The system interfaces include many asynchronous functions that provide automatic concurrency for you. These APIs may use system daemons and processes or create custom threads to perform their task and return the results to you. (The actual implementation is irrelevant because it is separated from your code.) As you design your application, look for functions that offer asynchronous behavior and consider using them instead of using the equivalent synchronous function on a custom thread\nTimers | You can use timers on your application’s main thread to perform periodic tasks that are too trivial to require a thread, but which still require servicing at regular intervals. For information on timers, see [Timer Sources](https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW21)\nSeparate processes | Although more heavyweight than threads, creating a separate process might be useful in cases where the task is only tangentially related to your application. You might use a process if a task requires a significant amount of memory or must be executed using root privileges. For example, you might use a 64-bit server process to compute a large data set while your 32-bit application displays the results to the user\n\n#### 线程安全 - [文档](https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/ThreadSafetySummary/ThreadSafetySummary.html#//apple_ref/doc/uid/10000057i-CH12-SW1)\n\n##### 原则\n- Immutable objects are generally thread-safe. Once you create them, you can safely pass these objects to and from threads. On the other hand, mutable objects are generally not thread-safe. To use mutable objects in a threaded application, the application must synchronize appropriately.\n- Many objects deemed “thread-unsafe” are only unsafe to use from multiple threads. Many of these objects can be used from any thread as long as it is only one thread at a time. Objects that are specifically restricted to the main thread of an application are called out as such\n- The main thread of the application is responsible for handling events. Although the Application Kit continues to work if other threads are involved in the event path, operations can occur out of sequence\n- If you want to use a thread to draw to a view, bracket all drawing code between the ***lockFocusIfCanDraw*** and ***unlockFocus*** methods of NSView\n\n##### Thread-Safe Classes and Functions\nThe following classes and functions are generally considered to be thread-safe. You can use the same instance from multiple threads without first acquiring a lock.\n> NSArray\nNSAssertionHandler\nNSAttributedString\nNSCalendarDate\nNSCharacterSet\nNSConditionLock\nNSConnection\nNSData\nNSDate\nNSDecimal functions\nNSDecimalNumber\nNSDecimalNumberHandler\nNSDeserializer\nNSDictionary\nNSDistantObject\nNSDistributedLock\nNSDistributedNotificationCenter\nNSException\nNSFileManager (in OS X v10.5 and later)\nNSHost\nNSLock\nNSLog/NSLogv\nNSMethodSignature\nNSNotification\nNSNotificationCenter\nNSNumber\nNSObject\nNSPortCoder\nNSPortMessage\nNSPortNameServer\nNSProtocolChecker\nNSProxy\nNSRecursiveLock\nNSSet\nNSString\nNSThread\nNSTimer\nNSTimeZone\nNSUserDefaults\nNSValue\n\n##### Thread-Unsafe Classes\nThe following classes and functions are generally not thread-safe. In most cases, you can use these classes from any thread as long as you use them from only one thread at a time.\n\n>NSArchiver\nNSAutoreleasePool\nNSBundle\nNSCalendar\nNSCoder\nNSCountedSet\nNSDateFormatter\nNSEnumerator\nNSFileHandle\nNSFormatter\nNSHashTable functions\nNSInvocation\nNSJavaSetup functions\nNSMapTable functions\nNSMutableArray\nNSMutableAttributedString\nNSMutableCharacterSet\nNSMutableData\nNSMutableDictionary\nNSMutableSet\nNSMutableString\nNSNotificationQueue\nNSNumberFormatter\nNSPipe\nNSPort\nNSProcessInfo\nNSRunLoop\nNSScanner\nNSSerializer\nNSTask\nNSUnarchiver\nNSUndoManager\n\n#####Main Thread Only Classes\n\nThe following class must be used only from the main thread of an application.\n\n> NSAppleScript\n\n### 多线程的死锁 - 张超耀\n- 俗话说，人多好办事！在程序里也是这样，如果是同一个应用程序需要并行处理多件任务，那就可以创建多条线程。但是人多了，往往会出现冲突，使得这个工作无法再进行下去了(正所谓三个和尚没水喝)，这就是“死锁”。\n\n#### 死锁的产生\n- [哲学家进餐问题](http://baike.baidu.com/link?url=OgOrpH_xTP7U0C0tM59aBhq83uaKe0Ck9MQEL1G41A3q-D1hVuynm3ra-U93RoQICKbmqhs7nTuCoN_elydnr_)\n\n**那么我们如何来消除“死锁”呢？首先，让我们来看看产生“死锁”的必要条件：**\n\n- 互斥：就是说多个线程不能同时使用同一资源\n\n- 请求和保持：就是某线程必须同时拥有多个资源才能完成任务，否则它将占用已经拥有的资源直到拥有他所需的所有资源为止\n\n- 不剥夺：就是说所有线程的优先级都相同，不能在别的线程没有释放资源的情况下，夺走其已占有的资源\n\n- 循环等待，就是没有资源满足的线程无限期地等待\n\n**有的朋友可能已经明白了，只要打破这这几个必要条件，就能打破“死锁”！**\n\n- 互斥：就是要让多个线程能共享资源\n\n- 请求和保持：只要当检测到自己所需的资源仍被别的线程占用，即释放自己已占有的资源（毫不利己，专门利人），或者在经过一段时间的等待后，还未得到所需资源，才释放，这都能打破请求和保持\n\n- 不剥夺：只要给线程制定一个优先级即可\n\n- 最后的循环等待的解决方法其实和`请求和保持`是一样的，都是等待一段时间后释放资源。\n\n**好了，希望通过这个例子能让不了解死锁的朋友对“死锁”能有一定的认识**\n\n## 集合的并行操作 - 王胜\n\n用for循环操作一个集合，即读取集合元素，同时又删除集合中的元素，会发生什么事情呢？\n\n上代码【号外，号外，此示例来源于我们项目中的真实代码哦~】\n\n```Java\n// Target class\nclass Target {\n\tint id;// ID\n\tString type;// 类型\n\tint count;// 未读消息数\n\n\tpublic Target(int id, String type, int count) {\n\t\tthis.id = id;\n\t\tthis.type = type;\n\t\tthis.count = count;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"Target [id=\" + id + \", type=\" + type + \", count=\" + count + \"]\";\n\t}\n\n}\n\n// 以下是模拟一组target集合，target包含group、room、user类型。\nList<Target> sessions = new ArrayList<Target>();\nsessions.add(new Target(1, \"group\", 1));\nsessions.add(new Target(2, \"group\", 1));\nsessions.add(new Target(3, \"group\", 1));\nsessions.add(new Target(4, \"room\", 1));\nsessions.add(new Target(5, \"group\", 1));\nsessions.add(new Target(6, \"group\", 1));\nsessions.add(new Target(7, \"group\", 1));\nsessions.add(new Target(8, \"user\", 1));\nsessions.add(new Target(9, \"user\", 1));\nsessions.add(new Target(10, \"group\", 1));\nSystem.out.println(\"before size:\"+sessions.size()+\", sessions:\"+humanPrintList(sessions));\nint totalUnread = 0;// 统计集合中类型为group的target未读消息数量\nfor (int i=0;i<sessions.size();i++) {\n\tSystem.out.println(\"read index:\" + i + \", session:\"+sessions.get(i));\n\tif (sessions.get(i).type.equals(\"group\")) {// 如果是group类型，则累加未读消息数\n\t\tSystem.out.println(\"==> add totalUnread\");\n\t\ttotalUnread += sessions.get(i).count;\n\t} else {// 否则，将target移除集合\n\t\tSystem.out.println(\"==> remove\");\n\t\tsessions.remove(i);\n\t}\n}\nSystem.out.println(\"after size:\"+sessions.size()+\", totalUnread:\"+totalUnread+\",sessions:\"+humanPrintList(sessions));\n```\n\n至此，示例代码结束。大家可以猜测下最后的输出中sessions的长度，内容以及总共的未读消息数据。\n\n项目中的代码，期望结果是剩余集合只包含group类型的target，而且totalUnread的值是类型为group的target的未读消息数之和。可是，运行的结果却是：\n\n```\nbefore size:10, sessions:\n========== List content: ===========\nTarget [id=1, type=group, count=1]\nTarget [id=2, type=group, count=1]\nTarget [id=3, type=group, count=1]\nTarget [id=4, type=room, count=1]\nTarget [id=5, type=group, count=1]\nTarget [id=6, type=group, count=1]\nTarget [id=7, type=group, count=1]\nTarget [id=8, type=user, count=1]\nTarget [id=9, type=user, count=1]\nTarget [id=10, type=group, count=1]\n====================================\nread index:0, session:Target [id=1, type=group, count=1]\n==> add totalUnread\nread index:1, session:Target [id=2, type=group, count=1]\n==> add totalUnread\nread index:2, session:Target [id=3, type=group, count=1]\n==> add totalUnread\nread index:3, session:Target [id=4, type=room, count=1]\n==> remove\nread index:4, session:Target [id=6, type=group, count=1]\n==> add totalUnread\nread index:5, session:Target [id=7, type=group, count=1]\n==> add totalUnread\nread index:6, session:Target [id=8, type=user, count=1]\n==> remove\nread index:7, session:Target [id=10, type=group, count=1]\n==> add totalUnread\nafter size:8, totalUnread:6,sessions:\n========== List content: ===========\nTarget [id=1, type=group, count=1]\nTarget [id=2, type=group, count=1]\nTarget [id=3, type=group, count=1]\nTarget [id=5, type=group, count=1]\nTarget [id=6, type=group, count=1]\nTarget [id=7, type=group, count=1]\nTarget [id=9, type=user, count=1]\nTarget [id=10, type=group, count=1]\n====================================\n```\n\n为什么结果完全不是预期的呢？原因是程序走到else时，将元素移除，后面的元素自动往前移动，所以继续取下一个下标时，被移除的后一个元素悄悄溜走了，成了漏网之鱼。\n\n**解决方法** : 最简单的就是在remove后执行 ```i--; ```\n","source":"_posts/线程并发和同步.md","raw":"title: 扯扯线程并发和同步的那些事\ndate: 2015-06-26 23:04:29\ntags:\n- 线程\n- 同步异步\ncategories: 移动组周分享\n\n---\n\n\n## 扯扯线程并发和同步的那些事 2015.6.26\n\n### 线程基础的那些事——李仙鹏\n\n#### 线程\n\n线程俗称为轻量级进程。在现代OS中，通常以线程作为基本的调度单位。线程会共享进程范围内的资源，例如内存句柄和文件句柄，但每个线程又有各自的程序计数器、栈以及局部变量等。因此，再配合多核CPU，多个线程方可被并发执行。\n\n##### 线程的上下文切换\n\n如果当前运行线程数与CPU核数相同，那么这些线程将不会被系统调度出去。\n\n但是，如果可运行的线程数量大于CPU核数，那么系统会通过上下文切换，将某个正在运行的线程调度出来，从而使其他线程能够获得CPU的时间片，从而得到运行。\n\n**上下文切换需要一定的开销：**\n\n1. 系统和应用程序都使用一组相同的CPU，线程调度需要访问系统资源。系统代码消耗越多的CPU时间，分配到应用程序的可用CPU时间就越少。\n2. 上下文切换会导致处理器的一些缓存缺失\n\n> 线程的以上特性，促使了现代编程的并发和同步问题：\n>\n> * 安全性问题。安全性的含义是“永远不会发生糟糕的事情”\n> * 活跃性问题。活跃性关注的目标为“某件正确的事情最终会发生”\n> * 性能问题。性能关注的点事“正确的事情尽快发生”\n\n#### 超线程（Hyper-Threading）\n\n为何我们会经常听到宣传说：四核八线程并行（如I5处理器）、八核十六线程并行（如I7）。原因是，这些CPU使用了超线程技术。超线程最早由因特尔研发，并在奔腾四处理器将技术主流化。\n\n超线程技术是在CPU内部仅复制必要的资源、让CPU模拟成两个线程；也就是一个实体核心，两个逻辑线程，在一单位时间内处理两个线程的工作，模拟实体双核心、双线程运作。\n\n虽然采用超线程技术能同时执行两个线程，但它并不象两个真正的CPU那样，每个CPU都具有独立的资源。当两个线程都同时需要某一个资源时，其中一个要暂时停止，并让出资源，直到这些资源闲置后才能继续。因此超线程的性能并不等于两颗CPU的性能。\n\n#### GUI为什么都是单线程\n\n许多人曾经尝试过编写多线程的GUI来处理事件，但最终都由于竞态条件和死锁导致的稳定性而重回到单线程的事件队列模型：使用UI线程从队列中抽取事件，并将事件分发给事件处理器（消费者）。\n\n另一个重要原因是MVC会导致多线程的GUI因为不一致的锁定顺序而发生死锁。\n![MVC模式图](http://www.51cto.com/files/uploadimg/20061010/1202170.gif)\n\n#### 推荐两本书\n\n> **值得一看：**\n\n> * [深入理解计算机系统](http://book.douban.com/subject/5333562/)\n> * [Java并发编程实战](http://book.douban.com/subject/10484692/)\n\n### JAVA多线程中的单例——贾学涛\n\n#### 常见单利模写法\n\n\n\tpublic class Singleton {  \n\n\t\tprivate static Singleton mInstance；\n\n\t\tprivate Singleton(){\n\t\t}\n\n\t\tpublic static Singleton getInstance(){\n\t\t\tif (mInstance == null) {\n\t\t\t\tmInstance = new Singleton();\n\t\t\t}\n\t\t\treturn mInstance;\n\t\t}\n\t}\n\n* 缺点：非线程安全的，在多线程并发的情况下容易出现多个实例存在的情况\n\n#### 改为线程安全的单例模式\n通过添加synchronized关键字  \n\n\tpublic class Singleton {  \n\n\t\tprivate static Singleton mInstance；\n\n\t\tprivate Singleton(){\n\t\t}\n\n\t\tpublic static synchronized Singleton getInstance(){\n\t\t\tif (mInstance == null) {\n\t\t\t\tmInstance = new Singleton();\n\t\t\t}\n\t\t\treturn mInstance;\n\t\t}\n\t}\n\n* 缺点：每次都要进行同步检查，实际上需要检查的时机是在首次创建实例的时候。\n\n#### 改为双重检查锁单例模式\n\n\tpublic class Singleton {  \n\n\t\tprivate static Singleton mInstance；\n\n\t\tprivate Singleton(){\n\t\t}\n\n\t\tpublic static Singleton getInstance(){\n\t\t\tif (mInstance == null) {          //Single Checked\n\t\t\t\tsynchronized(Singleton.class) {\n\t\t\t\t\tif (mInstance == null) {        //Double Checked\n\t\t\t\t\t\tmInstance = new Singleton();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn mInstance;\n\t\t}\n\t}\n\n* instance = new Singleton()这句，并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情  \n\n\t> 1.给 instance 分配内存  \n\t> 2.调用 Singleton 的构造函数来初始化成员变量  \n\t> 3.将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了）  \n\n\t但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的.可能会出现第一次检测是mInstance为非null时，有可能实例还未创建。所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。\n\n#### 为实例变量增加volatile关键字\n\n\tpublic class Singleton {  \n\n\t\tprivate volatile static Singleton mInstance；    // 增加volatile关键字\n\n\t\tprivate Singleton(){\n\t\t}\n\n\t\tpublic static Singleton getInstance(){\n\t\t\tif (mInstance == null) {          //Single Checked\n\t\t\t\tsynchronized(Singleton.class) {\n\t\t\t\t\tif (mInstance == null) {        //Double Checked\n\t\t\t\t\t\tmInstance = new Singleton();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn mInstance;\n\t\t}\n\t}\n\n* 使用 volatile 的主要原因是其另一个特性：禁止指令重排序优化。也就是说，在 volatile 变量的赋值操作后面会有一个内存屏障，读操作不会被重排序到内存屏障之前\n\n* Java 5 以前的版本使用了 volatile 的双检锁还是有问题的。其原因是 Java 5 以前的 JMM （Java 内存模型）是存在缺陷的，即时将变量声明成 volatile 也不能完全避免重排序\n\n\n#### 饿汉加载单例模式\n\n\tpublic class Singleton {  \n\n\t\tprivate static Singleton mInstance ＝ new Singleton()；\n\n\t\tprivate Singleton(){\n\t\t}\n\n\t\tpublic static Singleton getInstance(){\n\t\t\treturn mInstance;\n\t\t}\n\t}\n\n变种的饿汉加载单例模式\n\n\tpublic class Singleton {\n\n\t\tprivate static Singleton mInstance；\n\n\t\tstatic {\n\t\t\tmInstance = new Singleton();\n\t\t}\n\n\t\tprivate Singleton(){\n\t\t}\n\n\t\tpublic static Singleton getInstance(){\n\t\t\treturn mInstance;\n\t\t}\n\t}\n\n* 缺点：在类被加载的时候就会去创建实例，牺牲空间来保证时间，与之前的单例模式相反，懒汉加载是牺牲时间，来保证空间，在需要的时候再去创建实例。\n\n#### 通过静态内部类来创建单例\n\n\tpublic class Singleton {\n\n\t\tprivate Singleton(){\n\t\t}\n\n\t\tpublic static Singleton getInstance(){\n\t\t\treturn InnerClass.mInstance;\n\t\t}\n\n\t\tprivate staitc class InnerClass{\n\t\t\tpublic static Singleton mInstance = new Singleton();\n\t\t}\n\t}\n* 与前者一样，通过classloader机制来保证线程安全，区别是，前者当Singleton类被加载时，就会创建实例，而后者是在需要调用getInstance的时候去加载内部类的时候，来创建实例。\n\n#### 通过枚举来创建单例\n\n\tpublic enum Singleton {\n\t\tINSTANCE;\n\t}\n\n访问实例对象 Singleton.INSTANCE\n\n*默认枚举实例的创建是线程安全的，但是在枚举中的其他任何方法由程序员自己负责。\n\n### 为什么要有线程同步之喂金鱼问题——曾铭\n\n#### 喂金鱼问题\n- 金鱼一天不吃会饿死，一天吃两次会撑死；\n- 张三、李四，每天每人分别会去执行这件事一次；\n\n#### 方案 1\n\n两人执行一致\n\n```\nif (noFeed) {\n\tfeed fish\n}\n```\n\n张三  \t\t\t\t| 李四\n--- \t\t\t\t| ---\nif (noFeed) {\t\t| .\n. \t\t\t\t\t| if (noFeed) {\n.\t\t\t\t\t| feed fish\nfeed fish\t\t\t| .\nfish died\t\t\t| .\n\n##### 结论\n- feed fish 时间越长，鱼被撑死可能性越大\n- 没解决问题\n\n#### 方案 2\n\n两人执行一致\n\n```\nif (noNote) {\n\tleave note\n\n\tif (noFeed) {\n\t\tfeed fish\n\t}\n\n\tremove note\n}\n```\n\n张三  \t\t\t\t| 李四\n--- \t\t\t\t| ---\nif (noNote) {\t\t| .\n. \t\t\t\t\t| if (noNote) {\n.\t\t\t\t\t| leave note\nleave note\t\t\t| .\nif (noFeed) {\t\t| .\n. \t\t\t\t\t| if (noFeed) {\n.\t\t\t\t\t| feed fish\nfeed fish\t\t\t| .\nfish died\t\t\t| .\n\n##### 结论\n- noNote, noFeed 按特定顺序执行才会出问题\n- noNote 多了一层保护，如果 leave note 时间很短，出问题可能性很小\n- 没解决问题\n\n\n#### 方案 3\n\n张三执行\n\n```\nleave note3\n\nif (noNote4) {\n\tif (noFeed) {\n\t\tfeed fish\n\t}\n}\n\nremove note3\n```\n\n李四执行\n\n```\nleave note4\n\nif (noNote3) {\n\tif (noFeed) {\n\t\tfeed fish\n\t}\n}\n\nremove note4\n```\n\n张三  | 李四\n--- | ---\nleave note3\t\t| .\n. \t\t\t\t\t| leave note4\n.\t\t\t\t\t| if (noNote3) {\nif (noNote4) {\t| .\nremove note3\t| .\n. \t\t\t\t\t| remove note4\n...\t\t\t\t\t| ...\nfish died\t\t\t| .\n\n##### 结论\n- 不会被撑死了，可能会被饿死……\n- 没解决问题\n\n#### 方案 4\n\n张三执行\n\n```\nleave note3\n\nwhile (noNote4)\n{\n\tsleep (1)\n}\n\nif (noFeed) {\n\tfeed fish\n}\n\nremove note3\n```\n\n李四执行\n\n```\nleave note4\n\nif (noNote3) {\n\tif (noFeed) {\n\t\tfeed fish\n\t}\n}\n\nremove note4\n```\n\n##### 结论\n- 的确解决了问题\n- 能优化么？\n\t- 程序不不对称\n\t- 循环等待的浪费\n\n#### 方案 5\n\n两人执行一致\n\n```\nlock()\n\nif (noFeed) {\n\tfeed fish\n}\n\nunlock()\n\n```\n\n##### 总结\n- 能解决问题\n- 程序对称\n- 持有锁需要等待，未解决浪费问题\n\t- 生产者与消费者问题\n\n#### END\n\n**全部内容来自[《计算机的心智·操作系统之哲学原理》——\u0004邹恒明](http://book.douban.com/subject/3670621/) 第七章**\n\n### iOS并发相关的概念介绍——潘君\n@(归纳中)[iOS]\n\n#### 基础概念\n#####竞态条件\n竞态条件（race condition），从多进程间通信的角度来讲，是指两个或多个进程对共享的数据进行读或写的操作时，最终的结果取决于这些进程的执行顺序。\n竞态条件（race condition）是指设备或系统出现不恰当的执行时序，而得到不正确的结果。\n\n注: `atomic` 可以解决竞态竞争 但是无法保证类是`线程安全`的\n\n#### iOS中的相关概念\n#####atomic属性\n\n> property 修饰符\n\n加了atomic后生成的setter,类似如下代码:\n\n```\n- (void)setProp:(NSString *)newValue {\n    [_prop lock];\n    _prop = newValue;\n    [_prop unlock];\n}\n```\n\n\n#####@synchronized指令\n\n> 引用自[@synchronized(id anObject) ｛｝定义和使用](http://www.xuebuyuan.com/1682784.html)\n> 1.作用：创建了一个互斥锁，它的作用和其他语言中的互斥锁作用一样\n\n> 2.解释：这个是OBC中的一个锁定令牌，防止｛｝里的内容在同一时间内被其他线程访问，起到了线程保护的作用\n\n> 3.使用范围：一般在单例模式或者操作类的static变量的时候使用，即共用的变量的时候\n\n> 4.外延：这个令牌隐式的包含了异常处理，如果你不想使用的话，就使用锁吧\n\n> 5.它的参数是id类型，如果用\n> @synchronized(1) {\n> }\n> 编译器提示\n> @synchronzied requires an Objective-C object type.\n> 也就是说需要一个objective C的对象类型。\n\n```\n@synchronized(id anObject){\n\t // test code\n}\n```\n\n#####NSLock\n\n使用样例:\n\n```\n//主线程中\nTestObj *obj = [[TestObj alloc] init];\nNSLock *lock = [[NSLock alloc] init];\n\n//线程1\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n    [lock lock];\n    [obj method1];\n    sleep(10);\n    [lock unlock];\n});\n\n//线程2\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n    sleep(1);//以保证让线程2的代码后执行\n    [lock lock];\n    [obj method2];\n    [lock unlock];\n});\n```\n\n\n###[iOS多线程](https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/Introduction/Introduction.html) - 杨志平\n\n####简介\n\niOS有三种多线程编程的技术，分别是：\n\n- #### NSThread\n- #### Cocoa NSOperation\n- #### GCD ***（全称：Grand Central Dispatch）***\n\n>  *这三种编程方式从上到下，抽象度层次是从低到高的，抽象度越高的使用越简单，也是Apple最推荐使用的*\n\n\n#### 三种方式的介绍：\n##### NSThread - [文档](https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Reference/Foundation/Classes/NSThread_Class/)\n> 优点：NSThread 比其他两个轻量级\n> 缺点：需要自己管理线程的生命周期，线程同步。线程同步对数据的加锁会有一定的系统开销\n\n##### NSOperation - [文档](https://developer.apple.com/library/mac/documentation/Cocoa/Reference/NSOperation_class/)\n> 优点：不需要关心线程管理，数据同步的事情，可以把精力放在自己需要执行的操作上。\n>创建NSOperation子类的对象，把对象添加到NSOperationQueue队列里执行。\n\n##### GCD - [文档](https://developer.apple.com/library/prerelease/ios/documentation/Performance/Reference/GCD_libdispatch_Ref/index.html)\n> Grand Central Dispatch (GCD)是Apple开发的一个多核编程的解决方法。在iOS4.0开始之后才能使用。GCD是一个替代诸如NSThread, NSOperationQueue, NSInvocationOperation等技术的很高效和强大的技术。\n\n\n>GCD的底层依然是用线程实现，不过这样可以让程序员不用关注实现的细节。\n\n\n#### 创建线程的开销 - [查看文档](https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/CreatingThreads/CreatingThreads.html)\nItem | Approximate cost | Notes\n----- | ----- | -----\nKernel data structures   |  Approximately 1 KB  |  This memory is used to store the thread data structures and attributes, much of which is allocated as wired memory and therefore cannot be paged to disk.\nStack space | 512 KB (secondary threads)  8 MB (OS X main thread)  1 MB (iOS main thread) | The minimum allowed stack size for secondary threads is 16 KB and the stack size must be a multiple of 4 KB. The space for this memory is set aside in your process space at thread creation time, but the actual pages associated with that memory are not created until they are needed.\nCreation time | Approximately 90 microseconds | This value reflects the time between the initial call to create the thread and the time at which the thread’s entry point routine began executing. The figures were determined by analyzing the mean and median values generated during thread creation on an Intel-based iMac with a 2 GHz Core Duo processor and 1 GB of RAM running OS X v10.5.\n\n\n#### 替代线程的一些技术\n\nItem | Approximate cost\n----- | -----\nOperation objects | Introduced in OS X v10.5, an operation object is a wrapper for a task that would normally be executed on a secondary thread. This wrapper hides the thread management aspects of performing the task, leaving you free to focus on the task itself. You typically use these objects in conjunction with an operation queue object, which actually manages the execution of the operation objects on one or more threads.For more information on how to use operation objects, see [Concurrency Programming Guide](https://developer.apple.com/library/mac/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008091).\nGrand Central Dispatch (GCD) | Introduced in Mac OS x v10.6, Grand Central Dispatch is another alternative to threads that lets you focus on the tasks you need to perform rather than on thread management. With GCD, you define the task you want to perform and add it to a work queue, which handles the scheduling of your task on an appropriate thread. Work queues take into account the number of available cores and the current load to execute your tasks more efficiently than you could do yourself using threads.For information on how to use GCD and work queues, see [Concurrency Programming Guide](https://developer.apple.com/library/mac/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008091)\nIdle-time notifications | For tasks that are relatively short and very low priority, idle time notifications let you perform the task at a time when your application is not as busy. Cocoa provides support for idle-time notifications using the NSNotificationQueue object. To request an idle-time notification, post a notification to the default [NSNotificationQueue](https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSNotificationQueue_Class/index.html#//apple_ref/occ/cl/NSNotificationQueue) object using the [NSPostWhenIdle](https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSNotificationQueue_Class/index.html#//apple_ref/c/econst/NSPostWhenIdle) option. The queue delays the delivery of your notification object until the run loop becomes idle. For more information, see [Notification Programming Topics](https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Notifications/Introduction/introNotifications.html#//apple_ref/doc/uid/10000043i).\nAsynchronous functions | The system interfaces include many asynchronous functions that provide automatic concurrency for you. These APIs may use system daemons and processes or create custom threads to perform their task and return the results to you. (The actual implementation is irrelevant because it is separated from your code.) As you design your application, look for functions that offer asynchronous behavior and consider using them instead of using the equivalent synchronous function on a custom thread\nTimers | You can use timers on your application’s main thread to perform periodic tasks that are too trivial to require a thread, but which still require servicing at regular intervals. For information on timers, see [Timer Sources](https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW21)\nSeparate processes | Although more heavyweight than threads, creating a separate process might be useful in cases where the task is only tangentially related to your application. You might use a process if a task requires a significant amount of memory or must be executed using root privileges. For example, you might use a 64-bit server process to compute a large data set while your 32-bit application displays the results to the user\n\n#### 线程安全 - [文档](https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/ThreadSafetySummary/ThreadSafetySummary.html#//apple_ref/doc/uid/10000057i-CH12-SW1)\n\n##### 原则\n- Immutable objects are generally thread-safe. Once you create them, you can safely pass these objects to and from threads. On the other hand, mutable objects are generally not thread-safe. To use mutable objects in a threaded application, the application must synchronize appropriately.\n- Many objects deemed “thread-unsafe” are only unsafe to use from multiple threads. Many of these objects can be used from any thread as long as it is only one thread at a time. Objects that are specifically restricted to the main thread of an application are called out as such\n- The main thread of the application is responsible for handling events. Although the Application Kit continues to work if other threads are involved in the event path, operations can occur out of sequence\n- If you want to use a thread to draw to a view, bracket all drawing code between the ***lockFocusIfCanDraw*** and ***unlockFocus*** methods of NSView\n\n##### Thread-Safe Classes and Functions\nThe following classes and functions are generally considered to be thread-safe. You can use the same instance from multiple threads without first acquiring a lock.\n> NSArray\nNSAssertionHandler\nNSAttributedString\nNSCalendarDate\nNSCharacterSet\nNSConditionLock\nNSConnection\nNSData\nNSDate\nNSDecimal functions\nNSDecimalNumber\nNSDecimalNumberHandler\nNSDeserializer\nNSDictionary\nNSDistantObject\nNSDistributedLock\nNSDistributedNotificationCenter\nNSException\nNSFileManager (in OS X v10.5 and later)\nNSHost\nNSLock\nNSLog/NSLogv\nNSMethodSignature\nNSNotification\nNSNotificationCenter\nNSNumber\nNSObject\nNSPortCoder\nNSPortMessage\nNSPortNameServer\nNSProtocolChecker\nNSProxy\nNSRecursiveLock\nNSSet\nNSString\nNSThread\nNSTimer\nNSTimeZone\nNSUserDefaults\nNSValue\n\n##### Thread-Unsafe Classes\nThe following classes and functions are generally not thread-safe. In most cases, you can use these classes from any thread as long as you use them from only one thread at a time.\n\n>NSArchiver\nNSAutoreleasePool\nNSBundle\nNSCalendar\nNSCoder\nNSCountedSet\nNSDateFormatter\nNSEnumerator\nNSFileHandle\nNSFormatter\nNSHashTable functions\nNSInvocation\nNSJavaSetup functions\nNSMapTable functions\nNSMutableArray\nNSMutableAttributedString\nNSMutableCharacterSet\nNSMutableData\nNSMutableDictionary\nNSMutableSet\nNSMutableString\nNSNotificationQueue\nNSNumberFormatter\nNSPipe\nNSPort\nNSProcessInfo\nNSRunLoop\nNSScanner\nNSSerializer\nNSTask\nNSUnarchiver\nNSUndoManager\n\n#####Main Thread Only Classes\n\nThe following class must be used only from the main thread of an application.\n\n> NSAppleScript\n\n### 多线程的死锁 - 张超耀\n- 俗话说，人多好办事！在程序里也是这样，如果是同一个应用程序需要并行处理多件任务，那就可以创建多条线程。但是人多了，往往会出现冲突，使得这个工作无法再进行下去了(正所谓三个和尚没水喝)，这就是“死锁”。\n\n#### 死锁的产生\n- [哲学家进餐问题](http://baike.baidu.com/link?url=OgOrpH_xTP7U0C0tM59aBhq83uaKe0Ck9MQEL1G41A3q-D1hVuynm3ra-U93RoQICKbmqhs7nTuCoN_elydnr_)\n\n**那么我们如何来消除“死锁”呢？首先，让我们来看看产生“死锁”的必要条件：**\n\n- 互斥：就是说多个线程不能同时使用同一资源\n\n- 请求和保持：就是某线程必须同时拥有多个资源才能完成任务，否则它将占用已经拥有的资源直到拥有他所需的所有资源为止\n\n- 不剥夺：就是说所有线程的优先级都相同，不能在别的线程没有释放资源的情况下，夺走其已占有的资源\n\n- 循环等待，就是没有资源满足的线程无限期地等待\n\n**有的朋友可能已经明白了，只要打破这这几个必要条件，就能打破“死锁”！**\n\n- 互斥：就是要让多个线程能共享资源\n\n- 请求和保持：只要当检测到自己所需的资源仍被别的线程占用，即释放自己已占有的资源（毫不利己，专门利人），或者在经过一段时间的等待后，还未得到所需资源，才释放，这都能打破请求和保持\n\n- 不剥夺：只要给线程制定一个优先级即可\n\n- 最后的循环等待的解决方法其实和`请求和保持`是一样的，都是等待一段时间后释放资源。\n\n**好了，希望通过这个例子能让不了解死锁的朋友对“死锁”能有一定的认识**\n\n## 集合的并行操作 - 王胜\n\n用for循环操作一个集合，即读取集合元素，同时又删除集合中的元素，会发生什么事情呢？\n\n上代码【号外，号外，此示例来源于我们项目中的真实代码哦~】\n\n```Java\n// Target class\nclass Target {\n\tint id;// ID\n\tString type;// 类型\n\tint count;// 未读消息数\n\n\tpublic Target(int id, String type, int count) {\n\t\tthis.id = id;\n\t\tthis.type = type;\n\t\tthis.count = count;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"Target [id=\" + id + \", type=\" + type + \", count=\" + count + \"]\";\n\t}\n\n}\n\n// 以下是模拟一组target集合，target包含group、room、user类型。\nList<Target> sessions = new ArrayList<Target>();\nsessions.add(new Target(1, \"group\", 1));\nsessions.add(new Target(2, \"group\", 1));\nsessions.add(new Target(3, \"group\", 1));\nsessions.add(new Target(4, \"room\", 1));\nsessions.add(new Target(5, \"group\", 1));\nsessions.add(new Target(6, \"group\", 1));\nsessions.add(new Target(7, \"group\", 1));\nsessions.add(new Target(8, \"user\", 1));\nsessions.add(new Target(9, \"user\", 1));\nsessions.add(new Target(10, \"group\", 1));\nSystem.out.println(\"before size:\"+sessions.size()+\", sessions:\"+humanPrintList(sessions));\nint totalUnread = 0;// 统计集合中类型为group的target未读消息数量\nfor (int i=0;i<sessions.size();i++) {\n\tSystem.out.println(\"read index:\" + i + \", session:\"+sessions.get(i));\n\tif (sessions.get(i).type.equals(\"group\")) {// 如果是group类型，则累加未读消息数\n\t\tSystem.out.println(\"==> add totalUnread\");\n\t\ttotalUnread += sessions.get(i).count;\n\t} else {// 否则，将target移除集合\n\t\tSystem.out.println(\"==> remove\");\n\t\tsessions.remove(i);\n\t}\n}\nSystem.out.println(\"after size:\"+sessions.size()+\", totalUnread:\"+totalUnread+\",sessions:\"+humanPrintList(sessions));\n```\n\n至此，示例代码结束。大家可以猜测下最后的输出中sessions的长度，内容以及总共的未读消息数据。\n\n项目中的代码，期望结果是剩余集合只包含group类型的target，而且totalUnread的值是类型为group的target的未读消息数之和。可是，运行的结果却是：\n\n```\nbefore size:10, sessions:\n========== List content: ===========\nTarget [id=1, type=group, count=1]\nTarget [id=2, type=group, count=1]\nTarget [id=3, type=group, count=1]\nTarget [id=4, type=room, count=1]\nTarget [id=5, type=group, count=1]\nTarget [id=6, type=group, count=1]\nTarget [id=7, type=group, count=1]\nTarget [id=8, type=user, count=1]\nTarget [id=9, type=user, count=1]\nTarget [id=10, type=group, count=1]\n====================================\nread index:0, session:Target [id=1, type=group, count=1]\n==> add totalUnread\nread index:1, session:Target [id=2, type=group, count=1]\n==> add totalUnread\nread index:2, session:Target [id=3, type=group, count=1]\n==> add totalUnread\nread index:3, session:Target [id=4, type=room, count=1]\n==> remove\nread index:4, session:Target [id=6, type=group, count=1]\n==> add totalUnread\nread index:5, session:Target [id=7, type=group, count=1]\n==> add totalUnread\nread index:6, session:Target [id=8, type=user, count=1]\n==> remove\nread index:7, session:Target [id=10, type=group, count=1]\n==> add totalUnread\nafter size:8, totalUnread:6,sessions:\n========== List content: ===========\nTarget [id=1, type=group, count=1]\nTarget [id=2, type=group, count=1]\nTarget [id=3, type=group, count=1]\nTarget [id=5, type=group, count=1]\nTarget [id=6, type=group, count=1]\nTarget [id=7, type=group, count=1]\nTarget [id=9, type=user, count=1]\nTarget [id=10, type=group, count=1]\n====================================\n```\n\n为什么结果完全不是预期的呢？原因是程序走到else时，将元素移除，后面的元素自动往前移动，所以继续取下一个下标时，被移除的后一个元素悄悄溜走了，成了漏网之鱼。\n\n**解决方法** : 最简单的就是在remove后执行 ```i--; ```\n","slug":"线程并发和同步","published":1,"updated":"2021-09-10T07:04:21.949Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cktfeap4g002pc2xx4ct1lmku","content":"<h2 id=\"扯扯线程并发和同步的那些事-2015-6-26\"><a href=\"#扯扯线程并发和同步的那些事-2015-6-26\" class=\"headerlink\" title=\"扯扯线程并发和同步的那些事 2015.6.26\"></a>扯扯线程并发和同步的那些事 2015.6.26</h2><h3 id=\"线程基础的那些事——李仙鹏\"><a href=\"#线程基础的那些事——李仙鹏\" class=\"headerlink\" title=\"线程基础的那些事——李仙鹏\"></a>线程基础的那些事——李仙鹏</h3><h4 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h4><p>线程俗称为轻量级进程。在现代OS中，通常以线程作为基本的调度单位。线程会共享进程范围内的资源，例如内存句柄和文件句柄，但每个线程又有各自的程序计数器、栈以及局部变量等。因此，再配合多核CPU，多个线程方可被并发执行。</p>\n<h5 id=\"线程的上下文切换\"><a href=\"#线程的上下文切换\" class=\"headerlink\" title=\"线程的上下文切换\"></a>线程的上下文切换</h5><p>如果当前运行线程数与CPU核数相同，那么这些线程将不会被系统调度出去。</p>\n<p>但是，如果可运行的线程数量大于CPU核数，那么系统会通过上下文切换，将某个正在运行的线程调度出来，从而使其他线程能够获得CPU的时间片，从而得到运行。</p>\n<p><strong>上下文切换需要一定的开销：</strong></p>\n<ol>\n<li>系统和应用程序都使用一组相同的CPU，线程调度需要访问系统资源。系统代码消耗越多的CPU时间，分配到应用程序的可用CPU时间就越少。</li>\n<li>上下文切换会导致处理器的一些缓存缺失</li>\n</ol>\n<blockquote>\n<p>线程的以上特性，促使了现代编程的并发和同步问题：</p>\n<ul>\n<li>安全性问题。安全性的含义是“永远不会发生糟糕的事情”</li>\n<li>活跃性问题。活跃性关注的目标为“某件正确的事情最终会发生”</li>\n<li>性能问题。性能关注的点事“正确的事情尽快发生”</li>\n</ul>\n</blockquote>\n<h4 id=\"超线程（Hyper-Threading）\"><a href=\"#超线程（Hyper-Threading）\" class=\"headerlink\" title=\"超线程（Hyper-Threading）\"></a>超线程（Hyper-Threading）</h4><p>为何我们会经常听到宣传说：四核八线程并行（如I5处理器）、八核十六线程并行（如I7）。原因是，这些CPU使用了超线程技术。超线程最早由因特尔研发，并在奔腾四处理器将技术主流化。</p>\n<p>超线程技术是在CPU内部仅复制必要的资源、让CPU模拟成两个线程；也就是一个实体核心，两个逻辑线程，在一单位时间内处理两个线程的工作，模拟实体双核心、双线程运作。</p>\n<p>虽然采用超线程技术能同时执行两个线程，但它并不象两个真正的CPU那样，每个CPU都具有独立的资源。当两个线程都同时需要某一个资源时，其中一个要暂时停止，并让出资源，直到这些资源闲置后才能继续。因此超线程的性能并不等于两颗CPU的性能。</p>\n<h4 id=\"GUI为什么都是单线程\"><a href=\"#GUI为什么都是单线程\" class=\"headerlink\" title=\"GUI为什么都是单线程\"></a>GUI为什么都是单线程</h4><p>许多人曾经尝试过编写多线程的GUI来处理事件，但最终都由于竞态条件和死锁导致的稳定性而重回到单线程的事件队列模型：使用UI线程从队列中抽取事件，并将事件分发给事件处理器（消费者）。</p>\n<p>另一个重要原因是MVC会导致多线程的GUI因为不一致的锁定顺序而发生死锁。<br><img src=\"http://www.51cto.com/files/uploadimg/20061010/1202170.gif\" alt=\"MVC模式图\"></p>\n<h4 id=\"推荐两本书\"><a href=\"#推荐两本书\" class=\"headerlink\" title=\"推荐两本书\"></a>推荐两本书</h4><blockquote>\n<p><strong>值得一看：</strong></p>\n<ul>\n<li><a href=\"http://book.douban.com/subject/5333562/\" target=\"_blank\" rel=\"noopener\">深入理解计算机系统</a></li>\n<li><a href=\"http://book.douban.com/subject/10484692/\" target=\"_blank\" rel=\"noopener\">Java并发编程实战</a></li>\n</ul>\n</blockquote>\n<h3 id=\"JAVA多线程中的单例——贾学涛\"><a href=\"#JAVA多线程中的单例——贾学涛\" class=\"headerlink\" title=\"JAVA多线程中的单例——贾学涛\"></a>JAVA多线程中的单例——贾学涛</h3><h4 id=\"常见单利模写法\"><a href=\"#常见单利模写法\" class=\"headerlink\" title=\"常见单利模写法\"></a>常见单利模写法</h4><pre><code>public class Singleton {  \n\n    private static Singleton mInstance；\n\n    private Singleton(){\n    }\n\n    public static Singleton getInstance(){\n        if (mInstance == null) {\n            mInstance = new Singleton();\n        }\n        return mInstance;\n    }\n}\n</code></pre><ul>\n<li>缺点：非线程安全的，在多线程并发的情况下容易出现多个实例存在的情况</li>\n</ul>\n<h4 id=\"改为线程安全的单例模式\"><a href=\"#改为线程安全的单例模式\" class=\"headerlink\" title=\"改为线程安全的单例模式\"></a>改为线程安全的单例模式</h4><p>通过添加synchronized关键字  </p>\n<pre><code>public class Singleton {  \n\n    private static Singleton mInstance；\n\n    private Singleton(){\n    }\n\n    public static synchronized Singleton getInstance(){\n        if (mInstance == null) {\n            mInstance = new Singleton();\n        }\n        return mInstance;\n    }\n}\n</code></pre><ul>\n<li>缺点：每次都要进行同步检查，实际上需要检查的时机是在首次创建实例的时候。</li>\n</ul>\n<h4 id=\"改为双重检查锁单例模式\"><a href=\"#改为双重检查锁单例模式\" class=\"headerlink\" title=\"改为双重检查锁单例模式\"></a>改为双重检查锁单例模式</h4><pre><code>public class Singleton {  \n\n    private static Singleton mInstance；\n\n    private Singleton(){\n    }\n\n    public static Singleton getInstance(){\n        if (mInstance == null) {          //Single Checked\n            synchronized(Singleton.class) {\n                if (mInstance == null) {        //Double Checked\n                    mInstance = new Singleton();\n                }\n            }\n        }\n        return mInstance;\n    }\n}\n</code></pre><ul>\n<li><p>instance = new Singleton()这句，并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情  </p>\n<blockquote>\n<p>1.给 instance 分配内存<br>2.调用 Singleton 的构造函数来初始化成员变量<br>3.将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了）  </p>\n</blockquote>\n<p>  但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的.可能会出现第一次检测是mInstance为非null时，有可能实例还未创建。所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。</p>\n</li>\n</ul>\n<h4 id=\"为实例变量增加volatile关键字\"><a href=\"#为实例变量增加volatile关键字\" class=\"headerlink\" title=\"为实例变量增加volatile关键字\"></a>为实例变量增加volatile关键字</h4><pre><code>public class Singleton {  \n\n    private volatile static Singleton mInstance；    // 增加volatile关键字\n\n    private Singleton(){\n    }\n\n    public static Singleton getInstance(){\n        if (mInstance == null) {          //Single Checked\n            synchronized(Singleton.class) {\n                if (mInstance == null) {        //Double Checked\n                    mInstance = new Singleton();\n                }\n            }\n        }\n        return mInstance;\n    }\n}\n</code></pre><ul>\n<li><p>使用 volatile 的主要原因是其另一个特性：禁止指令重排序优化。也就是说，在 volatile 变量的赋值操作后面会有一个内存屏障，读操作不会被重排序到内存屏障之前</p>\n</li>\n<li><p>Java 5 以前的版本使用了 volatile 的双检锁还是有问题的。其原因是 Java 5 以前的 JMM （Java 内存模型）是存在缺陷的，即时将变量声明成 volatile 也不能完全避免重排序</p>\n</li>\n</ul>\n<h4 id=\"饿汉加载单例模式\"><a href=\"#饿汉加载单例模式\" class=\"headerlink\" title=\"饿汉加载单例模式\"></a>饿汉加载单例模式</h4><pre><code>public class Singleton {  \n\n    private static Singleton mInstance ＝ new Singleton()；\n\n    private Singleton(){\n    }\n\n    public static Singleton getInstance(){\n        return mInstance;\n    }\n}\n</code></pre><p>变种的饿汉加载单例模式</p>\n<pre><code>public class Singleton {\n\n    private static Singleton mInstance；\n\n    static {\n        mInstance = new Singleton();\n    }\n\n    private Singleton(){\n    }\n\n    public static Singleton getInstance(){\n        return mInstance;\n    }\n}\n</code></pre><ul>\n<li>缺点：在类被加载的时候就会去创建实例，牺牲空间来保证时间，与之前的单例模式相反，懒汉加载是牺牲时间，来保证空间，在需要的时候再去创建实例。</li>\n</ul>\n<h4 id=\"通过静态内部类来创建单例\"><a href=\"#通过静态内部类来创建单例\" class=\"headerlink\" title=\"通过静态内部类来创建单例\"></a>通过静态内部类来创建单例</h4><pre><code>public class Singleton {\n\n    private Singleton(){\n    }\n\n    public static Singleton getInstance(){\n        return InnerClass.mInstance;\n    }\n\n    private staitc class InnerClass{\n        public static Singleton mInstance = new Singleton();\n    }\n}\n</code></pre><ul>\n<li>与前者一样，通过classloader机制来保证线程安全，区别是，前者当Singleton类被加载时，就会创建实例，而后者是在需要调用getInstance的时候去加载内部类的时候，来创建实例。</li>\n</ul>\n<h4 id=\"通过枚举来创建单例\"><a href=\"#通过枚举来创建单例\" class=\"headerlink\" title=\"通过枚举来创建单例\"></a>通过枚举来创建单例</h4><pre><code>public enum Singleton {\n    INSTANCE;\n}\n</code></pre><p>访问实例对象 Singleton.INSTANCE</p>\n<p>*默认枚举实例的创建是线程安全的，但是在枚举中的其他任何方法由程序员自己负责。</p>\n<h3 id=\"为什么要有线程同步之喂金鱼问题——曾铭\"><a href=\"#为什么要有线程同步之喂金鱼问题——曾铭\" class=\"headerlink\" title=\"为什么要有线程同步之喂金鱼问题——曾铭\"></a>为什么要有线程同步之喂金鱼问题——曾铭</h3><h4 id=\"喂金鱼问题\"><a href=\"#喂金鱼问题\" class=\"headerlink\" title=\"喂金鱼问题\"></a>喂金鱼问题</h4><ul>\n<li>金鱼一天不吃会饿死，一天吃两次会撑死；</li>\n<li>张三、李四，每天每人分别会去执行这件事一次；</li>\n</ul>\n<h4 id=\"方案-1\"><a href=\"#方案-1\" class=\"headerlink\" title=\"方案 1\"></a>方案 1</h4><p>两人执行一致</p>\n<pre><code>if (noFeed) {\n    feed fish\n}\n</code></pre><table>\n<thead>\n<tr>\n<th>张三</th>\n<th>李四</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>if (noFeed) {</td>\n<td>.</td>\n</tr>\n<tr>\n<td>.</td>\n<td>if (noFeed) {</td>\n</tr>\n<tr>\n<td>.</td>\n<td>feed fish</td>\n</tr>\n<tr>\n<td>feed fish</td>\n<td>.</td>\n</tr>\n<tr>\n<td>fish died</td>\n<td>.</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h5><ul>\n<li>feed fish 时间越长，鱼被撑死可能性越大</li>\n<li>没解决问题</li>\n</ul>\n<h4 id=\"方案-2\"><a href=\"#方案-2\" class=\"headerlink\" title=\"方案 2\"></a>方案 2</h4><p>两人执行一致</p>\n<pre><code>if (noNote) {\n    leave note\n\n    if (noFeed) {\n        feed fish\n    }\n\n    remove note\n}\n</code></pre><table>\n<thead>\n<tr>\n<th>张三</th>\n<th>李四</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>if (noNote) {</td>\n<td>.</td>\n</tr>\n<tr>\n<td>.</td>\n<td>if (noNote) {</td>\n</tr>\n<tr>\n<td>.</td>\n<td>leave note</td>\n</tr>\n<tr>\n<td>leave note</td>\n<td>.</td>\n</tr>\n<tr>\n<td>if (noFeed) {</td>\n<td>.</td>\n</tr>\n<tr>\n<td>.</td>\n<td>if (noFeed) {</td>\n</tr>\n<tr>\n<td>.</td>\n<td>feed fish</td>\n</tr>\n<tr>\n<td>feed fish</td>\n<td>.</td>\n</tr>\n<tr>\n<td>fish died</td>\n<td>.</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"结论-1\"><a href=\"#结论-1\" class=\"headerlink\" title=\"结论\"></a>结论</h5><ul>\n<li>noNote, noFeed 按特定顺序执行才会出问题</li>\n<li>noNote 多了一层保护，如果 leave note 时间很短，出问题可能性很小</li>\n<li>没解决问题</li>\n</ul>\n<h4 id=\"方案-3\"><a href=\"#方案-3\" class=\"headerlink\" title=\"方案 3\"></a>方案 3</h4><p>张三执行</p>\n<pre><code>leave note3\n\nif (noNote4) {\n    if (noFeed) {\n        feed fish\n    }\n}\n\nremove note3\n</code></pre><p>李四执行</p>\n<pre><code>leave note4\n\nif (noNote3) {\n    if (noFeed) {\n        feed fish\n    }\n}\n\nremove note4\n</code></pre><table>\n<thead>\n<tr>\n<th>张三</th>\n<th>李四</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>leave note3</td>\n<td>.</td>\n</tr>\n<tr>\n<td>.</td>\n<td>leave note4</td>\n</tr>\n<tr>\n<td>.</td>\n<td>if (noNote3) {</td>\n</tr>\n<tr>\n<td>if (noNote4) {</td>\n<td>.</td>\n</tr>\n<tr>\n<td>remove note3</td>\n<td>.</td>\n</tr>\n<tr>\n<td>.</td>\n<td>remove note4</td>\n</tr>\n<tr>\n<td>…</td>\n<td>…</td>\n</tr>\n<tr>\n<td>fish died</td>\n<td>.</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"结论-2\"><a href=\"#结论-2\" class=\"headerlink\" title=\"结论\"></a>结论</h5><ul>\n<li>不会被撑死了，可能会被饿死……</li>\n<li>没解决问题</li>\n</ul>\n<h4 id=\"方案-4\"><a href=\"#方案-4\" class=\"headerlink\" title=\"方案 4\"></a>方案 4</h4><p>张三执行</p>\n<pre><code>leave note3\n\nwhile (noNote4)\n{\n    sleep (1)\n}\n\nif (noFeed) {\n    feed fish\n}\n\nremove note3\n</code></pre><p>李四执行</p>\n<pre><code>leave note4\n\nif (noNote3) {\n    if (noFeed) {\n        feed fish\n    }\n}\n\nremove note4\n</code></pre><h5 id=\"结论-3\"><a href=\"#结论-3\" class=\"headerlink\" title=\"结论\"></a>结论</h5><ul>\n<li>的确解决了问题</li>\n<li>能优化么？<ul>\n<li>程序不不对称</li>\n<li>循环等待的浪费</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"方案-5\"><a href=\"#方案-5\" class=\"headerlink\" title=\"方案 5\"></a>方案 5</h4><p>两人执行一致</p>\n<pre><code>lock()\n\nif (noFeed) {\n    feed fish\n}\n\nunlock()\n</code></pre><h5 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h5><ul>\n<li>能解决问题</li>\n<li>程序对称</li>\n<li>持有锁需要等待，未解决浪费问题<ul>\n<li>生产者与消费者问题</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"END\"><a href=\"#END\" class=\"headerlink\" title=\"END\"></a>END</h4><p><strong>全部内容来自<a href=\"http://book.douban.com/subject/3670621/\" target=\"_blank\" rel=\"noopener\">《计算机的心智·操作系统之哲学原理》——\u0004邹恒明</a> 第七章</strong></p>\n<h3 id=\"iOS并发相关的概念介绍——潘君\"><a href=\"#iOS并发相关的概念介绍——潘君\" class=\"headerlink\" title=\"iOS并发相关的概念介绍——潘君\"></a>iOS并发相关的概念介绍——潘君</h3><p>@(归纳中)[iOS]</p>\n<h4 id=\"基础概念\"><a href=\"#基础概念\" class=\"headerlink\" title=\"基础概念\"></a>基础概念</h4><p>#####竞态条件<br>竞态条件（race condition），从多进程间通信的角度来讲，是指两个或多个进程对共享的数据进行读或写的操作时，最终的结果取决于这些进程的执行顺序。<br>竞态条件（race condition）是指设备或系统出现不恰当的执行时序，而得到不正确的结果。</p>\n<p>注: <code>atomic</code> 可以解决竞态竞争 但是无法保证类是<code>线程安全</code>的</p>\n<h4 id=\"iOS中的相关概念\"><a href=\"#iOS中的相关概念\" class=\"headerlink\" title=\"iOS中的相关概念\"></a>iOS中的相关概念</h4><p>#####atomic属性</p>\n<blockquote>\n<p>property 修饰符</p>\n</blockquote>\n<p>加了atomic后生成的setter,类似如下代码:</p>\n<pre><code>- (void)setProp:(NSString *)newValue {\n    [_prop lock];\n    _prop = newValue;\n    [_prop unlock];\n}\n</code></pre><p>#####@synchronized指令</p>\n<blockquote>\n<p>引用自<a href=\"http://www.xuebuyuan.com/1682784.html\" target=\"_blank\" rel=\"noopener\">@synchronized(id anObject) ｛｝定义和使用</a><br>1.作用：创建了一个互斥锁，它的作用和其他语言中的互斥锁作用一样</p>\n<p>2.解释：这个是OBC中的一个锁定令牌，防止｛｝里的内容在同一时间内被其他线程访问，起到了线程保护的作用</p>\n<p>3.使用范围：一般在单例模式或者操作类的static变量的时候使用，即共用的变量的时候</p>\n<p>4.外延：这个令牌隐式的包含了异常处理，如果你不想使用的话，就使用锁吧</p>\n<p>5.它的参数是id类型，如果用<br>@synchronized(1) {<br>}<br>编译器提示<br>@synchronzied requires an Objective-C object type.<br>也就是说需要一个objective C的对象类型。</p>\n</blockquote>\n<pre><code>@synchronized(id anObject){\n     // test code\n}\n</code></pre><p>#####NSLock</p>\n<p>使用样例:</p>\n<pre><code>//主线程中\nTestObj *obj = [[TestObj alloc] init];\nNSLock *lock = [[NSLock alloc] init];\n\n//线程1\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n    [lock lock];\n    [obj method1];\n    sleep(10);\n    [lock unlock];\n});\n\n//线程2\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n    sleep(1);//以保证让线程2的代码后执行\n    [lock lock];\n    [obj method2];\n    [lock unlock];\n});\n</code></pre><p>###<a href=\"https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/Introduction/Introduction.html\" target=\"_blank\" rel=\"noopener\">iOS多线程</a> - 杨志平</p>\n<p>####简介</p>\n<p>iOS有三种多线程编程的技术，分别是：</p>\n<ul>\n<li><h4 id=\"NSThread\"><a href=\"#NSThread\" class=\"headerlink\" title=\"NSThread\"></a>NSThread</h4></li>\n<li><h4 id=\"Cocoa-NSOperation\"><a href=\"#Cocoa-NSOperation\" class=\"headerlink\" title=\"Cocoa NSOperation\"></a>Cocoa NSOperation</h4></li>\n<li><h4 id=\"GCD-（全称：Grand-Central-Dispatch）\"><a href=\"#GCD-（全称：Grand-Central-Dispatch）\" class=\"headerlink\" title=\"GCD （全称：Grand Central Dispatch）\"></a>GCD <strong><em>（全称：Grand Central Dispatch）</em></strong></h4></li>\n</ul>\n<blockquote>\n<p> <em>这三种编程方式从上到下，抽象度层次是从低到高的，抽象度越高的使用越简单，也是Apple最推荐使用的</em></p>\n</blockquote>\n<h4 id=\"三种方式的介绍：\"><a href=\"#三种方式的介绍：\" class=\"headerlink\" title=\"三种方式的介绍：\"></a>三种方式的介绍：</h4><h5 id=\"NSThread-文档\"><a href=\"#NSThread-文档\" class=\"headerlink\" title=\"NSThread - 文档\"></a>NSThread - <a href=\"https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Reference/Foundation/Classes/NSThread_Class/\" target=\"_blank\" rel=\"noopener\">文档</a></h5><blockquote>\n<p>优点：NSThread 比其他两个轻量级<br>缺点：需要自己管理线程的生命周期，线程同步。线程同步对数据的加锁会有一定的系统开销</p>\n</blockquote>\n<h5 id=\"NSOperation-文档\"><a href=\"#NSOperation-文档\" class=\"headerlink\" title=\"NSOperation - 文档\"></a>NSOperation - <a href=\"https://developer.apple.com/library/mac/documentation/Cocoa/Reference/NSOperation_class/\" target=\"_blank\" rel=\"noopener\">文档</a></h5><blockquote>\n<p>优点：不需要关心线程管理，数据同步的事情，可以把精力放在自己需要执行的操作上。<br>创建NSOperation子类的对象，把对象添加到NSOperationQueue队列里执行。</p>\n</blockquote>\n<h5 id=\"GCD-文档\"><a href=\"#GCD-文档\" class=\"headerlink\" title=\"GCD - 文档\"></a>GCD - <a href=\"https://developer.apple.com/library/prerelease/ios/documentation/Performance/Reference/GCD_libdispatch_Ref/index.html\" target=\"_blank\" rel=\"noopener\">文档</a></h5><blockquote>\n<p>Grand Central Dispatch (GCD)是Apple开发的一个多核编程的解决方法。在iOS4.0开始之后才能使用。GCD是一个替代诸如NSThread, NSOperationQueue, NSInvocationOperation等技术的很高效和强大的技术。</p>\n<p>GCD的底层依然是用线程实现，不过这样可以让程序员不用关注实现的细节。</p>\n</blockquote>\n<h4 id=\"创建线程的开销-查看文档\"><a href=\"#创建线程的开销-查看文档\" class=\"headerlink\" title=\"创建线程的开销 - 查看文档\"></a>创建线程的开销 - <a href=\"https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/CreatingThreads/CreatingThreads.html\" target=\"_blank\" rel=\"noopener\">查看文档</a></h4><table>\n<thead>\n<tr>\n<th>Item</th>\n<th>Approximate cost</th>\n<th>Notes</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Kernel data structures</td>\n<td>Approximately 1 KB</td>\n<td>This memory is used to store the thread data structures and attributes, much of which is allocated as wired memory and therefore cannot be paged to disk.</td>\n</tr>\n<tr>\n<td>Stack space</td>\n<td>512 KB (secondary threads)  8 MB (OS X main thread)  1 MB (iOS main thread)</td>\n<td>The minimum allowed stack size for secondary threads is 16 KB and the stack size must be a multiple of 4 KB. The space for this memory is set aside in your process space at thread creation time, but the actual pages associated with that memory are not created until they are needed.</td>\n</tr>\n<tr>\n<td>Creation time</td>\n<td>Approximately 90 microseconds</td>\n<td>This value reflects the time between the initial call to create the thread and the time at which the thread’s entry point routine began executing. The figures were determined by analyzing the mean and median values generated during thread creation on an Intel-based iMac with a 2 GHz Core Duo processor and 1 GB of RAM running OS X v10.5.</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"替代线程的一些技术\"><a href=\"#替代线程的一些技术\" class=\"headerlink\" title=\"替代线程的一些技术\"></a>替代线程的一些技术</h4><table>\n<thead>\n<tr>\n<th>Item</th>\n<th>Approximate cost</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Operation objects</td>\n<td>Introduced in OS X v10.5, an operation object is a wrapper for a task that would normally be executed on a secondary thread. This wrapper hides the thread management aspects of performing the task, leaving you free to focus on the task itself. You typically use these objects in conjunction with an operation queue object, which actually manages the execution of the operation objects on one or more threads.For more information on how to use operation objects, see <a href=\"https://developer.apple.com/library/mac/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008091\" target=\"_blank\" rel=\"noopener\">Concurrency Programming Guide</a>.</td>\n</tr>\n<tr>\n<td>Grand Central Dispatch (GCD)</td>\n<td>Introduced in Mac OS x v10.6, Grand Central Dispatch is another alternative to threads that lets you focus on the tasks you need to perform rather than on thread management. With GCD, you define the task you want to perform and add it to a work queue, which handles the scheduling of your task on an appropriate thread. Work queues take into account the number of available cores and the current load to execute your tasks more efficiently than you could do yourself using threads.For information on how to use GCD and work queues, see <a href=\"https://developer.apple.com/library/mac/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008091\" target=\"_blank\" rel=\"noopener\">Concurrency Programming Guide</a></td>\n</tr>\n<tr>\n<td>Idle-time notifications</td>\n<td>For tasks that are relatively short and very low priority, idle time notifications let you perform the task at a time when your application is not as busy. Cocoa provides support for idle-time notifications using the NSNotificationQueue object. To request an idle-time notification, post a notification to the default <a href=\"https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSNotificationQueue_Class/index.html#//apple_ref/occ/cl/NSNotificationQueue\" target=\"_blank\" rel=\"noopener\">NSNotificationQueue</a> object using the <a href=\"https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSNotificationQueue_Class/index.html#//apple_ref/c/econst/NSPostWhenIdle\" target=\"_blank\" rel=\"noopener\">NSPostWhenIdle</a> option. The queue delays the delivery of your notification object until the run loop becomes idle. For more information, see <a href=\"https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Notifications/Introduction/introNotifications.html#//apple_ref/doc/uid/10000043i\" target=\"_blank\" rel=\"noopener\">Notification Programming Topics</a>.</td>\n</tr>\n<tr>\n<td>Asynchronous functions</td>\n<td>The system interfaces include many asynchronous functions that provide automatic concurrency for you. These APIs may use system daemons and processes or create custom threads to perform their task and return the results to you. (The actual implementation is irrelevant because it is separated from your code.) As you design your application, look for functions that offer asynchronous behavior and consider using them instead of using the equivalent synchronous function on a custom thread</td>\n</tr>\n<tr>\n<td>Timers</td>\n<td>You can use timers on your application’s main thread to perform periodic tasks that are too trivial to require a thread, but which still require servicing at regular intervals. For information on timers, see <a href=\"https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW21\" target=\"_blank\" rel=\"noopener\">Timer Sources</a></td>\n</tr>\n<tr>\n<td>Separate processes</td>\n<td>Although more heavyweight than threads, creating a separate process might be useful in cases where the task is only tangentially related to your application. You might use a process if a task requires a significant amount of memory or must be executed using root privileges. For example, you might use a 64-bit server process to compute a large data set while your 32-bit application displays the results to the user</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"线程安全-文档\"><a href=\"#线程安全-文档\" class=\"headerlink\" title=\"线程安全 - 文档\"></a>线程安全 - <a href=\"https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/ThreadSafetySummary/ThreadSafetySummary.html#//apple_ref/doc/uid/10000057i-CH12-SW1\" target=\"_blank\" rel=\"noopener\">文档</a></h4><h5 id=\"原则\"><a href=\"#原则\" class=\"headerlink\" title=\"原则\"></a>原则</h5><ul>\n<li>Immutable objects are generally thread-safe. Once you create them, you can safely pass these objects to and from threads. On the other hand, mutable objects are generally not thread-safe. To use mutable objects in a threaded application, the application must synchronize appropriately.</li>\n<li>Many objects deemed “thread-unsafe” are only unsafe to use from multiple threads. Many of these objects can be used from any thread as long as it is only one thread at a time. Objects that are specifically restricted to the main thread of an application are called out as such</li>\n<li>The main thread of the application is responsible for handling events. Although the Application Kit continues to work if other threads are involved in the event path, operations can occur out of sequence</li>\n<li>If you want to use a thread to draw to a view, bracket all drawing code between the <strong><em>lockFocusIfCanDraw</em></strong> and <strong><em>unlockFocus</em></strong> methods of NSView</li>\n</ul>\n<h5 id=\"Thread-Safe-Classes-and-Functions\"><a href=\"#Thread-Safe-Classes-and-Functions\" class=\"headerlink\" title=\"Thread-Safe Classes and Functions\"></a>Thread-Safe Classes and Functions</h5><p>The following classes and functions are generally considered to be thread-safe. You can use the same instance from multiple threads without first acquiring a lock.</p>\n<blockquote>\n<p>NSArray<br>NSAssertionHandler<br>NSAttributedString<br>NSCalendarDate<br>NSCharacterSet<br>NSConditionLock<br>NSConnection<br>NSData<br>NSDate<br>NSDecimal functions<br>NSDecimalNumber<br>NSDecimalNumberHandler<br>NSDeserializer<br>NSDictionary<br>NSDistantObject<br>NSDistributedLock<br>NSDistributedNotificationCenter<br>NSException<br>NSFileManager (in OS X v10.5 and later)<br>NSHost<br>NSLock<br>NSLog/NSLogv<br>NSMethodSignature<br>NSNotification<br>NSNotificationCenter<br>NSNumber<br>NSObject<br>NSPortCoder<br>NSPortMessage<br>NSPortNameServer<br>NSProtocolChecker<br>NSProxy<br>NSRecursiveLock<br>NSSet<br>NSString<br>NSThread<br>NSTimer<br>NSTimeZone<br>NSUserDefaults<br>NSValue</p>\n</blockquote>\n<h5 id=\"Thread-Unsafe-Classes\"><a href=\"#Thread-Unsafe-Classes\" class=\"headerlink\" title=\"Thread-Unsafe Classes\"></a>Thread-Unsafe Classes</h5><p>The following classes and functions are generally not thread-safe. In most cases, you can use these classes from any thread as long as you use them from only one thread at a time.</p>\n<blockquote>\n<p>NSArchiver<br>NSAutoreleasePool<br>NSBundle<br>NSCalendar<br>NSCoder<br>NSCountedSet<br>NSDateFormatter<br>NSEnumerator<br>NSFileHandle<br>NSFormatter<br>NSHashTable functions<br>NSInvocation<br>NSJavaSetup functions<br>NSMapTable functions<br>NSMutableArray<br>NSMutableAttributedString<br>NSMutableCharacterSet<br>NSMutableData<br>NSMutableDictionary<br>NSMutableSet<br>NSMutableString<br>NSNotificationQueue<br>NSNumberFormatter<br>NSPipe<br>NSPort<br>NSProcessInfo<br>NSRunLoop<br>NSScanner<br>NSSerializer<br>NSTask<br>NSUnarchiver<br>NSUndoManager</p>\n</blockquote>\n<p>#####Main Thread Only Classes</p>\n<p>The following class must be used only from the main thread of an application.</p>\n<blockquote>\n<p>NSAppleScript</p>\n</blockquote>\n<h3 id=\"多线程的死锁-张超耀\"><a href=\"#多线程的死锁-张超耀\" class=\"headerlink\" title=\"多线程的死锁 - 张超耀\"></a>多线程的死锁 - 张超耀</h3><ul>\n<li>俗话说，人多好办事！在程序里也是这样，如果是同一个应用程序需要并行处理多件任务，那就可以创建多条线程。但是人多了，往往会出现冲突，使得这个工作无法再进行下去了(正所谓三个和尚没水喝)，这就是“死锁”。</li>\n</ul>\n<h4 id=\"死锁的产生\"><a href=\"#死锁的产生\" class=\"headerlink\" title=\"死锁的产生\"></a>死锁的产生</h4><ul>\n<li><a href=\"http://baike.baidu.com/link?url=OgOrpH_xTP7U0C0tM59aBhq83uaKe0Ck9MQEL1G41A3q-D1hVuynm3ra-U93RoQICKbmqhs7nTuCoN_elydnr_\" target=\"_blank\" rel=\"noopener\">哲学家进餐问题</a></li>\n</ul>\n<p><strong>那么我们如何来消除“死锁”呢？首先，让我们来看看产生“死锁”的必要条件：</strong></p>\n<ul>\n<li><p>互斥：就是说多个线程不能同时使用同一资源</p>\n</li>\n<li><p>请求和保持：就是某线程必须同时拥有多个资源才能完成任务，否则它将占用已经拥有的资源直到拥有他所需的所有资源为止</p>\n</li>\n<li><p>不剥夺：就是说所有线程的优先级都相同，不能在别的线程没有释放资源的情况下，夺走其已占有的资源</p>\n</li>\n<li><p>循环等待，就是没有资源满足的线程无限期地等待</p>\n</li>\n</ul>\n<p><strong>有的朋友可能已经明白了，只要打破这这几个必要条件，就能打破“死锁”！</strong></p>\n<ul>\n<li><p>互斥：就是要让多个线程能共享资源</p>\n</li>\n<li><p>请求和保持：只要当检测到自己所需的资源仍被别的线程占用，即释放自己已占有的资源（毫不利己，专门利人），或者在经过一段时间的等待后，还未得到所需资源，才释放，这都能打破请求和保持</p>\n</li>\n<li><p>不剥夺：只要给线程制定一个优先级即可</p>\n</li>\n<li><p>最后的循环等待的解决方法其实和<code>请求和保持</code>是一样的，都是等待一段时间后释放资源。</p>\n</li>\n</ul>\n<p><strong>好了，希望通过这个例子能让不了解死锁的朋友对“死锁”能有一定的认识</strong></p>\n<h2 id=\"集合的并行操作-王胜\"><a href=\"#集合的并行操作-王胜\" class=\"headerlink\" title=\"集合的并行操作 - 王胜\"></a>集合的并行操作 - 王胜</h2><p>用for循环操作一个集合，即读取集合元素，同时又删除集合中的元素，会发生什么事情呢？</p>\n<p>上代码【号外，号外，此示例来源于我们项目中的真实代码哦~】</p>\n<pre><code class=\"Java\">// Target class\nclass Target {\n    int id;// ID\n    String type;// 类型\n    int count;// 未读消息数\n\n    public Target(int id, String type, int count) {\n        this.id = id;\n        this.type = type;\n        this.count = count;\n    }\n\n    @Override\n    public String toString() {\n        return &quot;Target [id=&quot; + id + &quot;, type=&quot; + type + &quot;, count=&quot; + count + &quot;]&quot;;\n    }\n\n}\n\n// 以下是模拟一组target集合，target包含group、room、user类型。\nList&lt;Target&gt; sessions = new ArrayList&lt;Target&gt;();\nsessions.add(new Target(1, &quot;group&quot;, 1));\nsessions.add(new Target(2, &quot;group&quot;, 1));\nsessions.add(new Target(3, &quot;group&quot;, 1));\nsessions.add(new Target(4, &quot;room&quot;, 1));\nsessions.add(new Target(5, &quot;group&quot;, 1));\nsessions.add(new Target(6, &quot;group&quot;, 1));\nsessions.add(new Target(7, &quot;group&quot;, 1));\nsessions.add(new Target(8, &quot;user&quot;, 1));\nsessions.add(new Target(9, &quot;user&quot;, 1));\nsessions.add(new Target(10, &quot;group&quot;, 1));\nSystem.out.println(&quot;before size:&quot;+sessions.size()+&quot;, sessions:&quot;+humanPrintList(sessions));\nint totalUnread = 0;// 统计集合中类型为group的target未读消息数量\nfor (int i=0;i&lt;sessions.size();i++) {\n    System.out.println(&quot;read index:&quot; + i + &quot;, session:&quot;+sessions.get(i));\n    if (sessions.get(i).type.equals(&quot;group&quot;)) {// 如果是group类型，则累加未读消息数\n        System.out.println(&quot;==&gt; add totalUnread&quot;);\n        totalUnread += sessions.get(i).count;\n    } else {// 否则，将target移除集合\n        System.out.println(&quot;==&gt; remove&quot;);\n        sessions.remove(i);\n    }\n}\nSystem.out.println(&quot;after size:&quot;+sessions.size()+&quot;, totalUnread:&quot;+totalUnread+&quot;,sessions:&quot;+humanPrintList(sessions));\n</code></pre>\n<p>至此，示例代码结束。大家可以猜测下最后的输出中sessions的长度，内容以及总共的未读消息数据。</p>\n<p>项目中的代码，期望结果是剩余集合只包含group类型的target，而且totalUnread的值是类型为group的target的未读消息数之和。可是，运行的结果却是：</p>\n<pre><code>before size:10, sessions:\n========== List content: ===========\nTarget [id=1, type=group, count=1]\nTarget [id=2, type=group, count=1]\nTarget [id=3, type=group, count=1]\nTarget [id=4, type=room, count=1]\nTarget [id=5, type=group, count=1]\nTarget [id=6, type=group, count=1]\nTarget [id=7, type=group, count=1]\nTarget [id=8, type=user, count=1]\nTarget [id=9, type=user, count=1]\nTarget [id=10, type=group, count=1]\n====================================\nread index:0, session:Target [id=1, type=group, count=1]\n==&gt; add totalUnread\nread index:1, session:Target [id=2, type=group, count=1]\n==&gt; add totalUnread\nread index:2, session:Target [id=3, type=group, count=1]\n==&gt; add totalUnread\nread index:3, session:Target [id=4, type=room, count=1]\n==&gt; remove\nread index:4, session:Target [id=6, type=group, count=1]\n==&gt; add totalUnread\nread index:5, session:Target [id=7, type=group, count=1]\n==&gt; add totalUnread\nread index:6, session:Target [id=8, type=user, count=1]\n==&gt; remove\nread index:7, session:Target [id=10, type=group, count=1]\n==&gt; add totalUnread\nafter size:8, totalUnread:6,sessions:\n========== List content: ===========\nTarget [id=1, type=group, count=1]\nTarget [id=2, type=group, count=1]\nTarget [id=3, type=group, count=1]\nTarget [id=5, type=group, count=1]\nTarget [id=6, type=group, count=1]\nTarget [id=7, type=group, count=1]\nTarget [id=9, type=user, count=1]\nTarget [id=10, type=group, count=1]\n====================================\n</code></pre><p>为什么结果完全不是预期的呢？原因是程序走到else时，将元素移除，后面的元素自动往前移动，所以继续取下一个下标时，被移除的后一个元素悄悄溜走了，成了漏网之鱼。</p>\n<p><strong>解决方法</strong> : 最简单的就是在remove后执行 <code>i--;</code></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"扯扯线程并发和同步的那些事-2015-6-26\"><a href=\"#扯扯线程并发和同步的那些事-2015-6-26\" class=\"headerlink\" title=\"扯扯线程并发和同步的那些事 2015.6.26\"></a>扯扯线程并发和同步的那些事 2015.6.26</h2><h3 id=\"线程基础的那些事——李仙鹏\"><a href=\"#线程基础的那些事——李仙鹏\" class=\"headerlink\" title=\"线程基础的那些事——李仙鹏\"></a>线程基础的那些事——李仙鹏</h3><h4 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h4><p>线程俗称为轻量级进程。在现代OS中，通常以线程作为基本的调度单位。线程会共享进程范围内的资源，例如内存句柄和文件句柄，但每个线程又有各自的程序计数器、栈以及局部变量等。因此，再配合多核CPU，多个线程方可被并发执行。</p>\n<h5 id=\"线程的上下文切换\"><a href=\"#线程的上下文切换\" class=\"headerlink\" title=\"线程的上下文切换\"></a>线程的上下文切换</h5><p>如果当前运行线程数与CPU核数相同，那么这些线程将不会被系统调度出去。</p>\n<p>但是，如果可运行的线程数量大于CPU核数，那么系统会通过上下文切换，将某个正在运行的线程调度出来，从而使其他线程能够获得CPU的时间片，从而得到运行。</p>\n<p><strong>上下文切换需要一定的开销：</strong></p>\n<ol>\n<li>系统和应用程序都使用一组相同的CPU，线程调度需要访问系统资源。系统代码消耗越多的CPU时间，分配到应用程序的可用CPU时间就越少。</li>\n<li>上下文切换会导致处理器的一些缓存缺失</li>\n</ol>\n<blockquote>\n<p>线程的以上特性，促使了现代编程的并发和同步问题：</p>\n<ul>\n<li>安全性问题。安全性的含义是“永远不会发生糟糕的事情”</li>\n<li>活跃性问题。活跃性关注的目标为“某件正确的事情最终会发生”</li>\n<li>性能问题。性能关注的点事“正确的事情尽快发生”</li>\n</ul>\n</blockquote>\n<h4 id=\"超线程（Hyper-Threading）\"><a href=\"#超线程（Hyper-Threading）\" class=\"headerlink\" title=\"超线程（Hyper-Threading）\"></a>超线程（Hyper-Threading）</h4><p>为何我们会经常听到宣传说：四核八线程并行（如I5处理器）、八核十六线程并行（如I7）。原因是，这些CPU使用了超线程技术。超线程最早由因特尔研发，并在奔腾四处理器将技术主流化。</p>\n<p>超线程技术是在CPU内部仅复制必要的资源、让CPU模拟成两个线程；也就是一个实体核心，两个逻辑线程，在一单位时间内处理两个线程的工作，模拟实体双核心、双线程运作。</p>\n<p>虽然采用超线程技术能同时执行两个线程，但它并不象两个真正的CPU那样，每个CPU都具有独立的资源。当两个线程都同时需要某一个资源时，其中一个要暂时停止，并让出资源，直到这些资源闲置后才能继续。因此超线程的性能并不等于两颗CPU的性能。</p>\n<h4 id=\"GUI为什么都是单线程\"><a href=\"#GUI为什么都是单线程\" class=\"headerlink\" title=\"GUI为什么都是单线程\"></a>GUI为什么都是单线程</h4><p>许多人曾经尝试过编写多线程的GUI来处理事件，但最终都由于竞态条件和死锁导致的稳定性而重回到单线程的事件队列模型：使用UI线程从队列中抽取事件，并将事件分发给事件处理器（消费者）。</p>\n<p>另一个重要原因是MVC会导致多线程的GUI因为不一致的锁定顺序而发生死锁。<br><img src=\"http://www.51cto.com/files/uploadimg/20061010/1202170.gif\" alt=\"MVC模式图\"></p>\n<h4 id=\"推荐两本书\"><a href=\"#推荐两本书\" class=\"headerlink\" title=\"推荐两本书\"></a>推荐两本书</h4><blockquote>\n<p><strong>值得一看：</strong></p>\n<ul>\n<li><a href=\"http://book.douban.com/subject/5333562/\" target=\"_blank\" rel=\"noopener\">深入理解计算机系统</a></li>\n<li><a href=\"http://book.douban.com/subject/10484692/\" target=\"_blank\" rel=\"noopener\">Java并发编程实战</a></li>\n</ul>\n</blockquote>\n<h3 id=\"JAVA多线程中的单例——贾学涛\"><a href=\"#JAVA多线程中的单例——贾学涛\" class=\"headerlink\" title=\"JAVA多线程中的单例——贾学涛\"></a>JAVA多线程中的单例——贾学涛</h3><h4 id=\"常见单利模写法\"><a href=\"#常见单利模写法\" class=\"headerlink\" title=\"常见单利模写法\"></a>常见单利模写法</h4><pre><code>public class Singleton {  \n\n    private static Singleton mInstance；\n\n    private Singleton(){\n    }\n\n    public static Singleton getInstance(){\n        if (mInstance == null) {\n            mInstance = new Singleton();\n        }\n        return mInstance;\n    }\n}\n</code></pre><ul>\n<li>缺点：非线程安全的，在多线程并发的情况下容易出现多个实例存在的情况</li>\n</ul>\n<h4 id=\"改为线程安全的单例模式\"><a href=\"#改为线程安全的单例模式\" class=\"headerlink\" title=\"改为线程安全的单例模式\"></a>改为线程安全的单例模式</h4><p>通过添加synchronized关键字  </p>\n<pre><code>public class Singleton {  \n\n    private static Singleton mInstance；\n\n    private Singleton(){\n    }\n\n    public static synchronized Singleton getInstance(){\n        if (mInstance == null) {\n            mInstance = new Singleton();\n        }\n        return mInstance;\n    }\n}\n</code></pre><ul>\n<li>缺点：每次都要进行同步检查，实际上需要检查的时机是在首次创建实例的时候。</li>\n</ul>\n<h4 id=\"改为双重检查锁单例模式\"><a href=\"#改为双重检查锁单例模式\" class=\"headerlink\" title=\"改为双重检查锁单例模式\"></a>改为双重检查锁单例模式</h4><pre><code>public class Singleton {  \n\n    private static Singleton mInstance；\n\n    private Singleton(){\n    }\n\n    public static Singleton getInstance(){\n        if (mInstance == null) {          //Single Checked\n            synchronized(Singleton.class) {\n                if (mInstance == null) {        //Double Checked\n                    mInstance = new Singleton();\n                }\n            }\n        }\n        return mInstance;\n    }\n}\n</code></pre><ul>\n<li><p>instance = new Singleton()这句，并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情  </p>\n<blockquote>\n<p>1.给 instance 分配内存<br>2.调用 Singleton 的构造函数来初始化成员变量<br>3.将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了）  </p>\n</blockquote>\n<p>  但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的.可能会出现第一次检测是mInstance为非null时，有可能实例还未创建。所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。</p>\n</li>\n</ul>\n<h4 id=\"为实例变量增加volatile关键字\"><a href=\"#为实例变量增加volatile关键字\" class=\"headerlink\" title=\"为实例变量增加volatile关键字\"></a>为实例变量增加volatile关键字</h4><pre><code>public class Singleton {  \n\n    private volatile static Singleton mInstance；    // 增加volatile关键字\n\n    private Singleton(){\n    }\n\n    public static Singleton getInstance(){\n        if (mInstance == null) {          //Single Checked\n            synchronized(Singleton.class) {\n                if (mInstance == null) {        //Double Checked\n                    mInstance = new Singleton();\n                }\n            }\n        }\n        return mInstance;\n    }\n}\n</code></pre><ul>\n<li><p>使用 volatile 的主要原因是其另一个特性：禁止指令重排序优化。也就是说，在 volatile 变量的赋值操作后面会有一个内存屏障，读操作不会被重排序到内存屏障之前</p>\n</li>\n<li><p>Java 5 以前的版本使用了 volatile 的双检锁还是有问题的。其原因是 Java 5 以前的 JMM （Java 内存模型）是存在缺陷的，即时将变量声明成 volatile 也不能完全避免重排序</p>\n</li>\n</ul>\n<h4 id=\"饿汉加载单例模式\"><a href=\"#饿汉加载单例模式\" class=\"headerlink\" title=\"饿汉加载单例模式\"></a>饿汉加载单例模式</h4><pre><code>public class Singleton {  \n\n    private static Singleton mInstance ＝ new Singleton()；\n\n    private Singleton(){\n    }\n\n    public static Singleton getInstance(){\n        return mInstance;\n    }\n}\n</code></pre><p>变种的饿汉加载单例模式</p>\n<pre><code>public class Singleton {\n\n    private static Singleton mInstance；\n\n    static {\n        mInstance = new Singleton();\n    }\n\n    private Singleton(){\n    }\n\n    public static Singleton getInstance(){\n        return mInstance;\n    }\n}\n</code></pre><ul>\n<li>缺点：在类被加载的时候就会去创建实例，牺牲空间来保证时间，与之前的单例模式相反，懒汉加载是牺牲时间，来保证空间，在需要的时候再去创建实例。</li>\n</ul>\n<h4 id=\"通过静态内部类来创建单例\"><a href=\"#通过静态内部类来创建单例\" class=\"headerlink\" title=\"通过静态内部类来创建单例\"></a>通过静态内部类来创建单例</h4><pre><code>public class Singleton {\n\n    private Singleton(){\n    }\n\n    public static Singleton getInstance(){\n        return InnerClass.mInstance;\n    }\n\n    private staitc class InnerClass{\n        public static Singleton mInstance = new Singleton();\n    }\n}\n</code></pre><ul>\n<li>与前者一样，通过classloader机制来保证线程安全，区别是，前者当Singleton类被加载时，就会创建实例，而后者是在需要调用getInstance的时候去加载内部类的时候，来创建实例。</li>\n</ul>\n<h4 id=\"通过枚举来创建单例\"><a href=\"#通过枚举来创建单例\" class=\"headerlink\" title=\"通过枚举来创建单例\"></a>通过枚举来创建单例</h4><pre><code>public enum Singleton {\n    INSTANCE;\n}\n</code></pre><p>访问实例对象 Singleton.INSTANCE</p>\n<p>*默认枚举实例的创建是线程安全的，但是在枚举中的其他任何方法由程序员自己负责。</p>\n<h3 id=\"为什么要有线程同步之喂金鱼问题——曾铭\"><a href=\"#为什么要有线程同步之喂金鱼问题——曾铭\" class=\"headerlink\" title=\"为什么要有线程同步之喂金鱼问题——曾铭\"></a>为什么要有线程同步之喂金鱼问题——曾铭</h3><h4 id=\"喂金鱼问题\"><a href=\"#喂金鱼问题\" class=\"headerlink\" title=\"喂金鱼问题\"></a>喂金鱼问题</h4><ul>\n<li>金鱼一天不吃会饿死，一天吃两次会撑死；</li>\n<li>张三、李四，每天每人分别会去执行这件事一次；</li>\n</ul>\n<h4 id=\"方案-1\"><a href=\"#方案-1\" class=\"headerlink\" title=\"方案 1\"></a>方案 1</h4><p>两人执行一致</p>\n<pre><code>if (noFeed) {\n    feed fish\n}\n</code></pre><table>\n<thead>\n<tr>\n<th>张三</th>\n<th>李四</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>if (noFeed) {</td>\n<td>.</td>\n</tr>\n<tr>\n<td>.</td>\n<td>if (noFeed) {</td>\n</tr>\n<tr>\n<td>.</td>\n<td>feed fish</td>\n</tr>\n<tr>\n<td>feed fish</td>\n<td>.</td>\n</tr>\n<tr>\n<td>fish died</td>\n<td>.</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h5><ul>\n<li>feed fish 时间越长，鱼被撑死可能性越大</li>\n<li>没解决问题</li>\n</ul>\n<h4 id=\"方案-2\"><a href=\"#方案-2\" class=\"headerlink\" title=\"方案 2\"></a>方案 2</h4><p>两人执行一致</p>\n<pre><code>if (noNote) {\n    leave note\n\n    if (noFeed) {\n        feed fish\n    }\n\n    remove note\n}\n</code></pre><table>\n<thead>\n<tr>\n<th>张三</th>\n<th>李四</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>if (noNote) {</td>\n<td>.</td>\n</tr>\n<tr>\n<td>.</td>\n<td>if (noNote) {</td>\n</tr>\n<tr>\n<td>.</td>\n<td>leave note</td>\n</tr>\n<tr>\n<td>leave note</td>\n<td>.</td>\n</tr>\n<tr>\n<td>if (noFeed) {</td>\n<td>.</td>\n</tr>\n<tr>\n<td>.</td>\n<td>if (noFeed) {</td>\n</tr>\n<tr>\n<td>.</td>\n<td>feed fish</td>\n</tr>\n<tr>\n<td>feed fish</td>\n<td>.</td>\n</tr>\n<tr>\n<td>fish died</td>\n<td>.</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"结论-1\"><a href=\"#结论-1\" class=\"headerlink\" title=\"结论\"></a>结论</h5><ul>\n<li>noNote, noFeed 按特定顺序执行才会出问题</li>\n<li>noNote 多了一层保护，如果 leave note 时间很短，出问题可能性很小</li>\n<li>没解决问题</li>\n</ul>\n<h4 id=\"方案-3\"><a href=\"#方案-3\" class=\"headerlink\" title=\"方案 3\"></a>方案 3</h4><p>张三执行</p>\n<pre><code>leave note3\n\nif (noNote4) {\n    if (noFeed) {\n        feed fish\n    }\n}\n\nremove note3\n</code></pre><p>李四执行</p>\n<pre><code>leave note4\n\nif (noNote3) {\n    if (noFeed) {\n        feed fish\n    }\n}\n\nremove note4\n</code></pre><table>\n<thead>\n<tr>\n<th>张三</th>\n<th>李四</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>leave note3</td>\n<td>.</td>\n</tr>\n<tr>\n<td>.</td>\n<td>leave note4</td>\n</tr>\n<tr>\n<td>.</td>\n<td>if (noNote3) {</td>\n</tr>\n<tr>\n<td>if (noNote4) {</td>\n<td>.</td>\n</tr>\n<tr>\n<td>remove note3</td>\n<td>.</td>\n</tr>\n<tr>\n<td>.</td>\n<td>remove note4</td>\n</tr>\n<tr>\n<td>…</td>\n<td>…</td>\n</tr>\n<tr>\n<td>fish died</td>\n<td>.</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"结论-2\"><a href=\"#结论-2\" class=\"headerlink\" title=\"结论\"></a>结论</h5><ul>\n<li>不会被撑死了，可能会被饿死……</li>\n<li>没解决问题</li>\n</ul>\n<h4 id=\"方案-4\"><a href=\"#方案-4\" class=\"headerlink\" title=\"方案 4\"></a>方案 4</h4><p>张三执行</p>\n<pre><code>leave note3\n\nwhile (noNote4)\n{\n    sleep (1)\n}\n\nif (noFeed) {\n    feed fish\n}\n\nremove note3\n</code></pre><p>李四执行</p>\n<pre><code>leave note4\n\nif (noNote3) {\n    if (noFeed) {\n        feed fish\n    }\n}\n\nremove note4\n</code></pre><h5 id=\"结论-3\"><a href=\"#结论-3\" class=\"headerlink\" title=\"结论\"></a>结论</h5><ul>\n<li>的确解决了问题</li>\n<li>能优化么？<ul>\n<li>程序不不对称</li>\n<li>循环等待的浪费</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"方案-5\"><a href=\"#方案-5\" class=\"headerlink\" title=\"方案 5\"></a>方案 5</h4><p>两人执行一致</p>\n<pre><code>lock()\n\nif (noFeed) {\n    feed fish\n}\n\nunlock()\n</code></pre><h5 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h5><ul>\n<li>能解决问题</li>\n<li>程序对称</li>\n<li>持有锁需要等待，未解决浪费问题<ul>\n<li>生产者与消费者问题</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"END\"><a href=\"#END\" class=\"headerlink\" title=\"END\"></a>END</h4><p><strong>全部内容来自<a href=\"http://book.douban.com/subject/3670621/\" target=\"_blank\" rel=\"noopener\">《计算机的心智·操作系统之哲学原理》——\u0004邹恒明</a> 第七章</strong></p>\n<h3 id=\"iOS并发相关的概念介绍——潘君\"><a href=\"#iOS并发相关的概念介绍——潘君\" class=\"headerlink\" title=\"iOS并发相关的概念介绍——潘君\"></a>iOS并发相关的概念介绍——潘君</h3><p>@(归纳中)[iOS]</p>\n<h4 id=\"基础概念\"><a href=\"#基础概念\" class=\"headerlink\" title=\"基础概念\"></a>基础概念</h4><p>#####竞态条件<br>竞态条件（race condition），从多进程间通信的角度来讲，是指两个或多个进程对共享的数据进行读或写的操作时，最终的结果取决于这些进程的执行顺序。<br>竞态条件（race condition）是指设备或系统出现不恰当的执行时序，而得到不正确的结果。</p>\n<p>注: <code>atomic</code> 可以解决竞态竞争 但是无法保证类是<code>线程安全</code>的</p>\n<h4 id=\"iOS中的相关概念\"><a href=\"#iOS中的相关概念\" class=\"headerlink\" title=\"iOS中的相关概念\"></a>iOS中的相关概念</h4><p>#####atomic属性</p>\n<blockquote>\n<p>property 修饰符</p>\n</blockquote>\n<p>加了atomic后生成的setter,类似如下代码:</p>\n<pre><code>- (void)setProp:(NSString *)newValue {\n    [_prop lock];\n    _prop = newValue;\n    [_prop unlock];\n}\n</code></pre><p>#####@synchronized指令</p>\n<blockquote>\n<p>引用自<a href=\"http://www.xuebuyuan.com/1682784.html\" target=\"_blank\" rel=\"noopener\">@synchronized(id anObject) ｛｝定义和使用</a><br>1.作用：创建了一个互斥锁，它的作用和其他语言中的互斥锁作用一样</p>\n<p>2.解释：这个是OBC中的一个锁定令牌，防止｛｝里的内容在同一时间内被其他线程访问，起到了线程保护的作用</p>\n<p>3.使用范围：一般在单例模式或者操作类的static变量的时候使用，即共用的变量的时候</p>\n<p>4.外延：这个令牌隐式的包含了异常处理，如果你不想使用的话，就使用锁吧</p>\n<p>5.它的参数是id类型，如果用<br>@synchronized(1) {<br>}<br>编译器提示<br>@synchronzied requires an Objective-C object type.<br>也就是说需要一个objective C的对象类型。</p>\n</blockquote>\n<pre><code>@synchronized(id anObject){\n     // test code\n}\n</code></pre><p>#####NSLock</p>\n<p>使用样例:</p>\n<pre><code>//主线程中\nTestObj *obj = [[TestObj alloc] init];\nNSLock *lock = [[NSLock alloc] init];\n\n//线程1\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n    [lock lock];\n    [obj method1];\n    sleep(10);\n    [lock unlock];\n});\n\n//线程2\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n    sleep(1);//以保证让线程2的代码后执行\n    [lock lock];\n    [obj method2];\n    [lock unlock];\n});\n</code></pre><p>###<a href=\"https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/Introduction/Introduction.html\" target=\"_blank\" rel=\"noopener\">iOS多线程</a> - 杨志平</p>\n<p>####简介</p>\n<p>iOS有三种多线程编程的技术，分别是：</p>\n<ul>\n<li><h4 id=\"NSThread\"><a href=\"#NSThread\" class=\"headerlink\" title=\"NSThread\"></a>NSThread</h4></li>\n<li><h4 id=\"Cocoa-NSOperation\"><a href=\"#Cocoa-NSOperation\" class=\"headerlink\" title=\"Cocoa NSOperation\"></a>Cocoa NSOperation</h4></li>\n<li><h4 id=\"GCD-（全称：Grand-Central-Dispatch）\"><a href=\"#GCD-（全称：Grand-Central-Dispatch）\" class=\"headerlink\" title=\"GCD （全称：Grand Central Dispatch）\"></a>GCD <strong><em>（全称：Grand Central Dispatch）</em></strong></h4></li>\n</ul>\n<blockquote>\n<p> <em>这三种编程方式从上到下，抽象度层次是从低到高的，抽象度越高的使用越简单，也是Apple最推荐使用的</em></p>\n</blockquote>\n<h4 id=\"三种方式的介绍：\"><a href=\"#三种方式的介绍：\" class=\"headerlink\" title=\"三种方式的介绍：\"></a>三种方式的介绍：</h4><h5 id=\"NSThread-文档\"><a href=\"#NSThread-文档\" class=\"headerlink\" title=\"NSThread - 文档\"></a>NSThread - <a href=\"https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Reference/Foundation/Classes/NSThread_Class/\" target=\"_blank\" rel=\"noopener\">文档</a></h5><blockquote>\n<p>优点：NSThread 比其他两个轻量级<br>缺点：需要自己管理线程的生命周期，线程同步。线程同步对数据的加锁会有一定的系统开销</p>\n</blockquote>\n<h5 id=\"NSOperation-文档\"><a href=\"#NSOperation-文档\" class=\"headerlink\" title=\"NSOperation - 文档\"></a>NSOperation - <a href=\"https://developer.apple.com/library/mac/documentation/Cocoa/Reference/NSOperation_class/\" target=\"_blank\" rel=\"noopener\">文档</a></h5><blockquote>\n<p>优点：不需要关心线程管理，数据同步的事情，可以把精力放在自己需要执行的操作上。<br>创建NSOperation子类的对象，把对象添加到NSOperationQueue队列里执行。</p>\n</blockquote>\n<h5 id=\"GCD-文档\"><a href=\"#GCD-文档\" class=\"headerlink\" title=\"GCD - 文档\"></a>GCD - <a href=\"https://developer.apple.com/library/prerelease/ios/documentation/Performance/Reference/GCD_libdispatch_Ref/index.html\" target=\"_blank\" rel=\"noopener\">文档</a></h5><blockquote>\n<p>Grand Central Dispatch (GCD)是Apple开发的一个多核编程的解决方法。在iOS4.0开始之后才能使用。GCD是一个替代诸如NSThread, NSOperationQueue, NSInvocationOperation等技术的很高效和强大的技术。</p>\n<p>GCD的底层依然是用线程实现，不过这样可以让程序员不用关注实现的细节。</p>\n</blockquote>\n<h4 id=\"创建线程的开销-查看文档\"><a href=\"#创建线程的开销-查看文档\" class=\"headerlink\" title=\"创建线程的开销 - 查看文档\"></a>创建线程的开销 - <a href=\"https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/CreatingThreads/CreatingThreads.html\" target=\"_blank\" rel=\"noopener\">查看文档</a></h4><table>\n<thead>\n<tr>\n<th>Item</th>\n<th>Approximate cost</th>\n<th>Notes</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Kernel data structures</td>\n<td>Approximately 1 KB</td>\n<td>This memory is used to store the thread data structures and attributes, much of which is allocated as wired memory and therefore cannot be paged to disk.</td>\n</tr>\n<tr>\n<td>Stack space</td>\n<td>512 KB (secondary threads)  8 MB (OS X main thread)  1 MB (iOS main thread)</td>\n<td>The minimum allowed stack size for secondary threads is 16 KB and the stack size must be a multiple of 4 KB. The space for this memory is set aside in your process space at thread creation time, but the actual pages associated with that memory are not created until they are needed.</td>\n</tr>\n<tr>\n<td>Creation time</td>\n<td>Approximately 90 microseconds</td>\n<td>This value reflects the time between the initial call to create the thread and the time at which the thread’s entry point routine began executing. The figures were determined by analyzing the mean and median values generated during thread creation on an Intel-based iMac with a 2 GHz Core Duo processor and 1 GB of RAM running OS X v10.5.</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"替代线程的一些技术\"><a href=\"#替代线程的一些技术\" class=\"headerlink\" title=\"替代线程的一些技术\"></a>替代线程的一些技术</h4><table>\n<thead>\n<tr>\n<th>Item</th>\n<th>Approximate cost</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Operation objects</td>\n<td>Introduced in OS X v10.5, an operation object is a wrapper for a task that would normally be executed on a secondary thread. This wrapper hides the thread management aspects of performing the task, leaving you free to focus on the task itself. You typically use these objects in conjunction with an operation queue object, which actually manages the execution of the operation objects on one or more threads.For more information on how to use operation objects, see <a href=\"https://developer.apple.com/library/mac/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008091\" target=\"_blank\" rel=\"noopener\">Concurrency Programming Guide</a>.</td>\n</tr>\n<tr>\n<td>Grand Central Dispatch (GCD)</td>\n<td>Introduced in Mac OS x v10.6, Grand Central Dispatch is another alternative to threads that lets you focus on the tasks you need to perform rather than on thread management. With GCD, you define the task you want to perform and add it to a work queue, which handles the scheduling of your task on an appropriate thread. Work queues take into account the number of available cores and the current load to execute your tasks more efficiently than you could do yourself using threads.For information on how to use GCD and work queues, see <a href=\"https://developer.apple.com/library/mac/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008091\" target=\"_blank\" rel=\"noopener\">Concurrency Programming Guide</a></td>\n</tr>\n<tr>\n<td>Idle-time notifications</td>\n<td>For tasks that are relatively short and very low priority, idle time notifications let you perform the task at a time when your application is not as busy. Cocoa provides support for idle-time notifications using the NSNotificationQueue object. To request an idle-time notification, post a notification to the default <a href=\"https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSNotificationQueue_Class/index.html#//apple_ref/occ/cl/NSNotificationQueue\" target=\"_blank\" rel=\"noopener\">NSNotificationQueue</a> object using the <a href=\"https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSNotificationQueue_Class/index.html#//apple_ref/c/econst/NSPostWhenIdle\" target=\"_blank\" rel=\"noopener\">NSPostWhenIdle</a> option. The queue delays the delivery of your notification object until the run loop becomes idle. For more information, see <a href=\"https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Notifications/Introduction/introNotifications.html#//apple_ref/doc/uid/10000043i\" target=\"_blank\" rel=\"noopener\">Notification Programming Topics</a>.</td>\n</tr>\n<tr>\n<td>Asynchronous functions</td>\n<td>The system interfaces include many asynchronous functions that provide automatic concurrency for you. These APIs may use system daemons and processes or create custom threads to perform their task and return the results to you. (The actual implementation is irrelevant because it is separated from your code.) As you design your application, look for functions that offer asynchronous behavior and consider using them instead of using the equivalent synchronous function on a custom thread</td>\n</tr>\n<tr>\n<td>Timers</td>\n<td>You can use timers on your application’s main thread to perform periodic tasks that are too trivial to require a thread, but which still require servicing at regular intervals. For information on timers, see <a href=\"https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW21\" target=\"_blank\" rel=\"noopener\">Timer Sources</a></td>\n</tr>\n<tr>\n<td>Separate processes</td>\n<td>Although more heavyweight than threads, creating a separate process might be useful in cases where the task is only tangentially related to your application. You might use a process if a task requires a significant amount of memory or must be executed using root privileges. For example, you might use a 64-bit server process to compute a large data set while your 32-bit application displays the results to the user</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"线程安全-文档\"><a href=\"#线程安全-文档\" class=\"headerlink\" title=\"线程安全 - 文档\"></a>线程安全 - <a href=\"https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/ThreadSafetySummary/ThreadSafetySummary.html#//apple_ref/doc/uid/10000057i-CH12-SW1\" target=\"_blank\" rel=\"noopener\">文档</a></h4><h5 id=\"原则\"><a href=\"#原则\" class=\"headerlink\" title=\"原则\"></a>原则</h5><ul>\n<li>Immutable objects are generally thread-safe. Once you create them, you can safely pass these objects to and from threads. On the other hand, mutable objects are generally not thread-safe. To use mutable objects in a threaded application, the application must synchronize appropriately.</li>\n<li>Many objects deemed “thread-unsafe” are only unsafe to use from multiple threads. Many of these objects can be used from any thread as long as it is only one thread at a time. Objects that are specifically restricted to the main thread of an application are called out as such</li>\n<li>The main thread of the application is responsible for handling events. Although the Application Kit continues to work if other threads are involved in the event path, operations can occur out of sequence</li>\n<li>If you want to use a thread to draw to a view, bracket all drawing code between the <strong><em>lockFocusIfCanDraw</em></strong> and <strong><em>unlockFocus</em></strong> methods of NSView</li>\n</ul>\n<h5 id=\"Thread-Safe-Classes-and-Functions\"><a href=\"#Thread-Safe-Classes-and-Functions\" class=\"headerlink\" title=\"Thread-Safe Classes and Functions\"></a>Thread-Safe Classes and Functions</h5><p>The following classes and functions are generally considered to be thread-safe. You can use the same instance from multiple threads without first acquiring a lock.</p>\n<blockquote>\n<p>NSArray<br>NSAssertionHandler<br>NSAttributedString<br>NSCalendarDate<br>NSCharacterSet<br>NSConditionLock<br>NSConnection<br>NSData<br>NSDate<br>NSDecimal functions<br>NSDecimalNumber<br>NSDecimalNumberHandler<br>NSDeserializer<br>NSDictionary<br>NSDistantObject<br>NSDistributedLock<br>NSDistributedNotificationCenter<br>NSException<br>NSFileManager (in OS X v10.5 and later)<br>NSHost<br>NSLock<br>NSLog/NSLogv<br>NSMethodSignature<br>NSNotification<br>NSNotificationCenter<br>NSNumber<br>NSObject<br>NSPortCoder<br>NSPortMessage<br>NSPortNameServer<br>NSProtocolChecker<br>NSProxy<br>NSRecursiveLock<br>NSSet<br>NSString<br>NSThread<br>NSTimer<br>NSTimeZone<br>NSUserDefaults<br>NSValue</p>\n</blockquote>\n<h5 id=\"Thread-Unsafe-Classes\"><a href=\"#Thread-Unsafe-Classes\" class=\"headerlink\" title=\"Thread-Unsafe Classes\"></a>Thread-Unsafe Classes</h5><p>The following classes and functions are generally not thread-safe. In most cases, you can use these classes from any thread as long as you use them from only one thread at a time.</p>\n<blockquote>\n<p>NSArchiver<br>NSAutoreleasePool<br>NSBundle<br>NSCalendar<br>NSCoder<br>NSCountedSet<br>NSDateFormatter<br>NSEnumerator<br>NSFileHandle<br>NSFormatter<br>NSHashTable functions<br>NSInvocation<br>NSJavaSetup functions<br>NSMapTable functions<br>NSMutableArray<br>NSMutableAttributedString<br>NSMutableCharacterSet<br>NSMutableData<br>NSMutableDictionary<br>NSMutableSet<br>NSMutableString<br>NSNotificationQueue<br>NSNumberFormatter<br>NSPipe<br>NSPort<br>NSProcessInfo<br>NSRunLoop<br>NSScanner<br>NSSerializer<br>NSTask<br>NSUnarchiver<br>NSUndoManager</p>\n</blockquote>\n<p>#####Main Thread Only Classes</p>\n<p>The following class must be used only from the main thread of an application.</p>\n<blockquote>\n<p>NSAppleScript</p>\n</blockquote>\n<h3 id=\"多线程的死锁-张超耀\"><a href=\"#多线程的死锁-张超耀\" class=\"headerlink\" title=\"多线程的死锁 - 张超耀\"></a>多线程的死锁 - 张超耀</h3><ul>\n<li>俗话说，人多好办事！在程序里也是这样，如果是同一个应用程序需要并行处理多件任务，那就可以创建多条线程。但是人多了，往往会出现冲突，使得这个工作无法再进行下去了(正所谓三个和尚没水喝)，这就是“死锁”。</li>\n</ul>\n<h4 id=\"死锁的产生\"><a href=\"#死锁的产生\" class=\"headerlink\" title=\"死锁的产生\"></a>死锁的产生</h4><ul>\n<li><a href=\"http://baike.baidu.com/link?url=OgOrpH_xTP7U0C0tM59aBhq83uaKe0Ck9MQEL1G41A3q-D1hVuynm3ra-U93RoQICKbmqhs7nTuCoN_elydnr_\" target=\"_blank\" rel=\"noopener\">哲学家进餐问题</a></li>\n</ul>\n<p><strong>那么我们如何来消除“死锁”呢？首先，让我们来看看产生“死锁”的必要条件：</strong></p>\n<ul>\n<li><p>互斥：就是说多个线程不能同时使用同一资源</p>\n</li>\n<li><p>请求和保持：就是某线程必须同时拥有多个资源才能完成任务，否则它将占用已经拥有的资源直到拥有他所需的所有资源为止</p>\n</li>\n<li><p>不剥夺：就是说所有线程的优先级都相同，不能在别的线程没有释放资源的情况下，夺走其已占有的资源</p>\n</li>\n<li><p>循环等待，就是没有资源满足的线程无限期地等待</p>\n</li>\n</ul>\n<p><strong>有的朋友可能已经明白了，只要打破这这几个必要条件，就能打破“死锁”！</strong></p>\n<ul>\n<li><p>互斥：就是要让多个线程能共享资源</p>\n</li>\n<li><p>请求和保持：只要当检测到自己所需的资源仍被别的线程占用，即释放自己已占有的资源（毫不利己，专门利人），或者在经过一段时间的等待后，还未得到所需资源，才释放，这都能打破请求和保持</p>\n</li>\n<li><p>不剥夺：只要给线程制定一个优先级即可</p>\n</li>\n<li><p>最后的循环等待的解决方法其实和<code>请求和保持</code>是一样的，都是等待一段时间后释放资源。</p>\n</li>\n</ul>\n<p><strong>好了，希望通过这个例子能让不了解死锁的朋友对“死锁”能有一定的认识</strong></p>\n<h2 id=\"集合的并行操作-王胜\"><a href=\"#集合的并行操作-王胜\" class=\"headerlink\" title=\"集合的并行操作 - 王胜\"></a>集合的并行操作 - 王胜</h2><p>用for循环操作一个集合，即读取集合元素，同时又删除集合中的元素，会发生什么事情呢？</p>\n<p>上代码【号外，号外，此示例来源于我们项目中的真实代码哦~】</p>\n<pre><code class=\"Java\">// Target class\nclass Target {\n    int id;// ID\n    String type;// 类型\n    int count;// 未读消息数\n\n    public Target(int id, String type, int count) {\n        this.id = id;\n        this.type = type;\n        this.count = count;\n    }\n\n    @Override\n    public String toString() {\n        return &quot;Target [id=&quot; + id + &quot;, type=&quot; + type + &quot;, count=&quot; + count + &quot;]&quot;;\n    }\n\n}\n\n// 以下是模拟一组target集合，target包含group、room、user类型。\nList&lt;Target&gt; sessions = new ArrayList&lt;Target&gt;();\nsessions.add(new Target(1, &quot;group&quot;, 1));\nsessions.add(new Target(2, &quot;group&quot;, 1));\nsessions.add(new Target(3, &quot;group&quot;, 1));\nsessions.add(new Target(4, &quot;room&quot;, 1));\nsessions.add(new Target(5, &quot;group&quot;, 1));\nsessions.add(new Target(6, &quot;group&quot;, 1));\nsessions.add(new Target(7, &quot;group&quot;, 1));\nsessions.add(new Target(8, &quot;user&quot;, 1));\nsessions.add(new Target(9, &quot;user&quot;, 1));\nsessions.add(new Target(10, &quot;group&quot;, 1));\nSystem.out.println(&quot;before size:&quot;+sessions.size()+&quot;, sessions:&quot;+humanPrintList(sessions));\nint totalUnread = 0;// 统计集合中类型为group的target未读消息数量\nfor (int i=0;i&lt;sessions.size();i++) {\n    System.out.println(&quot;read index:&quot; + i + &quot;, session:&quot;+sessions.get(i));\n    if (sessions.get(i).type.equals(&quot;group&quot;)) {// 如果是group类型，则累加未读消息数\n        System.out.println(&quot;==&gt; add totalUnread&quot;);\n        totalUnread += sessions.get(i).count;\n    } else {// 否则，将target移除集合\n        System.out.println(&quot;==&gt; remove&quot;);\n        sessions.remove(i);\n    }\n}\nSystem.out.println(&quot;after size:&quot;+sessions.size()+&quot;, totalUnread:&quot;+totalUnread+&quot;,sessions:&quot;+humanPrintList(sessions));\n</code></pre>\n<p>至此，示例代码结束。大家可以猜测下最后的输出中sessions的长度，内容以及总共的未读消息数据。</p>\n<p>项目中的代码，期望结果是剩余集合只包含group类型的target，而且totalUnread的值是类型为group的target的未读消息数之和。可是，运行的结果却是：</p>\n<pre><code>before size:10, sessions:\n========== List content: ===========\nTarget [id=1, type=group, count=1]\nTarget [id=2, type=group, count=1]\nTarget [id=3, type=group, count=1]\nTarget [id=4, type=room, count=1]\nTarget [id=5, type=group, count=1]\nTarget [id=6, type=group, count=1]\nTarget [id=7, type=group, count=1]\nTarget [id=8, type=user, count=1]\nTarget [id=9, type=user, count=1]\nTarget [id=10, type=group, count=1]\n====================================\nread index:0, session:Target [id=1, type=group, count=1]\n==&gt; add totalUnread\nread index:1, session:Target [id=2, type=group, count=1]\n==&gt; add totalUnread\nread index:2, session:Target [id=3, type=group, count=1]\n==&gt; add totalUnread\nread index:3, session:Target [id=4, type=room, count=1]\n==&gt; remove\nread index:4, session:Target [id=6, type=group, count=1]\n==&gt; add totalUnread\nread index:5, session:Target [id=7, type=group, count=1]\n==&gt; add totalUnread\nread index:6, session:Target [id=8, type=user, count=1]\n==&gt; remove\nread index:7, session:Target [id=10, type=group, count=1]\n==&gt; add totalUnread\nafter size:8, totalUnread:6,sessions:\n========== List content: ===========\nTarget [id=1, type=group, count=1]\nTarget [id=2, type=group, count=1]\nTarget [id=3, type=group, count=1]\nTarget [id=5, type=group, count=1]\nTarget [id=6, type=group, count=1]\nTarget [id=7, type=group, count=1]\nTarget [id=9, type=user, count=1]\nTarget [id=10, type=group, count=1]\n====================================\n</code></pre><p>为什么结果完全不是预期的呢？原因是程序走到else时，将元素移除，后面的元素自动往前移动，所以继续取下一个下标时，被移除的后一个元素悄悄溜走了，成了漏网之鱼。</p>\n<p><strong>解决方法</strong> : 最简单的就是在remove后执行 <code>i--;</code></p>\n"},{"title":"网络信息安全","date":"2015-07-31T11:08:35.000Z","_content":"\n## 微信支付的网络安全 - 王胜\n\n### 协议规则\n\n- 采用HTTPS传输\n- POST提交\n- MD5签名，请求和接收数据均需要校验签名，[详见](#安全规范)\n- 调用申请退款、撤销订单接口需要商户证书\n\n### 安全规范\n\n- 签名算法\n  1. 设所有发送或者接收到的数据为集合M，将集合M内非空参数值的参数按照参数名ASCII码从小到大排序（字典序），使用URL键值对的格式（即key1=value1&key2=value2…）拼接成字符串stringA。\n  2. 在stringA最后拼接上key得到stringSignTemp字符串，并对stringSignTemp进行MD5运算，再将得到的字符串所有字符转换为大写，得到sign值signValue\n- 生成随机数算法\n\n  微信支付API接口协议中包含字段nonce_str，主要保证签名不可预测。我们推荐生成随机数算法如下：调用随机数函数生成，将得到的值转换为字符串\n- 商户证书\n  - 获取商户证书\n    > 微信支付接口中，涉及资金回滚的接口会使用到商户证书，包括退款、撤销接口。\n   \n  - 使用商户证书\n  - 商户证书安全\n- 商户回调API安全\n\n  在普通的网络环境下，HTTP请求存在DNS劫持、运营商插入广告、数据被窃取，正常数据被修改等安全风险。商户回调接口使用HTTPS协议可以保证数据传输的安全性。所以微信支付建议商户提供给微信支付的各种回调采用HTTPS协议。请参考：[HTTPS搭建指南](https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=10_4)。\n\n参考资料：[微信支付](https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=4_1)\n\n## 安全『相对论』 - 曾铭\n\n### 角色\n\n#### 介质\n- 服务器\n- API\n- 网络传输过程\n- 客户端\n\n#### 人\n- owner： 开发者 内部人员\n- 用户：消费者、商家\n- 『坏人们』：黑客（白帽）、『友商』、路过……\n\n分清角色才能明白设定一个安全逻辑是针对谁，解决什么问题。\n\n### 目标\n\n- 『一有适当的利润，资本就会非常胆壮起来。只要有10％的利润，它就会到处被人使用；有20％，就会活泼起来；有50％，就会引起积极的冒险；有100％，就会使人不顾一切法律；有300％，就会使人不怕犯罪，甚至不怕绞首的危险。』\n- 没有绝对的安全，只有相对的安全\n- 为了安全是否影响了普通用户？能否变通？\n- 影响的是一个用户还是全部用户？\n- 能否补救？主动？被动？\n- 你不需要完美，你只需要比友商好一些\n\n### 实践\n\n聊聊发短信接口的案例\n- get -> post\n- 限制单日单个手机号，（避免单个手机号过多骚扰，产品不完整，建议加提示）\n- 限制单个 IP 请求次数 （有必要，但要适量放宽，要跟踪结果）\n- 图形验证码 (把问题转化为计算机不擅长的问题来保障安全，有必要，用户体验有影响，可优化）\n- 一种 API 加密方式（根本问题是：API 如何判断这个请求是可信的客户端发来的）\n\n```\n客户端 - 网络传输 - API\nkey, 加密（签名）算法 sign=md5(key+url_path+time)\n\n```\n\n## RSA -李仙鹏\n在公钥系统中，我们采用公钥加密，私钥解密的方式，使得报文能够比较安全的传输。\n\n假设A和B通信，但他们之间不通过对称密钥，B有一个公钥$K_B^+$和一个私钥$K_B^-$。为了与B实现通信，A首先需要获得B的公钥$K_B^+$对报文m进行加密，即$K_B^+(m)$；B收到A的加密报文后用私钥$K_B^-$进行解密，即$K_B^-(K_B^+(m))=m$。其中的加解密算法通常使用RSA（RSA取创始人Ron Rivest, Adi Shamir, Leonard Adleman的姓氏首字母）。\n\n### RSA工作方式\n\n加密时，首先把报文m做e次的幂运算，然后做模n的算数运算，即$m^e\\%n$；解密则先把上述密文值做d次幂，再做模n运算，即$(m^e)^d\\%n=m^\\left(ed\\right)\\%n$。\n\n### RSA工作原理推导\n\n为了解开RSA工作原理的神秘面纱，需要使用数论中的一个神奇结论：如果***p和q是素数***，且有$n=pq$，则$x^y\\%n$与$x^\\left(y\\%\\left(p-1\\right)\\left(q-1\\right)\\right)\\%n$相等。应用这个结论，那我们的私钥解密为：$$(m^e)^d\\%n=m^\\left(ed\\%\\left(p-1\\right)\\left(q-1\\right)\\right)\\%n$$\n\n注意，$m<n$，并且我们是这样选择e和d的：$ed-1$能被$\\left(p-1\\right)\\left(q-1\\right)$整除，等价地说$ed\\%\\left(p-1\\right)\\left(q-1\\right)=1$，由此可得：$$(m^e)^d\\%n=m^1\\%n=m\\qquad m<n，n=pq,ed\\%\\left(p-1\\right)\\left(q-1\\right)=1,p和q是素数$$\n\n于是乎，就得到了我们希望的结果：先对m做e次幂（加密）再做d次幂（解密），然后做模n的算数运算，就可得到原始报文m。另外通过颠倒上述公式的加解密次序，一样能得到原来的m。\n$$(m^e)^d\\%n=m=(m^d)^e\\%n\\Rightarrow K_B^-(K_B^+(m))=m=K_B^+(K_B^-(m))$$\n\n因此B对外公开的公钥$K_B^+$为二元组$(n,e)$，私钥$K_B^-$为二元组$(n,d)$\n\n####举例验证\n\n条件：$$m<n，\\quad n=pq,\\quad ed\\%\\left(p-1\\right)\\left(q-1\\right)=1,\\quad p和q是素数$$\n\n取简单的值：$$p=5,\\quad q=7$$\n\n那么可以推导出：$$n=pq=5*7=35,\\quad (ed-1)\\%(p-1)(q-1)=0\\Rightarrow (ed-1)\\%(5-1)(7-1)=0\\Rightarrow (ed-1)\\%24=0$$\n\n于是，我们可以简单起见，为了减少计算量，设$ed-1$为$24$的1倍，那么我们可取值$$e=5,\\quad d=5$$\n\n假设传输明文为：$$m=3$$\n\n那么综上所述，我们可以得出：\n\n- 加密，$m^e\\%n=3^5\\%35=33$\n\n- 解密，$(m^e\\%n)^d\\%n=33^5\\%35=3=m$，因此对RSA加密后的密文解密得到的就是原始的明文\n\n## iOS 越狱应用安全-潘君\n\n- 对ipa砸壳\n- class-dump 导出头文件\n- 头文件导入project方便查看\n- 善用Xcode的搜索找需要hook的函数\n- hook函数完成不可告人的目的\n\t- [Message Hook](http://blog.sina.com.cn/s/blog_45e2b66c01016jn5.html)\n\n### 参考资料\n- [iOS Security](http://security.ios-wiki.com/)\n- [iOSRE](http://iosre.com/c/development-discussion)\n\n# 网络安全 - 张超耀\n## 主要特性\n- 保密性\n\t- 信息不泄露给非授权用户、实体或过程，或供其利用的特性。\n\n- 完整性\n\t- 数据未经授权不能进行改变的特性。即信息在存储或传输过程中保持不被修改、不被破坏和丢失的特性。\n\n- 可用性\n\t- 可被授权实体访问并按需求使用的特性。即当需要时能否存取所需的信息。例如网络环境下拒绝服务、破坏网络和有关系统的正常运行等都属于对可用性的攻击；\n\n- 可控性\n\t- 对信息的传播及内容具有控制能力。\n\n- 可审查性\n\t- 出现安全问题时提供依据与手段\n\n## 主要类型\n### 网络安全由于不同的环境和应用而产生了不同的类型。主要有以下几种:\n\n- 系统安全\n\t- 运行系统安全即保证信息处理和传输系统的安全。它侧重于保证系统正常运行。避免因为系统的崩演和损坏而对系统存储、处理和传输的消息造成破坏和损失。避免由于电磁泄翻，产生信息泄露，干扰他人或受他人干扰。\n\n- 网络的安全\n\t- 网络上系统信息的安全。包括用户口令鉴别，用户存取权限控制，数据存取权限、方式控制，安全审计。安全问题跟踩。计算机病毒防治，数据加密等。\n\n- 信息传播安全\n\t- 网络上信息传播安全，即信息传播后果的安全，包括信息过滤等。它侧重于防止和控制由非法、有害的信息进行传播所产生的后果，避免公用网络上大云自由传翰的信息失控。\n\n- 信息内容安全\n\t- 网络上信息内容的安全。它侧重于保护信息的保密性、真实性和完整性。避免攻击者利用系统的安全漏润进行窃听、冒充、诈编等有损于合法用户的行为。其本质是保护用户的利益和隐私。\n\n## HTTP加密 -吴明\n- 对称性加密\n\t- 加密双方使用同一个密钥进行加密和解密。密钥是控制加密及解密过程的指令。算法是一组规则，规定如何进行加密和解密\n\t- 常用算法:\n\t\t- DES、3DES、TDEA、Blowfish、RC2、RC4、RC5、IDEA、SKIPJACK、AES\n- 非对称性加密\n\t- 非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。\n\t- RSA、Elgamal、背包算法、Rabin、D-H、ECC（椭圆曲线加密算法）\n- 对称性加密示例\n\t- sig计算\nsig主要用来做校验，由BaseString和SecretKey通过HMAC-SHA1算法计算得到的。\n\t- BaseString 组成\n BaseString由以下三部分组成：http方法名、请求url和参数，其中参数需要按照统一的规则进行编码和排序，具体规则如下：\n根据参数名称将所有请求参数按照参数名字母的先后顺序逐个比较，进行升序排序（参数名注意区分大小写），然后使用=号连接参数名和编码后的参数值，最后使用_下划线连接经过上述处理后的参数，例如：\n<code>\nparam1=encode(value1)_param2=encode(value2)_parma3=encode(value3)\n</code>\n注：a、比如参数名：abcdef和abcDef，abc都是一样的，大写D的asi码在小写d的asi码前面，所以：abcDef排在abcdef前面\nb、BaseString中的参数是指所有GET/POST的请求参数，但不包括sig参数，也不包括cookie或HTTP header字段\n将http方法名、请求url和参数这三部分用”&”连接起来，然后再进行\nencode编码即得到BaseString，使用伪代码描述以上过程如下：\n<code>\nBaseString=encode(httpMethod+\"&\"+httpUrl+\"&\"+sorted_query_params.each{|p,v|p+\"=\"+encode(v)}.join(\"_\"))\n</code>\n然后使用BaseString和SecretKey通过HMAC-SHA1算法计算sig，最后将计算\n出的sig进行编码，使用伪代码描述签名过程如下：\nencode (getHmacSHA1Sig(BaseString, SecretKey)）\n - sig计算示例\n例如某个请求的url为http://192.168.6.218:8080/test/jobplan/login，假设使用的ConsumerKey为eqsrje1tlarvvm54fwsjhcb4,使用的SecretKey为ks5t9fpiwmo3oanccu4f6eas,请求中用到的参数如下：\n<code>\nconsumer_key – eqsrje1tlarvvm54fwsjhcb4\nhrid - 00016145\npassword - 7215ee9c7d9dc229d2921a40e899ec5f\nfields - dspName\nformat – xml\ntimestamp - 2013-11-20 09:21:17\n</code>\n首先依据上面的算法得出BaseString为:\n<code>\nPOST%26http%3A%2F%2F192.168.6.218%3A8080%2FfuannaEP%2Fjobplan%2Flogin%26consumer_key%3Deqsrje1tlarvvm54fwsjhcb4_fields%3DdspName_format%3Djson_hrid%3D00016145_password%3D7215ee9c7d9dc229d2921a40e899ec5f_timestamp%3D2013-11-20%2B09%253A21%253A17\n</code>\n通过BaseString和SecretKey通过HMAC-SHA1算法计算所得的签名如下：\ndqgTQkET7MxSShy1M4WXbWEKodA%3D\n然后就可以发送请求，生成的http 请求链接如下：\n<code>\nhttp://192.168.6.218:8080/test/jobplan/login?password=7215ee9c7d9dc229d2921a40e899ec5f&consumer_key=eqsrje1tlarvvm54fwsjhcb4&hrid=10057&format=xml&fields=dspName×tamp =2013-11-20 09:21:17&signature=dqgTQkET7MxSShy1M4WXbWEKodA%3D\n</code>","source":"_posts/网络信息安全.md","raw":"title: 网络信息安全\ndate: 2015-07-31  11:08:35\ntags:\ncategories: 移动组周分享\n---\n\n## 微信支付的网络安全 - 王胜\n\n### 协议规则\n\n- 采用HTTPS传输\n- POST提交\n- MD5签名，请求和接收数据均需要校验签名，[详见](#安全规范)\n- 调用申请退款、撤销订单接口需要商户证书\n\n### 安全规范\n\n- 签名算法\n  1. 设所有发送或者接收到的数据为集合M，将集合M内非空参数值的参数按照参数名ASCII码从小到大排序（字典序），使用URL键值对的格式（即key1=value1&key2=value2…）拼接成字符串stringA。\n  2. 在stringA最后拼接上key得到stringSignTemp字符串，并对stringSignTemp进行MD5运算，再将得到的字符串所有字符转换为大写，得到sign值signValue\n- 生成随机数算法\n\n  微信支付API接口协议中包含字段nonce_str，主要保证签名不可预测。我们推荐生成随机数算法如下：调用随机数函数生成，将得到的值转换为字符串\n- 商户证书\n  - 获取商户证书\n    > 微信支付接口中，涉及资金回滚的接口会使用到商户证书，包括退款、撤销接口。\n   \n  - 使用商户证书\n  - 商户证书安全\n- 商户回调API安全\n\n  在普通的网络环境下，HTTP请求存在DNS劫持、运营商插入广告、数据被窃取，正常数据被修改等安全风险。商户回调接口使用HTTPS协议可以保证数据传输的安全性。所以微信支付建议商户提供给微信支付的各种回调采用HTTPS协议。请参考：[HTTPS搭建指南](https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=10_4)。\n\n参考资料：[微信支付](https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=4_1)\n\n## 安全『相对论』 - 曾铭\n\n### 角色\n\n#### 介质\n- 服务器\n- API\n- 网络传输过程\n- 客户端\n\n#### 人\n- owner： 开发者 内部人员\n- 用户：消费者、商家\n- 『坏人们』：黑客（白帽）、『友商』、路过……\n\n分清角色才能明白设定一个安全逻辑是针对谁，解决什么问题。\n\n### 目标\n\n- 『一有适当的利润，资本就会非常胆壮起来。只要有10％的利润，它就会到处被人使用；有20％，就会活泼起来；有50％，就会引起积极的冒险；有100％，就会使人不顾一切法律；有300％，就会使人不怕犯罪，甚至不怕绞首的危险。』\n- 没有绝对的安全，只有相对的安全\n- 为了安全是否影响了普通用户？能否变通？\n- 影响的是一个用户还是全部用户？\n- 能否补救？主动？被动？\n- 你不需要完美，你只需要比友商好一些\n\n### 实践\n\n聊聊发短信接口的案例\n- get -> post\n- 限制单日单个手机号，（避免单个手机号过多骚扰，产品不完整，建议加提示）\n- 限制单个 IP 请求次数 （有必要，但要适量放宽，要跟踪结果）\n- 图形验证码 (把问题转化为计算机不擅长的问题来保障安全，有必要，用户体验有影响，可优化）\n- 一种 API 加密方式（根本问题是：API 如何判断这个请求是可信的客户端发来的）\n\n```\n客户端 - 网络传输 - API\nkey, 加密（签名）算法 sign=md5(key+url_path+time)\n\n```\n\n## RSA -李仙鹏\n在公钥系统中，我们采用公钥加密，私钥解密的方式，使得报文能够比较安全的传输。\n\n假设A和B通信，但他们之间不通过对称密钥，B有一个公钥$K_B^+$和一个私钥$K_B^-$。为了与B实现通信，A首先需要获得B的公钥$K_B^+$对报文m进行加密，即$K_B^+(m)$；B收到A的加密报文后用私钥$K_B^-$进行解密，即$K_B^-(K_B^+(m))=m$。其中的加解密算法通常使用RSA（RSA取创始人Ron Rivest, Adi Shamir, Leonard Adleman的姓氏首字母）。\n\n### RSA工作方式\n\n加密时，首先把报文m做e次的幂运算，然后做模n的算数运算，即$m^e\\%n$；解密则先把上述密文值做d次幂，再做模n运算，即$(m^e)^d\\%n=m^\\left(ed\\right)\\%n$。\n\n### RSA工作原理推导\n\n为了解开RSA工作原理的神秘面纱，需要使用数论中的一个神奇结论：如果***p和q是素数***，且有$n=pq$，则$x^y\\%n$与$x^\\left(y\\%\\left(p-1\\right)\\left(q-1\\right)\\right)\\%n$相等。应用这个结论，那我们的私钥解密为：$$(m^e)^d\\%n=m^\\left(ed\\%\\left(p-1\\right)\\left(q-1\\right)\\right)\\%n$$\n\n注意，$m<n$，并且我们是这样选择e和d的：$ed-1$能被$\\left(p-1\\right)\\left(q-1\\right)$整除，等价地说$ed\\%\\left(p-1\\right)\\left(q-1\\right)=1$，由此可得：$$(m^e)^d\\%n=m^1\\%n=m\\qquad m<n，n=pq,ed\\%\\left(p-1\\right)\\left(q-1\\right)=1,p和q是素数$$\n\n于是乎，就得到了我们希望的结果：先对m做e次幂（加密）再做d次幂（解密），然后做模n的算数运算，就可得到原始报文m。另外通过颠倒上述公式的加解密次序，一样能得到原来的m。\n$$(m^e)^d\\%n=m=(m^d)^e\\%n\\Rightarrow K_B^-(K_B^+(m))=m=K_B^+(K_B^-(m))$$\n\n因此B对外公开的公钥$K_B^+$为二元组$(n,e)$，私钥$K_B^-$为二元组$(n,d)$\n\n####举例验证\n\n条件：$$m<n，\\quad n=pq,\\quad ed\\%\\left(p-1\\right)\\left(q-1\\right)=1,\\quad p和q是素数$$\n\n取简单的值：$$p=5,\\quad q=7$$\n\n那么可以推导出：$$n=pq=5*7=35,\\quad (ed-1)\\%(p-1)(q-1)=0\\Rightarrow (ed-1)\\%(5-1)(7-1)=0\\Rightarrow (ed-1)\\%24=0$$\n\n于是，我们可以简单起见，为了减少计算量，设$ed-1$为$24$的1倍，那么我们可取值$$e=5,\\quad d=5$$\n\n假设传输明文为：$$m=3$$\n\n那么综上所述，我们可以得出：\n\n- 加密，$m^e\\%n=3^5\\%35=33$\n\n- 解密，$(m^e\\%n)^d\\%n=33^5\\%35=3=m$，因此对RSA加密后的密文解密得到的就是原始的明文\n\n## iOS 越狱应用安全-潘君\n\n- 对ipa砸壳\n- class-dump 导出头文件\n- 头文件导入project方便查看\n- 善用Xcode的搜索找需要hook的函数\n- hook函数完成不可告人的目的\n\t- [Message Hook](http://blog.sina.com.cn/s/blog_45e2b66c01016jn5.html)\n\n### 参考资料\n- [iOS Security](http://security.ios-wiki.com/)\n- [iOSRE](http://iosre.com/c/development-discussion)\n\n# 网络安全 - 张超耀\n## 主要特性\n- 保密性\n\t- 信息不泄露给非授权用户、实体或过程，或供其利用的特性。\n\n- 完整性\n\t- 数据未经授权不能进行改变的特性。即信息在存储或传输过程中保持不被修改、不被破坏和丢失的特性。\n\n- 可用性\n\t- 可被授权实体访问并按需求使用的特性。即当需要时能否存取所需的信息。例如网络环境下拒绝服务、破坏网络和有关系统的正常运行等都属于对可用性的攻击；\n\n- 可控性\n\t- 对信息的传播及内容具有控制能力。\n\n- 可审查性\n\t- 出现安全问题时提供依据与手段\n\n## 主要类型\n### 网络安全由于不同的环境和应用而产生了不同的类型。主要有以下几种:\n\n- 系统安全\n\t- 运行系统安全即保证信息处理和传输系统的安全。它侧重于保证系统正常运行。避免因为系统的崩演和损坏而对系统存储、处理和传输的消息造成破坏和损失。避免由于电磁泄翻，产生信息泄露，干扰他人或受他人干扰。\n\n- 网络的安全\n\t- 网络上系统信息的安全。包括用户口令鉴别，用户存取权限控制，数据存取权限、方式控制，安全审计。安全问题跟踩。计算机病毒防治，数据加密等。\n\n- 信息传播安全\n\t- 网络上信息传播安全，即信息传播后果的安全，包括信息过滤等。它侧重于防止和控制由非法、有害的信息进行传播所产生的后果，避免公用网络上大云自由传翰的信息失控。\n\n- 信息内容安全\n\t- 网络上信息内容的安全。它侧重于保护信息的保密性、真实性和完整性。避免攻击者利用系统的安全漏润进行窃听、冒充、诈编等有损于合法用户的行为。其本质是保护用户的利益和隐私。\n\n## HTTP加密 -吴明\n- 对称性加密\n\t- 加密双方使用同一个密钥进行加密和解密。密钥是控制加密及解密过程的指令。算法是一组规则，规定如何进行加密和解密\n\t- 常用算法:\n\t\t- DES、3DES、TDEA、Blowfish、RC2、RC4、RC5、IDEA、SKIPJACK、AES\n- 非对称性加密\n\t- 非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。\n\t- RSA、Elgamal、背包算法、Rabin、D-H、ECC（椭圆曲线加密算法）\n- 对称性加密示例\n\t- sig计算\nsig主要用来做校验，由BaseString和SecretKey通过HMAC-SHA1算法计算得到的。\n\t- BaseString 组成\n BaseString由以下三部分组成：http方法名、请求url和参数，其中参数需要按照统一的规则进行编码和排序，具体规则如下：\n根据参数名称将所有请求参数按照参数名字母的先后顺序逐个比较，进行升序排序（参数名注意区分大小写），然后使用=号连接参数名和编码后的参数值，最后使用_下划线连接经过上述处理后的参数，例如：\n<code>\nparam1=encode(value1)_param2=encode(value2)_parma3=encode(value3)\n</code>\n注：a、比如参数名：abcdef和abcDef，abc都是一样的，大写D的asi码在小写d的asi码前面，所以：abcDef排在abcdef前面\nb、BaseString中的参数是指所有GET/POST的请求参数，但不包括sig参数，也不包括cookie或HTTP header字段\n将http方法名、请求url和参数这三部分用”&”连接起来，然后再进行\nencode编码即得到BaseString，使用伪代码描述以上过程如下：\n<code>\nBaseString=encode(httpMethod+\"&\"+httpUrl+\"&\"+sorted_query_params.each{|p,v|p+\"=\"+encode(v)}.join(\"_\"))\n</code>\n然后使用BaseString和SecretKey通过HMAC-SHA1算法计算sig，最后将计算\n出的sig进行编码，使用伪代码描述签名过程如下：\nencode (getHmacSHA1Sig(BaseString, SecretKey)）\n - sig计算示例\n例如某个请求的url为http://192.168.6.218:8080/test/jobplan/login，假设使用的ConsumerKey为eqsrje1tlarvvm54fwsjhcb4,使用的SecretKey为ks5t9fpiwmo3oanccu4f6eas,请求中用到的参数如下：\n<code>\nconsumer_key – eqsrje1tlarvvm54fwsjhcb4\nhrid - 00016145\npassword - 7215ee9c7d9dc229d2921a40e899ec5f\nfields - dspName\nformat – xml\ntimestamp - 2013-11-20 09:21:17\n</code>\n首先依据上面的算法得出BaseString为:\n<code>\nPOST%26http%3A%2F%2F192.168.6.218%3A8080%2FfuannaEP%2Fjobplan%2Flogin%26consumer_key%3Deqsrje1tlarvvm54fwsjhcb4_fields%3DdspName_format%3Djson_hrid%3D00016145_password%3D7215ee9c7d9dc229d2921a40e899ec5f_timestamp%3D2013-11-20%2B09%253A21%253A17\n</code>\n通过BaseString和SecretKey通过HMAC-SHA1算法计算所得的签名如下：\ndqgTQkET7MxSShy1M4WXbWEKodA%3D\n然后就可以发送请求，生成的http 请求链接如下：\n<code>\nhttp://192.168.6.218:8080/test/jobplan/login?password=7215ee9c7d9dc229d2921a40e899ec5f&consumer_key=eqsrje1tlarvvm54fwsjhcb4&hrid=10057&format=xml&fields=dspName×tamp =2013-11-20 09:21:17&signature=dqgTQkET7MxSShy1M4WXbWEKodA%3D\n</code>","slug":"网络信息安全","published":1,"updated":"2021-09-10T07:04:21.949Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cktfeap4i002sc2xx137pqwtf","content":"<h2 id=\"微信支付的网络安全-王胜\"><a href=\"#微信支付的网络安全-王胜\" class=\"headerlink\" title=\"微信支付的网络安全 - 王胜\"></a>微信支付的网络安全 - 王胜</h2><h3 id=\"协议规则\"><a href=\"#协议规则\" class=\"headerlink\" title=\"协议规则\"></a>协议规则</h3><ul>\n<li>采用HTTPS传输</li>\n<li>POST提交</li>\n<li>MD5签名，请求和接收数据均需要校验签名，<a href=\"#安全规范\">详见</a></li>\n<li>调用申请退款、撤销订单接口需要商户证书</li>\n</ul>\n<h3 id=\"安全规范\"><a href=\"#安全规范\" class=\"headerlink\" title=\"安全规范\"></a>安全规范</h3><ul>\n<li>签名算法<ol>\n<li>设所有发送或者接收到的数据为集合M，将集合M内非空参数值的参数按照参数名ASCII码从小到大排序（字典序），使用URL键值对的格式（即key1=value1&amp;key2=value2…）拼接成字符串stringA。</li>\n<li>在stringA最后拼接上key得到stringSignTemp字符串，并对stringSignTemp进行MD5运算，再将得到的字符串所有字符转换为大写，得到sign值signValue</li>\n</ol>\n</li>\n<li><p>生成随机数算法</p>\n<p>微信支付API接口协议中包含字段nonce_str，主要保证签名不可预测。我们推荐生成随机数算法如下：调用随机数函数生成，将得到的值转换为字符串</p>\n</li>\n<li><p>商户证书</p>\n<ul>\n<li><p>获取商户证书</p>\n<blockquote>\n<p>微信支付接口中，涉及资金回滚的接口会使用到商户证书，包括退款、撤销接口。</p>\n</blockquote>\n</li>\n<li><p>使用商户证书</p>\n</li>\n<li>商户证书安全</li>\n</ul>\n</li>\n<li><p>商户回调API安全</p>\n<p>在普通的网络环境下，HTTP请求存在DNS劫持、运营商插入广告、数据被窃取，正常数据被修改等安全风险。商户回调接口使用HTTPS协议可以保证数据传输的安全性。所以微信支付建议商户提供给微信支付的各种回调采用HTTPS协议。请参考：<a href=\"https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=10_4\" target=\"_blank\" rel=\"noopener\">HTTPS搭建指南</a>。</p>\n</li>\n</ul>\n<p>参考资料：<a href=\"https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=4_1\" target=\"_blank\" rel=\"noopener\">微信支付</a></p>\n<h2 id=\"安全『相对论』-曾铭\"><a href=\"#安全『相对论』-曾铭\" class=\"headerlink\" title=\"安全『相对论』 - 曾铭\"></a>安全『相对论』 - 曾铭</h2><h3 id=\"角色\"><a href=\"#角色\" class=\"headerlink\" title=\"角色\"></a>角色</h3><h4 id=\"介质\"><a href=\"#介质\" class=\"headerlink\" title=\"介质\"></a>介质</h4><ul>\n<li>服务器</li>\n<li>API</li>\n<li>网络传输过程</li>\n<li>客户端</li>\n</ul>\n<h4 id=\"人\"><a href=\"#人\" class=\"headerlink\" title=\"人\"></a>人</h4><ul>\n<li>owner： 开发者 内部人员</li>\n<li>用户：消费者、商家</li>\n<li>『坏人们』：黑客（白帽）、『友商』、路过……</li>\n</ul>\n<p>分清角色才能明白设定一个安全逻辑是针对谁，解决什么问题。</p>\n<h3 id=\"目标\"><a href=\"#目标\" class=\"headerlink\" title=\"目标\"></a>目标</h3><ul>\n<li>『一有适当的利润，资本就会非常胆壮起来。只要有10％的利润，它就会到处被人使用；有20％，就会活泼起来；有50％，就会引起积极的冒险；有100％，就会使人不顾一切法律；有300％，就会使人不怕犯罪，甚至不怕绞首的危险。』</li>\n<li>没有绝对的安全，只有相对的安全</li>\n<li>为了安全是否影响了普通用户？能否变通？</li>\n<li>影响的是一个用户还是全部用户？</li>\n<li>能否补救？主动？被动？</li>\n<li>你不需要完美，你只需要比友商好一些</li>\n</ul>\n<h3 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h3><p>聊聊发短信接口的案例</p>\n<ul>\n<li>get -&gt; post</li>\n<li>限制单日单个手机号，（避免单个手机号过多骚扰，产品不完整，建议加提示）</li>\n<li>限制单个 IP 请求次数 （有必要，但要适量放宽，要跟踪结果）</li>\n<li>图形验证码 (把问题转化为计算机不擅长的问题来保障安全，有必要，用户体验有影响，可优化）</li>\n<li>一种 API 加密方式（根本问题是：API 如何判断这个请求是可信的客户端发来的）</li>\n</ul>\n<pre><code>客户端 - 网络传输 - API\nkey, 加密（签名）算法 sign=md5(key+url_path+time)\n</code></pre><h2 id=\"RSA-李仙鹏\"><a href=\"#RSA-李仙鹏\" class=\"headerlink\" title=\"RSA -李仙鹏\"></a>RSA -李仙鹏</h2><p>在公钥系统中，我们采用公钥加密，私钥解密的方式，使得报文能够比较安全的传输。</p>\n<p>假设A和B通信，但他们之间不通过对称密钥，B有一个公钥$K_B^+$和一个私钥$K_B^-$。为了与B实现通信，A首先需要获得B的公钥$K_B^+$对报文m进行加密，即$K_B^+(m)$；B收到A的加密报文后用私钥$K_B^-$进行解密，即$K_B^-(K_B^+(m))=m$。其中的加解密算法通常使用RSA（RSA取创始人Ron Rivest, Adi Shamir, Leonard Adleman的姓氏首字母）。</p>\n<h3 id=\"RSA工作方式\"><a href=\"#RSA工作方式\" class=\"headerlink\" title=\"RSA工作方式\"></a>RSA工作方式</h3><p>加密时，首先把报文m做e次的幂运算，然后做模n的算数运算，即$m^e\\%n$；解密则先把上述密文值做d次幂，再做模n运算，即$(m^e)^d\\%n=m^\\left(ed\\right)\\%n$。</p>\n<h3 id=\"RSA工作原理推导\"><a href=\"#RSA工作原理推导\" class=\"headerlink\" title=\"RSA工作原理推导\"></a>RSA工作原理推导</h3><p>为了解开RSA工作原理的神秘面纱，需要使用数论中的一个神奇结论：如果<strong><em>p和q是素数</em></strong>，且有$n=pq$，则$x^y\\%n$与$x^\\left(y\\%\\left(p-1\\right)\\left(q-1\\right)\\right)\\%n$相等。应用这个结论，那我们的私钥解密为：$$(m^e)^d\\%n=m^\\left(ed\\%\\left(p-1\\right)\\left(q-1\\right)\\right)\\%n$$</p>\n<p>注意，$m&lt;n$，并且我们是这样选择e和d的：$ed-1$能被$\\left(p-1\\right)\\left(q-1\\right)$整除，等价地说$ed\\%\\left(p-1\\right)\\left(q-1\\right)=1$，由此可得：$$(m^e)^d\\%n=m^1\\%n=m\\qquad m&lt;n，n=pq,ed\\%\\left(p-1\\right)\\left(q-1\\right)=1,p和q是素数$$</p>\n<p>于是乎，就得到了我们希望的结果：先对m做e次幂（加密）再做d次幂（解密），然后做模n的算数运算，就可得到原始报文m。另外通过颠倒上述公式的加解密次序，一样能得到原来的m。<br>$$(m^e)^d\\%n=m=(m^d)^e\\%n\\Rightarrow K_B^-(K_B^+(m))=m=K_B^+(K_B^-(m))$$</p>\n<p>因此B对外公开的公钥$K_B^+$为二元组$(n,e)$，私钥$K_B^-$为二元组$(n,d)$</p>\n<p>####举例验证</p>\n<p>条件：$$m&lt;n，\\quad n=pq,\\quad ed\\%\\left(p-1\\right)\\left(q-1\\right)=1,\\quad p和q是素数$$</p>\n<p>取简单的值：$$p=5,\\quad q=7$$</p>\n<p>那么可以推导出：$$n=pq=5*7=35,\\quad (ed-1)\\%(p-1)(q-1)=0\\Rightarrow (ed-1)\\%(5-1)(7-1)=0\\Rightarrow (ed-1)\\%24=0$$</p>\n<p>于是，我们可以简单起见，为了减少计算量，设$ed-1$为$24$的1倍，那么我们可取值$$e=5,\\quad d=5$$</p>\n<p>假设传输明文为：$$m=3$$</p>\n<p>那么综上所述，我们可以得出：</p>\n<ul>\n<li><p>加密，$m^e\\%n=3^5\\%35=33$</p>\n</li>\n<li><p>解密，$(m^e\\%n)^d\\%n=33^5\\%35=3=m$，因此对RSA加密后的密文解密得到的就是原始的明文</p>\n</li>\n</ul>\n<h2 id=\"iOS-越狱应用安全-潘君\"><a href=\"#iOS-越狱应用安全-潘君\" class=\"headerlink\" title=\"iOS 越狱应用安全-潘君\"></a>iOS 越狱应用安全-潘君</h2><ul>\n<li>对ipa砸壳</li>\n<li>class-dump 导出头文件</li>\n<li>头文件导入project方便查看</li>\n<li>善用Xcode的搜索找需要hook的函数</li>\n<li>hook函数完成不可告人的目的<ul>\n<li><a href=\"http://blog.sina.com.cn/s/blog_45e2b66c01016jn5.html\" target=\"_blank\" rel=\"noopener\">Message Hook</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><ul>\n<li><a href=\"http://security.ios-wiki.com/\" target=\"_blank\" rel=\"noopener\">iOS Security</a></li>\n<li><a href=\"http://iosre.com/c/development-discussion\" target=\"_blank\" rel=\"noopener\">iOSRE</a></li>\n</ul>\n<h1 id=\"网络安全-张超耀\"><a href=\"#网络安全-张超耀\" class=\"headerlink\" title=\"网络安全 - 张超耀\"></a>网络安全 - 张超耀</h1><h2 id=\"主要特性\"><a href=\"#主要特性\" class=\"headerlink\" title=\"主要特性\"></a>主要特性</h2><ul>\n<li><p>保密性</p>\n<ul>\n<li>信息不泄露给非授权用户、实体或过程，或供其利用的特性。</li>\n</ul>\n</li>\n<li><p>完整性</p>\n<ul>\n<li>数据未经授权不能进行改变的特性。即信息在存储或传输过程中保持不被修改、不被破坏和丢失的特性。</li>\n</ul>\n</li>\n<li><p>可用性</p>\n<ul>\n<li>可被授权实体访问并按需求使用的特性。即当需要时能否存取所需的信息。例如网络环境下拒绝服务、破坏网络和有关系统的正常运行等都属于对可用性的攻击；</li>\n</ul>\n</li>\n<li><p>可控性</p>\n<ul>\n<li>对信息的传播及内容具有控制能力。</li>\n</ul>\n</li>\n<li><p>可审查性</p>\n<ul>\n<li>出现安全问题时提供依据与手段</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"主要类型\"><a href=\"#主要类型\" class=\"headerlink\" title=\"主要类型\"></a>主要类型</h2><h3 id=\"网络安全由于不同的环境和应用而产生了不同的类型。主要有以下几种\"><a href=\"#网络安全由于不同的环境和应用而产生了不同的类型。主要有以下几种\" class=\"headerlink\" title=\"网络安全由于不同的环境和应用而产生了不同的类型。主要有以下几种:\"></a>网络安全由于不同的环境和应用而产生了不同的类型。主要有以下几种:</h3><ul>\n<li><p>系统安全</p>\n<ul>\n<li>运行系统安全即保证信息处理和传输系统的安全。它侧重于保证系统正常运行。避免因为系统的崩演和损坏而对系统存储、处理和传输的消息造成破坏和损失。避免由于电磁泄翻，产生信息泄露，干扰他人或受他人干扰。</li>\n</ul>\n</li>\n<li><p>网络的安全</p>\n<ul>\n<li>网络上系统信息的安全。包括用户口令鉴别，用户存取权限控制，数据存取权限、方式控制，安全审计。安全问题跟踩。计算机病毒防治，数据加密等。</li>\n</ul>\n</li>\n<li><p>信息传播安全</p>\n<ul>\n<li>网络上信息传播安全，即信息传播后果的安全，包括信息过滤等。它侧重于防止和控制由非法、有害的信息进行传播所产生的后果，避免公用网络上大云自由传翰的信息失控。</li>\n</ul>\n</li>\n<li><p>信息内容安全</p>\n<ul>\n<li>网络上信息内容的安全。它侧重于保护信息的保密性、真实性和完整性。避免攻击者利用系统的安全漏润进行窃听、冒充、诈编等有损于合法用户的行为。其本质是保护用户的利益和隐私。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"HTTP加密-吴明\"><a href=\"#HTTP加密-吴明\" class=\"headerlink\" title=\"HTTP加密 -吴明\"></a>HTTP加密 -吴明</h2><ul>\n<li>对称性加密<ul>\n<li>加密双方使用同一个密钥进行加密和解密。密钥是控制加密及解密过程的指令。算法是一组规则，规定如何进行加密和解密</li>\n<li>常用算法:<ul>\n<li>DES、3DES、TDEA、Blowfish、RC2、RC4、RC5、IDEA、SKIPJACK、AES</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>非对称性加密<ul>\n<li>非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。</li>\n<li>RSA、Elgamal、背包算法、Rabin、D-H、ECC（椭圆曲线加密算法）</li>\n</ul>\n</li>\n<li>对称性加密示例<ul>\n<li>sig计算<br>sig主要用来做校验，由BaseString和SecretKey通过HMAC-SHA1算法计算得到的。</li>\n<li>BaseString 组成<br>BaseString由以下三部分组成：http方法名、请求url和参数，其中参数需要按照统一的规则进行编码和排序，具体规则如下：<br>根据参数名称将所有请求参数按照参数名字母的先后顺序逐个比较，进行升序排序（参数名注意区分大小写），然后使用=号连接参数名和编码后的参数值，最后使用_下划线连接经过上述处理后的参数，例如：<br><code><br>param1=encode(value1)_param2=encode(value2)_parma3=encode(value3)<br></code><br>注：a、比如参数名：abcdef和abcDef，abc都是一样的，大写D的asi码在小写d的asi码前面，所以：abcDef排在abcdef前面<br>b、BaseString中的参数是指所有GET/POST的请求参数，但不包括sig参数，也不包括cookie或HTTP header字段<br>将http方法名、请求url和参数这三部分用”&amp;”连接起来，然后再进行<br>encode编码即得到BaseString，使用伪代码描述以上过程如下：<br><code><br>BaseString=encode(httpMethod+”&amp;”+httpUrl+”&amp;”+sorted_query<em>params.each{|p,v|p+”=”+encode(v)}.join(“</em>“))<br></code><br>然后使用BaseString和SecretKey通过HMAC-SHA1算法计算sig，最后将计算<br>出的sig进行编码，使用伪代码描述签名过程如下：<br>encode (getHmacSHA1Sig(BaseString, SecretKey)）<ul>\n<li>sig计算示例<br>例如某个请求的url为<a href=\"http://192.168.6.218:8080/test/jobplan/login，假设使用的ConsumerKey为eqsrje1tlarvvm54fwsjhcb4,使用的SecretKey为ks5t9fpiwmo3oanccu4f6eas,请求中用到的参数如下：\" target=\"_blank\" rel=\"noopener\">http://192.168.6.218:8080/test/jobplan/login，假设使用的ConsumerKey为eqsrje1tlarvvm54fwsjhcb4,使用的SecretKey为ks5t9fpiwmo3oanccu4f6eas,请求中用到的参数如下：</a><br><code><br>consumer_key – eqsrje1tlarvvm54fwsjhcb4<br>hrid - 00016145<br>password - 7215ee9c7d9dc229d2921a40e899ec5f<br>fields - dspName<br>format – xml<br>timestamp - 2013-11-20 09:21:17<br></code><br>首先依据上面的算法得出BaseString为:<br><code><br>POST%26http%3A%2F%2F192.168.6.218%3A8080%2FfuannaEP%2Fjobplan%2Flogin%26consumer_key%3Deqsrje1tlarvvm54fwsjhcb4_fields%3DdspName_format%3Djson_hrid%3D00016145_password%3D7215ee9c7d9dc229d2921a40e899ec5f_timestamp%3D2013-11-20%2B09%253A21%253A17<br></code><br>通过BaseString和SecretKey通过HMAC-SHA1算法计算所得的签名如下：<br>dqgTQkET7MxSShy1M4WXbWEKodA%3D<br>然后就可以发送请求，生成的http 请求链接如下：<br><code><br><a href=\"http://192.168.6.218:8080/test/jobplan/login?password=7215ee9c7d9dc229d2921a40e899ec5f&amp;consumer_key=eqsrje1tlarvvm54fwsjhcb4&amp;hrid=10057&amp;format=xml&amp;fields=dspName×tamp\" target=\"_blank\" rel=\"noopener\">http://192.168.6.218:8080/test/jobplan/login?password=7215ee9c7d9dc229d2921a40e899ec5f&amp;consumer_key=eqsrje1tlarvvm54fwsjhcb4&amp;hrid=10057&amp;format=xml&amp;fields=dspName×tamp</a> =2013-11-20 09:21:17&amp;signature=dqgTQkET7MxSShy1M4WXbWEKodA%3D<br></code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"微信支付的网络安全-王胜\"><a href=\"#微信支付的网络安全-王胜\" class=\"headerlink\" title=\"微信支付的网络安全 - 王胜\"></a>微信支付的网络安全 - 王胜</h2><h3 id=\"协议规则\"><a href=\"#协议规则\" class=\"headerlink\" title=\"协议规则\"></a>协议规则</h3><ul>\n<li>采用HTTPS传输</li>\n<li>POST提交</li>\n<li>MD5签名，请求和接收数据均需要校验签名，<a href=\"#安全规范\">详见</a></li>\n<li>调用申请退款、撤销订单接口需要商户证书</li>\n</ul>\n<h3 id=\"安全规范\"><a href=\"#安全规范\" class=\"headerlink\" title=\"安全规范\"></a>安全规范</h3><ul>\n<li>签名算法<ol>\n<li>设所有发送或者接收到的数据为集合M，将集合M内非空参数值的参数按照参数名ASCII码从小到大排序（字典序），使用URL键值对的格式（即key1=value1&amp;key2=value2…）拼接成字符串stringA。</li>\n<li>在stringA最后拼接上key得到stringSignTemp字符串，并对stringSignTemp进行MD5运算，再将得到的字符串所有字符转换为大写，得到sign值signValue</li>\n</ol>\n</li>\n<li><p>生成随机数算法</p>\n<p>微信支付API接口协议中包含字段nonce_str，主要保证签名不可预测。我们推荐生成随机数算法如下：调用随机数函数生成，将得到的值转换为字符串</p>\n</li>\n<li><p>商户证书</p>\n<ul>\n<li><p>获取商户证书</p>\n<blockquote>\n<p>微信支付接口中，涉及资金回滚的接口会使用到商户证书，包括退款、撤销接口。</p>\n</blockquote>\n</li>\n<li><p>使用商户证书</p>\n</li>\n<li>商户证书安全</li>\n</ul>\n</li>\n<li><p>商户回调API安全</p>\n<p>在普通的网络环境下，HTTP请求存在DNS劫持、运营商插入广告、数据被窃取，正常数据被修改等安全风险。商户回调接口使用HTTPS协议可以保证数据传输的安全性。所以微信支付建议商户提供给微信支付的各种回调采用HTTPS协议。请参考：<a href=\"https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=10_4\" target=\"_blank\" rel=\"noopener\">HTTPS搭建指南</a>。</p>\n</li>\n</ul>\n<p>参考资料：<a href=\"https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=4_1\" target=\"_blank\" rel=\"noopener\">微信支付</a></p>\n<h2 id=\"安全『相对论』-曾铭\"><a href=\"#安全『相对论』-曾铭\" class=\"headerlink\" title=\"安全『相对论』 - 曾铭\"></a>安全『相对论』 - 曾铭</h2><h3 id=\"角色\"><a href=\"#角色\" class=\"headerlink\" title=\"角色\"></a>角色</h3><h4 id=\"介质\"><a href=\"#介质\" class=\"headerlink\" title=\"介质\"></a>介质</h4><ul>\n<li>服务器</li>\n<li>API</li>\n<li>网络传输过程</li>\n<li>客户端</li>\n</ul>\n<h4 id=\"人\"><a href=\"#人\" class=\"headerlink\" title=\"人\"></a>人</h4><ul>\n<li>owner： 开发者 内部人员</li>\n<li>用户：消费者、商家</li>\n<li>『坏人们』：黑客（白帽）、『友商』、路过……</li>\n</ul>\n<p>分清角色才能明白设定一个安全逻辑是针对谁，解决什么问题。</p>\n<h3 id=\"目标\"><a href=\"#目标\" class=\"headerlink\" title=\"目标\"></a>目标</h3><ul>\n<li>『一有适当的利润，资本就会非常胆壮起来。只要有10％的利润，它就会到处被人使用；有20％，就会活泼起来；有50％，就会引起积极的冒险；有100％，就会使人不顾一切法律；有300％，就会使人不怕犯罪，甚至不怕绞首的危险。』</li>\n<li>没有绝对的安全，只有相对的安全</li>\n<li>为了安全是否影响了普通用户？能否变通？</li>\n<li>影响的是一个用户还是全部用户？</li>\n<li>能否补救？主动？被动？</li>\n<li>你不需要完美，你只需要比友商好一些</li>\n</ul>\n<h3 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h3><p>聊聊发短信接口的案例</p>\n<ul>\n<li>get -&gt; post</li>\n<li>限制单日单个手机号，（避免单个手机号过多骚扰，产品不完整，建议加提示）</li>\n<li>限制单个 IP 请求次数 （有必要，但要适量放宽，要跟踪结果）</li>\n<li>图形验证码 (把问题转化为计算机不擅长的问题来保障安全，有必要，用户体验有影响，可优化）</li>\n<li>一种 API 加密方式（根本问题是：API 如何判断这个请求是可信的客户端发来的）</li>\n</ul>\n<pre><code>客户端 - 网络传输 - API\nkey, 加密（签名）算法 sign=md5(key+url_path+time)\n</code></pre><h2 id=\"RSA-李仙鹏\"><a href=\"#RSA-李仙鹏\" class=\"headerlink\" title=\"RSA -李仙鹏\"></a>RSA -李仙鹏</h2><p>在公钥系统中，我们采用公钥加密，私钥解密的方式，使得报文能够比较安全的传输。</p>\n<p>假设A和B通信，但他们之间不通过对称密钥，B有一个公钥$K_B^+$和一个私钥$K_B^-$。为了与B实现通信，A首先需要获得B的公钥$K_B^+$对报文m进行加密，即$K_B^+(m)$；B收到A的加密报文后用私钥$K_B^-$进行解密，即$K_B^-(K_B^+(m))=m$。其中的加解密算法通常使用RSA（RSA取创始人Ron Rivest, Adi Shamir, Leonard Adleman的姓氏首字母）。</p>\n<h3 id=\"RSA工作方式\"><a href=\"#RSA工作方式\" class=\"headerlink\" title=\"RSA工作方式\"></a>RSA工作方式</h3><p>加密时，首先把报文m做e次的幂运算，然后做模n的算数运算，即$m^e\\%n$；解密则先把上述密文值做d次幂，再做模n运算，即$(m^e)^d\\%n=m^\\left(ed\\right)\\%n$。</p>\n<h3 id=\"RSA工作原理推导\"><a href=\"#RSA工作原理推导\" class=\"headerlink\" title=\"RSA工作原理推导\"></a>RSA工作原理推导</h3><p>为了解开RSA工作原理的神秘面纱，需要使用数论中的一个神奇结论：如果<strong><em>p和q是素数</em></strong>，且有$n=pq$，则$x^y\\%n$与$x^\\left(y\\%\\left(p-1\\right)\\left(q-1\\right)\\right)\\%n$相等。应用这个结论，那我们的私钥解密为：$$(m^e)^d\\%n=m^\\left(ed\\%\\left(p-1\\right)\\left(q-1\\right)\\right)\\%n$$</p>\n<p>注意，$m&lt;n$，并且我们是这样选择e和d的：$ed-1$能被$\\left(p-1\\right)\\left(q-1\\right)$整除，等价地说$ed\\%\\left(p-1\\right)\\left(q-1\\right)=1$，由此可得：$$(m^e)^d\\%n=m^1\\%n=m\\qquad m&lt;n，n=pq,ed\\%\\left(p-1\\right)\\left(q-1\\right)=1,p和q是素数$$</p>\n<p>于是乎，就得到了我们希望的结果：先对m做e次幂（加密）再做d次幂（解密），然后做模n的算数运算，就可得到原始报文m。另外通过颠倒上述公式的加解密次序，一样能得到原来的m。<br>$$(m^e)^d\\%n=m=(m^d)^e\\%n\\Rightarrow K_B^-(K_B^+(m))=m=K_B^+(K_B^-(m))$$</p>\n<p>因此B对外公开的公钥$K_B^+$为二元组$(n,e)$，私钥$K_B^-$为二元组$(n,d)$</p>\n<p>####举例验证</p>\n<p>条件：$$m&lt;n，\\quad n=pq,\\quad ed\\%\\left(p-1\\right)\\left(q-1\\right)=1,\\quad p和q是素数$$</p>\n<p>取简单的值：$$p=5,\\quad q=7$$</p>\n<p>那么可以推导出：$$n=pq=5*7=35,\\quad (ed-1)\\%(p-1)(q-1)=0\\Rightarrow (ed-1)\\%(5-1)(7-1)=0\\Rightarrow (ed-1)\\%24=0$$</p>\n<p>于是，我们可以简单起见，为了减少计算量，设$ed-1$为$24$的1倍，那么我们可取值$$e=5,\\quad d=5$$</p>\n<p>假设传输明文为：$$m=3$$</p>\n<p>那么综上所述，我们可以得出：</p>\n<ul>\n<li><p>加密，$m^e\\%n=3^5\\%35=33$</p>\n</li>\n<li><p>解密，$(m^e\\%n)^d\\%n=33^5\\%35=3=m$，因此对RSA加密后的密文解密得到的就是原始的明文</p>\n</li>\n</ul>\n<h2 id=\"iOS-越狱应用安全-潘君\"><a href=\"#iOS-越狱应用安全-潘君\" class=\"headerlink\" title=\"iOS 越狱应用安全-潘君\"></a>iOS 越狱应用安全-潘君</h2><ul>\n<li>对ipa砸壳</li>\n<li>class-dump 导出头文件</li>\n<li>头文件导入project方便查看</li>\n<li>善用Xcode的搜索找需要hook的函数</li>\n<li>hook函数完成不可告人的目的<ul>\n<li><a href=\"http://blog.sina.com.cn/s/blog_45e2b66c01016jn5.html\" target=\"_blank\" rel=\"noopener\">Message Hook</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><ul>\n<li><a href=\"http://security.ios-wiki.com/\" target=\"_blank\" rel=\"noopener\">iOS Security</a></li>\n<li><a href=\"http://iosre.com/c/development-discussion\" target=\"_blank\" rel=\"noopener\">iOSRE</a></li>\n</ul>\n<h1 id=\"网络安全-张超耀\"><a href=\"#网络安全-张超耀\" class=\"headerlink\" title=\"网络安全 - 张超耀\"></a>网络安全 - 张超耀</h1><h2 id=\"主要特性\"><a href=\"#主要特性\" class=\"headerlink\" title=\"主要特性\"></a>主要特性</h2><ul>\n<li><p>保密性</p>\n<ul>\n<li>信息不泄露给非授权用户、实体或过程，或供其利用的特性。</li>\n</ul>\n</li>\n<li><p>完整性</p>\n<ul>\n<li>数据未经授权不能进行改变的特性。即信息在存储或传输过程中保持不被修改、不被破坏和丢失的特性。</li>\n</ul>\n</li>\n<li><p>可用性</p>\n<ul>\n<li>可被授权实体访问并按需求使用的特性。即当需要时能否存取所需的信息。例如网络环境下拒绝服务、破坏网络和有关系统的正常运行等都属于对可用性的攻击；</li>\n</ul>\n</li>\n<li><p>可控性</p>\n<ul>\n<li>对信息的传播及内容具有控制能力。</li>\n</ul>\n</li>\n<li><p>可审查性</p>\n<ul>\n<li>出现安全问题时提供依据与手段</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"主要类型\"><a href=\"#主要类型\" class=\"headerlink\" title=\"主要类型\"></a>主要类型</h2><h3 id=\"网络安全由于不同的环境和应用而产生了不同的类型。主要有以下几种\"><a href=\"#网络安全由于不同的环境和应用而产生了不同的类型。主要有以下几种\" class=\"headerlink\" title=\"网络安全由于不同的环境和应用而产生了不同的类型。主要有以下几种:\"></a>网络安全由于不同的环境和应用而产生了不同的类型。主要有以下几种:</h3><ul>\n<li><p>系统安全</p>\n<ul>\n<li>运行系统安全即保证信息处理和传输系统的安全。它侧重于保证系统正常运行。避免因为系统的崩演和损坏而对系统存储、处理和传输的消息造成破坏和损失。避免由于电磁泄翻，产生信息泄露，干扰他人或受他人干扰。</li>\n</ul>\n</li>\n<li><p>网络的安全</p>\n<ul>\n<li>网络上系统信息的安全。包括用户口令鉴别，用户存取权限控制，数据存取权限、方式控制，安全审计。安全问题跟踩。计算机病毒防治，数据加密等。</li>\n</ul>\n</li>\n<li><p>信息传播安全</p>\n<ul>\n<li>网络上信息传播安全，即信息传播后果的安全，包括信息过滤等。它侧重于防止和控制由非法、有害的信息进行传播所产生的后果，避免公用网络上大云自由传翰的信息失控。</li>\n</ul>\n</li>\n<li><p>信息内容安全</p>\n<ul>\n<li>网络上信息内容的安全。它侧重于保护信息的保密性、真实性和完整性。避免攻击者利用系统的安全漏润进行窃听、冒充、诈编等有损于合法用户的行为。其本质是保护用户的利益和隐私。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"HTTP加密-吴明\"><a href=\"#HTTP加密-吴明\" class=\"headerlink\" title=\"HTTP加密 -吴明\"></a>HTTP加密 -吴明</h2><ul>\n<li>对称性加密<ul>\n<li>加密双方使用同一个密钥进行加密和解密。密钥是控制加密及解密过程的指令。算法是一组规则，规定如何进行加密和解密</li>\n<li>常用算法:<ul>\n<li>DES、3DES、TDEA、Blowfish、RC2、RC4、RC5、IDEA、SKIPJACK、AES</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>非对称性加密<ul>\n<li>非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。</li>\n<li>RSA、Elgamal、背包算法、Rabin、D-H、ECC（椭圆曲线加密算法）</li>\n</ul>\n</li>\n<li>对称性加密示例<ul>\n<li>sig计算<br>sig主要用来做校验，由BaseString和SecretKey通过HMAC-SHA1算法计算得到的。</li>\n<li>BaseString 组成<br>BaseString由以下三部分组成：http方法名、请求url和参数，其中参数需要按照统一的规则进行编码和排序，具体规则如下：<br>根据参数名称将所有请求参数按照参数名字母的先后顺序逐个比较，进行升序排序（参数名注意区分大小写），然后使用=号连接参数名和编码后的参数值，最后使用_下划线连接经过上述处理后的参数，例如：<br><code><br>param1=encode(value1)_param2=encode(value2)_parma3=encode(value3)<br></code><br>注：a、比如参数名：abcdef和abcDef，abc都是一样的，大写D的asi码在小写d的asi码前面，所以：abcDef排在abcdef前面<br>b、BaseString中的参数是指所有GET/POST的请求参数，但不包括sig参数，也不包括cookie或HTTP header字段<br>将http方法名、请求url和参数这三部分用”&amp;”连接起来，然后再进行<br>encode编码即得到BaseString，使用伪代码描述以上过程如下：<br><code><br>BaseString=encode(httpMethod+”&amp;”+httpUrl+”&amp;”+sorted_query<em>params.each{|p,v|p+”=”+encode(v)}.join(“</em>“))<br></code><br>然后使用BaseString和SecretKey通过HMAC-SHA1算法计算sig，最后将计算<br>出的sig进行编码，使用伪代码描述签名过程如下：<br>encode (getHmacSHA1Sig(BaseString, SecretKey)）<ul>\n<li>sig计算示例<br>例如某个请求的url为<a href=\"http://192.168.6.218:8080/test/jobplan/login，假设使用的ConsumerKey为eqsrje1tlarvvm54fwsjhcb4,使用的SecretKey为ks5t9fpiwmo3oanccu4f6eas,请求中用到的参数如下：\" target=\"_blank\" rel=\"noopener\">http://192.168.6.218:8080/test/jobplan/login，假设使用的ConsumerKey为eqsrje1tlarvvm54fwsjhcb4,使用的SecretKey为ks5t9fpiwmo3oanccu4f6eas,请求中用到的参数如下：</a><br><code><br>consumer_key – eqsrje1tlarvvm54fwsjhcb4<br>hrid - 00016145<br>password - 7215ee9c7d9dc229d2921a40e899ec5f<br>fields - dspName<br>format – xml<br>timestamp - 2013-11-20 09:21:17<br></code><br>首先依据上面的算法得出BaseString为:<br><code><br>POST%26http%3A%2F%2F192.168.6.218%3A8080%2FfuannaEP%2Fjobplan%2Flogin%26consumer_key%3Deqsrje1tlarvvm54fwsjhcb4_fields%3DdspName_format%3Djson_hrid%3D00016145_password%3D7215ee9c7d9dc229d2921a40e899ec5f_timestamp%3D2013-11-20%2B09%253A21%253A17<br></code><br>通过BaseString和SecretKey通过HMAC-SHA1算法计算所得的签名如下：<br>dqgTQkET7MxSShy1M4WXbWEKodA%3D<br>然后就可以发送请求，生成的http 请求链接如下：<br><code><br><a href=\"http://192.168.6.218:8080/test/jobplan/login?password=7215ee9c7d9dc229d2921a40e899ec5f&amp;consumer_key=eqsrje1tlarvvm54fwsjhcb4&amp;hrid=10057&amp;format=xml&amp;fields=dspName×tamp\" target=\"_blank\" rel=\"noopener\">http://192.168.6.218:8080/test/jobplan/login?password=7215ee9c7d9dc229d2921a40e899ec5f&amp;consumer_key=eqsrje1tlarvvm54fwsjhcb4&amp;hrid=10057&amp;format=xml&amp;fields=dspName×tamp</a> =2013-11-20 09:21:17&amp;signature=dqgTQkET7MxSShy1M4WXbWEKodA%3D<br></code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n"},{"title":"简单谈谈计算机网络","date":"2015-07-24T09:46:13.000Z","_content":"\n## RESTful API 设计介绍 - 曾铭\n\n### WHAT\n- API 概念\n- 其它方案 SOAP 等\n- HTTP 无状态\n- RESTful 概念 REpresentational State Transfer 表征性状态传输\n- 复用 HTTP 本身的协议定义\n- 带来的好处：通用，动词，code，缓存，安全\n\n### 例子\n\n```\nBAD\n/getProduct\n/addProduct\n/deleteProduct\n/listProducts\n/productShop?productId=1\n```\n- 对单一实体的重复\n- 多个实体对操作的重复\n- 实体之间逻辑接口的重复定义\n\n```\nGOOD\nGET /products : will return the list of all products\nGET /products/4 : will retrieve product #4\nPOST /products : will add a product to the collection\nPUT /products/4 : will update product #4\nDELETE /products/4 : will delete product #4\n\nGET /products/4/shop\nGET /users/3/favorite_schools\nPOST /users/3/favorite_schools\nPUT /users/3/favorite_schools/5\n```\n\n- 好的 API 定义清晰，可预期。\n\n### 总结\n\n- 重复的实现或设计，嗅嗅不好的味道\n- 重复制造轮子，而不是重复发明轮子 （如用户授权，加密，缓存等）\n- RESTful 不仅仅适用于 APP，重点是 C/S\n- 各端实现：[参考覃超的知乎回答](http://www.zhihu.com/question/28557115/answer/48094438)\n\n\n***\n\n## IP网段划分 - 王胜\n\n### 三大类IP段\n\n- A类地址\n  - 第1字节为[网络地址](http://baike.baidu.com/view/547479.htm)，其他3个字节为主机地址。另外，第1个字节的最高位固定为0。\n  - 地址范围：1.0.0.0到126.255.255.255。\n  - 默认子网掩码：255.0.0.0，一个子网最多可以容纳1677万多台电脑。\n  - 保留地址：127.0.0.0到127.255.255.255是保留地址，用做循环测试用。\n  - 私有地址：10.0.0.0到10.255.255.255。【0000 1010】\n  \n- B类地址\n  - 第1字节和第2字节为网络地址，其他2个字节为主机地址。另外1个字节的前2位固定为10。\n  - 地址范围：128.0.0.0到191.255.255.255。\n  - 默认子网掩码：255.255.0.0　一个子网最多可以容纳6万台电脑。\n  - 保留地址：169.254.0.0到169.254.255.255是保留地址。如果你的IP地址是自动获取IP地址，而你在网络上又没有找到可用的DHCP服务器，这时你将会从169.254.0.1到169.254.255.254中临时获得一个IP地址。\n  - 私有地址：在B类地址中，172.16.0.0到172.31.255.255是私有地址。\n\n- C类地址\n  - 第1字节、第2字节和第3个字节为网络地址，第4个字节为主机地址。另外第1个字节的前三位固定为110。\n  - 地址范围：192.0.0.0到223.255.255.255。\n  - 默认子网掩码　255.255.255.0　一个子网最多可以容纳254台电脑。\n  - 私有地址：192.168.0.0到192.168.255.255是私有地址。\n\n### 两个特殊地址\n\n- 0.0.0.0 [全网地址](http://www.cnblogs.com/hnrainll/archive/2011/10/13/2210101.html)，三界之外的收容器\n- 255.255.255.255 广播地址\n\n***\n## OSI七层模型详解 - 吴明\n[OSI七层模型详解](http://blog.csdn.net/yaopeng_2005/article/details/7064869)\n\n- 物理层：\n\t- 相关协议：IEEE802.2,Ethernet v.2,Internetwork\n- 数据链路层\n \t- 相关协议：MPLS，XTP,DCAP\n- 网络层\n- 传输层\n\t- 相关协议：EGP,NHRP\n- 会话层：\n- 表示层：\n- 应用层:\n\n***\n\n## 网络分层协议模型 - 张超耀\n###网络分层协议模型\n- 根据 TCP/IP协议簇的协议来命名\n\t- 应用层　　数据\t\t 　 泛指应用层使用的\n\t- 传输层　　数据段　　　　　传输层\n\t- 网络层　　数据包　　　　　网络层\n\t- 链路层　　帧　　　　　　　网络接入层\n\t- 物理层　　比特(位)　　　 通过介质实际传输数据时使用的\n\n- OSI七成协议模型\n\t- 应用层:例如HTTP、SMTP、SNMP、FTP、Telnet、SIP、SSH、NFS、RTSP、XMPP、Whois、ENRP\n\t- 表示层:例如XDR、ASN.1、SMB、AFP、NCP\n\t- 会话层:例如ASAP、TLS、SSH、ISO 8327 / CCITT X.225、RPC、NetBIOS、ASP、Winsock、BSD sockets\n\t- 传输层:例如TCP、UDP、RTP、SCTP、SPX、ATP、IL\n\t- 网络层:例如IP、ICMP、IGMP、IPX、BGP、OSPF、RIP、IGRP、EIGRP、ARP、RARP、X.25\n\t- 数据链路层:例如以太网、令牌环、HDLC、帧中继、ISDN、ATM、IEEE 802.11、FDDI、PPP\n\t- 物理层:例如线路、无线电、光纤\n \n- 分层的好处:\n\t- 各层之间是独立的\n\t- 灵活性好\n\t- 结构上可分割开\n\t- 易于实现和维护\n\t- 能促进标准化工作\n\n### 协议模型:\n![](http://pic002.cnblogs.com/images/2012/387401/2012070810010373.jpg)\n\n### 包装数据包的过程 \n- TCP传给IP的数据单元称作TCP报文段或简称为TCP段(TCP segment)，传给网络接口层的数据单元称作IP数据报(IPdatagram).通过以太网传输的比特流称作帧(Frame)\n![](http://hiphotos.baidu.com/exp/pic/item/90cebeec08fa513dd74179353f6d55fbb3fbd937.jpg)\n\n### 分用即解包的过程\n![](http://pic002.cnblogs.com/images/2012/387401/2012072116365656.png)\n\n\n### 不同层直接协议关系\n![](http://pic002.cnblogs.com/images/2012/387401/2012072116311034.png)\n\n***\n## TCP/IP三次握手与四次挥手 - 李仙鹏\n\n![TCP/IP三次握手与四次挥手](http://mmbiz.qpic.cn/mmbiz/NVvB3l3e9aESeCKMfdLmzic5mS9DReZ3ecGqraIDhDam4NmtRiceSzXCpICsu2keyhg1pMwxZVJBWTIvnwpkL6CA/640?wxfrom=5)\n\n> 引用自[图解 TCP/IP 协议](http://mp.weixin.qq.com/s?__biz=MzA3MDMyMjkzNg==&mid=210133499&idx=1&sn=d56455712de557b74ce17997fe29c06f&scene=1&key=0acd51d81cb052bc42a5850a900340ace87cb6cc26440e97233d7fab5311d8b5021ca25b901ab1d0434b3a23ead87ef2&ascene=0&uin=MTg4NDcxOTMyMQ%3D%3D&devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.4+build(14E46)&version=11020012&pass_ticket=Mh3kdFcxrCoIa0yIg1d7eLqJGuQkBQLzt2YIYx5poC%2BLzaWWMRZ5D1Vl6Pobd8ui)\n\n***\n\n## 计算机网络安全 - 杨志平\n\n### 2015网络安全事件\n- 携程网内部员工误删除代码 网站整体宕机12小时\n- 支付宝机房电缆被挖断 部分区域服务中断\n- 网易骨干网遭攻击 百万用户无法打游戏\n- 海康威视被黑客植入代码 导致被远程监控\n\n### 敏感数据（账号、密码等）\n- 账号密码（post明文显示）\n- 重要资源数据（防爬虫）\n- 多重账号威胁（网络账号通用）\n- 通讯协议破解（iMessage）\n\n### 网络传输加密\n\n- 数据加密算法\n\n\t- 对称式加密技术\t(加密-解密)\n\t\t- DES（Data Encryption Standard）\n\t\t>数据加密标准，速度较快，适用于加密大量数据的场合。\n\t\t- 3DES（Triple DES）\n\t\t>是基于DES，对一块数据用三个不同的密钥进行三次加密，强度更高。\n\t\t- AES（Advanced Encryption Standard）\n\t\t>高级加密标准，是下一代的加密算法标准，速度快，安全级别高；\n\t\n\n\t- 非对称式加密技术（公钥-私钥）\n\t\t- RSA\n\t\t>是一个支持变长密钥的公共密钥算法，需要加密的文件块的长度也是可变的；\n\t\t- DSA（Digital Signature Algorithm）\n\t\t>数字签名算法，是一种标准的 DSS（数字签名标准）；\n\t\t- ECC（Elliptic Curves Cryptography）\n\t\t>椭圆曲线密码编码学。\n\t\n\t- 散列算法 （不可逆）\n\t\t- MD5（Message Digest Algorithm 5）\n\t\t>是RSA数据安全公司开发的一种单向散列算法，非可逆，相同的明文产生相同的密文。\n\t\t- SHA（Secure Hash Algorithm）\n\t\t>可以对任意长度的数据运算生成一个160位的数值；\n\n[3个著名加密算法(MD5、RSA、DES)的解析](http://www.iplaysoft.com/encrypt-arithmetic.html)\n\n### 简单加密演示\n- 简单位移式加密（经典：凯撒加密）\n \n```\n“恺撒密码”据传是古罗马恺撒大帝用来保护重要军情的加密系统。它是一种替代密码，通过将字母按顺序推后起3位起到加密作用，\n如将字母A换作字母D，将字母B换作字母E。据说恺撒是率先使用加密函的古代将领之一，因此这种加密方法被称为恺撒密码。\n假如有这样一条指令：\nRETURN TO ROME\n用恺撒密码加密后就成为：\nUHWXUA WR URPH\n```\n\n- 置换加密\n\n```\n令明文m=m1,m2,...mL。令置换矩阵所决定的置换为pi，则加密置换c=Ek(m)=(c1,c2,...cL)=mpi(1),mpi(2),...,mpi(L)\n解密置换\nd=Dk(c)=(cn^-1(1),cn^-1(2),...cn^-1(L))\n例，置换密码。给定明文为the simplest possible transposition ciphers,\n将明文分成长为L=5的段，\nm1=thesi, m2=mples m3=tposs m4=iblet,\nm5=ransp, m6=ositi m7=oncip m8=hersx\n最后一段长不足5，加添一个字母x。将隔断的字母序号按下述置换矩阵进行换位：\nEk= 0 1 2 3 4\n3 0 4 2 1\n得到密文如下\nSTIEH EMSLP STSOP EITLB SRPNA TOIIS IOPCN SHXRE\n```\n\n***\n\n## Alamofire文档阅读 - 潘君\n\n`AFNetworking的继承者`\n\n摘录自[Alamofire 官方文档](https://github.com/Alamofire/Alamofire)\n\n### Feature\n - Chainable Request / Response methods\n\t 链式 request / response\n\t  Complete Documentation\n \n```\n// Response handlers can even be chained:\nAlamofire.request(.GET, \"http://httpbin.org/get\")\n         .responseString { _, _, string, _ in\n             println(string)\n         }\n         .responseJSON { _, _, JSON, _ in\n             println(JSON)\n         }\n```\n\n-  URL / JSON / plist Parameter Encoding\n\t除了以上几种 还可以自定义\n\tAlamofire provides built-in response serialization for strings, JSON, and property lists, but others can be added in extensions on Alamofire.Request.\n\t\n - Upload File / Data / Stream / MultipartFormData\n\t 多种文件上传方式\n\t \n- Download using Request or Resume data\n\n-  Authentication with NSURLCredential\n\n-  HTTP Response Validation\n\n-  Progress Closure & NSProgress\n-  cURL Debug Output\n- Comprehensive Unit Test Coverage\n\n### 某些点\n\n- url编码\nGET\n```\nGET Request With URL-Encoded Parameters\nAlamofire.request(.GET, \"http://httpbin.org/get\", parameters: [\"foo\": \"bar\"])\n// http://httpbin.org/get?foo=bar\n```\n\nPOST\n```\nlet parameters = [\n    \"foo\": \"bar\",\n    \"baz\": [\"a\", 1],\n    \"qux\": [\n        \"x\": 1,\n        \"y\": 2,\n        \"z\": 3\n    ]\n]\n\nAlamofire.request(.POST, \"http://httpbin.org/post\", parameters: parameters)\n// HTTP body: foo=bar&baz[]=a&baz[]=1&qux[x]=1&qux[y]=2&qux[z]=3\n```\n\n- 转object\nGeneric Response Object Serialization\n\n- 校验\n```\nManual Validation\n\nAlamofire.request(.GET, \"http://httpbin.org/get\", parameters: [\"foo\": \"bar\"])\n         .validate(statusCode: 200..<300)\n         .validate(contentType: [\"application/json\"])\n         .response { _, _, _, error in\n                  println(error)\n         }\nAutomatic Validation\n\nAutomatically validates status code within 200...299 range, and that the Content-Type header of the response matches the Accept header of the request, if one is provided.\n\nAlamofire.request(.GET, \"http://httpbin.org/get\", parameters: [\"foo\": \"bar\"])\n         .validate()\n         .response { _, _, _, error in\n             println(error)\n         }\n```\n\n- 方便打印\nPrintable\n\n```\nlet request = Alamofire.request(.GET, \"http://httpbin.org/ip\")\n\nprintln(request)\n\n// GET http://httpbin.org/ip (200)\n```\n\nDebugPrintable\n\n```\n\tlet request = Alamofire.request(.GET, \"http://httpbin.org/get\", parameters: [\"foo\": \"bar\"])\n\t\n\tdebugPrintln(request)\n```\n\n- 支持暂停/恢复/取消\n1. suspend(): Suspends the underlying task and dispatch queue\n2. resume(): Resumes the underlying task and dispatch queue. If the owning manager does not have startRequestsImmediately set to true, the request must call resume() in order to start.\n3. cancel(): Cancels the underlying task, producing an error that is passed to any registered response handlers.\n\n- 自定义response serializer\n","source":"_posts/简单谈谈计算机网络.md","raw":"title: 简单谈谈计算机网络\ndate: 2015-07-24 09:46:13\ntags:\ncategories: 移动组周分享\n---\n\n## RESTful API 设计介绍 - 曾铭\n\n### WHAT\n- API 概念\n- 其它方案 SOAP 等\n- HTTP 无状态\n- RESTful 概念 REpresentational State Transfer 表征性状态传输\n- 复用 HTTP 本身的协议定义\n- 带来的好处：通用，动词，code，缓存，安全\n\n### 例子\n\n```\nBAD\n/getProduct\n/addProduct\n/deleteProduct\n/listProducts\n/productShop?productId=1\n```\n- 对单一实体的重复\n- 多个实体对操作的重复\n- 实体之间逻辑接口的重复定义\n\n```\nGOOD\nGET /products : will return the list of all products\nGET /products/4 : will retrieve product #4\nPOST /products : will add a product to the collection\nPUT /products/4 : will update product #4\nDELETE /products/4 : will delete product #4\n\nGET /products/4/shop\nGET /users/3/favorite_schools\nPOST /users/3/favorite_schools\nPUT /users/3/favorite_schools/5\n```\n\n- 好的 API 定义清晰，可预期。\n\n### 总结\n\n- 重复的实现或设计，嗅嗅不好的味道\n- 重复制造轮子，而不是重复发明轮子 （如用户授权，加密，缓存等）\n- RESTful 不仅仅适用于 APP，重点是 C/S\n- 各端实现：[参考覃超的知乎回答](http://www.zhihu.com/question/28557115/answer/48094438)\n\n\n***\n\n## IP网段划分 - 王胜\n\n### 三大类IP段\n\n- A类地址\n  - 第1字节为[网络地址](http://baike.baidu.com/view/547479.htm)，其他3个字节为主机地址。另外，第1个字节的最高位固定为0。\n  - 地址范围：1.0.0.0到126.255.255.255。\n  - 默认子网掩码：255.0.0.0，一个子网最多可以容纳1677万多台电脑。\n  - 保留地址：127.0.0.0到127.255.255.255是保留地址，用做循环测试用。\n  - 私有地址：10.0.0.0到10.255.255.255。【0000 1010】\n  \n- B类地址\n  - 第1字节和第2字节为网络地址，其他2个字节为主机地址。另外1个字节的前2位固定为10。\n  - 地址范围：128.0.0.0到191.255.255.255。\n  - 默认子网掩码：255.255.0.0　一个子网最多可以容纳6万台电脑。\n  - 保留地址：169.254.0.0到169.254.255.255是保留地址。如果你的IP地址是自动获取IP地址，而你在网络上又没有找到可用的DHCP服务器，这时你将会从169.254.0.1到169.254.255.254中临时获得一个IP地址。\n  - 私有地址：在B类地址中，172.16.0.0到172.31.255.255是私有地址。\n\n- C类地址\n  - 第1字节、第2字节和第3个字节为网络地址，第4个字节为主机地址。另外第1个字节的前三位固定为110。\n  - 地址范围：192.0.0.0到223.255.255.255。\n  - 默认子网掩码　255.255.255.0　一个子网最多可以容纳254台电脑。\n  - 私有地址：192.168.0.0到192.168.255.255是私有地址。\n\n### 两个特殊地址\n\n- 0.0.0.0 [全网地址](http://www.cnblogs.com/hnrainll/archive/2011/10/13/2210101.html)，三界之外的收容器\n- 255.255.255.255 广播地址\n\n***\n## OSI七层模型详解 - 吴明\n[OSI七层模型详解](http://blog.csdn.net/yaopeng_2005/article/details/7064869)\n\n- 物理层：\n\t- 相关协议：IEEE802.2,Ethernet v.2,Internetwork\n- 数据链路层\n \t- 相关协议：MPLS，XTP,DCAP\n- 网络层\n- 传输层\n\t- 相关协议：EGP,NHRP\n- 会话层：\n- 表示层：\n- 应用层:\n\n***\n\n## 网络分层协议模型 - 张超耀\n###网络分层协议模型\n- 根据 TCP/IP协议簇的协议来命名\n\t- 应用层　　数据\t\t 　 泛指应用层使用的\n\t- 传输层　　数据段　　　　　传输层\n\t- 网络层　　数据包　　　　　网络层\n\t- 链路层　　帧　　　　　　　网络接入层\n\t- 物理层　　比特(位)　　　 通过介质实际传输数据时使用的\n\n- OSI七成协议模型\n\t- 应用层:例如HTTP、SMTP、SNMP、FTP、Telnet、SIP、SSH、NFS、RTSP、XMPP、Whois、ENRP\n\t- 表示层:例如XDR、ASN.1、SMB、AFP、NCP\n\t- 会话层:例如ASAP、TLS、SSH、ISO 8327 / CCITT X.225、RPC、NetBIOS、ASP、Winsock、BSD sockets\n\t- 传输层:例如TCP、UDP、RTP、SCTP、SPX、ATP、IL\n\t- 网络层:例如IP、ICMP、IGMP、IPX、BGP、OSPF、RIP、IGRP、EIGRP、ARP、RARP、X.25\n\t- 数据链路层:例如以太网、令牌环、HDLC、帧中继、ISDN、ATM、IEEE 802.11、FDDI、PPP\n\t- 物理层:例如线路、无线电、光纤\n \n- 分层的好处:\n\t- 各层之间是独立的\n\t- 灵活性好\n\t- 结构上可分割开\n\t- 易于实现和维护\n\t- 能促进标准化工作\n\n### 协议模型:\n![](http://pic002.cnblogs.com/images/2012/387401/2012070810010373.jpg)\n\n### 包装数据包的过程 \n- TCP传给IP的数据单元称作TCP报文段或简称为TCP段(TCP segment)，传给网络接口层的数据单元称作IP数据报(IPdatagram).通过以太网传输的比特流称作帧(Frame)\n![](http://hiphotos.baidu.com/exp/pic/item/90cebeec08fa513dd74179353f6d55fbb3fbd937.jpg)\n\n### 分用即解包的过程\n![](http://pic002.cnblogs.com/images/2012/387401/2012072116365656.png)\n\n\n### 不同层直接协议关系\n![](http://pic002.cnblogs.com/images/2012/387401/2012072116311034.png)\n\n***\n## TCP/IP三次握手与四次挥手 - 李仙鹏\n\n![TCP/IP三次握手与四次挥手](http://mmbiz.qpic.cn/mmbiz/NVvB3l3e9aESeCKMfdLmzic5mS9DReZ3ecGqraIDhDam4NmtRiceSzXCpICsu2keyhg1pMwxZVJBWTIvnwpkL6CA/640?wxfrom=5)\n\n> 引用自[图解 TCP/IP 协议](http://mp.weixin.qq.com/s?__biz=MzA3MDMyMjkzNg==&mid=210133499&idx=1&sn=d56455712de557b74ce17997fe29c06f&scene=1&key=0acd51d81cb052bc42a5850a900340ace87cb6cc26440e97233d7fab5311d8b5021ca25b901ab1d0434b3a23ead87ef2&ascene=0&uin=MTg4NDcxOTMyMQ%3D%3D&devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.4+build(14E46)&version=11020012&pass_ticket=Mh3kdFcxrCoIa0yIg1d7eLqJGuQkBQLzt2YIYx5poC%2BLzaWWMRZ5D1Vl6Pobd8ui)\n\n***\n\n## 计算机网络安全 - 杨志平\n\n### 2015网络安全事件\n- 携程网内部员工误删除代码 网站整体宕机12小时\n- 支付宝机房电缆被挖断 部分区域服务中断\n- 网易骨干网遭攻击 百万用户无法打游戏\n- 海康威视被黑客植入代码 导致被远程监控\n\n### 敏感数据（账号、密码等）\n- 账号密码（post明文显示）\n- 重要资源数据（防爬虫）\n- 多重账号威胁（网络账号通用）\n- 通讯协议破解（iMessage）\n\n### 网络传输加密\n\n- 数据加密算法\n\n\t- 对称式加密技术\t(加密-解密)\n\t\t- DES（Data Encryption Standard）\n\t\t>数据加密标准，速度较快，适用于加密大量数据的场合。\n\t\t- 3DES（Triple DES）\n\t\t>是基于DES，对一块数据用三个不同的密钥进行三次加密，强度更高。\n\t\t- AES（Advanced Encryption Standard）\n\t\t>高级加密标准，是下一代的加密算法标准，速度快，安全级别高；\n\t\n\n\t- 非对称式加密技术（公钥-私钥）\n\t\t- RSA\n\t\t>是一个支持变长密钥的公共密钥算法，需要加密的文件块的长度也是可变的；\n\t\t- DSA（Digital Signature Algorithm）\n\t\t>数字签名算法，是一种标准的 DSS（数字签名标准）；\n\t\t- ECC（Elliptic Curves Cryptography）\n\t\t>椭圆曲线密码编码学。\n\t\n\t- 散列算法 （不可逆）\n\t\t- MD5（Message Digest Algorithm 5）\n\t\t>是RSA数据安全公司开发的一种单向散列算法，非可逆，相同的明文产生相同的密文。\n\t\t- SHA（Secure Hash Algorithm）\n\t\t>可以对任意长度的数据运算生成一个160位的数值；\n\n[3个著名加密算法(MD5、RSA、DES)的解析](http://www.iplaysoft.com/encrypt-arithmetic.html)\n\n### 简单加密演示\n- 简单位移式加密（经典：凯撒加密）\n \n```\n“恺撒密码”据传是古罗马恺撒大帝用来保护重要军情的加密系统。它是一种替代密码，通过将字母按顺序推后起3位起到加密作用，\n如将字母A换作字母D，将字母B换作字母E。据说恺撒是率先使用加密函的古代将领之一，因此这种加密方法被称为恺撒密码。\n假如有这样一条指令：\nRETURN TO ROME\n用恺撒密码加密后就成为：\nUHWXUA WR URPH\n```\n\n- 置换加密\n\n```\n令明文m=m1,m2,...mL。令置换矩阵所决定的置换为pi，则加密置换c=Ek(m)=(c1,c2,...cL)=mpi(1),mpi(2),...,mpi(L)\n解密置换\nd=Dk(c)=(cn^-1(1),cn^-1(2),...cn^-1(L))\n例，置换密码。给定明文为the simplest possible transposition ciphers,\n将明文分成长为L=5的段，\nm1=thesi, m2=mples m3=tposs m4=iblet,\nm5=ransp, m6=ositi m7=oncip m8=hersx\n最后一段长不足5，加添一个字母x。将隔断的字母序号按下述置换矩阵进行换位：\nEk= 0 1 2 3 4\n3 0 4 2 1\n得到密文如下\nSTIEH EMSLP STSOP EITLB SRPNA TOIIS IOPCN SHXRE\n```\n\n***\n\n## Alamofire文档阅读 - 潘君\n\n`AFNetworking的继承者`\n\n摘录自[Alamofire 官方文档](https://github.com/Alamofire/Alamofire)\n\n### Feature\n - Chainable Request / Response methods\n\t 链式 request / response\n\t  Complete Documentation\n \n```\n// Response handlers can even be chained:\nAlamofire.request(.GET, \"http://httpbin.org/get\")\n         .responseString { _, _, string, _ in\n             println(string)\n         }\n         .responseJSON { _, _, JSON, _ in\n             println(JSON)\n         }\n```\n\n-  URL / JSON / plist Parameter Encoding\n\t除了以上几种 还可以自定义\n\tAlamofire provides built-in response serialization for strings, JSON, and property lists, but others can be added in extensions on Alamofire.Request.\n\t\n - Upload File / Data / Stream / MultipartFormData\n\t 多种文件上传方式\n\t \n- Download using Request or Resume data\n\n-  Authentication with NSURLCredential\n\n-  HTTP Response Validation\n\n-  Progress Closure & NSProgress\n-  cURL Debug Output\n- Comprehensive Unit Test Coverage\n\n### 某些点\n\n- url编码\nGET\n```\nGET Request With URL-Encoded Parameters\nAlamofire.request(.GET, \"http://httpbin.org/get\", parameters: [\"foo\": \"bar\"])\n// http://httpbin.org/get?foo=bar\n```\n\nPOST\n```\nlet parameters = [\n    \"foo\": \"bar\",\n    \"baz\": [\"a\", 1],\n    \"qux\": [\n        \"x\": 1,\n        \"y\": 2,\n        \"z\": 3\n    ]\n]\n\nAlamofire.request(.POST, \"http://httpbin.org/post\", parameters: parameters)\n// HTTP body: foo=bar&baz[]=a&baz[]=1&qux[x]=1&qux[y]=2&qux[z]=3\n```\n\n- 转object\nGeneric Response Object Serialization\n\n- 校验\n```\nManual Validation\n\nAlamofire.request(.GET, \"http://httpbin.org/get\", parameters: [\"foo\": \"bar\"])\n         .validate(statusCode: 200..<300)\n         .validate(contentType: [\"application/json\"])\n         .response { _, _, _, error in\n                  println(error)\n         }\nAutomatic Validation\n\nAutomatically validates status code within 200...299 range, and that the Content-Type header of the response matches the Accept header of the request, if one is provided.\n\nAlamofire.request(.GET, \"http://httpbin.org/get\", parameters: [\"foo\": \"bar\"])\n         .validate()\n         .response { _, _, _, error in\n             println(error)\n         }\n```\n\n- 方便打印\nPrintable\n\n```\nlet request = Alamofire.request(.GET, \"http://httpbin.org/ip\")\n\nprintln(request)\n\n// GET http://httpbin.org/ip (200)\n```\n\nDebugPrintable\n\n```\n\tlet request = Alamofire.request(.GET, \"http://httpbin.org/get\", parameters: [\"foo\": \"bar\"])\n\t\n\tdebugPrintln(request)\n```\n\n- 支持暂停/恢复/取消\n1. suspend(): Suspends the underlying task and dispatch queue\n2. resume(): Resumes the underlying task and dispatch queue. If the owning manager does not have startRequestsImmediately set to true, the request must call resume() in order to start.\n3. cancel(): Cancels the underlying task, producing an error that is passed to any registered response handlers.\n\n- 自定义response serializer\n","slug":"简单谈谈计算机网络","published":1,"updated":"2021-09-10T07:04:21.948Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cktfeap4j002vc2xxby0fowxx","content":"<h2 id=\"RESTful-API-设计介绍-曾铭\"><a href=\"#RESTful-API-设计介绍-曾铭\" class=\"headerlink\" title=\"RESTful API 设计介绍 - 曾铭\"></a>RESTful API 设计介绍 - 曾铭</h2><h3 id=\"WHAT\"><a href=\"#WHAT\" class=\"headerlink\" title=\"WHAT\"></a>WHAT</h3><ul>\n<li>API 概念</li>\n<li>其它方案 SOAP 等</li>\n<li>HTTP 无状态</li>\n<li>RESTful 概念 REpresentational State Transfer 表征性状态传输</li>\n<li>复用 HTTP 本身的协议定义</li>\n<li>带来的好处：通用，动词，code，缓存，安全</li>\n</ul>\n<h3 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h3><pre><code>BAD\n/getProduct\n/addProduct\n/deleteProduct\n/listProducts\n/productShop?productId=1\n</code></pre><ul>\n<li>对单一实体的重复</li>\n<li>多个实体对操作的重复</li>\n<li>实体之间逻辑接口的重复定义</li>\n</ul>\n<pre><code>GOOD\nGET /products : will return the list of all products\nGET /products/4 : will retrieve product #4\nPOST /products : will add a product to the collection\nPUT /products/4 : will update product #4\nDELETE /products/4 : will delete product #4\n\nGET /products/4/shop\nGET /users/3/favorite_schools\nPOST /users/3/favorite_schools\nPUT /users/3/favorite_schools/5\n</code></pre><ul>\n<li>好的 API 定义清晰，可预期。</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li>重复的实现或设计，嗅嗅不好的味道</li>\n<li>重复制造轮子，而不是重复发明轮子 （如用户授权，加密，缓存等）</li>\n<li>RESTful 不仅仅适用于 APP，重点是 C/S</li>\n<li>各端实现：<a href=\"http://www.zhihu.com/question/28557115/answer/48094438\" target=\"_blank\" rel=\"noopener\">参考覃超的知乎回答</a></li>\n</ul>\n<hr>\n<h2 id=\"IP网段划分-王胜\"><a href=\"#IP网段划分-王胜\" class=\"headerlink\" title=\"IP网段划分 - 王胜\"></a>IP网段划分 - 王胜</h2><h3 id=\"三大类IP段\"><a href=\"#三大类IP段\" class=\"headerlink\" title=\"三大类IP段\"></a>三大类IP段</h3><ul>\n<li><p>A类地址</p>\n<ul>\n<li>第1字节为<a href=\"http://baike.baidu.com/view/547479.htm\" target=\"_blank\" rel=\"noopener\">网络地址</a>，其他3个字节为主机地址。另外，第1个字节的最高位固定为0。</li>\n<li>地址范围：1.0.0.0到126.255.255.255。</li>\n<li>默认子网掩码：255.0.0.0，一个子网最多可以容纳1677万多台电脑。</li>\n<li>保留地址：127.0.0.0到127.255.255.255是保留地址，用做循环测试用。</li>\n<li>私有地址：10.0.0.0到10.255.255.255。【0000 1010】</li>\n</ul>\n</li>\n<li><p>B类地址</p>\n<ul>\n<li>第1字节和第2字节为网络地址，其他2个字节为主机地址。另外1个字节的前2位固定为10。</li>\n<li>地址范围：128.0.0.0到191.255.255.255。</li>\n<li>默认子网掩码：255.255.0.0　一个子网最多可以容纳6万台电脑。</li>\n<li>保留地址：169.254.0.0到169.254.255.255是保留地址。如果你的IP地址是自动获取IP地址，而你在网络上又没有找到可用的DHCP服务器，这时你将会从169.254.0.1到169.254.255.254中临时获得一个IP地址。</li>\n<li>私有地址：在B类地址中，172.16.0.0到172.31.255.255是私有地址。</li>\n</ul>\n</li>\n<li><p>C类地址</p>\n<ul>\n<li>第1字节、第2字节和第3个字节为网络地址，第4个字节为主机地址。另外第1个字节的前三位固定为110。</li>\n<li>地址范围：192.0.0.0到223.255.255.255。</li>\n<li>默认子网掩码　255.255.255.0　一个子网最多可以容纳254台电脑。</li>\n<li>私有地址：192.168.0.0到192.168.255.255是私有地址。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"两个特殊地址\"><a href=\"#两个特殊地址\" class=\"headerlink\" title=\"两个特殊地址\"></a>两个特殊地址</h3><ul>\n<li>0.0.0.0 <a href=\"http://www.cnblogs.com/hnrainll/archive/2011/10/13/2210101.html\" target=\"_blank\" rel=\"noopener\">全网地址</a>，三界之外的收容器</li>\n<li>255.255.255.255 广播地址</li>\n</ul>\n<hr>\n<h2 id=\"OSI七层模型详解-吴明\"><a href=\"#OSI七层模型详解-吴明\" class=\"headerlink\" title=\"OSI七层模型详解 - 吴明\"></a>OSI七层模型详解 - 吴明</h2><p><a href=\"http://blog.csdn.net/yaopeng_2005/article/details/7064869\" target=\"_blank\" rel=\"noopener\">OSI七层模型详解</a></p>\n<ul>\n<li>物理层：<ul>\n<li>相关协议：IEEE802.2,Ethernet v.2,Internetwork</li>\n</ul>\n</li>\n<li>数据链路层<ul>\n<li>相关协议：MPLS，XTP,DCAP</li>\n</ul>\n</li>\n<li>网络层</li>\n<li>传输层<ul>\n<li>相关协议：EGP,NHRP</li>\n</ul>\n</li>\n<li>会话层：</li>\n<li>表示层：</li>\n<li>应用层:</li>\n</ul>\n<hr>\n<h2 id=\"网络分层协议模型-张超耀\"><a href=\"#网络分层协议模型-张超耀\" class=\"headerlink\" title=\"网络分层协议模型 - 张超耀\"></a>网络分层协议模型 - 张超耀</h2><p>###网络分层协议模型</p>\n<ul>\n<li><p>根据 TCP/IP协议簇的协议来命名</p>\n<ul>\n<li>应用层　　数据         　 泛指应用层使用的</li>\n<li>传输层　　数据段　　　　　传输层</li>\n<li>网络层　　数据包　　　　　网络层</li>\n<li>链路层　　帧　　　　　　　网络接入层</li>\n<li>物理层　　比特(位)　　　 通过介质实际传输数据时使用的</li>\n</ul>\n</li>\n<li><p>OSI七成协议模型</p>\n<ul>\n<li>应用层:例如HTTP、SMTP、SNMP、FTP、Telnet、SIP、SSH、NFS、RTSP、XMPP、Whois、ENRP</li>\n<li>表示层:例如XDR、ASN.1、SMB、AFP、NCP</li>\n<li>会话层:例如ASAP、TLS、SSH、ISO 8327 / CCITT X.225、RPC、NetBIOS、ASP、Winsock、BSD sockets</li>\n<li>传输层:例如TCP、UDP、RTP、SCTP、SPX、ATP、IL</li>\n<li>网络层:例如IP、ICMP、IGMP、IPX、BGP、OSPF、RIP、IGRP、EIGRP、ARP、RARP、X.25</li>\n<li>数据链路层:例如以太网、令牌环、HDLC、帧中继、ISDN、ATM、IEEE 802.11、FDDI、PPP</li>\n<li>物理层:例如线路、无线电、光纤</li>\n</ul>\n</li>\n<li><p>分层的好处:</p>\n<ul>\n<li>各层之间是独立的</li>\n<li>灵活性好</li>\n<li>结构上可分割开</li>\n<li>易于实现和维护</li>\n<li>能促进标准化工作</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"协议模型\"><a href=\"#协议模型\" class=\"headerlink\" title=\"协议模型:\"></a>协议模型:</h3><p><img src=\"http://pic002.cnblogs.com/images/2012/387401/2012070810010373.jpg\" alt></p>\n<h3 id=\"包装数据包的过程\"><a href=\"#包装数据包的过程\" class=\"headerlink\" title=\"包装数据包的过程\"></a>包装数据包的过程</h3><ul>\n<li>TCP传给IP的数据单元称作TCP报文段或简称为TCP段(TCP segment)，传给网络接口层的数据单元称作IP数据报(IPdatagram).通过以太网传输的比特流称作帧(Frame)<br><img src=\"http://hiphotos.baidu.com/exp/pic/item/90cebeec08fa513dd74179353f6d55fbb3fbd937.jpg\" alt></li>\n</ul>\n<h3 id=\"分用即解包的过程\"><a href=\"#分用即解包的过程\" class=\"headerlink\" title=\"分用即解包的过程\"></a>分用即解包的过程</h3><p><img src=\"http://pic002.cnblogs.com/images/2012/387401/2012072116365656.png\" alt></p>\n<h3 id=\"不同层直接协议关系\"><a href=\"#不同层直接协议关系\" class=\"headerlink\" title=\"不同层直接协议关系\"></a>不同层直接协议关系</h3><p><img src=\"http://pic002.cnblogs.com/images/2012/387401/2012072116311034.png\" alt></p>\n<hr>\n<h2 id=\"TCP-IP三次握手与四次挥手-李仙鹏\"><a href=\"#TCP-IP三次握手与四次挥手-李仙鹏\" class=\"headerlink\" title=\"TCP/IP三次握手与四次挥手 - 李仙鹏\"></a>TCP/IP三次握手与四次挥手 - 李仙鹏</h2><p><img src=\"http://mmbiz.qpic.cn/mmbiz/NVvB3l3e9aESeCKMfdLmzic5mS9DReZ3ecGqraIDhDam4NmtRiceSzXCpICsu2keyhg1pMwxZVJBWTIvnwpkL6CA/640?wxfrom=5\" alt=\"TCP/IP三次握手与四次挥手\"></p>\n<blockquote>\n<p>引用自<a href=\"http://mp.weixin.qq.com/s?__biz=MzA3MDMyMjkzNg==&amp;mid=210133499&amp;idx=1&amp;sn=d56455712de557b74ce17997fe29c06f&amp;scene=1&amp;key=0acd51d81cb052bc42a5850a900340ace87cb6cc26440e97233d7fab5311d8b5021ca25b901ab1d0434b3a23ead87ef2&amp;ascene=0&amp;uin=MTg4NDcxOTMyMQ%3D%3D&amp;devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.4+build(14E46\" target=\"_blank\" rel=\"noopener\">图解 TCP/IP 协议</a>&amp;version=11020012&amp;pass_ticket=Mh3kdFcxrCoIa0yIg1d7eLqJGuQkBQLzt2YIYx5poC%2BLzaWWMRZ5D1Vl6Pobd8ui)</p>\n</blockquote>\n<hr>\n<h2 id=\"计算机网络安全-杨志平\"><a href=\"#计算机网络安全-杨志平\" class=\"headerlink\" title=\"计算机网络安全 - 杨志平\"></a>计算机网络安全 - 杨志平</h2><h3 id=\"2015网络安全事件\"><a href=\"#2015网络安全事件\" class=\"headerlink\" title=\"2015网络安全事件\"></a>2015网络安全事件</h3><ul>\n<li>携程网内部员工误删除代码 网站整体宕机12小时</li>\n<li>支付宝机房电缆被挖断 部分区域服务中断</li>\n<li>网易骨干网遭攻击 百万用户无法打游戏</li>\n<li>海康威视被黑客植入代码 导致被远程监控</li>\n</ul>\n<h3 id=\"敏感数据（账号、密码等）\"><a href=\"#敏感数据（账号、密码等）\" class=\"headerlink\" title=\"敏感数据（账号、密码等）\"></a>敏感数据（账号、密码等）</h3><ul>\n<li>账号密码（post明文显示）</li>\n<li>重要资源数据（防爬虫）</li>\n<li>多重账号威胁（网络账号通用）</li>\n<li>通讯协议破解（iMessage）</li>\n</ul>\n<h3 id=\"网络传输加密\"><a href=\"#网络传输加密\" class=\"headerlink\" title=\"网络传输加密\"></a>网络传输加密</h3><ul>\n<li><p>数据加密算法</p>\n<ul>\n<li>对称式加密技术    (加密-解密)<ul>\n<li>DES（Data Encryption Standard）<blockquote>\n<p>数据加密标准，速度较快，适用于加密大量数据的场合。</p>\n</blockquote>\n</li>\n<li>3DES（Triple DES）<blockquote>\n<p>是基于DES，对一块数据用三个不同的密钥进行三次加密，强度更高。</p>\n</blockquote>\n</li>\n<li>AES（Advanced Encryption Standard）<blockquote>\n<p>高级加密标准，是下一代的加密算法标准，速度快，安全级别高；</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<pre><code>- 非对称式加密技术（公钥-私钥）\n    - RSA\n    &gt;是一个支持变长密钥的公共密钥算法，需要加密的文件块的长度也是可变的；\n    - DSA（Digital Signature Algorithm）\n    &gt;数字签名算法，是一种标准的 DSS（数字签名标准）；\n    - ECC（Elliptic Curves Cryptography）\n    &gt;椭圆曲线密码编码学。\n\n- 散列算法 （不可逆）\n    - MD5（Message Digest Algorithm 5）\n    &gt;是RSA数据安全公司开发的一种单向散列算法，非可逆，相同的明文产生相同的密文。\n    - SHA（Secure Hash Algorithm）\n    &gt;可以对任意长度的数据运算生成一个160位的数值；\n</code></pre><p><a href=\"http://www.iplaysoft.com/encrypt-arithmetic.html\" target=\"_blank\" rel=\"noopener\">3个著名加密算法(MD5、RSA、DES)的解析</a></p>\n<h3 id=\"简单加密演示\"><a href=\"#简单加密演示\" class=\"headerlink\" title=\"简单加密演示\"></a>简单加密演示</h3><ul>\n<li>简单位移式加密（经典：凯撒加密）</li>\n</ul>\n<pre><code>“恺撒密码”据传是古罗马恺撒大帝用来保护重要军情的加密系统。它是一种替代密码，通过将字母按顺序推后起3位起到加密作用，\n如将字母A换作字母D，将字母B换作字母E。据说恺撒是率先使用加密函的古代将领之一，因此这种加密方法被称为恺撒密码。\n假如有这样一条指令：\nRETURN TO ROME\n用恺撒密码加密后就成为：\nUHWXUA WR URPH\n</code></pre><ul>\n<li>置换加密</li>\n</ul>\n<pre><code>令明文m=m1,m2,...mL。令置换矩阵所决定的置换为pi，则加密置换c=Ek(m)=(c1,c2,...cL)=mpi(1),mpi(2),...,mpi(L)\n解密置换\nd=Dk(c)=(cn^-1(1),cn^-1(2),...cn^-1(L))\n例，置换密码。给定明文为the simplest possible transposition ciphers,\n将明文分成长为L=5的段，\nm1=thesi, m2=mples m3=tposs m4=iblet,\nm5=ransp, m6=ositi m7=oncip m8=hersx\n最后一段长不足5，加添一个字母x。将隔断的字母序号按下述置换矩阵进行换位：\nEk= 0 1 2 3 4\n3 0 4 2 1\n得到密文如下\nSTIEH EMSLP STSOP EITLB SRPNA TOIIS IOPCN SHXRE\n</code></pre><hr>\n<h2 id=\"Alamofire文档阅读-潘君\"><a href=\"#Alamofire文档阅读-潘君\" class=\"headerlink\" title=\"Alamofire文档阅读 - 潘君\"></a>Alamofire文档阅读 - 潘君</h2><p><code>AFNetworking的继承者</code></p>\n<p>摘录自<a href=\"https://github.com/Alamofire/Alamofire\" target=\"_blank\" rel=\"noopener\">Alamofire 官方文档</a></p>\n<h3 id=\"Feature\"><a href=\"#Feature\" class=\"headerlink\" title=\"Feature\"></a>Feature</h3><ul>\n<li>Chainable Request / Response methods<br>  链式 request / response<br>   Complete Documentation</li>\n</ul>\n<pre><code>// Response handlers can even be chained:\nAlamofire.request(.GET, &quot;http://httpbin.org/get&quot;)\n         .responseString { _, _, string, _ in\n             println(string)\n         }\n         .responseJSON { _, _, JSON, _ in\n             println(JSON)\n         }\n</code></pre><ul>\n<li><p>URL / JSON / plist Parameter Encoding<br> 除了以上几种 还可以自定义<br> Alamofire provides built-in response serialization for strings, JSON, and property lists, but others can be added in extensions on Alamofire.Request.</p>\n<ul>\n<li>Upload File / Data / Stream / MultipartFormData<br>多种文件上传方式</li>\n</ul>\n</li>\n<li><p>Download using Request or Resume data</p>\n</li>\n<li><p>Authentication with NSURLCredential</p>\n</li>\n<li><p>HTTP Response Validation</p>\n</li>\n<li><p>Progress Closure &amp; NSProgress</p>\n</li>\n<li>cURL Debug Output</li>\n<li>Comprehensive Unit Test Coverage</li>\n</ul>\n<h3 id=\"某些点\"><a href=\"#某些点\" class=\"headerlink\" title=\"某些点\"></a>某些点</h3><ul>\n<li>url编码<br>GET<pre><code>GET Request With URL-Encoded Parameters\nAlamofire.request(.GET, &quot;http://httpbin.org/get&quot;, parameters: [&quot;foo&quot;: &quot;bar&quot;])\n// http://httpbin.org/get?foo=bar\n</code></pre></li>\n</ul>\n<p>POST</p>\n<pre><code>let parameters = [\n    &quot;foo&quot;: &quot;bar&quot;,\n    &quot;baz&quot;: [&quot;a&quot;, 1],\n    &quot;qux&quot;: [\n        &quot;x&quot;: 1,\n        &quot;y&quot;: 2,\n        &quot;z&quot;: 3\n    ]\n]\n\nAlamofire.request(.POST, &quot;http://httpbin.org/post&quot;, parameters: parameters)\n// HTTP body: foo=bar&amp;baz[]=a&amp;baz[]=1&amp;qux[x]=1&amp;qux[y]=2&amp;qux[z]=3\n</code></pre><ul>\n<li><p>转object<br>Generic Response Object Serialization</p>\n</li>\n<li><p>校验<br>```<br>Manual Validation</p>\n</li>\n</ul>\n<p>Alamofire.request(.GET, “<a href=\"http://httpbin.org/get\" target=\"_blank\" rel=\"noopener\">http://httpbin.org/get</a>“, parameters: [“foo”: “bar”])<br>         .validate(statusCode: 200..&lt;300)<br>         .validate(contentType: [“application/json”])<br>         .response { <em>, </em>, _, error in<br>                  println(error)<br>         }<br>Automatic Validation</p>\n<p>Automatically validates status code within 200…299 range, and that the Content-Type header of the response matches the Accept header of the request, if one is provided.</p>\n<p>Alamofire.request(.GET, “<a href=\"http://httpbin.org/get\" target=\"_blank\" rel=\"noopener\">http://httpbin.org/get</a>“, parameters: [“foo”: “bar”])<br>         .validate()<br>         .response { <em>, </em>, _, error in<br>             println(error)<br>         }</p>\n<pre><code>\n- 方便打印\nPrintable\n</code></pre><p>let request = Alamofire.request(.GET, “<a href=\"http://httpbin.org/ip\" target=\"_blank\" rel=\"noopener\">http://httpbin.org/ip</a>“)</p>\n<p>println(request)</p>\n<p>// GET <a href=\"http://httpbin.org/ip\" target=\"_blank\" rel=\"noopener\">http://httpbin.org/ip</a> (200)</p>\n<pre><code>\nDebugPrintable\n</code></pre><pre><code>let request = Alamofire.request(.GET, &quot;http://httpbin.org/get&quot;, parameters: [&quot;foo&quot;: &quot;bar&quot;])\n\ndebugPrintln(request)\n</code></pre><p>```</p>\n<ul>\n<li>支持暂停/恢复/取消</li>\n</ul>\n<ol>\n<li>suspend(): Suspends the underlying task and dispatch queue</li>\n<li>resume(): Resumes the underlying task and dispatch queue. If the owning manager does not have startRequestsImmediately set to true, the request must call resume() in order to start.</li>\n<li>cancel(): Cancels the underlying task, producing an error that is passed to any registered response handlers.</li>\n</ol>\n<ul>\n<li>自定义response serializer</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"RESTful-API-设计介绍-曾铭\"><a href=\"#RESTful-API-设计介绍-曾铭\" class=\"headerlink\" title=\"RESTful API 设计介绍 - 曾铭\"></a>RESTful API 设计介绍 - 曾铭</h2><h3 id=\"WHAT\"><a href=\"#WHAT\" class=\"headerlink\" title=\"WHAT\"></a>WHAT</h3><ul>\n<li>API 概念</li>\n<li>其它方案 SOAP 等</li>\n<li>HTTP 无状态</li>\n<li>RESTful 概念 REpresentational State Transfer 表征性状态传输</li>\n<li>复用 HTTP 本身的协议定义</li>\n<li>带来的好处：通用，动词，code，缓存，安全</li>\n</ul>\n<h3 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h3><pre><code>BAD\n/getProduct\n/addProduct\n/deleteProduct\n/listProducts\n/productShop?productId=1\n</code></pre><ul>\n<li>对单一实体的重复</li>\n<li>多个实体对操作的重复</li>\n<li>实体之间逻辑接口的重复定义</li>\n</ul>\n<pre><code>GOOD\nGET /products : will return the list of all products\nGET /products/4 : will retrieve product #4\nPOST /products : will add a product to the collection\nPUT /products/4 : will update product #4\nDELETE /products/4 : will delete product #4\n\nGET /products/4/shop\nGET /users/3/favorite_schools\nPOST /users/3/favorite_schools\nPUT /users/3/favorite_schools/5\n</code></pre><ul>\n<li>好的 API 定义清晰，可预期。</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li>重复的实现或设计，嗅嗅不好的味道</li>\n<li>重复制造轮子，而不是重复发明轮子 （如用户授权，加密，缓存等）</li>\n<li>RESTful 不仅仅适用于 APP，重点是 C/S</li>\n<li>各端实现：<a href=\"http://www.zhihu.com/question/28557115/answer/48094438\" target=\"_blank\" rel=\"noopener\">参考覃超的知乎回答</a></li>\n</ul>\n<hr>\n<h2 id=\"IP网段划分-王胜\"><a href=\"#IP网段划分-王胜\" class=\"headerlink\" title=\"IP网段划分 - 王胜\"></a>IP网段划分 - 王胜</h2><h3 id=\"三大类IP段\"><a href=\"#三大类IP段\" class=\"headerlink\" title=\"三大类IP段\"></a>三大类IP段</h3><ul>\n<li><p>A类地址</p>\n<ul>\n<li>第1字节为<a href=\"http://baike.baidu.com/view/547479.htm\" target=\"_blank\" rel=\"noopener\">网络地址</a>，其他3个字节为主机地址。另外，第1个字节的最高位固定为0。</li>\n<li>地址范围：1.0.0.0到126.255.255.255。</li>\n<li>默认子网掩码：255.0.0.0，一个子网最多可以容纳1677万多台电脑。</li>\n<li>保留地址：127.0.0.0到127.255.255.255是保留地址，用做循环测试用。</li>\n<li>私有地址：10.0.0.0到10.255.255.255。【0000 1010】</li>\n</ul>\n</li>\n<li><p>B类地址</p>\n<ul>\n<li>第1字节和第2字节为网络地址，其他2个字节为主机地址。另外1个字节的前2位固定为10。</li>\n<li>地址范围：128.0.0.0到191.255.255.255。</li>\n<li>默认子网掩码：255.255.0.0　一个子网最多可以容纳6万台电脑。</li>\n<li>保留地址：169.254.0.0到169.254.255.255是保留地址。如果你的IP地址是自动获取IP地址，而你在网络上又没有找到可用的DHCP服务器，这时你将会从169.254.0.1到169.254.255.254中临时获得一个IP地址。</li>\n<li>私有地址：在B类地址中，172.16.0.0到172.31.255.255是私有地址。</li>\n</ul>\n</li>\n<li><p>C类地址</p>\n<ul>\n<li>第1字节、第2字节和第3个字节为网络地址，第4个字节为主机地址。另外第1个字节的前三位固定为110。</li>\n<li>地址范围：192.0.0.0到223.255.255.255。</li>\n<li>默认子网掩码　255.255.255.0　一个子网最多可以容纳254台电脑。</li>\n<li>私有地址：192.168.0.0到192.168.255.255是私有地址。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"两个特殊地址\"><a href=\"#两个特殊地址\" class=\"headerlink\" title=\"两个特殊地址\"></a>两个特殊地址</h3><ul>\n<li>0.0.0.0 <a href=\"http://www.cnblogs.com/hnrainll/archive/2011/10/13/2210101.html\" target=\"_blank\" rel=\"noopener\">全网地址</a>，三界之外的收容器</li>\n<li>255.255.255.255 广播地址</li>\n</ul>\n<hr>\n<h2 id=\"OSI七层模型详解-吴明\"><a href=\"#OSI七层模型详解-吴明\" class=\"headerlink\" title=\"OSI七层模型详解 - 吴明\"></a>OSI七层模型详解 - 吴明</h2><p><a href=\"http://blog.csdn.net/yaopeng_2005/article/details/7064869\" target=\"_blank\" rel=\"noopener\">OSI七层模型详解</a></p>\n<ul>\n<li>物理层：<ul>\n<li>相关协议：IEEE802.2,Ethernet v.2,Internetwork</li>\n</ul>\n</li>\n<li>数据链路层<ul>\n<li>相关协议：MPLS，XTP,DCAP</li>\n</ul>\n</li>\n<li>网络层</li>\n<li>传输层<ul>\n<li>相关协议：EGP,NHRP</li>\n</ul>\n</li>\n<li>会话层：</li>\n<li>表示层：</li>\n<li>应用层:</li>\n</ul>\n<hr>\n<h2 id=\"网络分层协议模型-张超耀\"><a href=\"#网络分层协议模型-张超耀\" class=\"headerlink\" title=\"网络分层协议模型 - 张超耀\"></a>网络分层协议模型 - 张超耀</h2><p>###网络分层协议模型</p>\n<ul>\n<li><p>根据 TCP/IP协议簇的协议来命名</p>\n<ul>\n<li>应用层　　数据         　 泛指应用层使用的</li>\n<li>传输层　　数据段　　　　　传输层</li>\n<li>网络层　　数据包　　　　　网络层</li>\n<li>链路层　　帧　　　　　　　网络接入层</li>\n<li>物理层　　比特(位)　　　 通过介质实际传输数据时使用的</li>\n</ul>\n</li>\n<li><p>OSI七成协议模型</p>\n<ul>\n<li>应用层:例如HTTP、SMTP、SNMP、FTP、Telnet、SIP、SSH、NFS、RTSP、XMPP、Whois、ENRP</li>\n<li>表示层:例如XDR、ASN.1、SMB、AFP、NCP</li>\n<li>会话层:例如ASAP、TLS、SSH、ISO 8327 / CCITT X.225、RPC、NetBIOS、ASP、Winsock、BSD sockets</li>\n<li>传输层:例如TCP、UDP、RTP、SCTP、SPX、ATP、IL</li>\n<li>网络层:例如IP、ICMP、IGMP、IPX、BGP、OSPF、RIP、IGRP、EIGRP、ARP、RARP、X.25</li>\n<li>数据链路层:例如以太网、令牌环、HDLC、帧中继、ISDN、ATM、IEEE 802.11、FDDI、PPP</li>\n<li>物理层:例如线路、无线电、光纤</li>\n</ul>\n</li>\n<li><p>分层的好处:</p>\n<ul>\n<li>各层之间是独立的</li>\n<li>灵活性好</li>\n<li>结构上可分割开</li>\n<li>易于实现和维护</li>\n<li>能促进标准化工作</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"协议模型\"><a href=\"#协议模型\" class=\"headerlink\" title=\"协议模型:\"></a>协议模型:</h3><p><img src=\"http://pic002.cnblogs.com/images/2012/387401/2012070810010373.jpg\" alt></p>\n<h3 id=\"包装数据包的过程\"><a href=\"#包装数据包的过程\" class=\"headerlink\" title=\"包装数据包的过程\"></a>包装数据包的过程</h3><ul>\n<li>TCP传给IP的数据单元称作TCP报文段或简称为TCP段(TCP segment)，传给网络接口层的数据单元称作IP数据报(IPdatagram).通过以太网传输的比特流称作帧(Frame)<br><img src=\"http://hiphotos.baidu.com/exp/pic/item/90cebeec08fa513dd74179353f6d55fbb3fbd937.jpg\" alt></li>\n</ul>\n<h3 id=\"分用即解包的过程\"><a href=\"#分用即解包的过程\" class=\"headerlink\" title=\"分用即解包的过程\"></a>分用即解包的过程</h3><p><img src=\"http://pic002.cnblogs.com/images/2012/387401/2012072116365656.png\" alt></p>\n<h3 id=\"不同层直接协议关系\"><a href=\"#不同层直接协议关系\" class=\"headerlink\" title=\"不同层直接协议关系\"></a>不同层直接协议关系</h3><p><img src=\"http://pic002.cnblogs.com/images/2012/387401/2012072116311034.png\" alt></p>\n<hr>\n<h2 id=\"TCP-IP三次握手与四次挥手-李仙鹏\"><a href=\"#TCP-IP三次握手与四次挥手-李仙鹏\" class=\"headerlink\" title=\"TCP/IP三次握手与四次挥手 - 李仙鹏\"></a>TCP/IP三次握手与四次挥手 - 李仙鹏</h2><p><img src=\"http://mmbiz.qpic.cn/mmbiz/NVvB3l3e9aESeCKMfdLmzic5mS9DReZ3ecGqraIDhDam4NmtRiceSzXCpICsu2keyhg1pMwxZVJBWTIvnwpkL6CA/640?wxfrom=5\" alt=\"TCP/IP三次握手与四次挥手\"></p>\n<blockquote>\n<p>引用自<a href=\"http://mp.weixin.qq.com/s?__biz=MzA3MDMyMjkzNg==&amp;mid=210133499&amp;idx=1&amp;sn=d56455712de557b74ce17997fe29c06f&amp;scene=1&amp;key=0acd51d81cb052bc42a5850a900340ace87cb6cc26440e97233d7fab5311d8b5021ca25b901ab1d0434b3a23ead87ef2&amp;ascene=0&amp;uin=MTg4NDcxOTMyMQ%3D%3D&amp;devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.4+build(14E46\" target=\"_blank\" rel=\"noopener\">图解 TCP/IP 协议</a>&amp;version=11020012&amp;pass_ticket=Mh3kdFcxrCoIa0yIg1d7eLqJGuQkBQLzt2YIYx5poC%2BLzaWWMRZ5D1Vl6Pobd8ui)</p>\n</blockquote>\n<hr>\n<h2 id=\"计算机网络安全-杨志平\"><a href=\"#计算机网络安全-杨志平\" class=\"headerlink\" title=\"计算机网络安全 - 杨志平\"></a>计算机网络安全 - 杨志平</h2><h3 id=\"2015网络安全事件\"><a href=\"#2015网络安全事件\" class=\"headerlink\" title=\"2015网络安全事件\"></a>2015网络安全事件</h3><ul>\n<li>携程网内部员工误删除代码 网站整体宕机12小时</li>\n<li>支付宝机房电缆被挖断 部分区域服务中断</li>\n<li>网易骨干网遭攻击 百万用户无法打游戏</li>\n<li>海康威视被黑客植入代码 导致被远程监控</li>\n</ul>\n<h3 id=\"敏感数据（账号、密码等）\"><a href=\"#敏感数据（账号、密码等）\" class=\"headerlink\" title=\"敏感数据（账号、密码等）\"></a>敏感数据（账号、密码等）</h3><ul>\n<li>账号密码（post明文显示）</li>\n<li>重要资源数据（防爬虫）</li>\n<li>多重账号威胁（网络账号通用）</li>\n<li>通讯协议破解（iMessage）</li>\n</ul>\n<h3 id=\"网络传输加密\"><a href=\"#网络传输加密\" class=\"headerlink\" title=\"网络传输加密\"></a>网络传输加密</h3><ul>\n<li><p>数据加密算法</p>\n<ul>\n<li>对称式加密技术    (加密-解密)<ul>\n<li>DES（Data Encryption Standard）<blockquote>\n<p>数据加密标准，速度较快，适用于加密大量数据的场合。</p>\n</blockquote>\n</li>\n<li>3DES（Triple DES）<blockquote>\n<p>是基于DES，对一块数据用三个不同的密钥进行三次加密，强度更高。</p>\n</blockquote>\n</li>\n<li>AES（Advanced Encryption Standard）<blockquote>\n<p>高级加密标准，是下一代的加密算法标准，速度快，安全级别高；</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<pre><code>- 非对称式加密技术（公钥-私钥）\n    - RSA\n    &gt;是一个支持变长密钥的公共密钥算法，需要加密的文件块的长度也是可变的；\n    - DSA（Digital Signature Algorithm）\n    &gt;数字签名算法，是一种标准的 DSS（数字签名标准）；\n    - ECC（Elliptic Curves Cryptography）\n    &gt;椭圆曲线密码编码学。\n\n- 散列算法 （不可逆）\n    - MD5（Message Digest Algorithm 5）\n    &gt;是RSA数据安全公司开发的一种单向散列算法，非可逆，相同的明文产生相同的密文。\n    - SHA（Secure Hash Algorithm）\n    &gt;可以对任意长度的数据运算生成一个160位的数值；\n</code></pre><p><a href=\"http://www.iplaysoft.com/encrypt-arithmetic.html\" target=\"_blank\" rel=\"noopener\">3个著名加密算法(MD5、RSA、DES)的解析</a></p>\n<h3 id=\"简单加密演示\"><a href=\"#简单加密演示\" class=\"headerlink\" title=\"简单加密演示\"></a>简单加密演示</h3><ul>\n<li>简单位移式加密（经典：凯撒加密）</li>\n</ul>\n<pre><code>“恺撒密码”据传是古罗马恺撒大帝用来保护重要军情的加密系统。它是一种替代密码，通过将字母按顺序推后起3位起到加密作用，\n如将字母A换作字母D，将字母B换作字母E。据说恺撒是率先使用加密函的古代将领之一，因此这种加密方法被称为恺撒密码。\n假如有这样一条指令：\nRETURN TO ROME\n用恺撒密码加密后就成为：\nUHWXUA WR URPH\n</code></pre><ul>\n<li>置换加密</li>\n</ul>\n<pre><code>令明文m=m1,m2,...mL。令置换矩阵所决定的置换为pi，则加密置换c=Ek(m)=(c1,c2,...cL)=mpi(1),mpi(2),...,mpi(L)\n解密置换\nd=Dk(c)=(cn^-1(1),cn^-1(2),...cn^-1(L))\n例，置换密码。给定明文为the simplest possible transposition ciphers,\n将明文分成长为L=5的段，\nm1=thesi, m2=mples m3=tposs m4=iblet,\nm5=ransp, m6=ositi m7=oncip m8=hersx\n最后一段长不足5，加添一个字母x。将隔断的字母序号按下述置换矩阵进行换位：\nEk= 0 1 2 3 4\n3 0 4 2 1\n得到密文如下\nSTIEH EMSLP STSOP EITLB SRPNA TOIIS IOPCN SHXRE\n</code></pre><hr>\n<h2 id=\"Alamofire文档阅读-潘君\"><a href=\"#Alamofire文档阅读-潘君\" class=\"headerlink\" title=\"Alamofire文档阅读 - 潘君\"></a>Alamofire文档阅读 - 潘君</h2><p><code>AFNetworking的继承者</code></p>\n<p>摘录自<a href=\"https://github.com/Alamofire/Alamofire\" target=\"_blank\" rel=\"noopener\">Alamofire 官方文档</a></p>\n<h3 id=\"Feature\"><a href=\"#Feature\" class=\"headerlink\" title=\"Feature\"></a>Feature</h3><ul>\n<li>Chainable Request / Response methods<br>  链式 request / response<br>   Complete Documentation</li>\n</ul>\n<pre><code>// Response handlers can even be chained:\nAlamofire.request(.GET, &quot;http://httpbin.org/get&quot;)\n         .responseString { _, _, string, _ in\n             println(string)\n         }\n         .responseJSON { _, _, JSON, _ in\n             println(JSON)\n         }\n</code></pre><ul>\n<li><p>URL / JSON / plist Parameter Encoding<br> 除了以上几种 还可以自定义<br> Alamofire provides built-in response serialization for strings, JSON, and property lists, but others can be added in extensions on Alamofire.Request.</p>\n<ul>\n<li>Upload File / Data / Stream / MultipartFormData<br>多种文件上传方式</li>\n</ul>\n</li>\n<li><p>Download using Request or Resume data</p>\n</li>\n<li><p>Authentication with NSURLCredential</p>\n</li>\n<li><p>HTTP Response Validation</p>\n</li>\n<li><p>Progress Closure &amp; NSProgress</p>\n</li>\n<li>cURL Debug Output</li>\n<li>Comprehensive Unit Test Coverage</li>\n</ul>\n<h3 id=\"某些点\"><a href=\"#某些点\" class=\"headerlink\" title=\"某些点\"></a>某些点</h3><ul>\n<li>url编码<br>GET<pre><code>GET Request With URL-Encoded Parameters\nAlamofire.request(.GET, &quot;http://httpbin.org/get&quot;, parameters: [&quot;foo&quot;: &quot;bar&quot;])\n// http://httpbin.org/get?foo=bar\n</code></pre></li>\n</ul>\n<p>POST</p>\n<pre><code>let parameters = [\n    &quot;foo&quot;: &quot;bar&quot;,\n    &quot;baz&quot;: [&quot;a&quot;, 1],\n    &quot;qux&quot;: [\n        &quot;x&quot;: 1,\n        &quot;y&quot;: 2,\n        &quot;z&quot;: 3\n    ]\n]\n\nAlamofire.request(.POST, &quot;http://httpbin.org/post&quot;, parameters: parameters)\n// HTTP body: foo=bar&amp;baz[]=a&amp;baz[]=1&amp;qux[x]=1&amp;qux[y]=2&amp;qux[z]=3\n</code></pre><ul>\n<li><p>转object<br>Generic Response Object Serialization</p>\n</li>\n<li><p>校验<br>```<br>Manual Validation</p>\n</li>\n</ul>\n<p>Alamofire.request(.GET, “<a href=\"http://httpbin.org/get\" target=\"_blank\" rel=\"noopener\">http://httpbin.org/get</a>“, parameters: [“foo”: “bar”])<br>         .validate(statusCode: 200..&lt;300)<br>         .validate(contentType: [“application/json”])<br>         .response { <em>, </em>, _, error in<br>                  println(error)<br>         }<br>Automatic Validation</p>\n<p>Automatically validates status code within 200…299 range, and that the Content-Type header of the response matches the Accept header of the request, if one is provided.</p>\n<p>Alamofire.request(.GET, “<a href=\"http://httpbin.org/get\" target=\"_blank\" rel=\"noopener\">http://httpbin.org/get</a>“, parameters: [“foo”: “bar”])<br>         .validate()<br>         .response { <em>, </em>, _, error in<br>             println(error)<br>         }</p>\n<pre><code>\n- 方便打印\nPrintable\n</code></pre><p>let request = Alamofire.request(.GET, “<a href=\"http://httpbin.org/ip\" target=\"_blank\" rel=\"noopener\">http://httpbin.org/ip</a>“)</p>\n<p>println(request)</p>\n<p>// GET <a href=\"http://httpbin.org/ip\" target=\"_blank\" rel=\"noopener\">http://httpbin.org/ip</a> (200)</p>\n<pre><code>\nDebugPrintable\n</code></pre><pre><code>let request = Alamofire.request(.GET, &quot;http://httpbin.org/get&quot;, parameters: [&quot;foo&quot;: &quot;bar&quot;])\n\ndebugPrintln(request)\n</code></pre><p>```</p>\n<ul>\n<li>支持暂停/恢复/取消</li>\n</ul>\n<ol>\n<li>suspend(): Suspends the underlying task and dispatch queue</li>\n<li>resume(): Resumes the underlying task and dispatch queue. If the owning manager does not have startRequestsImmediately set to true, the request must call resume() in order to start.</li>\n<li>cancel(): Cancels the underlying task, producing an error that is passed to any registered response handlers.</li>\n</ol>\n<ul>\n<li>自定义response serializer</li>\n</ul>\n"},{"title":"聊聊提高代码质量","date":"2015-08-14T13:08:35.000Z","_content":"\n## 什么样的代码才是好的——李仙鹏\n\n### 我所理解的好代码\n\n- 代码规范——可读性\n\t- 统一命名方式（[Google Java代码风格](http://www.hawstein.com/posts/google-java-style.html)）\n\t- 尽量不要出现magic number\n\t- 清晰的代码注释文档（[改善Java文档的理由、建议和技巧](http://www.importnew.com/16459.html#rd?sukey=fc78a68049a14bb28cbb47b788e9ade0d111f3c2348d187194837eb45a0be9421f2e0aad0fec6b2290f2a561779caea1)）\n\t- 控制方法或者函数的细粒度\n\t- 减少代码冗余\n\n- 代码耦合低——可扩展性、可移植性\n\t- 尽量采用接口实现，减少继承\n\t- 通用功能尽量抽取作为一个独立的方法，避免重复造轮子\n\t- 设计模式并不能提高代码执行效率，但容易对代码进行模块切分，从而进行代码的解耦合。设计模式也可以算是程序员的一种通用“语言“，方便程序员之间的沟通.\n\t\t- 根据不同OS或者语言特性，从大的架构上遵循MVC或者MVP或者其它类似的层次分明的设计模式。\n\n- 严格的code review\n\t- 能够发现潜在的bug、不合理的实现和是否遵从代码规范\n\t- 有助于代码提交人员对自身代码质量的要求——面子问题\n\n- 性能\n\n> 以上这些点都是为了程序的健壮性、可扩展性、可移植性。最终目标，在核心开发人员变动或者产品需求变动后，都不会对代码维护、版本迭代和程序稳定性造成重大影响。\n\n### 51offer-v2.5.0重写中，我们是如何做的\n\n- 整体架构上采用[MVP模式](http://baike.baidu.com/view/3456444.htm)\n\t- V和P通过接口实现交互，M只被P处理，P处理完后通过接口反馈给V\n![MVP](http://magenic.com/Portals/0/xBlog/uploads/2015/4/10/presenter-view-model-1-mvp-pattern-for-android-jeff-angellini.png)\n\n- 代码可移植性和可扩展性\n\t- 按照是否通用原则，命名包名——非通用包名，放在offer包下；通用功能模块，放在非offer包下。这样有利于快速移植，或者打成JAR包\n\t- 接口实现，减少继承——在类的继承中，减少继承体系中每层父类的职责范围\n\n- HTTP请求\n\t- 底层请求采用[OkHttp](http://square.github.io/okhttp/)，[OkHttp](http://square.github.io/okhttp/)默认实现的功能为：\n\t\t- 支持协议——[HTTP/2](http://baike.baidu.com/view/11521153.htm)和[SPDY](http://baike.baidu.com/view/2984528.htm), 可以合并多个到同一个主机的请求\n \t\t- 使用连接池技术减少请求的延迟\n \t\t- 使用GZIP压缩减少传输的数据量\n \t\t- 报文缓存响应，避免重复的网络请求\n\n- json解析\n\t- [Gson](https://sites.google.com/site/gson/gson-user-guide)，这是[综合考虑Json使用场景后的选择结果](http://www.open-open.com/lib/view/open1434377191317.html)——方便json字符串到对象之间的转换、[Gson](https://sites.google.com/site/gson/gson-user-guide)在处理短的json时速度比较快、[Gson](https://sites.google.com/site/gson/gson-user-guide)不需要太多的注解\n\n- 图片加载\n\t- 采用[Android-Universal-Image-Loader](https://github.com/nostra13/Android-Universal-Image-Loader)\n\t\t- 多线程图片加载\n\t\t- 可自定义的加载器\n\t\t- 可自定义的图片显示回调\n\t\t- 图片三级缓存——内存和硬盘缓存的图片通过多种数据结构管理\n\t\t- 监听加载过程\n\n\t- bitmap显示质量设置为RGB_565——一个像素需要16位表示，Android中默认为ARGB_8888——一个像素需要32位表示。这种方式在***基本保障图片质量要求***的同时，还能够大大减少手机的内存占用\n\n- 数据存储\n\t- 由于目前客户端还未涉及到大量数据和离线加载模式，所以我们暂不使用数据库（以后在做IM或者离线加载时，会考虑使用ORM来访问数据库），综合速度考虑使用Android的SharedPreference\n\n## 组件通信库EventBus - 吴强\n  EventBus是一个Android端优化的publish/subscribe消息总线，简化了应用程序内各组件间、组件与后台线程间的通信。\n\n###  三个主要元素：\n- Event：事件\n >Event可以是任意类型的对象\n- Subscriber：事件订阅者，接收特定的事件\n  >在EventBus中，使用约定来指定事件订阅者以简化使用。即所有事件订阅都都是以onEvent开头的函数，具体来说，函数的名字是onEvent，onEventMainThread，onEventBackgroundThread，onEventAsync这四个\n- Publisher:事件发布者，用于通知Subscriber有事件发生\n  >可以在任意线程任意位置发送事件，直接调用EventBus的post(Object)方法，可以自己实例化EventBus对象，但一般使用默认的单例就好了：EventBus.getDefault()，根据post函数参数的类型，会自动调用订阅相应类型事件的函数。\n\n###  ThreadMode\n  Subscriber函数的名字只能是那4个，因为每个事件订阅函数都是和一个ThreadMode相关联的，ThreadMode指定了会调用的函数。有以下四个ThreadMode：\n\n- PostThread:\n  事件的处理在和事件的发送在相同的进程，所以事件处理时间不应太长，不然影响事件的发送线程，而这个线程可能是UI线程。对应的函数名是onEvent。\n- MainThread:\n  事件的处理会在UI线程中执行。事件处理时间不能太长，这个不用说的，长了会ANR的，对应的函数名是onEventMainThread。\n- BackgroundThread:\n  事件的处理会在一个后台线程中执行，对应的函数名是onEventBackgroundThread，虽然名字是BackgroundThread，事件处理是在后台线程，但事件处理时间还是不应该太长，因为如果发送事件的线程是后台线程，会直接执行事件，如果当前线程是UI线程，事件会被加到一个队列中，由一个线程依次处理这些事件，如果某个事件处理时间太长，会阻塞后面的事件的派发或处理。\n- Async:\n  事件处理会在单独的线程中执行，主要用于在后台线程中执行耗时操作，每个事件会开启一个线程（有线程池），但最好限制线程的数目。\n\n### 注册事件与解除注册\n- 通过EventBus.getDefault().register方法可以向EventBus注册来订阅事件\n- 通过registerSticky可以注册Stick事件处理函数\n- 通过EventBus.getDefault().unregister方法解除EventBus事件订阅\n\n### Post事件\n- 直接调用EventBus.getDefault().post(Event)就可以发送事件，根据Event的类型就可以发送到相应事件的订阅者。\n- 当通过postSticky发送一个事件时，这个类型的事件的最后一次事件会被缓存起来，当有订阅者通过registerSticky注册时，会把之前缓存起来的这个事件直接发送给它\n\n### 缺点\n  无法进程间通信，如果一个应用内有多个进程的话就没办法了\n\n### 注意事项及要点\n- 同一个onEvent函数不能被注册两次，所以不能在一个类中注册同时还在父类中注册\n- 当Post一个事件时，这个事件类的父类的事件也会被Post。\n- Post的事件无Subscriber处理时会Post `NoSubscriberEvent`事件，当调用Subscriber失败时会Post `SubscriberExceptionEvent`事件。\n\n### 其他\n  EventBus中还有个Util包，主要作用是可以通过AsyncExecutor执行一个Runnable，通过内部的RunnableEx(可以搜索异常的Runnable)当Runnable抛出异常时通过EventBus发消息显示错误对话框。\n\n参考资料：[快速Android开发系列通信篇之EventBus](http://www.cnblogs.com/angeldevil/p/3715934.html)\n\n## 如何提高代码质量——吴明\n\n![Alt text](http://ww4.sinaimg.cn/large/7cc829d3jw1dpx6ahcgfuj.jpg)\n\n- code review\n- [命名规范](http://www.hawstein.com/posts/google-java-style.html)\n  - java命名规范:\n    - java类：m+模块+功能(如:mLoginRegester)\n    - 控件类：m+模块+功能+控件缩写(如:mLoginRegesterBtn)\n    - 常量:模块+功能(如:SCHOOL_COUNT_MAX)\n  - xml命名规范\n   - id:模块+功能+控件缩写\n  - color，string，dimen，drawable\n  - 图片：模块_功能_备注_状态\n  - 注释\n- 好的框架\n  - okhttp\n  - Gson\n- 设计模式:\n - [单例模式](http://cantellow.iteye.com/blog/838473)\n - 工厂模式\n - 策略模式\n - 代理模式\n - [mvp模式](http://blog.csdn.net/cym492224103/article/details/38776873)\n- 处理异常\n- 优化性能\n\n- 代码测试工具:静态代码分析\n\n## 如何写一份好的代码 - 张超耀\n\n### 数据结构和核心算法\n\n- 数据结构的重要性：低水平程序员总在考虑代码，高水平程序员总在考虑数据结构及其之间的关系\n\n- 数据结构决定算法,数据结构考虑清楚了，核心的算法自然就出来了，这就是关于每个类的每个方法如何实现的问题\n\n### 功能实现\n\n- 思路确定后，实现过程也需要大量的构思活动。碰到比较熟悉有经验的领域，自然可以轻车熟路，但难免会有一些你不太熟悉的技术需要尝试。作为一个程序员，最大的挑战也是最大的乐趣所在，就是不断学习新的技术，没有这样的心态，很快就会落后。\n\n- 那么遇到不熟悉的技术怎么办？Demo先行，这样做的好处是把单个技术问题和其他潜在的bug隔离开来，便于快速学习新技术。否则，直接在项目里写代码出错以后，要判断问题的源头都要多费好几倍的精力。\n\n### 测试\n\n- 测试很重要，设计测试用例就像开发时设计数据结构一样，也是很关键的。\n\n### 代码可读性\n\n- 要想自己满意，代码的可读性一定要好。要做到一年后甚至几年后你拿到自己写的代码，还能很容易看明白当时的思路和实现。这就涉及到命名和注释的问题\n\n- 命名就像超市里的商品标签一样，要让看得人一目了然就知道这是个什么东西\n\n- 注释也是很重要的，它可以用来说明一段代码的作用，算法的设计思想，或者是方法调用的参数格式要求等\n\n### 最后总结一下：\n- 技术水平是可以慢慢提高的，但是好的编程习惯需要从一开始就养成，它会让你在前进的道路上事半功倍，受益终生。\n\n## 怎样写好的代码 - 曾铭\n\n> 有两种方式构建软件设计：一种是把软件做得很简单以至于明显找不到缺陷；另一种是把它做得很复杂以至于找不到明显的缺陷\n——C.A.R. Hoare\n\n### 谁来写？角色的定义\n- 程序员 vs 工程师\n- 实现功能 vs 解决问题\n- 搭个帐篷 vs 照顾孩子\n\n### 好的代码？\n\n> 一个程序员更希望接手一个有bug但是看的懂的工程，还是一个没bug但是看不懂的工程？\n\n- 代码跟人聊天，解释做什么，注释解释为什么这么做，要注意什么\n- 面向接口而不仅仅面向对象\n\n举例：在 APP 开发和 API 开发之间，面向 API 文档做开发\n\n### 写的过程？（推荐开发过程）\n\n- 需求明确（理解来源及演进）\n- 整体设计（外在联系，临界条件，错误处理）\n- 实现（验证思路，解决问题及优化）**切记不要拿到需求直接跳到这一步**\n\n### 好？目标\n\n- 可运行，可读，可维护，可测试\n- 参见 TDD，BDD\n","source":"_posts/聊聊提高代码质量.md","raw":"title: 聊聊提高代码质量\ndate: 2015-08-14  13:08:35\ntags:\ncategories: 移动组周分享\n---\n\n## 什么样的代码才是好的——李仙鹏\n\n### 我所理解的好代码\n\n- 代码规范——可读性\n\t- 统一命名方式（[Google Java代码风格](http://www.hawstein.com/posts/google-java-style.html)）\n\t- 尽量不要出现magic number\n\t- 清晰的代码注释文档（[改善Java文档的理由、建议和技巧](http://www.importnew.com/16459.html#rd?sukey=fc78a68049a14bb28cbb47b788e9ade0d111f3c2348d187194837eb45a0be9421f2e0aad0fec6b2290f2a561779caea1)）\n\t- 控制方法或者函数的细粒度\n\t- 减少代码冗余\n\n- 代码耦合低——可扩展性、可移植性\n\t- 尽量采用接口实现，减少继承\n\t- 通用功能尽量抽取作为一个独立的方法，避免重复造轮子\n\t- 设计模式并不能提高代码执行效率，但容易对代码进行模块切分，从而进行代码的解耦合。设计模式也可以算是程序员的一种通用“语言“，方便程序员之间的沟通.\n\t\t- 根据不同OS或者语言特性，从大的架构上遵循MVC或者MVP或者其它类似的层次分明的设计模式。\n\n- 严格的code review\n\t- 能够发现潜在的bug、不合理的实现和是否遵从代码规范\n\t- 有助于代码提交人员对自身代码质量的要求——面子问题\n\n- 性能\n\n> 以上这些点都是为了程序的健壮性、可扩展性、可移植性。最终目标，在核心开发人员变动或者产品需求变动后，都不会对代码维护、版本迭代和程序稳定性造成重大影响。\n\n### 51offer-v2.5.0重写中，我们是如何做的\n\n- 整体架构上采用[MVP模式](http://baike.baidu.com/view/3456444.htm)\n\t- V和P通过接口实现交互，M只被P处理，P处理完后通过接口反馈给V\n![MVP](http://magenic.com/Portals/0/xBlog/uploads/2015/4/10/presenter-view-model-1-mvp-pattern-for-android-jeff-angellini.png)\n\n- 代码可移植性和可扩展性\n\t- 按照是否通用原则，命名包名——非通用包名，放在offer包下；通用功能模块，放在非offer包下。这样有利于快速移植，或者打成JAR包\n\t- 接口实现，减少继承——在类的继承中，减少继承体系中每层父类的职责范围\n\n- HTTP请求\n\t- 底层请求采用[OkHttp](http://square.github.io/okhttp/)，[OkHttp](http://square.github.io/okhttp/)默认实现的功能为：\n\t\t- 支持协议——[HTTP/2](http://baike.baidu.com/view/11521153.htm)和[SPDY](http://baike.baidu.com/view/2984528.htm), 可以合并多个到同一个主机的请求\n \t\t- 使用连接池技术减少请求的延迟\n \t\t- 使用GZIP压缩减少传输的数据量\n \t\t- 报文缓存响应，避免重复的网络请求\n\n- json解析\n\t- [Gson](https://sites.google.com/site/gson/gson-user-guide)，这是[综合考虑Json使用场景后的选择结果](http://www.open-open.com/lib/view/open1434377191317.html)——方便json字符串到对象之间的转换、[Gson](https://sites.google.com/site/gson/gson-user-guide)在处理短的json时速度比较快、[Gson](https://sites.google.com/site/gson/gson-user-guide)不需要太多的注解\n\n- 图片加载\n\t- 采用[Android-Universal-Image-Loader](https://github.com/nostra13/Android-Universal-Image-Loader)\n\t\t- 多线程图片加载\n\t\t- 可自定义的加载器\n\t\t- 可自定义的图片显示回调\n\t\t- 图片三级缓存——内存和硬盘缓存的图片通过多种数据结构管理\n\t\t- 监听加载过程\n\n\t- bitmap显示质量设置为RGB_565——一个像素需要16位表示，Android中默认为ARGB_8888——一个像素需要32位表示。这种方式在***基本保障图片质量要求***的同时，还能够大大减少手机的内存占用\n\n- 数据存储\n\t- 由于目前客户端还未涉及到大量数据和离线加载模式，所以我们暂不使用数据库（以后在做IM或者离线加载时，会考虑使用ORM来访问数据库），综合速度考虑使用Android的SharedPreference\n\n## 组件通信库EventBus - 吴强\n  EventBus是一个Android端优化的publish/subscribe消息总线，简化了应用程序内各组件间、组件与后台线程间的通信。\n\n###  三个主要元素：\n- Event：事件\n >Event可以是任意类型的对象\n- Subscriber：事件订阅者，接收特定的事件\n  >在EventBus中，使用约定来指定事件订阅者以简化使用。即所有事件订阅都都是以onEvent开头的函数，具体来说，函数的名字是onEvent，onEventMainThread，onEventBackgroundThread，onEventAsync这四个\n- Publisher:事件发布者，用于通知Subscriber有事件发生\n  >可以在任意线程任意位置发送事件，直接调用EventBus的post(Object)方法，可以自己实例化EventBus对象，但一般使用默认的单例就好了：EventBus.getDefault()，根据post函数参数的类型，会自动调用订阅相应类型事件的函数。\n\n###  ThreadMode\n  Subscriber函数的名字只能是那4个，因为每个事件订阅函数都是和一个ThreadMode相关联的，ThreadMode指定了会调用的函数。有以下四个ThreadMode：\n\n- PostThread:\n  事件的处理在和事件的发送在相同的进程，所以事件处理时间不应太长，不然影响事件的发送线程，而这个线程可能是UI线程。对应的函数名是onEvent。\n- MainThread:\n  事件的处理会在UI线程中执行。事件处理时间不能太长，这个不用说的，长了会ANR的，对应的函数名是onEventMainThread。\n- BackgroundThread:\n  事件的处理会在一个后台线程中执行，对应的函数名是onEventBackgroundThread，虽然名字是BackgroundThread，事件处理是在后台线程，但事件处理时间还是不应该太长，因为如果发送事件的线程是后台线程，会直接执行事件，如果当前线程是UI线程，事件会被加到一个队列中，由一个线程依次处理这些事件，如果某个事件处理时间太长，会阻塞后面的事件的派发或处理。\n- Async:\n  事件处理会在单独的线程中执行，主要用于在后台线程中执行耗时操作，每个事件会开启一个线程（有线程池），但最好限制线程的数目。\n\n### 注册事件与解除注册\n- 通过EventBus.getDefault().register方法可以向EventBus注册来订阅事件\n- 通过registerSticky可以注册Stick事件处理函数\n- 通过EventBus.getDefault().unregister方法解除EventBus事件订阅\n\n### Post事件\n- 直接调用EventBus.getDefault().post(Event)就可以发送事件，根据Event的类型就可以发送到相应事件的订阅者。\n- 当通过postSticky发送一个事件时，这个类型的事件的最后一次事件会被缓存起来，当有订阅者通过registerSticky注册时，会把之前缓存起来的这个事件直接发送给它\n\n### 缺点\n  无法进程间通信，如果一个应用内有多个进程的话就没办法了\n\n### 注意事项及要点\n- 同一个onEvent函数不能被注册两次，所以不能在一个类中注册同时还在父类中注册\n- 当Post一个事件时，这个事件类的父类的事件也会被Post。\n- Post的事件无Subscriber处理时会Post `NoSubscriberEvent`事件，当调用Subscriber失败时会Post `SubscriberExceptionEvent`事件。\n\n### 其他\n  EventBus中还有个Util包，主要作用是可以通过AsyncExecutor执行一个Runnable，通过内部的RunnableEx(可以搜索异常的Runnable)当Runnable抛出异常时通过EventBus发消息显示错误对话框。\n\n参考资料：[快速Android开发系列通信篇之EventBus](http://www.cnblogs.com/angeldevil/p/3715934.html)\n\n## 如何提高代码质量——吴明\n\n![Alt text](http://ww4.sinaimg.cn/large/7cc829d3jw1dpx6ahcgfuj.jpg)\n\n- code review\n- [命名规范](http://www.hawstein.com/posts/google-java-style.html)\n  - java命名规范:\n    - java类：m+模块+功能(如:mLoginRegester)\n    - 控件类：m+模块+功能+控件缩写(如:mLoginRegesterBtn)\n    - 常量:模块+功能(如:SCHOOL_COUNT_MAX)\n  - xml命名规范\n   - id:模块+功能+控件缩写\n  - color，string，dimen，drawable\n  - 图片：模块_功能_备注_状态\n  - 注释\n- 好的框架\n  - okhttp\n  - Gson\n- 设计模式:\n - [单例模式](http://cantellow.iteye.com/blog/838473)\n - 工厂模式\n - 策略模式\n - 代理模式\n - [mvp模式](http://blog.csdn.net/cym492224103/article/details/38776873)\n- 处理异常\n- 优化性能\n\n- 代码测试工具:静态代码分析\n\n## 如何写一份好的代码 - 张超耀\n\n### 数据结构和核心算法\n\n- 数据结构的重要性：低水平程序员总在考虑代码，高水平程序员总在考虑数据结构及其之间的关系\n\n- 数据结构决定算法,数据结构考虑清楚了，核心的算法自然就出来了，这就是关于每个类的每个方法如何实现的问题\n\n### 功能实现\n\n- 思路确定后，实现过程也需要大量的构思活动。碰到比较熟悉有经验的领域，自然可以轻车熟路，但难免会有一些你不太熟悉的技术需要尝试。作为一个程序员，最大的挑战也是最大的乐趣所在，就是不断学习新的技术，没有这样的心态，很快就会落后。\n\n- 那么遇到不熟悉的技术怎么办？Demo先行，这样做的好处是把单个技术问题和其他潜在的bug隔离开来，便于快速学习新技术。否则，直接在项目里写代码出错以后，要判断问题的源头都要多费好几倍的精力。\n\n### 测试\n\n- 测试很重要，设计测试用例就像开发时设计数据结构一样，也是很关键的。\n\n### 代码可读性\n\n- 要想自己满意，代码的可读性一定要好。要做到一年后甚至几年后你拿到自己写的代码，还能很容易看明白当时的思路和实现。这就涉及到命名和注释的问题\n\n- 命名就像超市里的商品标签一样，要让看得人一目了然就知道这是个什么东西\n\n- 注释也是很重要的，它可以用来说明一段代码的作用，算法的设计思想，或者是方法调用的参数格式要求等\n\n### 最后总结一下：\n- 技术水平是可以慢慢提高的，但是好的编程习惯需要从一开始就养成，它会让你在前进的道路上事半功倍，受益终生。\n\n## 怎样写好的代码 - 曾铭\n\n> 有两种方式构建软件设计：一种是把软件做得很简单以至于明显找不到缺陷；另一种是把它做得很复杂以至于找不到明显的缺陷\n——C.A.R. Hoare\n\n### 谁来写？角色的定义\n- 程序员 vs 工程师\n- 实现功能 vs 解决问题\n- 搭个帐篷 vs 照顾孩子\n\n### 好的代码？\n\n> 一个程序员更希望接手一个有bug但是看的懂的工程，还是一个没bug但是看不懂的工程？\n\n- 代码跟人聊天，解释做什么，注释解释为什么这么做，要注意什么\n- 面向接口而不仅仅面向对象\n\n举例：在 APP 开发和 API 开发之间，面向 API 文档做开发\n\n### 写的过程？（推荐开发过程）\n\n- 需求明确（理解来源及演进）\n- 整体设计（外在联系，临界条件，错误处理）\n- 实现（验证思路，解决问题及优化）**切记不要拿到需求直接跳到这一步**\n\n### 好？目标\n\n- 可运行，可读，可维护，可测试\n- 参见 TDD，BDD\n","slug":"聊聊提高代码质量","published":1,"updated":"2021-09-10T07:04:21.950Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cktfeap4k002zc2xx6sjzuqzk","content":"<h2 id=\"什么样的代码才是好的——李仙鹏\"><a href=\"#什么样的代码才是好的——李仙鹏\" class=\"headerlink\" title=\"什么样的代码才是好的——李仙鹏\"></a>什么样的代码才是好的——李仙鹏</h2><h3 id=\"我所理解的好代码\"><a href=\"#我所理解的好代码\" class=\"headerlink\" title=\"我所理解的好代码\"></a>我所理解的好代码</h3><ul>\n<li><p>代码规范——可读性</p>\n<ul>\n<li>统一命名方式（<a href=\"http://www.hawstein.com/posts/google-java-style.html\" target=\"_blank\" rel=\"noopener\">Google Java代码风格</a>）</li>\n<li>尽量不要出现magic number</li>\n<li>清晰的代码注释文档（<a href=\"http://www.importnew.com/16459.html#rd?sukey=fc78a68049a14bb28cbb47b788e9ade0d111f3c2348d187194837eb45a0be9421f2e0aad0fec6b2290f2a561779caea1\" target=\"_blank\" rel=\"noopener\">改善Java文档的理由、建议和技巧</a>）</li>\n<li>控制方法或者函数的细粒度</li>\n<li>减少代码冗余</li>\n</ul>\n</li>\n<li><p>代码耦合低——可扩展性、可移植性</p>\n<ul>\n<li>尽量采用接口实现，减少继承</li>\n<li>通用功能尽量抽取作为一个独立的方法，避免重复造轮子</li>\n<li>设计模式并不能提高代码执行效率，但容易对代码进行模块切分，从而进行代码的解耦合。设计模式也可以算是程序员的一种通用“语言“，方便程序员之间的沟通.<ul>\n<li>根据不同OS或者语言特性，从大的架构上遵循MVC或者MVP或者其它类似的层次分明的设计模式。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>严格的code review</p>\n<ul>\n<li>能够发现潜在的bug、不合理的实现和是否遵从代码规范</li>\n<li>有助于代码提交人员对自身代码质量的要求——面子问题</li>\n</ul>\n</li>\n<li><p>性能</p>\n</li>\n</ul>\n<blockquote>\n<p>以上这些点都是为了程序的健壮性、可扩展性、可移植性。最终目标，在核心开发人员变动或者产品需求变动后，都不会对代码维护、版本迭代和程序稳定性造成重大影响。</p>\n</blockquote>\n<h3 id=\"51offer-v2-5-0重写中，我们是如何做的\"><a href=\"#51offer-v2-5-0重写中，我们是如何做的\" class=\"headerlink\" title=\"51offer-v2.5.0重写中，我们是如何做的\"></a>51offer-v2.5.0重写中，我们是如何做的</h3><ul>\n<li><p>整体架构上采用<a href=\"http://baike.baidu.com/view/3456444.htm\" target=\"_blank\" rel=\"noopener\">MVP模式</a></p>\n<ul>\n<li>V和P通过接口实现交互，M只被P处理，P处理完后通过接口反馈给V<br><img src=\"http://magenic.com/Portals/0/xBlog/uploads/2015/4/10/presenter-view-model-1-mvp-pattern-for-android-jeff-angellini.png\" alt=\"MVP\"></li>\n</ul>\n</li>\n<li><p>代码可移植性和可扩展性</p>\n<ul>\n<li>按照是否通用原则，命名包名——非通用包名，放在offer包下；通用功能模块，放在非offer包下。这样有利于快速移植，或者打成JAR包</li>\n<li>接口实现，减少继承——在类的继承中，减少继承体系中每层父类的职责范围</li>\n</ul>\n</li>\n<li><p>HTTP请求</p>\n<ul>\n<li>底层请求采用<a href=\"http://square.github.io/okhttp/\" target=\"_blank\" rel=\"noopener\">OkHttp</a>，<a href=\"http://square.github.io/okhttp/\" target=\"_blank\" rel=\"noopener\">OkHttp</a>默认实现的功能为：<ul>\n<li>支持协议——<a href=\"http://baike.baidu.com/view/11521153.htm\" target=\"_blank\" rel=\"noopener\">HTTP/2</a>和<a href=\"http://baike.baidu.com/view/2984528.htm\" target=\"_blank\" rel=\"noopener\">SPDY</a>, 可以合并多个到同一个主机的请求<ul>\n<li>使用连接池技术减少请求的延迟</li>\n<li>使用GZIP压缩减少传输的数据量</li>\n<li>报文缓存响应，避免重复的网络请求</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>json解析</p>\n<ul>\n<li><a href=\"https://sites.google.com/site/gson/gson-user-guide\" target=\"_blank\" rel=\"noopener\">Gson</a>，这是<a href=\"http://www.open-open.com/lib/view/open1434377191317.html\" target=\"_blank\" rel=\"noopener\">综合考虑Json使用场景后的选择结果</a>——方便json字符串到对象之间的转换、<a href=\"https://sites.google.com/site/gson/gson-user-guide\" target=\"_blank\" rel=\"noopener\">Gson</a>在处理短的json时速度比较快、<a href=\"https://sites.google.com/site/gson/gson-user-guide\" target=\"_blank\" rel=\"noopener\">Gson</a>不需要太多的注解</li>\n</ul>\n</li>\n<li><p>图片加载</p>\n<ul>\n<li><p>采用<a href=\"https://github.com/nostra13/Android-Universal-Image-Loader\" target=\"_blank\" rel=\"noopener\">Android-Universal-Image-Loader</a></p>\n<ul>\n<li>多线程图片加载</li>\n<li>可自定义的加载器</li>\n<li>可自定义的图片显示回调</li>\n<li>图片三级缓存——内存和硬盘缓存的图片通过多种数据结构管理</li>\n<li>监听加载过程</li>\n</ul>\n</li>\n<li><p>bitmap显示质量设置为RGB_565——一个像素需要16位表示，Android中默认为ARGB_8888——一个像素需要32位表示。这种方式在<strong><em>基本保障图片质量要求</em></strong>的同时，还能够大大减少手机的内存占用</p>\n</li>\n</ul>\n</li>\n<li><p>数据存储</p>\n<ul>\n<li>由于目前客户端还未涉及到大量数据和离线加载模式，所以我们暂不使用数据库（以后在做IM或者离线加载时，会考虑使用ORM来访问数据库），综合速度考虑使用Android的SharedPreference</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"组件通信库EventBus-吴强\"><a href=\"#组件通信库EventBus-吴强\" class=\"headerlink\" title=\"组件通信库EventBus - 吴强\"></a>组件通信库EventBus - 吴强</h2><p>  EventBus是一个Android端优化的publish/subscribe消息总线，简化了应用程序内各组件间、组件与后台线程间的通信。</p>\n<h3 id=\"三个主要元素：\"><a href=\"#三个主要元素：\" class=\"headerlink\" title=\"三个主要元素：\"></a>三个主要元素：</h3><ul>\n<li>Event：事件<blockquote>\n<p>Event可以是任意类型的对象</p>\n</blockquote>\n</li>\n<li>Subscriber：事件订阅者，接收特定的事件<blockquote>\n<p>在EventBus中，使用约定来指定事件订阅者以简化使用。即所有事件订阅都都是以onEvent开头的函数，具体来说，函数的名字是onEvent，onEventMainThread，onEventBackgroundThread，onEventAsync这四个</p>\n</blockquote>\n</li>\n<li>Publisher:事件发布者，用于通知Subscriber有事件发生<blockquote>\n<p>可以在任意线程任意位置发送事件，直接调用EventBus的post(Object)方法，可以自己实例化EventBus对象，但一般使用默认的单例就好了：EventBus.getDefault()，根据post函数参数的类型，会自动调用订阅相应类型事件的函数。</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"ThreadMode\"><a href=\"#ThreadMode\" class=\"headerlink\" title=\"ThreadMode\"></a>ThreadMode</h3><p>  Subscriber函数的名字只能是那4个，因为每个事件订阅函数都是和一个ThreadMode相关联的，ThreadMode指定了会调用的函数。有以下四个ThreadMode：</p>\n<ul>\n<li>PostThread:<br>事件的处理在和事件的发送在相同的进程，所以事件处理时间不应太长，不然影响事件的发送线程，而这个线程可能是UI线程。对应的函数名是onEvent。</li>\n<li>MainThread:<br>事件的处理会在UI线程中执行。事件处理时间不能太长，这个不用说的，长了会ANR的，对应的函数名是onEventMainThread。</li>\n<li>BackgroundThread:<br>事件的处理会在一个后台线程中执行，对应的函数名是onEventBackgroundThread，虽然名字是BackgroundThread，事件处理是在后台线程，但事件处理时间还是不应该太长，因为如果发送事件的线程是后台线程，会直接执行事件，如果当前线程是UI线程，事件会被加到一个队列中，由一个线程依次处理这些事件，如果某个事件处理时间太长，会阻塞后面的事件的派发或处理。</li>\n<li>Async:<br>事件处理会在单独的线程中执行，主要用于在后台线程中执行耗时操作，每个事件会开启一个线程（有线程池），但最好限制线程的数目。</li>\n</ul>\n<h3 id=\"注册事件与解除注册\"><a href=\"#注册事件与解除注册\" class=\"headerlink\" title=\"注册事件与解除注册\"></a>注册事件与解除注册</h3><ul>\n<li>通过EventBus.getDefault().register方法可以向EventBus注册来订阅事件</li>\n<li>通过registerSticky可以注册Stick事件处理函数</li>\n<li>通过EventBus.getDefault().unregister方法解除EventBus事件订阅</li>\n</ul>\n<h3 id=\"Post事件\"><a href=\"#Post事件\" class=\"headerlink\" title=\"Post事件\"></a>Post事件</h3><ul>\n<li>直接调用EventBus.getDefault().post(Event)就可以发送事件，根据Event的类型就可以发送到相应事件的订阅者。</li>\n<li>当通过postSticky发送一个事件时，这个类型的事件的最后一次事件会被缓存起来，当有订阅者通过registerSticky注册时，会把之前缓存起来的这个事件直接发送给它</li>\n</ul>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><p>  无法进程间通信，如果一个应用内有多个进程的话就没办法了</p>\n<h3 id=\"注意事项及要点\"><a href=\"#注意事项及要点\" class=\"headerlink\" title=\"注意事项及要点\"></a>注意事项及要点</h3><ul>\n<li>同一个onEvent函数不能被注册两次，所以不能在一个类中注册同时还在父类中注册</li>\n<li>当Post一个事件时，这个事件类的父类的事件也会被Post。</li>\n<li>Post的事件无Subscriber处理时会Post <code>NoSubscriberEvent</code>事件，当调用Subscriber失败时会Post <code>SubscriberExceptionEvent</code>事件。</li>\n</ul>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><p>  EventBus中还有个Util包，主要作用是可以通过AsyncExecutor执行一个Runnable，通过内部的RunnableEx(可以搜索异常的Runnable)当Runnable抛出异常时通过EventBus发消息显示错误对话框。</p>\n<p>参考资料：<a href=\"http://www.cnblogs.com/angeldevil/p/3715934.html\" target=\"_blank\" rel=\"noopener\">快速Android开发系列通信篇之EventBus</a></p>\n<h2 id=\"如何提高代码质量——吴明\"><a href=\"#如何提高代码质量——吴明\" class=\"headerlink\" title=\"如何提高代码质量——吴明\"></a>如何提高代码质量——吴明</h2><p><img src=\"http://ww4.sinaimg.cn/large/7cc829d3jw1dpx6ahcgfuj.jpg\" alt=\"Alt text\"></p>\n<ul>\n<li>code review</li>\n<li><a href=\"http://www.hawstein.com/posts/google-java-style.html\" target=\"_blank\" rel=\"noopener\">命名规范</a><ul>\n<li>java命名规范:<ul>\n<li>java类：m+模块+功能(如:mLoginRegester)</li>\n<li>控件类：m+模块+功能+控件缩写(如:mLoginRegesterBtn)</li>\n<li>常量:模块+功能(如:SCHOOL_COUNT_MAX)</li>\n</ul>\n</li>\n<li>xml命名规范<ul>\n<li>id:模块+功能+控件缩写</li>\n</ul>\n</li>\n<li>color，string，dimen，drawable</li>\n<li>图片：模块<em>功能</em>备注_状态</li>\n<li>注释</li>\n</ul>\n</li>\n<li>好的框架<ul>\n<li>okhttp</li>\n<li>Gson</li>\n</ul>\n</li>\n<li>设计模式:<ul>\n<li><a href=\"http://cantellow.iteye.com/blog/838473\" target=\"_blank\" rel=\"noopener\">单例模式</a></li>\n<li>工厂模式</li>\n<li>策略模式</li>\n<li>代理模式</li>\n<li><a href=\"http://blog.csdn.net/cym492224103/article/details/38776873\" target=\"_blank\" rel=\"noopener\">mvp模式</a></li>\n</ul>\n</li>\n<li>处理异常</li>\n<li><p>优化性能</p>\n</li>\n<li><p>代码测试工具:静态代码分析</p>\n</li>\n</ul>\n<h2 id=\"如何写一份好的代码-张超耀\"><a href=\"#如何写一份好的代码-张超耀\" class=\"headerlink\" title=\"如何写一份好的代码 - 张超耀\"></a>如何写一份好的代码 - 张超耀</h2><h3 id=\"数据结构和核心算法\"><a href=\"#数据结构和核心算法\" class=\"headerlink\" title=\"数据结构和核心算法\"></a>数据结构和核心算法</h3><ul>\n<li><p>数据结构的重要性：低水平程序员总在考虑代码，高水平程序员总在考虑数据结构及其之间的关系</p>\n</li>\n<li><p>数据结构决定算法,数据结构考虑清楚了，核心的算法自然就出来了，这就是关于每个类的每个方法如何实现的问题</p>\n</li>\n</ul>\n<h3 id=\"功能实现\"><a href=\"#功能实现\" class=\"headerlink\" title=\"功能实现\"></a>功能实现</h3><ul>\n<li><p>思路确定后，实现过程也需要大量的构思活动。碰到比较熟悉有经验的领域，自然可以轻车熟路，但难免会有一些你不太熟悉的技术需要尝试。作为一个程序员，最大的挑战也是最大的乐趣所在，就是不断学习新的技术，没有这样的心态，很快就会落后。</p>\n</li>\n<li><p>那么遇到不熟悉的技术怎么办？Demo先行，这样做的好处是把单个技术问题和其他潜在的bug隔离开来，便于快速学习新技术。否则，直接在项目里写代码出错以后，要判断问题的源头都要多费好几倍的精力。</p>\n</li>\n</ul>\n<h3 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h3><ul>\n<li>测试很重要，设计测试用例就像开发时设计数据结构一样，也是很关键的。</li>\n</ul>\n<h3 id=\"代码可读性\"><a href=\"#代码可读性\" class=\"headerlink\" title=\"代码可读性\"></a>代码可读性</h3><ul>\n<li><p>要想自己满意，代码的可读性一定要好。要做到一年后甚至几年后你拿到自己写的代码，还能很容易看明白当时的思路和实现。这就涉及到命名和注释的问题</p>\n</li>\n<li><p>命名就像超市里的商品标签一样，要让看得人一目了然就知道这是个什么东西</p>\n</li>\n<li><p>注释也是很重要的，它可以用来说明一段代码的作用，算法的设计思想，或者是方法调用的参数格式要求等</p>\n</li>\n</ul>\n<h3 id=\"最后总结一下：\"><a href=\"#最后总结一下：\" class=\"headerlink\" title=\"最后总结一下：\"></a>最后总结一下：</h3><ul>\n<li>技术水平是可以慢慢提高的，但是好的编程习惯需要从一开始就养成，它会让你在前进的道路上事半功倍，受益终生。</li>\n</ul>\n<h2 id=\"怎样写好的代码-曾铭\"><a href=\"#怎样写好的代码-曾铭\" class=\"headerlink\" title=\"怎样写好的代码 - 曾铭\"></a>怎样写好的代码 - 曾铭</h2><blockquote>\n<p>有两种方式构建软件设计：一种是把软件做得很简单以至于明显找不到缺陷；另一种是把它做得很复杂以至于找不到明显的缺陷<br>——C.A.R. Hoare</p>\n</blockquote>\n<h3 id=\"谁来写？角色的定义\"><a href=\"#谁来写？角色的定义\" class=\"headerlink\" title=\"谁来写？角色的定义\"></a>谁来写？角色的定义</h3><ul>\n<li>程序员 vs 工程师</li>\n<li>实现功能 vs 解决问题</li>\n<li>搭个帐篷 vs 照顾孩子</li>\n</ul>\n<h3 id=\"好的代码？\"><a href=\"#好的代码？\" class=\"headerlink\" title=\"好的代码？\"></a>好的代码？</h3><blockquote>\n<p>一个程序员更希望接手一个有bug但是看的懂的工程，还是一个没bug但是看不懂的工程？</p>\n</blockquote>\n<ul>\n<li>代码跟人聊天，解释做什么，注释解释为什么这么做，要注意什么</li>\n<li>面向接口而不仅仅面向对象</li>\n</ul>\n<p>举例：在 APP 开发和 API 开发之间，面向 API 文档做开发</p>\n<h3 id=\"写的过程？（推荐开发过程）\"><a href=\"#写的过程？（推荐开发过程）\" class=\"headerlink\" title=\"写的过程？（推荐开发过程）\"></a>写的过程？（推荐开发过程）</h3><ul>\n<li>需求明确（理解来源及演进）</li>\n<li>整体设计（外在联系，临界条件，错误处理）</li>\n<li>实现（验证思路，解决问题及优化）<strong>切记不要拿到需求直接跳到这一步</strong></li>\n</ul>\n<h3 id=\"好？目标\"><a href=\"#好？目标\" class=\"headerlink\" title=\"好？目标\"></a>好？目标</h3><ul>\n<li>可运行，可读，可维护，可测试</li>\n<li>参见 TDD，BDD</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"什么样的代码才是好的——李仙鹏\"><a href=\"#什么样的代码才是好的——李仙鹏\" class=\"headerlink\" title=\"什么样的代码才是好的——李仙鹏\"></a>什么样的代码才是好的——李仙鹏</h2><h3 id=\"我所理解的好代码\"><a href=\"#我所理解的好代码\" class=\"headerlink\" title=\"我所理解的好代码\"></a>我所理解的好代码</h3><ul>\n<li><p>代码规范——可读性</p>\n<ul>\n<li>统一命名方式（<a href=\"http://www.hawstein.com/posts/google-java-style.html\" target=\"_blank\" rel=\"noopener\">Google Java代码风格</a>）</li>\n<li>尽量不要出现magic number</li>\n<li>清晰的代码注释文档（<a href=\"http://www.importnew.com/16459.html#rd?sukey=fc78a68049a14bb28cbb47b788e9ade0d111f3c2348d187194837eb45a0be9421f2e0aad0fec6b2290f2a561779caea1\" target=\"_blank\" rel=\"noopener\">改善Java文档的理由、建议和技巧</a>）</li>\n<li>控制方法或者函数的细粒度</li>\n<li>减少代码冗余</li>\n</ul>\n</li>\n<li><p>代码耦合低——可扩展性、可移植性</p>\n<ul>\n<li>尽量采用接口实现，减少继承</li>\n<li>通用功能尽量抽取作为一个独立的方法，避免重复造轮子</li>\n<li>设计模式并不能提高代码执行效率，但容易对代码进行模块切分，从而进行代码的解耦合。设计模式也可以算是程序员的一种通用“语言“，方便程序员之间的沟通.<ul>\n<li>根据不同OS或者语言特性，从大的架构上遵循MVC或者MVP或者其它类似的层次分明的设计模式。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>严格的code review</p>\n<ul>\n<li>能够发现潜在的bug、不合理的实现和是否遵从代码规范</li>\n<li>有助于代码提交人员对自身代码质量的要求——面子问题</li>\n</ul>\n</li>\n<li><p>性能</p>\n</li>\n</ul>\n<blockquote>\n<p>以上这些点都是为了程序的健壮性、可扩展性、可移植性。最终目标，在核心开发人员变动或者产品需求变动后，都不会对代码维护、版本迭代和程序稳定性造成重大影响。</p>\n</blockquote>\n<h3 id=\"51offer-v2-5-0重写中，我们是如何做的\"><a href=\"#51offer-v2-5-0重写中，我们是如何做的\" class=\"headerlink\" title=\"51offer-v2.5.0重写中，我们是如何做的\"></a>51offer-v2.5.0重写中，我们是如何做的</h3><ul>\n<li><p>整体架构上采用<a href=\"http://baike.baidu.com/view/3456444.htm\" target=\"_blank\" rel=\"noopener\">MVP模式</a></p>\n<ul>\n<li>V和P通过接口实现交互，M只被P处理，P处理完后通过接口反馈给V<br><img src=\"http://magenic.com/Portals/0/xBlog/uploads/2015/4/10/presenter-view-model-1-mvp-pattern-for-android-jeff-angellini.png\" alt=\"MVP\"></li>\n</ul>\n</li>\n<li><p>代码可移植性和可扩展性</p>\n<ul>\n<li>按照是否通用原则，命名包名——非通用包名，放在offer包下；通用功能模块，放在非offer包下。这样有利于快速移植，或者打成JAR包</li>\n<li>接口实现，减少继承——在类的继承中，减少继承体系中每层父类的职责范围</li>\n</ul>\n</li>\n<li><p>HTTP请求</p>\n<ul>\n<li>底层请求采用<a href=\"http://square.github.io/okhttp/\" target=\"_blank\" rel=\"noopener\">OkHttp</a>，<a href=\"http://square.github.io/okhttp/\" target=\"_blank\" rel=\"noopener\">OkHttp</a>默认实现的功能为：<ul>\n<li>支持协议——<a href=\"http://baike.baidu.com/view/11521153.htm\" target=\"_blank\" rel=\"noopener\">HTTP/2</a>和<a href=\"http://baike.baidu.com/view/2984528.htm\" target=\"_blank\" rel=\"noopener\">SPDY</a>, 可以合并多个到同一个主机的请求<ul>\n<li>使用连接池技术减少请求的延迟</li>\n<li>使用GZIP压缩减少传输的数据量</li>\n<li>报文缓存响应，避免重复的网络请求</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>json解析</p>\n<ul>\n<li><a href=\"https://sites.google.com/site/gson/gson-user-guide\" target=\"_blank\" rel=\"noopener\">Gson</a>，这是<a href=\"http://www.open-open.com/lib/view/open1434377191317.html\" target=\"_blank\" rel=\"noopener\">综合考虑Json使用场景后的选择结果</a>——方便json字符串到对象之间的转换、<a href=\"https://sites.google.com/site/gson/gson-user-guide\" target=\"_blank\" rel=\"noopener\">Gson</a>在处理短的json时速度比较快、<a href=\"https://sites.google.com/site/gson/gson-user-guide\" target=\"_blank\" rel=\"noopener\">Gson</a>不需要太多的注解</li>\n</ul>\n</li>\n<li><p>图片加载</p>\n<ul>\n<li><p>采用<a href=\"https://github.com/nostra13/Android-Universal-Image-Loader\" target=\"_blank\" rel=\"noopener\">Android-Universal-Image-Loader</a></p>\n<ul>\n<li>多线程图片加载</li>\n<li>可自定义的加载器</li>\n<li>可自定义的图片显示回调</li>\n<li>图片三级缓存——内存和硬盘缓存的图片通过多种数据结构管理</li>\n<li>监听加载过程</li>\n</ul>\n</li>\n<li><p>bitmap显示质量设置为RGB_565——一个像素需要16位表示，Android中默认为ARGB_8888——一个像素需要32位表示。这种方式在<strong><em>基本保障图片质量要求</em></strong>的同时，还能够大大减少手机的内存占用</p>\n</li>\n</ul>\n</li>\n<li><p>数据存储</p>\n<ul>\n<li>由于目前客户端还未涉及到大量数据和离线加载模式，所以我们暂不使用数据库（以后在做IM或者离线加载时，会考虑使用ORM来访问数据库），综合速度考虑使用Android的SharedPreference</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"组件通信库EventBus-吴强\"><a href=\"#组件通信库EventBus-吴强\" class=\"headerlink\" title=\"组件通信库EventBus - 吴强\"></a>组件通信库EventBus - 吴强</h2><p>  EventBus是一个Android端优化的publish/subscribe消息总线，简化了应用程序内各组件间、组件与后台线程间的通信。</p>\n<h3 id=\"三个主要元素：\"><a href=\"#三个主要元素：\" class=\"headerlink\" title=\"三个主要元素：\"></a>三个主要元素：</h3><ul>\n<li>Event：事件<blockquote>\n<p>Event可以是任意类型的对象</p>\n</blockquote>\n</li>\n<li>Subscriber：事件订阅者，接收特定的事件<blockquote>\n<p>在EventBus中，使用约定来指定事件订阅者以简化使用。即所有事件订阅都都是以onEvent开头的函数，具体来说，函数的名字是onEvent，onEventMainThread，onEventBackgroundThread，onEventAsync这四个</p>\n</blockquote>\n</li>\n<li>Publisher:事件发布者，用于通知Subscriber有事件发生<blockquote>\n<p>可以在任意线程任意位置发送事件，直接调用EventBus的post(Object)方法，可以自己实例化EventBus对象，但一般使用默认的单例就好了：EventBus.getDefault()，根据post函数参数的类型，会自动调用订阅相应类型事件的函数。</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"ThreadMode\"><a href=\"#ThreadMode\" class=\"headerlink\" title=\"ThreadMode\"></a>ThreadMode</h3><p>  Subscriber函数的名字只能是那4个，因为每个事件订阅函数都是和一个ThreadMode相关联的，ThreadMode指定了会调用的函数。有以下四个ThreadMode：</p>\n<ul>\n<li>PostThread:<br>事件的处理在和事件的发送在相同的进程，所以事件处理时间不应太长，不然影响事件的发送线程，而这个线程可能是UI线程。对应的函数名是onEvent。</li>\n<li>MainThread:<br>事件的处理会在UI线程中执行。事件处理时间不能太长，这个不用说的，长了会ANR的，对应的函数名是onEventMainThread。</li>\n<li>BackgroundThread:<br>事件的处理会在一个后台线程中执行，对应的函数名是onEventBackgroundThread，虽然名字是BackgroundThread，事件处理是在后台线程，但事件处理时间还是不应该太长，因为如果发送事件的线程是后台线程，会直接执行事件，如果当前线程是UI线程，事件会被加到一个队列中，由一个线程依次处理这些事件，如果某个事件处理时间太长，会阻塞后面的事件的派发或处理。</li>\n<li>Async:<br>事件处理会在单独的线程中执行，主要用于在后台线程中执行耗时操作，每个事件会开启一个线程（有线程池），但最好限制线程的数目。</li>\n</ul>\n<h3 id=\"注册事件与解除注册\"><a href=\"#注册事件与解除注册\" class=\"headerlink\" title=\"注册事件与解除注册\"></a>注册事件与解除注册</h3><ul>\n<li>通过EventBus.getDefault().register方法可以向EventBus注册来订阅事件</li>\n<li>通过registerSticky可以注册Stick事件处理函数</li>\n<li>通过EventBus.getDefault().unregister方法解除EventBus事件订阅</li>\n</ul>\n<h3 id=\"Post事件\"><a href=\"#Post事件\" class=\"headerlink\" title=\"Post事件\"></a>Post事件</h3><ul>\n<li>直接调用EventBus.getDefault().post(Event)就可以发送事件，根据Event的类型就可以发送到相应事件的订阅者。</li>\n<li>当通过postSticky发送一个事件时，这个类型的事件的最后一次事件会被缓存起来，当有订阅者通过registerSticky注册时，会把之前缓存起来的这个事件直接发送给它</li>\n</ul>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><p>  无法进程间通信，如果一个应用内有多个进程的话就没办法了</p>\n<h3 id=\"注意事项及要点\"><a href=\"#注意事项及要点\" class=\"headerlink\" title=\"注意事项及要点\"></a>注意事项及要点</h3><ul>\n<li>同一个onEvent函数不能被注册两次，所以不能在一个类中注册同时还在父类中注册</li>\n<li>当Post一个事件时，这个事件类的父类的事件也会被Post。</li>\n<li>Post的事件无Subscriber处理时会Post <code>NoSubscriberEvent</code>事件，当调用Subscriber失败时会Post <code>SubscriberExceptionEvent</code>事件。</li>\n</ul>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><p>  EventBus中还有个Util包，主要作用是可以通过AsyncExecutor执行一个Runnable，通过内部的RunnableEx(可以搜索异常的Runnable)当Runnable抛出异常时通过EventBus发消息显示错误对话框。</p>\n<p>参考资料：<a href=\"http://www.cnblogs.com/angeldevil/p/3715934.html\" target=\"_blank\" rel=\"noopener\">快速Android开发系列通信篇之EventBus</a></p>\n<h2 id=\"如何提高代码质量——吴明\"><a href=\"#如何提高代码质量——吴明\" class=\"headerlink\" title=\"如何提高代码质量——吴明\"></a>如何提高代码质量——吴明</h2><p><img src=\"http://ww4.sinaimg.cn/large/7cc829d3jw1dpx6ahcgfuj.jpg\" alt=\"Alt text\"></p>\n<ul>\n<li>code review</li>\n<li><a href=\"http://www.hawstein.com/posts/google-java-style.html\" target=\"_blank\" rel=\"noopener\">命名规范</a><ul>\n<li>java命名规范:<ul>\n<li>java类：m+模块+功能(如:mLoginRegester)</li>\n<li>控件类：m+模块+功能+控件缩写(如:mLoginRegesterBtn)</li>\n<li>常量:模块+功能(如:SCHOOL_COUNT_MAX)</li>\n</ul>\n</li>\n<li>xml命名规范<ul>\n<li>id:模块+功能+控件缩写</li>\n</ul>\n</li>\n<li>color，string，dimen，drawable</li>\n<li>图片：模块<em>功能</em>备注_状态</li>\n<li>注释</li>\n</ul>\n</li>\n<li>好的框架<ul>\n<li>okhttp</li>\n<li>Gson</li>\n</ul>\n</li>\n<li>设计模式:<ul>\n<li><a href=\"http://cantellow.iteye.com/blog/838473\" target=\"_blank\" rel=\"noopener\">单例模式</a></li>\n<li>工厂模式</li>\n<li>策略模式</li>\n<li>代理模式</li>\n<li><a href=\"http://blog.csdn.net/cym492224103/article/details/38776873\" target=\"_blank\" rel=\"noopener\">mvp模式</a></li>\n</ul>\n</li>\n<li>处理异常</li>\n<li><p>优化性能</p>\n</li>\n<li><p>代码测试工具:静态代码分析</p>\n</li>\n</ul>\n<h2 id=\"如何写一份好的代码-张超耀\"><a href=\"#如何写一份好的代码-张超耀\" class=\"headerlink\" title=\"如何写一份好的代码 - 张超耀\"></a>如何写一份好的代码 - 张超耀</h2><h3 id=\"数据结构和核心算法\"><a href=\"#数据结构和核心算法\" class=\"headerlink\" title=\"数据结构和核心算法\"></a>数据结构和核心算法</h3><ul>\n<li><p>数据结构的重要性：低水平程序员总在考虑代码，高水平程序员总在考虑数据结构及其之间的关系</p>\n</li>\n<li><p>数据结构决定算法,数据结构考虑清楚了，核心的算法自然就出来了，这就是关于每个类的每个方法如何实现的问题</p>\n</li>\n</ul>\n<h3 id=\"功能实现\"><a href=\"#功能实现\" class=\"headerlink\" title=\"功能实现\"></a>功能实现</h3><ul>\n<li><p>思路确定后，实现过程也需要大量的构思活动。碰到比较熟悉有经验的领域，自然可以轻车熟路，但难免会有一些你不太熟悉的技术需要尝试。作为一个程序员，最大的挑战也是最大的乐趣所在，就是不断学习新的技术，没有这样的心态，很快就会落后。</p>\n</li>\n<li><p>那么遇到不熟悉的技术怎么办？Demo先行，这样做的好处是把单个技术问题和其他潜在的bug隔离开来，便于快速学习新技术。否则，直接在项目里写代码出错以后，要判断问题的源头都要多费好几倍的精力。</p>\n</li>\n</ul>\n<h3 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h3><ul>\n<li>测试很重要，设计测试用例就像开发时设计数据结构一样，也是很关键的。</li>\n</ul>\n<h3 id=\"代码可读性\"><a href=\"#代码可读性\" class=\"headerlink\" title=\"代码可读性\"></a>代码可读性</h3><ul>\n<li><p>要想自己满意，代码的可读性一定要好。要做到一年后甚至几年后你拿到自己写的代码，还能很容易看明白当时的思路和实现。这就涉及到命名和注释的问题</p>\n</li>\n<li><p>命名就像超市里的商品标签一样，要让看得人一目了然就知道这是个什么东西</p>\n</li>\n<li><p>注释也是很重要的，它可以用来说明一段代码的作用，算法的设计思想，或者是方法调用的参数格式要求等</p>\n</li>\n</ul>\n<h3 id=\"最后总结一下：\"><a href=\"#最后总结一下：\" class=\"headerlink\" title=\"最后总结一下：\"></a>最后总结一下：</h3><ul>\n<li>技术水平是可以慢慢提高的，但是好的编程习惯需要从一开始就养成，它会让你在前进的道路上事半功倍，受益终生。</li>\n</ul>\n<h2 id=\"怎样写好的代码-曾铭\"><a href=\"#怎样写好的代码-曾铭\" class=\"headerlink\" title=\"怎样写好的代码 - 曾铭\"></a>怎样写好的代码 - 曾铭</h2><blockquote>\n<p>有两种方式构建软件设计：一种是把软件做得很简单以至于明显找不到缺陷；另一种是把它做得很复杂以至于找不到明显的缺陷<br>——C.A.R. Hoare</p>\n</blockquote>\n<h3 id=\"谁来写？角色的定义\"><a href=\"#谁来写？角色的定义\" class=\"headerlink\" title=\"谁来写？角色的定义\"></a>谁来写？角色的定义</h3><ul>\n<li>程序员 vs 工程师</li>\n<li>实现功能 vs 解决问题</li>\n<li>搭个帐篷 vs 照顾孩子</li>\n</ul>\n<h3 id=\"好的代码？\"><a href=\"#好的代码？\" class=\"headerlink\" title=\"好的代码？\"></a>好的代码？</h3><blockquote>\n<p>一个程序员更希望接手一个有bug但是看的懂的工程，还是一个没bug但是看不懂的工程？</p>\n</blockquote>\n<ul>\n<li>代码跟人聊天，解释做什么，注释解释为什么这么做，要注意什么</li>\n<li>面向接口而不仅仅面向对象</li>\n</ul>\n<p>举例：在 APP 开发和 API 开发之间，面向 API 文档做开发</p>\n<h3 id=\"写的过程？（推荐开发过程）\"><a href=\"#写的过程？（推荐开发过程）\" class=\"headerlink\" title=\"写的过程？（推荐开发过程）\"></a>写的过程？（推荐开发过程）</h3><ul>\n<li>需求明确（理解来源及演进）</li>\n<li>整体设计（外在联系，临界条件，错误处理）</li>\n<li>实现（验证思路，解决问题及优化）<strong>切记不要拿到需求直接跳到这一步</strong></li>\n</ul>\n<h3 id=\"好？目标\"><a href=\"#好？目标\" class=\"headerlink\" title=\"好？目标\"></a>好？目标</h3><ul>\n<li>可运行，可读，可维护，可测试</li>\n<li>参见 TDD，BDD</li>\n</ul>\n"},{"title":"英语","date":"2015-10-23T10:30:00.000Z","_content":"\n## 参与开源提高英语读写 - 王胜\n\n### 阅读能力\n- 泡开源论坛，查看讨论\n- 阅读源代码包括注解、代码提交说明\n\n> 前期泡论坛，看注解、提交说明时需耐下性子，借助翻译工具。时间长了，久而久之，词汇量就上升了。\n\n### 书写能力\n\n- 试图修复bug或者提交建议\n- 尝试翻译开源软件的使用手册\n\n> 经历了阅读阶段的词汇量的积累，可以再通过书写来巩固词汇量的运用。此阶段要拥有儿童学语言的勇气，不要担心自己写错，被其他参与开源的人看到笑话。\n\n## MOOC 上手 - 曾铭\n\n### Massive Open Online Courses 大型开放式网络课程\n- Coursera\n- Udacity\n- edX\n- 中国大学MOOC\n\n### 上手感受\n- 视频教程 vs 正规课程\n- 视频教程：目标不清晰、散漫不专注、孤单、没有回顾总结，易放弃（遗忘、注意力转移）\n- 正规课程：目标清晰（结课证）、专注（每周测验）、作业互评、论坛讨论，易放弃（压力）\n- 专业教育的未来（非基本教育）\n\n### 建议\n\n- 根据兴趣上手，不必贪多，先坚持完成 1 门课(4-6h/w 并不容易)\n- 只对视频教程感兴趣？为网易公开课点个赞\n\n\n##dispatch_sync的坑 - 潘君\n- 官方文档\n```\ndispatch_sync\nSubmits a block object for execution on a dispatch queue and waits until that block completes.\n\n。。。。。\n\nAs an optimization, this function invokes the block on the current thread when possible.\n```\n\n- dispatch_sync 卡页面, 原因见官方说明最后一句，优化搞的鬼\n```\n写 (删除操作) dispatch_sync\n```\n\n- 队列分为两种，一种是Serial Dispatch Queue，还有一种是Concurrent Dispatch Queue。\n\n- xun核心模块决定线程数\n\n\n\n参考资料：\n- [深入理解dispatch_sync](http://zhangbuhuai.com/2015/04/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3dispatch_sync/)\n- [dispatch_sync always scheduling a block on Main Thread](http://stackoverflow.com/questions/13972048/dispatch-sync-always-scheduling-a-block-on-main-thread)\n\n\n# 英语，程序员\n\n### 网站\n- [iTalki](http://www.italki.com)\n> 语言交换及专业老师订课辅导的网站\n\n- [YouTube一个订阅号](https://www.youtube.com/channel/UCwA7Aepp7nRUJNa8roQ-6Bw)\n> 比较有吸引力的老师，他的同事频道也很不错\n\n- [rayWenderlich](http://www.raywenderlich.com/)\n> 主要是iOS方面的，安卓覆盖一些。涵盖文字、视频、播客三方面\n\n### APP\n- 飞鱼口语\n> 国内开发的一个及时练习口语的APP，主要是方便\n\n- 每日英语听力（欧陆词典推出的）\n> radio 模块很不错，资源不算多但比较有质量。\n\n- Podcast\n\t- 圆桌会议（RoundTable）\n\t- rayWenderlich （程序员职业发展及新技术点探讨，英式口语）\n\n### 工具\n- Skype 和志同道合的人交流，练习口语 \n\n### EF Education \n- [网站地址](http://ec.ef.com)\n> 想小试牛刀的记得想我拿一下账号密码\n","source":"_posts/英语.md","raw":"title: 英语\ndate: 2015-10-23  10:30:00\ntags:\ncategories: 移动组周分享\n---\n\n## 参与开源提高英语读写 - 王胜\n\n### 阅读能力\n- 泡开源论坛，查看讨论\n- 阅读源代码包括注解、代码提交说明\n\n> 前期泡论坛，看注解、提交说明时需耐下性子，借助翻译工具。时间长了，久而久之，词汇量就上升了。\n\n### 书写能力\n\n- 试图修复bug或者提交建议\n- 尝试翻译开源软件的使用手册\n\n> 经历了阅读阶段的词汇量的积累，可以再通过书写来巩固词汇量的运用。此阶段要拥有儿童学语言的勇气，不要担心自己写错，被其他参与开源的人看到笑话。\n\n## MOOC 上手 - 曾铭\n\n### Massive Open Online Courses 大型开放式网络课程\n- Coursera\n- Udacity\n- edX\n- 中国大学MOOC\n\n### 上手感受\n- 视频教程 vs 正规课程\n- 视频教程：目标不清晰、散漫不专注、孤单、没有回顾总结，易放弃（遗忘、注意力转移）\n- 正规课程：目标清晰（结课证）、专注（每周测验）、作业互评、论坛讨论，易放弃（压力）\n- 专业教育的未来（非基本教育）\n\n### 建议\n\n- 根据兴趣上手，不必贪多，先坚持完成 1 门课(4-6h/w 并不容易)\n- 只对视频教程感兴趣？为网易公开课点个赞\n\n\n##dispatch_sync的坑 - 潘君\n- 官方文档\n```\ndispatch_sync\nSubmits a block object for execution on a dispatch queue and waits until that block completes.\n\n。。。。。\n\nAs an optimization, this function invokes the block on the current thread when possible.\n```\n\n- dispatch_sync 卡页面, 原因见官方说明最后一句，优化搞的鬼\n```\n写 (删除操作) dispatch_sync\n```\n\n- 队列分为两种，一种是Serial Dispatch Queue，还有一种是Concurrent Dispatch Queue。\n\n- xun核心模块决定线程数\n\n\n\n参考资料：\n- [深入理解dispatch_sync](http://zhangbuhuai.com/2015/04/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3dispatch_sync/)\n- [dispatch_sync always scheduling a block on Main Thread](http://stackoverflow.com/questions/13972048/dispatch-sync-always-scheduling-a-block-on-main-thread)\n\n\n# 英语，程序员\n\n### 网站\n- [iTalki](http://www.italki.com)\n> 语言交换及专业老师订课辅导的网站\n\n- [YouTube一个订阅号](https://www.youtube.com/channel/UCwA7Aepp7nRUJNa8roQ-6Bw)\n> 比较有吸引力的老师，他的同事频道也很不错\n\n- [rayWenderlich](http://www.raywenderlich.com/)\n> 主要是iOS方面的，安卓覆盖一些。涵盖文字、视频、播客三方面\n\n### APP\n- 飞鱼口语\n> 国内开发的一个及时练习口语的APP，主要是方便\n\n- 每日英语听力（欧陆词典推出的）\n> radio 模块很不错，资源不算多但比较有质量。\n\n- Podcast\n\t- 圆桌会议（RoundTable）\n\t- rayWenderlich （程序员职业发展及新技术点探讨，英式口语）\n\n### 工具\n- Skype 和志同道合的人交流，练习口语 \n\n### EF Education \n- [网站地址](http://ec.ef.com)\n> 想小试牛刀的记得想我拿一下账号密码\n","slug":"英语","published":1,"updated":"2021-09-10T07:04:21.950Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cktfeap4l0032c2xx35ayzs61","content":"<h2 id=\"参与开源提高英语读写-王胜\"><a href=\"#参与开源提高英语读写-王胜\" class=\"headerlink\" title=\"参与开源提高英语读写 - 王胜\"></a>参与开源提高英语读写 - 王胜</h2><h3 id=\"阅读能力\"><a href=\"#阅读能力\" class=\"headerlink\" title=\"阅读能力\"></a>阅读能力</h3><ul>\n<li>泡开源论坛，查看讨论</li>\n<li>阅读源代码包括注解、代码提交说明</li>\n</ul>\n<blockquote>\n<p>前期泡论坛，看注解、提交说明时需耐下性子，借助翻译工具。时间长了，久而久之，词汇量就上升了。</p>\n</blockquote>\n<h3 id=\"书写能力\"><a href=\"#书写能力\" class=\"headerlink\" title=\"书写能力\"></a>书写能力</h3><ul>\n<li>试图修复bug或者提交建议</li>\n<li>尝试翻译开源软件的使用手册</li>\n</ul>\n<blockquote>\n<p>经历了阅读阶段的词汇量的积累，可以再通过书写来巩固词汇量的运用。此阶段要拥有儿童学语言的勇气，不要担心自己写错，被其他参与开源的人看到笑话。</p>\n</blockquote>\n<h2 id=\"MOOC-上手-曾铭\"><a href=\"#MOOC-上手-曾铭\" class=\"headerlink\" title=\"MOOC 上手 - 曾铭\"></a>MOOC 上手 - 曾铭</h2><h3 id=\"Massive-Open-Online-Courses-大型开放式网络课程\"><a href=\"#Massive-Open-Online-Courses-大型开放式网络课程\" class=\"headerlink\" title=\"Massive Open Online Courses 大型开放式网络课程\"></a>Massive Open Online Courses 大型开放式网络课程</h3><ul>\n<li>Coursera</li>\n<li>Udacity</li>\n<li>edX</li>\n<li>中国大学MOOC</li>\n</ul>\n<h3 id=\"上手感受\"><a href=\"#上手感受\" class=\"headerlink\" title=\"上手感受\"></a>上手感受</h3><ul>\n<li>视频教程 vs 正规课程</li>\n<li>视频教程：目标不清晰、散漫不专注、孤单、没有回顾总结，易放弃（遗忘、注意力转移）</li>\n<li>正规课程：目标清晰（结课证）、专注（每周测验）、作业互评、论坛讨论，易放弃（压力）</li>\n<li>专业教育的未来（非基本教育）</li>\n</ul>\n<h3 id=\"建议\"><a href=\"#建议\" class=\"headerlink\" title=\"建议\"></a>建议</h3><ul>\n<li>根据兴趣上手，不必贪多，先坚持完成 1 门课(4-6h/w 并不容易)</li>\n<li>只对视频教程感兴趣？为网易公开课点个赞</li>\n</ul>\n<p>##dispatch_sync的坑 - 潘君</p>\n<ul>\n<li>官方文档<br>```<br>dispatch_sync<br>Submits a block object for execution on a dispatch queue and waits until that block completes.</li>\n</ul>\n<p>。。。。。</p>\n<p>As an optimization, this function invokes the block on the current thread when possible.</p>\n<pre><code>\n- dispatch_sync 卡页面, 原因见官方说明最后一句，优化搞的鬼\n</code></pre><p>写 (删除操作) dispatch_sync<br>```</p>\n<ul>\n<li><p>队列分为两种，一种是Serial Dispatch Queue，还有一种是Concurrent Dispatch Queue。</p>\n</li>\n<li><p>xun核心模块决定线程数</p>\n</li>\n</ul>\n<p>参考资料：</p>\n<ul>\n<li><a href=\"http://zhangbuhuai.com/2015/04/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3dispatch_sync/\" target=\"_blank\" rel=\"noopener\">深入理解dispatch_sync</a></li>\n<li><a href=\"http://stackoverflow.com/questions/13972048/dispatch-sync-always-scheduling-a-block-on-main-thread\" target=\"_blank\" rel=\"noopener\">dispatch_sync always scheduling a block on Main Thread</a></li>\n</ul>\n<h1 id=\"英语，程序员\"><a href=\"#英语，程序员\" class=\"headerlink\" title=\"英语，程序员\"></a>英语，程序员</h1><h3 id=\"网站\"><a href=\"#网站\" class=\"headerlink\" title=\"网站\"></a>网站</h3><ul>\n<li><p><a href=\"http://www.italki.com\" target=\"_blank\" rel=\"noopener\">iTalki</a></p>\n<blockquote>\n<p>语言交换及专业老师订课辅导的网站</p>\n</blockquote>\n</li>\n<li><p><a href=\"https://www.youtube.com/channel/UCwA7Aepp7nRUJNa8roQ-6Bw\" target=\"_blank\" rel=\"noopener\">YouTube一个订阅号</a></p>\n<blockquote>\n<p>比较有吸引力的老师，他的同事频道也很不错</p>\n</blockquote>\n</li>\n<li><p><a href=\"http://www.raywenderlich.com/\" target=\"_blank\" rel=\"noopener\">rayWenderlich</a></p>\n<blockquote>\n<p>主要是iOS方面的，安卓覆盖一些。涵盖文字、视频、播客三方面</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"APP\"><a href=\"#APP\" class=\"headerlink\" title=\"APP\"></a>APP</h3><ul>\n<li><p>飞鱼口语</p>\n<blockquote>\n<p>国内开发的一个及时练习口语的APP，主要是方便</p>\n</blockquote>\n</li>\n<li><p>每日英语听力（欧陆词典推出的）</p>\n<blockquote>\n<p>radio 模块很不错，资源不算多但比较有质量。</p>\n</blockquote>\n</li>\n<li><p>Podcast</p>\n<ul>\n<li>圆桌会议（RoundTable）</li>\n<li>rayWenderlich （程序员职业发展及新技术点探讨，英式口语）</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h3><ul>\n<li>Skype 和志同道合的人交流，练习口语 </li>\n</ul>\n<h3 id=\"EF-Education\"><a href=\"#EF-Education\" class=\"headerlink\" title=\"EF Education\"></a>EF Education</h3><ul>\n<li><a href=\"http://ec.ef.com\" target=\"_blank\" rel=\"noopener\">网站地址</a><blockquote>\n<p>想小试牛刀的记得想我拿一下账号密码</p>\n</blockquote>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"参与开源提高英语读写-王胜\"><a href=\"#参与开源提高英语读写-王胜\" class=\"headerlink\" title=\"参与开源提高英语读写 - 王胜\"></a>参与开源提高英语读写 - 王胜</h2><h3 id=\"阅读能力\"><a href=\"#阅读能力\" class=\"headerlink\" title=\"阅读能力\"></a>阅读能力</h3><ul>\n<li>泡开源论坛，查看讨论</li>\n<li>阅读源代码包括注解、代码提交说明</li>\n</ul>\n<blockquote>\n<p>前期泡论坛，看注解、提交说明时需耐下性子，借助翻译工具。时间长了，久而久之，词汇量就上升了。</p>\n</blockquote>\n<h3 id=\"书写能力\"><a href=\"#书写能力\" class=\"headerlink\" title=\"书写能力\"></a>书写能力</h3><ul>\n<li>试图修复bug或者提交建议</li>\n<li>尝试翻译开源软件的使用手册</li>\n</ul>\n<blockquote>\n<p>经历了阅读阶段的词汇量的积累，可以再通过书写来巩固词汇量的运用。此阶段要拥有儿童学语言的勇气，不要担心自己写错，被其他参与开源的人看到笑话。</p>\n</blockquote>\n<h2 id=\"MOOC-上手-曾铭\"><a href=\"#MOOC-上手-曾铭\" class=\"headerlink\" title=\"MOOC 上手 - 曾铭\"></a>MOOC 上手 - 曾铭</h2><h3 id=\"Massive-Open-Online-Courses-大型开放式网络课程\"><a href=\"#Massive-Open-Online-Courses-大型开放式网络课程\" class=\"headerlink\" title=\"Massive Open Online Courses 大型开放式网络课程\"></a>Massive Open Online Courses 大型开放式网络课程</h3><ul>\n<li>Coursera</li>\n<li>Udacity</li>\n<li>edX</li>\n<li>中国大学MOOC</li>\n</ul>\n<h3 id=\"上手感受\"><a href=\"#上手感受\" class=\"headerlink\" title=\"上手感受\"></a>上手感受</h3><ul>\n<li>视频教程 vs 正规课程</li>\n<li>视频教程：目标不清晰、散漫不专注、孤单、没有回顾总结，易放弃（遗忘、注意力转移）</li>\n<li>正规课程：目标清晰（结课证）、专注（每周测验）、作业互评、论坛讨论，易放弃（压力）</li>\n<li>专业教育的未来（非基本教育）</li>\n</ul>\n<h3 id=\"建议\"><a href=\"#建议\" class=\"headerlink\" title=\"建议\"></a>建议</h3><ul>\n<li>根据兴趣上手，不必贪多，先坚持完成 1 门课(4-6h/w 并不容易)</li>\n<li>只对视频教程感兴趣？为网易公开课点个赞</li>\n</ul>\n<p>##dispatch_sync的坑 - 潘君</p>\n<ul>\n<li>官方文档<br>```<br>dispatch_sync<br>Submits a block object for execution on a dispatch queue and waits until that block completes.</li>\n</ul>\n<p>。。。。。</p>\n<p>As an optimization, this function invokes the block on the current thread when possible.</p>\n<pre><code>\n- dispatch_sync 卡页面, 原因见官方说明最后一句，优化搞的鬼\n</code></pre><p>写 (删除操作) dispatch_sync<br>```</p>\n<ul>\n<li><p>队列分为两种，一种是Serial Dispatch Queue，还有一种是Concurrent Dispatch Queue。</p>\n</li>\n<li><p>xun核心模块决定线程数</p>\n</li>\n</ul>\n<p>参考资料：</p>\n<ul>\n<li><a href=\"http://zhangbuhuai.com/2015/04/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3dispatch_sync/\" target=\"_blank\" rel=\"noopener\">深入理解dispatch_sync</a></li>\n<li><a href=\"http://stackoverflow.com/questions/13972048/dispatch-sync-always-scheduling-a-block-on-main-thread\" target=\"_blank\" rel=\"noopener\">dispatch_sync always scheduling a block on Main Thread</a></li>\n</ul>\n<h1 id=\"英语，程序员\"><a href=\"#英语，程序员\" class=\"headerlink\" title=\"英语，程序员\"></a>英语，程序员</h1><h3 id=\"网站\"><a href=\"#网站\" class=\"headerlink\" title=\"网站\"></a>网站</h3><ul>\n<li><p><a href=\"http://www.italki.com\" target=\"_blank\" rel=\"noopener\">iTalki</a></p>\n<blockquote>\n<p>语言交换及专业老师订课辅导的网站</p>\n</blockquote>\n</li>\n<li><p><a href=\"https://www.youtube.com/channel/UCwA7Aepp7nRUJNa8roQ-6Bw\" target=\"_blank\" rel=\"noopener\">YouTube一个订阅号</a></p>\n<blockquote>\n<p>比较有吸引力的老师，他的同事频道也很不错</p>\n</blockquote>\n</li>\n<li><p><a href=\"http://www.raywenderlich.com/\" target=\"_blank\" rel=\"noopener\">rayWenderlich</a></p>\n<blockquote>\n<p>主要是iOS方面的，安卓覆盖一些。涵盖文字、视频、播客三方面</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"APP\"><a href=\"#APP\" class=\"headerlink\" title=\"APP\"></a>APP</h3><ul>\n<li><p>飞鱼口语</p>\n<blockquote>\n<p>国内开发的一个及时练习口语的APP，主要是方便</p>\n</blockquote>\n</li>\n<li><p>每日英语听力（欧陆词典推出的）</p>\n<blockquote>\n<p>radio 模块很不错，资源不算多但比较有质量。</p>\n</blockquote>\n</li>\n<li><p>Podcast</p>\n<ul>\n<li>圆桌会议（RoundTable）</li>\n<li>rayWenderlich （程序员职业发展及新技术点探讨，英式口语）</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h3><ul>\n<li>Skype 和志同道合的人交流，练习口语 </li>\n</ul>\n<h3 id=\"EF-Education\"><a href=\"#EF-Education\" class=\"headerlink\" title=\"EF Education\"></a>EF Education</h3><ul>\n<li><a href=\"http://ec.ef.com\" target=\"_blank\" rel=\"noopener\">网站地址</a><blockquote>\n<p>想小试牛刀的记得想我拿一下账号密码</p>\n</blockquote>\n</li>\n</ul>\n"},{"title":"周精益分享 - 程序员装逼指南二期","date":"2015-11-04T10:30:00.000Z","_content":"\n\n## Android 单元测试  吴明\n- [Android单元测试支持](https://developer.android.com/intl/zh-cn/training/activity-testing/preparing-activity-testing.html)\n\t- Android studio 1.2 beta3版本，原生支持单元测试\n- 环境搭建 \n\t- 配置环境命令：./gradlew build connectedCheck  \n- 测试示例\t\n\t-  ![MacDown Screenshot](http://7xn0ue.com1.z0.glb.clouddn.com/420E036F-4D69-47F4-A639-5A5B294F7BDD.png)\n\t\n```\npublic class MyFirstTestActivityTest extends ActivityInstrumentationTestCase2<MyFirstTestActivity> {\n\n    private MyFirstTestActivity mFirstTestActivity;\n    private TextView mFirstTestText;\n\n    public MyFirstTestActivityTest() {\n        super(MyFirstTestActivity.class);\n    }\n\n    @Override\n    protected void setUp() throws Exception {\n        super.setUp();\n        mFirstTestActivity = getActivity();\n        mFirstTestText =\n                (TextView) mFirstTestActivity\n                .findViewById(R.id.my_first_test_text_view);\n    }\n}\n\n```\n- ps:由于配置环境一直报:\n\n```\nTest running failed: Instrumentation run failed due to 'java.lang.RuntimeException'\n\n```\n\n- [Automating UI Tests](https://developer.android.com/intl/zh-cn/training/testing/ui-testing/index.html)\n- [Building Effective Unit Tests](https://developer.android.com/intl/zh-cn/training/testing/unit-testing/index.html)\n- [Testing Display  Performance](https://developer.android.com/intl/zh-cn/training/testing/performance.html)\n- 问题：\n\t-  运行在模拟器上，通过对模拟器的操作或者mock，来触发函数调用，进而对其结果进行验证\n\t-  测试的编写和维护较为困难\n\n\n\n## Linux 文件权限入门 - 曾铭\n\n### 一个线上 bug\n图片上传 API 无法使用，定位到问题是 dev1 帐号移动的 tomcat 无法访问 /home/img_temp 目录，处理权限问题后搞定\n\n### 基本概念\nuser, group, others\n\n```\n[dev1@apps-51offer ~]$ ll\ntotal 16\n-rw-r--r-- 1 dev1 dev   742 Nov  5 11:22 ming.pub\ndrwxrwx--- 4 root root 4096 Nov  6 09:30 test1\ndrwxr-xr-- 2 dev1 dev  4096 Nov  6 10:44 test2\ndrwxr-xr-x 2 dev1 dev  4096 Nov  6 09:30 test3\n```\n\n- 文件 `-`\n- 文件夹 `d`\n- 链接 `l`\n\nrwx 读、写、执行权限 , 754 代表什么\n\n- 文件所有者变更：`chown ming:mobile file`\n- 文件权限变更： `chmod g+rx file`\n\n### 一个小坑\n\n#### 问：\n\n> `drwxr-xr-- 2 dev1 dev  4096 Nov  6 10:44 test2` 文件夹下有 `-rwxr-xr-- 2 root root  4096 Nov  6 10:44 file`\n> dev1 用户可以删除 file 这个文件吗？\n\n#### 答：\n\n> 可以，文件的 rwx 控制文件本身的读写运行权限，文件的增删文件名的修改要看文件夹的权限。\n\n\n\n##Android 压力测试工具 Monkey&MonkeyRunner- 杨俊构\n###Monkey\n\n#### 一、Monkey 是什么？\n\n   - Monkey 就是SDK中附带的一个工具。\n\n#### 二、Monkey 测试的目的？\n\n  - 该工具用于进行压力测试。 然后开发人员结合monkey 打印的日志 和系统打印的日志，结局测试中出现的问题。\n\n#### 三、Monkey 测试的特点？\n\n  - Monkey 测试,所有的事件都是随机产生的，不带任何人的主观性。\n\n#### 四、Monkey 命令详解\n \n- 标准的monkey 命令: [adb shell] monkey [options] <eventcount> ,\n\n  >  例如：adb shell monkey -v 500 --------产生500次随机事件，\n\n\n- 四大类—— 常用选项 、 事件选项 、 约束选项 、 调试选项\n\n  > -v：指定打印信息的详细级别，一个 -v增加一个级别 ， 默认级别为 0 。\n  > \n  > -s：指定产生随机事件种子值，相同的种子值产生相同的事件序列。如： -s 200\n  >\n  > -p：指定有效的package（如不指定，则对系统中所有package有效），一个-p 对应一个有效package， 如：-p com.ckt -p com.ckt.asura；\n  > \n\n\n#### 五、一个简单的monkey命令：\n\n- adb shell monkey -p com.xy.android.junit -s 500 -v 10000\n\n- 但是，工作中为了保证测试数量的完整进行，我们一般不会在发生错误时立刻退出压力测试。\n\n- monkey 测试命令如下\n\n\n> adb shell monkey -p com.xy.android.junit -s 500 --ignore-crashes --ignore-timeouts --monitor-native-crashes -v -v 10000 > E:\\monkey_log\\java_monkey_log.txt\n\n###MonkeyRunner\n####一、什么是monkeyrunner\n\n- monkeyrunner工具提供了一个API，使用此API写出的程序可以在Android代码之外控制Android设备和模拟器。通过monkeyrunner，您可以写出一个Python程序去安装一个Android应用程序或测试包，运行它，向它发送模拟击键，截取它的用户界面图片。\n\n- monkeyrunner工具的主要设计目的是用于测试功能/框架水平上的应用程序和设备，或用于运行单元测试套件，但您当然也可以将其用于其它目的。\n\n#### 二、monkeyrunner工具同Monkey工具的差别\n- Monkey： Monkey工具直接运行在设备或模拟器的adb shell中，生成用户或系统的伪随机事件流，属于黑盒测试。\n\n- monkeyrunner：monkeyrunner工具则是类似于灰盒测试的样子，可以编写定制一些测试方法和用例针对具体情况测试。\n\n#### 三、实例 ：双11抽取优惠券不停点击一个按钮脚本\n\n``` python \n#coding=utf-8 \nfrom com.android.monkeyrunner import MonkeyRunner, MonkeyDevice, MonkeyImage\nfrom com.android.monkeyrunner import MonkeyRunner as mr\nfrom com.android.monkeyrunner import MonkeyDevice as md\nfrom com.android.monkeyrunner import MonkeyImage as mi\ndevice=mr.waitForConnection()\nfor i in range(1000): \n\tMonkeyRunner.sleep(1)\n\tprint i\n\tdevice.touch(500,950,'DOWN_AND_UP')\nprint \"end\"\n```\n\n##人脸识别技术简单介绍- 王进\n#### Android自带的API:FaceDetector\n  - Step 1: 读取bitmap图片（API 只接受Bitmap）\n  ```\n  Bitmap sampleBmp=BitmapFactory.decodeResource(getResources(), R.drawable.sample1);\n  ```\n  (拍照或者从相册中也可以)\n  - Step 2: 通过FaceDetector API进行人脸识别\n  ```\n  //FaceDetecor只能读取RGB 565格式的Bitmap\n  Bitmap tmpBmp = inputImage.copy(Bitmap.Config.RGB_565, true);\n  //新建FaceDetector 实例，\n  FaceDetector faceDet = new FaceDetector(tmpBmp.getWidth(), tmpBmp.getHeight(), MAX_FACES);//MAX_FACES 搜索人脸个数\n  // 调用findFaces方法，将数据储存在facelist中\n  FaceDetector.Face[] faceList = new FaceDetector.Face[MAX_FACES];\nfaceDet.findFaces(tmpBmp, faceList);\n  ```\n  > 找人脸的原理是：找眼睛。\n  它返回的人脸数据face中，\n  通过调用public float eyesDistance ()，得到眼距\n  public void getMidPoint (PointF point)，得到两眼中心点位置。\n  public float confidence () 可以返回该人脸数据的可信度(0~1)，这个值越大，该人脸数据的准确度也就越高\n  \n  - Step3:对原图进行缩放，并在图上显示人脸框\n \n -  吐槽：\n A，只能接受Bitmap 格式的数据；\n B，只能识别双眼距离大于20 像素的人脸像（当然，这个可在framework层中修改）；\n C，只能检测出人脸的位置（双眼的中心点及距离），不能对人脸进行匹配（查找指定的脸谱）。\n\n###第三方Face++\n   - 在线API：基础版API供免费调用测试和小规模使用（会尽力维护API服务稳定性，但不保证每次调用均会成功），企业版API相对基础版API在算法和稳定性方面会有更好的表现\n   - 离线SDK包括人脸关键点定位等功能。\n   - 网址：http://www.faceplusplus.com.cn/\n\n## Android启动模式之singelTask扫盲－ 李仙鹏\n","source":"_posts/装逼指南二期.md","raw":"title: 周精益分享 - 程序员装逼指南二期\ndate: 2015-11-04  10:30:00\ntags:\ncategories: 移动组周分享\n---\n\n\n## Android 单元测试  吴明\n- [Android单元测试支持](https://developer.android.com/intl/zh-cn/training/activity-testing/preparing-activity-testing.html)\n\t- Android studio 1.2 beta3版本，原生支持单元测试\n- 环境搭建 \n\t- 配置环境命令：./gradlew build connectedCheck  \n- 测试示例\t\n\t-  ![MacDown Screenshot](http://7xn0ue.com1.z0.glb.clouddn.com/420E036F-4D69-47F4-A639-5A5B294F7BDD.png)\n\t\n```\npublic class MyFirstTestActivityTest extends ActivityInstrumentationTestCase2<MyFirstTestActivity> {\n\n    private MyFirstTestActivity mFirstTestActivity;\n    private TextView mFirstTestText;\n\n    public MyFirstTestActivityTest() {\n        super(MyFirstTestActivity.class);\n    }\n\n    @Override\n    protected void setUp() throws Exception {\n        super.setUp();\n        mFirstTestActivity = getActivity();\n        mFirstTestText =\n                (TextView) mFirstTestActivity\n                .findViewById(R.id.my_first_test_text_view);\n    }\n}\n\n```\n- ps:由于配置环境一直报:\n\n```\nTest running failed: Instrumentation run failed due to 'java.lang.RuntimeException'\n\n```\n\n- [Automating UI Tests](https://developer.android.com/intl/zh-cn/training/testing/ui-testing/index.html)\n- [Building Effective Unit Tests](https://developer.android.com/intl/zh-cn/training/testing/unit-testing/index.html)\n- [Testing Display  Performance](https://developer.android.com/intl/zh-cn/training/testing/performance.html)\n- 问题：\n\t-  运行在模拟器上，通过对模拟器的操作或者mock，来触发函数调用，进而对其结果进行验证\n\t-  测试的编写和维护较为困难\n\n\n\n## Linux 文件权限入门 - 曾铭\n\n### 一个线上 bug\n图片上传 API 无法使用，定位到问题是 dev1 帐号移动的 tomcat 无法访问 /home/img_temp 目录，处理权限问题后搞定\n\n### 基本概念\nuser, group, others\n\n```\n[dev1@apps-51offer ~]$ ll\ntotal 16\n-rw-r--r-- 1 dev1 dev   742 Nov  5 11:22 ming.pub\ndrwxrwx--- 4 root root 4096 Nov  6 09:30 test1\ndrwxr-xr-- 2 dev1 dev  4096 Nov  6 10:44 test2\ndrwxr-xr-x 2 dev1 dev  4096 Nov  6 09:30 test3\n```\n\n- 文件 `-`\n- 文件夹 `d`\n- 链接 `l`\n\nrwx 读、写、执行权限 , 754 代表什么\n\n- 文件所有者变更：`chown ming:mobile file`\n- 文件权限变更： `chmod g+rx file`\n\n### 一个小坑\n\n#### 问：\n\n> `drwxr-xr-- 2 dev1 dev  4096 Nov  6 10:44 test2` 文件夹下有 `-rwxr-xr-- 2 root root  4096 Nov  6 10:44 file`\n> dev1 用户可以删除 file 这个文件吗？\n\n#### 答：\n\n> 可以，文件的 rwx 控制文件本身的读写运行权限，文件的增删文件名的修改要看文件夹的权限。\n\n\n\n##Android 压力测试工具 Monkey&MonkeyRunner- 杨俊构\n###Monkey\n\n#### 一、Monkey 是什么？\n\n   - Monkey 就是SDK中附带的一个工具。\n\n#### 二、Monkey 测试的目的？\n\n  - 该工具用于进行压力测试。 然后开发人员结合monkey 打印的日志 和系统打印的日志，结局测试中出现的问题。\n\n#### 三、Monkey 测试的特点？\n\n  - Monkey 测试,所有的事件都是随机产生的，不带任何人的主观性。\n\n#### 四、Monkey 命令详解\n \n- 标准的monkey 命令: [adb shell] monkey [options] <eventcount> ,\n\n  >  例如：adb shell monkey -v 500 --------产生500次随机事件，\n\n\n- 四大类—— 常用选项 、 事件选项 、 约束选项 、 调试选项\n\n  > -v：指定打印信息的详细级别，一个 -v增加一个级别 ， 默认级别为 0 。\n  > \n  > -s：指定产生随机事件种子值，相同的种子值产生相同的事件序列。如： -s 200\n  >\n  > -p：指定有效的package（如不指定，则对系统中所有package有效），一个-p 对应一个有效package， 如：-p com.ckt -p com.ckt.asura；\n  > \n\n\n#### 五、一个简单的monkey命令：\n\n- adb shell monkey -p com.xy.android.junit -s 500 -v 10000\n\n- 但是，工作中为了保证测试数量的完整进行，我们一般不会在发生错误时立刻退出压力测试。\n\n- monkey 测试命令如下\n\n\n> adb shell monkey -p com.xy.android.junit -s 500 --ignore-crashes --ignore-timeouts --monitor-native-crashes -v -v 10000 > E:\\monkey_log\\java_monkey_log.txt\n\n###MonkeyRunner\n####一、什么是monkeyrunner\n\n- monkeyrunner工具提供了一个API，使用此API写出的程序可以在Android代码之外控制Android设备和模拟器。通过monkeyrunner，您可以写出一个Python程序去安装一个Android应用程序或测试包，运行它，向它发送模拟击键，截取它的用户界面图片。\n\n- monkeyrunner工具的主要设计目的是用于测试功能/框架水平上的应用程序和设备，或用于运行单元测试套件，但您当然也可以将其用于其它目的。\n\n#### 二、monkeyrunner工具同Monkey工具的差别\n- Monkey： Monkey工具直接运行在设备或模拟器的adb shell中，生成用户或系统的伪随机事件流，属于黑盒测试。\n\n- monkeyrunner：monkeyrunner工具则是类似于灰盒测试的样子，可以编写定制一些测试方法和用例针对具体情况测试。\n\n#### 三、实例 ：双11抽取优惠券不停点击一个按钮脚本\n\n``` python \n#coding=utf-8 \nfrom com.android.monkeyrunner import MonkeyRunner, MonkeyDevice, MonkeyImage\nfrom com.android.monkeyrunner import MonkeyRunner as mr\nfrom com.android.monkeyrunner import MonkeyDevice as md\nfrom com.android.monkeyrunner import MonkeyImage as mi\ndevice=mr.waitForConnection()\nfor i in range(1000): \n\tMonkeyRunner.sleep(1)\n\tprint i\n\tdevice.touch(500,950,'DOWN_AND_UP')\nprint \"end\"\n```\n\n##人脸识别技术简单介绍- 王进\n#### Android自带的API:FaceDetector\n  - Step 1: 读取bitmap图片（API 只接受Bitmap）\n  ```\n  Bitmap sampleBmp=BitmapFactory.decodeResource(getResources(), R.drawable.sample1);\n  ```\n  (拍照或者从相册中也可以)\n  - Step 2: 通过FaceDetector API进行人脸识别\n  ```\n  //FaceDetecor只能读取RGB 565格式的Bitmap\n  Bitmap tmpBmp = inputImage.copy(Bitmap.Config.RGB_565, true);\n  //新建FaceDetector 实例，\n  FaceDetector faceDet = new FaceDetector(tmpBmp.getWidth(), tmpBmp.getHeight(), MAX_FACES);//MAX_FACES 搜索人脸个数\n  // 调用findFaces方法，将数据储存在facelist中\n  FaceDetector.Face[] faceList = new FaceDetector.Face[MAX_FACES];\nfaceDet.findFaces(tmpBmp, faceList);\n  ```\n  > 找人脸的原理是：找眼睛。\n  它返回的人脸数据face中，\n  通过调用public float eyesDistance ()，得到眼距\n  public void getMidPoint (PointF point)，得到两眼中心点位置。\n  public float confidence () 可以返回该人脸数据的可信度(0~1)，这个值越大，该人脸数据的准确度也就越高\n  \n  - Step3:对原图进行缩放，并在图上显示人脸框\n \n -  吐槽：\n A，只能接受Bitmap 格式的数据；\n B，只能识别双眼距离大于20 像素的人脸像（当然，这个可在framework层中修改）；\n C，只能检测出人脸的位置（双眼的中心点及距离），不能对人脸进行匹配（查找指定的脸谱）。\n\n###第三方Face++\n   - 在线API：基础版API供免费调用测试和小规模使用（会尽力维护API服务稳定性，但不保证每次调用均会成功），企业版API相对基础版API在算法和稳定性方面会有更好的表现\n   - 离线SDK包括人脸关键点定位等功能。\n   - 网址：http://www.faceplusplus.com.cn/\n\n## Android启动模式之singelTask扫盲－ 李仙鹏\n","slug":"装逼指南二期","published":1,"updated":"2021-09-10T07:04:21.950Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cktfeap4n0036c2xx9r533ish","content":"<h2 id=\"Android-单元测试-吴明\"><a href=\"#Android-单元测试-吴明\" class=\"headerlink\" title=\"Android 单元测试  吴明\"></a>Android 单元测试  吴明</h2><ul>\n<li><a href=\"https://developer.android.com/intl/zh-cn/training/activity-testing/preparing-activity-testing.html\" target=\"_blank\" rel=\"noopener\">Android单元测试支持</a><ul>\n<li>Android studio 1.2 beta3版本，原生支持单元测试</li>\n</ul>\n</li>\n<li>环境搭建 <ul>\n<li>配置环境命令：./gradlew build connectedCheck  </li>\n</ul>\n</li>\n<li>测试示例    <ul>\n<li><img src=\"http://7xn0ue.com1.z0.glb.clouddn.com/420E036F-4D69-47F4-A639-5A5B294F7BDD.png\" alt=\"MacDown Screenshot\"></li>\n</ul>\n</li>\n</ul>\n<pre><code>public class MyFirstTestActivityTest extends ActivityInstrumentationTestCase2&lt;MyFirstTestActivity&gt; {\n\n    private MyFirstTestActivity mFirstTestActivity;\n    private TextView mFirstTestText;\n\n    public MyFirstTestActivityTest() {\n        super(MyFirstTestActivity.class);\n    }\n\n    @Override\n    protected void setUp() throws Exception {\n        super.setUp();\n        mFirstTestActivity = getActivity();\n        mFirstTestText =\n                (TextView) mFirstTestActivity\n                .findViewById(R.id.my_first_test_text_view);\n    }\n}\n</code></pre><ul>\n<li>ps:由于配置环境一直报:</li>\n</ul>\n<pre><code>Test running failed: Instrumentation run failed due to &#39;java.lang.RuntimeException&#39;\n</code></pre><ul>\n<li><a href=\"https://developer.android.com/intl/zh-cn/training/testing/ui-testing/index.html\" target=\"_blank\" rel=\"noopener\">Automating UI Tests</a></li>\n<li><a href=\"https://developer.android.com/intl/zh-cn/training/testing/unit-testing/index.html\" target=\"_blank\" rel=\"noopener\">Building Effective Unit Tests</a></li>\n<li><a href=\"https://developer.android.com/intl/zh-cn/training/testing/performance.html\" target=\"_blank\" rel=\"noopener\">Testing Display  Performance</a></li>\n<li>问题：<ul>\n<li>运行在模拟器上，通过对模拟器的操作或者mock，来触发函数调用，进而对其结果进行验证</li>\n<li>测试的编写和维护较为困难</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Linux-文件权限入门-曾铭\"><a href=\"#Linux-文件权限入门-曾铭\" class=\"headerlink\" title=\"Linux 文件权限入门 - 曾铭\"></a>Linux 文件权限入门 - 曾铭</h2><h3 id=\"一个线上-bug\"><a href=\"#一个线上-bug\" class=\"headerlink\" title=\"一个线上 bug\"></a>一个线上 bug</h3><p>图片上传 API 无法使用，定位到问题是 dev1 帐号移动的 tomcat 无法访问 /home/img_temp 目录，处理权限问题后搞定</p>\n<h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><p>user, group, others</p>\n<pre><code>[dev1@apps-51offer ~]$ ll\ntotal 16\n-rw-r--r-- 1 dev1 dev   742 Nov  5 11:22 ming.pub\ndrwxrwx--- 4 root root 4096 Nov  6 09:30 test1\ndrwxr-xr-- 2 dev1 dev  4096 Nov  6 10:44 test2\ndrwxr-xr-x 2 dev1 dev  4096 Nov  6 09:30 test3\n</code></pre><ul>\n<li>文件 <code>-</code></li>\n<li>文件夹 <code>d</code></li>\n<li>链接 <code>l</code></li>\n</ul>\n<p>rwx 读、写、执行权限 , 754 代表什么</p>\n<ul>\n<li>文件所有者变更：<code>chown ming:mobile file</code></li>\n<li>文件权限变更： <code>chmod g+rx file</code></li>\n</ul>\n<h3 id=\"一个小坑\"><a href=\"#一个小坑\" class=\"headerlink\" title=\"一个小坑\"></a>一个小坑</h3><h4 id=\"问：\"><a href=\"#问：\" class=\"headerlink\" title=\"问：\"></a>问：</h4><blockquote>\n<p><code>drwxr-xr-- 2 dev1 dev  4096 Nov  6 10:44 test2</code> 文件夹下有 <code>-rwxr-xr-- 2 root root  4096 Nov  6 10:44 file</code><br>dev1 用户可以删除 file 这个文件吗？</p>\n</blockquote>\n<h4 id=\"答：\"><a href=\"#答：\" class=\"headerlink\" title=\"答：\"></a>答：</h4><blockquote>\n<p>可以，文件的 rwx 控制文件本身的读写运行权限，文件的增删文件名的修改要看文件夹的权限。</p>\n</blockquote>\n<p>##Android 压力测试工具 Monkey&amp;MonkeyRunner- 杨俊构</p>\n<p>###Monkey</p>\n<h4 id=\"一、Monkey-是什么？\"><a href=\"#一、Monkey-是什么？\" class=\"headerlink\" title=\"一、Monkey 是什么？\"></a>一、Monkey 是什么？</h4><ul>\n<li>Monkey 就是SDK中附带的一个工具。</li>\n</ul>\n<h4 id=\"二、Monkey-测试的目的？\"><a href=\"#二、Monkey-测试的目的？\" class=\"headerlink\" title=\"二、Monkey 测试的目的？\"></a>二、Monkey 测试的目的？</h4><ul>\n<li>该工具用于进行压力测试。 然后开发人员结合monkey 打印的日志 和系统打印的日志，结局测试中出现的问题。</li>\n</ul>\n<h4 id=\"三、Monkey-测试的特点？\"><a href=\"#三、Monkey-测试的特点？\" class=\"headerlink\" title=\"三、Monkey 测试的特点？\"></a>三、Monkey 测试的特点？</h4><ul>\n<li>Monkey 测试,所有的事件都是随机产生的，不带任何人的主观性。</li>\n</ul>\n<h4 id=\"四、Monkey-命令详解\"><a href=\"#四、Monkey-命令详解\" class=\"headerlink\" title=\"四、Monkey 命令详解\"></a>四、Monkey 命令详解</h4><ul>\n<li><p>标准的monkey 命令: [adb shell] monkey [options] <eventcount> ,</eventcount></p>\n<blockquote>\n<p> 例如：adb shell monkey -v 500 ——–产生500次随机事件，</p>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li><p>四大类—— 常用选项 、 事件选项 、 约束选项 、 调试选项</p>\n<blockquote>\n<p>-v：指定打印信息的详细级别，一个 -v增加一个级别 ， 默认级别为 0 。</p>\n<p>-s：指定产生随机事件种子值，相同的种子值产生相同的事件序列。如： -s 200</p>\n<p>-p：指定有效的package（如不指定，则对系统中所有package有效），一个-p 对应一个有效package， 如：-p com.ckt -p com.ckt.asura；</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"五、一个简单的monkey命令：\"><a href=\"#五、一个简单的monkey命令：\" class=\"headerlink\" title=\"五、一个简单的monkey命令：\"></a>五、一个简单的monkey命令：</h4><ul>\n<li><p>adb shell monkey -p com.xy.android.junit -s 500 -v 10000</p>\n</li>\n<li><p>但是，工作中为了保证测试数量的完整进行，我们一般不会在发生错误时立刻退出压力测试。</p>\n</li>\n<li><p>monkey 测试命令如下</p>\n</li>\n</ul>\n<blockquote>\n<p>adb shell monkey -p com.xy.android.junit -s 500 –ignore-crashes –ignore-timeouts –monitor-native-crashes -v -v 10000 &gt; E:\\monkey_log\\java_monkey_log.txt</p>\n</blockquote>\n<p>###MonkeyRunner</p>\n<p>####一、什么是monkeyrunner</p>\n<ul>\n<li><p>monkeyrunner工具提供了一个API，使用此API写出的程序可以在Android代码之外控制Android设备和模拟器。通过monkeyrunner，您可以写出一个Python程序去安装一个Android应用程序或测试包，运行它，向它发送模拟击键，截取它的用户界面图片。</p>\n</li>\n<li><p>monkeyrunner工具的主要设计目的是用于测试功能/框架水平上的应用程序和设备，或用于运行单元测试套件，但您当然也可以将其用于其它目的。</p>\n</li>\n</ul>\n<h4 id=\"二、monkeyrunner工具同Monkey工具的差别\"><a href=\"#二、monkeyrunner工具同Monkey工具的差别\" class=\"headerlink\" title=\"二、monkeyrunner工具同Monkey工具的差别\"></a>二、monkeyrunner工具同Monkey工具的差别</h4><ul>\n<li><p>Monkey： Monkey工具直接运行在设备或模拟器的adb shell中，生成用户或系统的伪随机事件流，属于黑盒测试。</p>\n</li>\n<li><p>monkeyrunner：monkeyrunner工具则是类似于灰盒测试的样子，可以编写定制一些测试方法和用例针对具体情况测试。</p>\n</li>\n</ul>\n<h4 id=\"三、实例-：双11抽取优惠券不停点击一个按钮脚本\"><a href=\"#三、实例-：双11抽取优惠券不停点击一个按钮脚本\" class=\"headerlink\" title=\"三、实例 ：双11抽取优惠券不停点击一个按钮脚本\"></a>三、实例 ：双11抽取优惠券不停点击一个按钮脚本</h4><pre><code class=\"python\">#coding=utf-8 \nfrom com.android.monkeyrunner import MonkeyRunner, MonkeyDevice, MonkeyImage\nfrom com.android.monkeyrunner import MonkeyRunner as mr\nfrom com.android.monkeyrunner import MonkeyDevice as md\nfrom com.android.monkeyrunner import MonkeyImage as mi\ndevice=mr.waitForConnection()\nfor i in range(1000): \n    MonkeyRunner.sleep(1)\n    print i\n    device.touch(500,950,&#39;DOWN_AND_UP&#39;)\nprint &quot;end&quot;\n</code></pre>\n<p>##人脸识别技术简单介绍- 王进</p>\n<h4 id=\"Android自带的API-FaceDetector\"><a href=\"#Android自带的API-FaceDetector\" class=\"headerlink\" title=\"Android自带的API:FaceDetector\"></a>Android自带的API:FaceDetector</h4><ul>\n<li>Step 1: 读取bitmap图片（API 只接受Bitmap）<pre><code>Bitmap sampleBmp=BitmapFactory.decodeResource(getResources(), R.drawable.sample1);\n</code></pre>(拍照或者从相册中也可以)</li>\n<li><p>Step 2: 通过FaceDetector API进行人脸识别</p>\n<pre><code>//FaceDetecor只能读取RGB 565格式的Bitmap\nBitmap tmpBmp = inputImage.copy(Bitmap.Config.RGB_565, true);\n//新建FaceDetector 实例，\nFaceDetector faceDet = new FaceDetector(tmpBmp.getWidth(), tmpBmp.getHeight(), MAX_FACES);//MAX_FACES 搜索人脸个数\n// 调用findFaces方法，将数据储存在facelist中\nFaceDetector.Face[] faceList = new FaceDetector.Face[MAX_FACES];\nfaceDet.findFaces(tmpBmp, faceList);\n</code></pre><blockquote>\n<p>找人脸的原理是：找眼睛。<br>它返回的人脸数据face中，<br>通过调用public float eyesDistance ()，得到眼距<br>public void getMidPoint (PointF point)，得到两眼中心点位置。<br>public float confidence () 可以返回该人脸数据的可信度(0~1)，这个值越大，该人脸数据的准确度也就越高</p>\n</blockquote>\n</li>\n<li><p>Step3:对原图进行缩放，并在图上显示人脸框</p>\n<ul>\n<li>吐槽：<br>A，只能接受Bitmap 格式的数据；<br>B，只能识别双眼距离大于20 像素的人脸像（当然，这个可在framework层中修改）；<br>C，只能检测出人脸的位置（双眼的中心点及距离），不能对人脸进行匹配（查找指定的脸谱）。</li>\n</ul>\n</li>\n</ul>\n<p>###第三方Face++</p>\n<ul>\n<li>在线API：基础版API供免费调用测试和小规模使用（会尽力维护API服务稳定性，但不保证每次调用均会成功），企业版API相对基础版API在算法和稳定性方面会有更好的表现</li>\n<li>离线SDK包括人脸关键点定位等功能。</li>\n<li>网址：<a href=\"http://www.faceplusplus.com.cn/\" target=\"_blank\" rel=\"noopener\">http://www.faceplusplus.com.cn/</a></li>\n</ul>\n<h2 id=\"Android启动模式之singelTask扫盲－-李仙鹏\"><a href=\"#Android启动模式之singelTask扫盲－-李仙鹏\" class=\"headerlink\" title=\"Android启动模式之singelTask扫盲－ 李仙鹏\"></a>Android启动模式之singelTask扫盲－ 李仙鹏</h2>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Android-单元测试-吴明\"><a href=\"#Android-单元测试-吴明\" class=\"headerlink\" title=\"Android 单元测试  吴明\"></a>Android 单元测试  吴明</h2><ul>\n<li><a href=\"https://developer.android.com/intl/zh-cn/training/activity-testing/preparing-activity-testing.html\" target=\"_blank\" rel=\"noopener\">Android单元测试支持</a><ul>\n<li>Android studio 1.2 beta3版本，原生支持单元测试</li>\n</ul>\n</li>\n<li>环境搭建 <ul>\n<li>配置环境命令：./gradlew build connectedCheck  </li>\n</ul>\n</li>\n<li>测试示例    <ul>\n<li><img src=\"http://7xn0ue.com1.z0.glb.clouddn.com/420E036F-4D69-47F4-A639-5A5B294F7BDD.png\" alt=\"MacDown Screenshot\"></li>\n</ul>\n</li>\n</ul>\n<pre><code>public class MyFirstTestActivityTest extends ActivityInstrumentationTestCase2&lt;MyFirstTestActivity&gt; {\n\n    private MyFirstTestActivity mFirstTestActivity;\n    private TextView mFirstTestText;\n\n    public MyFirstTestActivityTest() {\n        super(MyFirstTestActivity.class);\n    }\n\n    @Override\n    protected void setUp() throws Exception {\n        super.setUp();\n        mFirstTestActivity = getActivity();\n        mFirstTestText =\n                (TextView) mFirstTestActivity\n                .findViewById(R.id.my_first_test_text_view);\n    }\n}\n</code></pre><ul>\n<li>ps:由于配置环境一直报:</li>\n</ul>\n<pre><code>Test running failed: Instrumentation run failed due to &#39;java.lang.RuntimeException&#39;\n</code></pre><ul>\n<li><a href=\"https://developer.android.com/intl/zh-cn/training/testing/ui-testing/index.html\" target=\"_blank\" rel=\"noopener\">Automating UI Tests</a></li>\n<li><a href=\"https://developer.android.com/intl/zh-cn/training/testing/unit-testing/index.html\" target=\"_blank\" rel=\"noopener\">Building Effective Unit Tests</a></li>\n<li><a href=\"https://developer.android.com/intl/zh-cn/training/testing/performance.html\" target=\"_blank\" rel=\"noopener\">Testing Display  Performance</a></li>\n<li>问题：<ul>\n<li>运行在模拟器上，通过对模拟器的操作或者mock，来触发函数调用，进而对其结果进行验证</li>\n<li>测试的编写和维护较为困难</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Linux-文件权限入门-曾铭\"><a href=\"#Linux-文件权限入门-曾铭\" class=\"headerlink\" title=\"Linux 文件权限入门 - 曾铭\"></a>Linux 文件权限入门 - 曾铭</h2><h3 id=\"一个线上-bug\"><a href=\"#一个线上-bug\" class=\"headerlink\" title=\"一个线上 bug\"></a>一个线上 bug</h3><p>图片上传 API 无法使用，定位到问题是 dev1 帐号移动的 tomcat 无法访问 /home/img_temp 目录，处理权限问题后搞定</p>\n<h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><p>user, group, others</p>\n<pre><code>[dev1@apps-51offer ~]$ ll\ntotal 16\n-rw-r--r-- 1 dev1 dev   742 Nov  5 11:22 ming.pub\ndrwxrwx--- 4 root root 4096 Nov  6 09:30 test1\ndrwxr-xr-- 2 dev1 dev  4096 Nov  6 10:44 test2\ndrwxr-xr-x 2 dev1 dev  4096 Nov  6 09:30 test3\n</code></pre><ul>\n<li>文件 <code>-</code></li>\n<li>文件夹 <code>d</code></li>\n<li>链接 <code>l</code></li>\n</ul>\n<p>rwx 读、写、执行权限 , 754 代表什么</p>\n<ul>\n<li>文件所有者变更：<code>chown ming:mobile file</code></li>\n<li>文件权限变更： <code>chmod g+rx file</code></li>\n</ul>\n<h3 id=\"一个小坑\"><a href=\"#一个小坑\" class=\"headerlink\" title=\"一个小坑\"></a>一个小坑</h3><h4 id=\"问：\"><a href=\"#问：\" class=\"headerlink\" title=\"问：\"></a>问：</h4><blockquote>\n<p><code>drwxr-xr-- 2 dev1 dev  4096 Nov  6 10:44 test2</code> 文件夹下有 <code>-rwxr-xr-- 2 root root  4096 Nov  6 10:44 file</code><br>dev1 用户可以删除 file 这个文件吗？</p>\n</blockquote>\n<h4 id=\"答：\"><a href=\"#答：\" class=\"headerlink\" title=\"答：\"></a>答：</h4><blockquote>\n<p>可以，文件的 rwx 控制文件本身的读写运行权限，文件的增删文件名的修改要看文件夹的权限。</p>\n</blockquote>\n<p>##Android 压力测试工具 Monkey&amp;MonkeyRunner- 杨俊构</p>\n<p>###Monkey</p>\n<h4 id=\"一、Monkey-是什么？\"><a href=\"#一、Monkey-是什么？\" class=\"headerlink\" title=\"一、Monkey 是什么？\"></a>一、Monkey 是什么？</h4><ul>\n<li>Monkey 就是SDK中附带的一个工具。</li>\n</ul>\n<h4 id=\"二、Monkey-测试的目的？\"><a href=\"#二、Monkey-测试的目的？\" class=\"headerlink\" title=\"二、Monkey 测试的目的？\"></a>二、Monkey 测试的目的？</h4><ul>\n<li>该工具用于进行压力测试。 然后开发人员结合monkey 打印的日志 和系统打印的日志，结局测试中出现的问题。</li>\n</ul>\n<h4 id=\"三、Monkey-测试的特点？\"><a href=\"#三、Monkey-测试的特点？\" class=\"headerlink\" title=\"三、Monkey 测试的特点？\"></a>三、Monkey 测试的特点？</h4><ul>\n<li>Monkey 测试,所有的事件都是随机产生的，不带任何人的主观性。</li>\n</ul>\n<h4 id=\"四、Monkey-命令详解\"><a href=\"#四、Monkey-命令详解\" class=\"headerlink\" title=\"四、Monkey 命令详解\"></a>四、Monkey 命令详解</h4><ul>\n<li><p>标准的monkey 命令: [adb shell] monkey [options] <eventcount> ,</eventcount></p>\n<blockquote>\n<p> 例如：adb shell monkey -v 500 ——–产生500次随机事件，</p>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li><p>四大类—— 常用选项 、 事件选项 、 约束选项 、 调试选项</p>\n<blockquote>\n<p>-v：指定打印信息的详细级别，一个 -v增加一个级别 ， 默认级别为 0 。</p>\n<p>-s：指定产生随机事件种子值，相同的种子值产生相同的事件序列。如： -s 200</p>\n<p>-p：指定有效的package（如不指定，则对系统中所有package有效），一个-p 对应一个有效package， 如：-p com.ckt -p com.ckt.asura；</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"五、一个简单的monkey命令：\"><a href=\"#五、一个简单的monkey命令：\" class=\"headerlink\" title=\"五、一个简单的monkey命令：\"></a>五、一个简单的monkey命令：</h4><ul>\n<li><p>adb shell monkey -p com.xy.android.junit -s 500 -v 10000</p>\n</li>\n<li><p>但是，工作中为了保证测试数量的完整进行，我们一般不会在发生错误时立刻退出压力测试。</p>\n</li>\n<li><p>monkey 测试命令如下</p>\n</li>\n</ul>\n<blockquote>\n<p>adb shell monkey -p com.xy.android.junit -s 500 –ignore-crashes –ignore-timeouts –monitor-native-crashes -v -v 10000 &gt; E:\\monkey_log\\java_monkey_log.txt</p>\n</blockquote>\n<p>###MonkeyRunner</p>\n<p>####一、什么是monkeyrunner</p>\n<ul>\n<li><p>monkeyrunner工具提供了一个API，使用此API写出的程序可以在Android代码之外控制Android设备和模拟器。通过monkeyrunner，您可以写出一个Python程序去安装一个Android应用程序或测试包，运行它，向它发送模拟击键，截取它的用户界面图片。</p>\n</li>\n<li><p>monkeyrunner工具的主要设计目的是用于测试功能/框架水平上的应用程序和设备，或用于运行单元测试套件，但您当然也可以将其用于其它目的。</p>\n</li>\n</ul>\n<h4 id=\"二、monkeyrunner工具同Monkey工具的差别\"><a href=\"#二、monkeyrunner工具同Monkey工具的差别\" class=\"headerlink\" title=\"二、monkeyrunner工具同Monkey工具的差别\"></a>二、monkeyrunner工具同Monkey工具的差别</h4><ul>\n<li><p>Monkey： Monkey工具直接运行在设备或模拟器的adb shell中，生成用户或系统的伪随机事件流，属于黑盒测试。</p>\n</li>\n<li><p>monkeyrunner：monkeyrunner工具则是类似于灰盒测试的样子，可以编写定制一些测试方法和用例针对具体情况测试。</p>\n</li>\n</ul>\n<h4 id=\"三、实例-：双11抽取优惠券不停点击一个按钮脚本\"><a href=\"#三、实例-：双11抽取优惠券不停点击一个按钮脚本\" class=\"headerlink\" title=\"三、实例 ：双11抽取优惠券不停点击一个按钮脚本\"></a>三、实例 ：双11抽取优惠券不停点击一个按钮脚本</h4><pre><code class=\"python\">#coding=utf-8 \nfrom com.android.monkeyrunner import MonkeyRunner, MonkeyDevice, MonkeyImage\nfrom com.android.monkeyrunner import MonkeyRunner as mr\nfrom com.android.monkeyrunner import MonkeyDevice as md\nfrom com.android.monkeyrunner import MonkeyImage as mi\ndevice=mr.waitForConnection()\nfor i in range(1000): \n    MonkeyRunner.sleep(1)\n    print i\n    device.touch(500,950,&#39;DOWN_AND_UP&#39;)\nprint &quot;end&quot;\n</code></pre>\n<p>##人脸识别技术简单介绍- 王进</p>\n<h4 id=\"Android自带的API-FaceDetector\"><a href=\"#Android自带的API-FaceDetector\" class=\"headerlink\" title=\"Android自带的API:FaceDetector\"></a>Android自带的API:FaceDetector</h4><ul>\n<li>Step 1: 读取bitmap图片（API 只接受Bitmap）<pre><code>Bitmap sampleBmp=BitmapFactory.decodeResource(getResources(), R.drawable.sample1);\n</code></pre>(拍照或者从相册中也可以)</li>\n<li><p>Step 2: 通过FaceDetector API进行人脸识别</p>\n<pre><code>//FaceDetecor只能读取RGB 565格式的Bitmap\nBitmap tmpBmp = inputImage.copy(Bitmap.Config.RGB_565, true);\n//新建FaceDetector 实例，\nFaceDetector faceDet = new FaceDetector(tmpBmp.getWidth(), tmpBmp.getHeight(), MAX_FACES);//MAX_FACES 搜索人脸个数\n// 调用findFaces方法，将数据储存在facelist中\nFaceDetector.Face[] faceList = new FaceDetector.Face[MAX_FACES];\nfaceDet.findFaces(tmpBmp, faceList);\n</code></pre><blockquote>\n<p>找人脸的原理是：找眼睛。<br>它返回的人脸数据face中，<br>通过调用public float eyesDistance ()，得到眼距<br>public void getMidPoint (PointF point)，得到两眼中心点位置。<br>public float confidence () 可以返回该人脸数据的可信度(0~1)，这个值越大，该人脸数据的准确度也就越高</p>\n</blockquote>\n</li>\n<li><p>Step3:对原图进行缩放，并在图上显示人脸框</p>\n<ul>\n<li>吐槽：<br>A，只能接受Bitmap 格式的数据；<br>B，只能识别双眼距离大于20 像素的人脸像（当然，这个可在framework层中修改）；<br>C，只能检测出人脸的位置（双眼的中心点及距离），不能对人脸进行匹配（查找指定的脸谱）。</li>\n</ul>\n</li>\n</ul>\n<p>###第三方Face++</p>\n<ul>\n<li>在线API：基础版API供免费调用测试和小规模使用（会尽力维护API服务稳定性，但不保证每次调用均会成功），企业版API相对基础版API在算法和稳定性方面会有更好的表现</li>\n<li>离线SDK包括人脸关键点定位等功能。</li>\n<li>网址：<a href=\"http://www.faceplusplus.com.cn/\" target=\"_blank\" rel=\"noopener\">http://www.faceplusplus.com.cn/</a></li>\n</ul>\n<h2 id=\"Android启动模式之singelTask扫盲－-李仙鹏\"><a href=\"#Android启动模式之singelTask扫盲－-李仙鹏\" class=\"headerlink\" title=\"Android启动模式之singelTask扫盲－ 李仙鹏\"></a>Android启动模式之singelTask扫盲－ 李仙鹏</h2>"},{"title":"那些年我们用过的第三方库","date":"2015-08-21T12:00:00.000Z","_content":"\n## SnapKit（Masonry） 的使用 - 杨志平\n\n> 这两个库的用法都是差不多的，只是由两个不同的人来主导开源  <br>\n> **[SnapKit](https://github.com/SnapKit/SnapKit)**是Swift版 <br>\n> **[Masonry](https://github.com/SnapKit/Masonry)**是OC版    \n> \n> 自动布局及交互式编程是iOS开发的趋势，同时Swift也会在不久将来替换OC语言。所以现在的iOS开发者可以开始学习Swift2.0 以及应用 Autolayout 来编程\n\n### 代码对比（概况了解）\n\n##### 开始前OC原生布局代码\n\n```\n\n\tUIView *superview = self;\n\t\n\tUIView *view1 = [[UIView alloc] init];\n\tview1.translatesAutoresizingMaskIntoConstraints = NO;\n\tview1.backgroundColor = [UIColor greenColor];\n\t[superview addSubview:view1];\n\n\tUIEdgeInsets padding = UIEdgeInsetsMake(10, 10, 10, 10);\n\n\t[superview addConstraints:@[\n\n    //view1 constraints\n    [NSLayoutConstraint constraintWithItem:view1\n                                 attribute:NSLayoutAttributeTop\n                                 relatedBy:NSLayoutRelationEqual\n                                    toItem:superview\n                                 attribute:NSLayoutAttributeTop\n                                multiplier:1.0\n                                  constant:padding.top],\n\n    [NSLayoutConstraint constraintWithItem:view1\n                                 attribute:NSLayoutAttributeLeft\n                                 relatedBy:NSLayoutRelationEqual\n                                    toItem:superview\n                                 attribute:NSLayoutAttributeLeft\n                                multiplier:1.0\n                                  constant:padding.left],\n\n    [NSLayoutConstraint constraintWithItem:view1\n                                 attribute:NSLayoutAttributeBottom\n                                 relatedBy:NSLayoutRelationEqual\n                                    toItem:superview\n                                 attribute:NSLayoutAttributeBottom\n                                multiplier:1.0\n                                  constant:-padding.bottom],\n\n    [NSLayoutConstraint constraintWithItem:view1\n                                 attribute:NSLayoutAttributeRight\n                                 relatedBy:NSLayoutRelationEqual\n                                    toItem:superview\n                                 attribute:NSLayoutAttributeRight\n                                multiplier:1\n                                  constant:-padding.right],\n \t]];\n \n```\n\n##### 使用Masonry\n\n精简\n\n```\n\n\tUIEdgeInsets padding = UIEdgeInsetsMake(10, 10, 10, 10);\n\n\t[view1 mas_makeConstraints:^(MASConstraintMaker *make) {\n    make.top.equalTo(superview.mas_top).with.offset(padding.top); //with \tis an optional semantic filler\n\t\tmake.left.equalTo(superview.mas_left).with.offset(padding.left);\n\t\tmake.bottom.equalTo(superview.mas_bottom).with.offset(-\tpadding.bottom);\n\t\tmake.right.equalTo(superview.mas_right).with.offset(-padding.right);\n\t}];\n\n```\n\n更加精简\n\n```\n\t[view1 mas_makeConstraints:^(MASConstraintMaker *make) {\n  \t \t make.edges.equalTo(superview).with.insets(padding);\n\t}];\n```\n\n##### 同理使用SnapKit\n\n精简\n\n```\n\n\tlet box = UIView()\n\tsuperview.addSubview(box)\n\n\tbox.snp_makeConstraints { (make) -> Void in\n\t\tmake.top.equalTo(superview).offset(20)\n\t\tmake.left.equalTo(superview).offset(20)\n\t\tmake.bottom.equalTo(superview).offset(-20)\n    \tmake.right.equalTo(superview).offset(-20)\n\t}\n\n```\n\n更加精简\n\n```\n\tbox.snp_makeConstraints { (make) -> Void in\n    \tmake.edges.equalTo(superview).inset(UIEdgeInsetsMake(20, 20, 20, 20))\n\t}\n```\n### 如何使用 && 原理\n\n#### 常见的约束类型对比\n\nViewAttribute \t\t| NSLayoutAttribute\n------------- \t\t| -------------------\nview.snp_left\t\t| NSLayoutAttribute.Left\nview.snp_right\t\t| NSLayoutAttribute.Right\nview.snp_top \t\t| NSLayoutAttribute.Top\nview.snp_bottom \t| NSLayoutAttribute.Bottom\nview.snp_leading\t| NSLayoutAttribute.Leading\nview.snp_trailing | NSLayoutAttribute.Trailing\nview.snp_width \t| NSLayoutAttribute.Width\nview.snp_height \t| NSLayoutAttribute.Height\nview.snp_centerX\t| NSLayoutAttribute.CenterX\nview.snp_centerY\t| NSLayoutAttribute.CenterY\nview.snp_baseline\t| NSLayoutAttribute.Baseline\n \n \n#### 常见的用法\n\n```\nmake.top.equalTo(42)\nmake.lessThanOrEqualTo.equalTo(SuperView)\nmake.top.equalTo(SuperView)\nmake.size.equalTo(CGSizeMake(50, 100))\nmake.edges.equalTo(UIEdgeInsetsMake(10, 0, 10, 0))\nmake.left.equalTo(view).offset(UIEdgeInsetsMake(10, 0, 10, 0))\n\nmake.height.equalTo(OtherView).offset(10)\nmake.trailing.equalTo(OtherView.snp_trailing).offset(10)\nmake.bottom.equalTo(-20).priority(250)\n\n\n```\n#### 对比交互式编程的约束布局\n\n![image](https://cloud.githubusercontent.com/assets/9360037/9401926/1e572316-4809-11e5-9a96-430e688cda85.png)\n\n----\n\n## JSONModel for swift 的探索 - 曾铭\n\n\n```\n// 可在 Playground 中尝试\nimport Foundation\nimport UIKit\n\n\n// 基本的类型转换\nlet a:String = \"\"\nlet b = \"\"\nvar c:String? = nil\nc = \"test\"\n\nlet d:String = c as String!\nvar e = Int(c!)\ne = Int(\"123\")\n\nvar f = Int(\"123\")!\n\nprint(\"a type:\\(a.dynamicType)\")\nprint(\"b type:\\(b.dynamicType)\")\nprint(\"c type:\\(c.dynamicType)\")\nprint(\"d type:\\(d.dynamicType)\")\nprint(\"e type:\\(e.dynamicType)\")\nprint(\"f type:\\(f.dynamicType)\\n\")\n\n\n// KVC for NSObject\n\nclass FooKVC : NSObject {\n    var p1 : String = \"s\"\n}\n\nlet fk1 = FooKVC()\n\nfk1.p1\n\nfk1.setValue(\"y\", forKey: \"p1\")\n\nfk1.p1\n\n// reflect for swift2.0\n\nclass A\n{\n    var name = \"namevalue\"\n    var age = 123\n    var some:(String, Int) = (\"ming\", 2)\n}\n\nlet a1 = A()\n\na1.age = 456\n\na1.age\n\n\nlet r = Mirror(reflecting: a1)\nfor c in r.children {\n    print(c.label.dynamicType)\n    print(c.label)\n    print(c.value.dynamicType)\n    print(c.value)\n    print(\"===\")\n}\n\n```\n\n\n- KVO for NSObject 略, 注意监听者与被监听者都要是 NSObject 子类\n\n\n### JSONModel for swift?\n\n>\nNB: Swift works in a different way under the hood than Objective-C. Therefore I can't find a way to re-create JSONModel in Swift. JSONModel in Objective-C works in Swift apps through CocoaPods or as an imported Objective-C library.\n\n### JSONModel 做的事情\n- String(NSData) -> Dictionary(Array)\n- Dictionary(Array) -> Model-Object\n\n### 对应实现\n- 容易:\n    - swift 容器取值的坑 https://github.com/SwiftyJSON/SwiftyJSON\n- swift 反射不支持赋值，没办法\n    - 通过 NSObject KVC 解决 https://github.com/PonyCui/PPJSONSerialization\n    - 临时方案？\n\n### 参考链接\n\n- [Swift-KVC (just `valueForKey:`)](https://github.com/leemorgan/Swift-KVC/blob/master/KVC%20Playground.playground/Contents.swift)\n- [Swift: KVO 注意事项和属性观察器](http://www.jianshu.com/p/e036e53d240e)\n- [List of class's properties in swift](http://stackoverflow.com/questions/24844681/list-of-classs-properties-in-swift)\n\n----\n\n## RATreeView的简单使用 - 张超耀\n### RATreeView:实现树形结构的TableView；点击每个cell，都可以展开出现新的cell；可以自定义树的层数\n![](https://camo.githubusercontent.com/87d3db881cf57dba674a89a6e1460c00277245b3/68747470733a2f2f7261772e6769746875622e636f6d2f417567757374796e69616b2f524154726565566965772f6d61737465722f53637265656e732f616e696d6174696f6e2e676966)\n\n### 主要方法介绍\n- cell的高度 \n`-(CGFloat)treeView:(RATreeView *)treeView heightForRowForItem:(id)item treeNodeInfo:(RATreeNodeInfo *)treeNodeInfo`\n- 这个函数决定是否可以展开，通过设定我们可以设置哪些单元格可以展开到下一层，哪些不可以展开  \n`- (BOOL)treeView:(RATreeView *)treeView shouldExpandItem:(id)item treeNodeInfo:(RATreeNodeInfo *)treeNodeInfo  \n` \n- 这个看字面意识就理解了，在单元格显示之前（或者说将要显示时）我们可以做些设置，这里是设置相应深度的颜色背景  \n`- (void)treeView:(RATreeView *)treeView willDisplayCell:(UITableViewCell *)cell forItem:(id)item treeNodeInfo:(RATreeNodeInfo *)treeNodeInfo `\n\n- 这里就是我们最熟悉的点击cell处理函数，看代码慢慢体会treeNodeInfo的使用，不想多说了  \n`-(void)treeView:(RATreeView *)treeView didSelectRowForItem:(id)item treeNodeInfo:(RATreeNodeInfo *)treeNodeInfo  \n`\n- 数据源处理，相当于UITableViewCell处理，关键还是理解treeNodeInfo概念  \n`- (UITableViewCell *)treeView:(RATreeView *)treeView cellForItem:(id)item treeNodeInfo:(RATreeNodeInfo *)treeNodeInfo  \n`\n- 返回每一层包含成员的个数，来制表  \n`- (NSInteger)treeView:(RATreeView *)treeView numberOfChildrenOfItem:(id)item  \n`\n- 返回cell对象  \n`- (id)treeView:(RATreeView *)treeView child:(NSInteger)index ofItem:(id)item  \n`\n### [RATreeView - github](https://github.com/Augustyniak/RATreeView)\n\n----\n\n## Facebook 开源的图片加载库Fresco - 王胜\n\n### Fresco诞生背景\n\n为提高Android中图片的加载速度，一般的图片库都采用了三级缓存：Memory Cache、Disk Cache和Network。但是，Android的系统层是将物理内存平均分配给每一个App。这样每个App所分配的空间都是有限的，早起的android设备，每个App只被分配16MB空间，这样，如果App中使用大量的图片，那么很容易因OOM而Crashes掉。Facebook App正是大量使用图片的App，面临这个问题刻不容缓，所以他们历尽艰难，开发了Fresco图片加载库。 \n  \n### Fresco诞生过程\n\n#### 内存区域分析：\n\n* Java heap\n\n  每个厂商会为App分配一个固定尺寸的运行空间。所有的申请通过Java的new操作申请，操作相对安全，通过GC内存自动回收保证内存不被泄露。但不幸的时，GC不够精确化，回收得不够及时。因此还是会存在OOM。\n  \n* Native heap\n\n  通过C或者C++可绕过Java虚拟机直接操作物理内存，但Java程序员习惯了GC的自动回收，很难操作C++的手动操作内存。\n  \n* Ashmen\n\n  Android还有一块内存区域，叫Ashmen。这里的操作很像Nativew heap，但是这里是系统调用的。Java 应用程序是不能直接访问Ashmen的，但是一些例外的情况可以操作，图片就是一种例外。\n\n  ```Java\n  BitmapFactory.Options = new BitmapFactory.Options();\n  options.inPurgeable = true;\n  Bitmap bitmap = BitmapFactory.decodeByteArray(jpeg, 0, jpeg.length, options);\n  ```\n\n#### 难点突破：\n\n尽管发现了Purgeable bitmaps，但是这个解码的过程是在UI线程操作的，因此他们又采用了异步实现，并保证了UI线程不引用时，unpin的区域不会被释放。\n\n#### 上层构建\n\n提供给上层调用时，采用了MVC的架构：\n\n* Model：DraweeHierarchy\n* Control：DraweeControllers\n* View：DraweeViews\n\n### 使用示例\n\n1. gradle配置中添加库引用\n\n   ```\n  compile 'com.facebook.fresco:fresco:0.6.1+'\n  ```\n2. xml中添加组件\n\n   ```XML\n  <com.facebook.drawee.view.SimpleDraweeView\n        android:id=\"@+id/sdv\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        fresco:roundAsCircle=\"true\"\n        fresco:roundingBorderWidth=\"1dp\"\n        fresco:roundingBorderColor=\"#00ff00\"\n  ```\n3. 代码中指定图片地址\n\n   ```Java\n   SimpleDraweeView sdv = (SimpleDraweeView) findViewById(R.id.sdv);\n   sdv.setImageURI(Uri.parse(\"http://g.hiphotos.baidu.com/image/pic/item/2e2eb9389b504fc2b351980be7dde71190ef6db5.jpg\"));\n  ```\n\n### 参考资料：\n- [Fresco的由来](https://code.facebook.com/posts/366199913563917/introducing-fresco-a-new-image-library-for-android/)\n- [Fresco的源码托管](http://github.com/facebook/fresco)\n- [中文使用手册](http://fresco-cn.org/docs/index.html)\n\n----\n\n#SIAlertView 阅读 - 潘君\n\n- 创建自定义alert view的流程\n\n自定义window->添加自定义view controller->定制view->view引用window\n\n- @class\n```\n@class SIAlertView;\n```\n能不使用import的就不使用 \n用@class代替\n\n- 通知 和 Block\n\n- 层级\n```\nconst UIWindowLevel UIWindowLevelSIAlert = 1996.0;  // don't overlap system's alert\nconst UIWindowLevel UIWindowLevelSIAlertBackground = 1985.0; // below the alert window\n```\n\n- UIViewTintAdjustmentMode\n通过获取keyWindow的`UIViewTintAdjustmentMode`来设置alertWindow的\n该属性能够设置tint的调整模式\n```\ntypedef enum {\n     // 和父视图的一样\n     UIViewTintAdjustmentModeAutomatic,              \n     // 不对tintColor做任何修改\n     UIViewTintAdjustmentModeNormal,\n     // 在原有tintColor基础上变暗\n     UIViewTintAdjustmentModeDimmed,}UIViewTintAdjustmentMode;\n```\n\n\n-  iOS特有版本代码\n```\n#ifdef __IPHONE_7_0\n//some code \n#endif\n此处填写iOS7才能运行的代码\n```\n\n- initialize\n```\n+ (void)initialize\n{\n    if (self != [SIAlertView class])\n        return;\n   \n    // 默认值赋值\n}\n\n一些值放在+(void)initialize；中赋值为默认值，这样不管通过何种方式初始化\n```\n\n- UIAppearance\nSIAlertView *appearance = [self appearance];\nUIView符合UIAppearence协议，能够全局修改所有实例的UI\n\n- 调用Bundle中资源\n[UIImage imageNamed:@\"SIAlertView.bundle/button-default\"]\nbundle中资源的调用方法\n\n\n- _cmd\noc特有的方法，无法通过c语言获取\n\n-  [self invalidateLayout]\n\n- 合理利用循环引用\n\n```\n    if (!self.alertWindow) {\n        UIWindow *window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds];\n        window.autoresizingMask = UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleHeight;\n        window.opaque = NO;\n        window.windowLevel = UIWindowLevelSIAlert;\n        window.rootViewController = viewController;\n        self.alertWindow = window;\n    }\n```\n\n- oldKeyWindow\n通知alert后面的视图转变方向\n取用一些oldKeyWindow的值\n\n----\n\n## android饼图库 -吴明\n- 饼图选择\n\t- [AChartEngine](https://github.com/jondwillis/AChartEngine/tree/master/achartengine):(太丑了)\n\t- [xcl-charts](https://github.com/xcltapestry/XCL-Charts):(接口文档没有)\n\t- [HelloCharts](https://github.com/lecho/hellocharts-android):(接口文档没有)\n\t- [MPAndroidChart](https://github.com/PhilJay/MPAndroidChart):(接口文档多)\n- [MPAndroidChart](https://github.com/PhilJay/MPAndroidChart)\n\t- ![Alt Image Text](https://camo.githubusercontent.com/7e8a4a3c938c21d032d44d999edd781b6e146f2a/68747470733a2f2f7261772e6769746875622e636f6d2f5068696c4a61792f4d50416e64726f696443686172742f6d61737465722f73637265656e73686f74732f73696d706c6564657369676e5f7069656368617274312e706e67)\n\t- 饼图对象:PieChat\n\t- [详见接口文档](https://github.com/PhilJay/MPAndroidChart/wiki)\n\t\n\t\n---- \n\n## HeaderFooterRecyclerViewAdapter——李仙鹏\n[HeaderFooterRecyclerViewAdapter](https://gist.github.com/mheras/0908873267def75dc746)，用于RecyclerView。可方便的添加header或者footer。使用非常简单，只需要按照实际需求，在对应的header、content、footer相关方法进行重写即可。\n\n附上源码\n\n```\npublic abstract class HeaderFooterRecyclerViewAdapter extends RecyclerView.Adapter<RecyclerView.ViewHolder> {\n\n    private static final int VIEW_TYPE_MAX_COUNT = 1000;\n    private static final int HEADER_VIEW_TYPE_OFFSET = 0;\n    private static final int FOOTER_VIEW_TYPE_OFFSET = HEADER_VIEW_TYPE_OFFSET + VIEW_TYPE_MAX_COUNT;\n    private static final int CONTENT_VIEW_TYPE_OFFSET = FOOTER_VIEW_TYPE_OFFSET + VIEW_TYPE_MAX_COUNT;\n\n    private int headerItemCount;\n    private int contentItemCount;\n    private int footerItemCount;\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {\n\n        // Delegate to proper methods based on the viewType ranges.\n        if (viewType >= HEADER_VIEW_TYPE_OFFSET && viewType < HEADER_VIEW_TYPE_OFFSET + VIEW_TYPE_MAX_COUNT) {\n            return onCreateHeaderItemViewHolder(parent, viewType - HEADER_VIEW_TYPE_OFFSET);\n        } else if (viewType >= FOOTER_VIEW_TYPE_OFFSET && viewType < FOOTER_VIEW_TYPE_OFFSET + VIEW_TYPE_MAX_COUNT) {\n            return onCreateFooterItemViewHolder(parent, viewType - FOOTER_VIEW_TYPE_OFFSET);\n        } else if (viewType >= CONTENT_VIEW_TYPE_OFFSET && viewType < CONTENT_VIEW_TYPE_OFFSET + VIEW_TYPE_MAX_COUNT) {\n            return onCreateContentItemViewHolder(parent, viewType - CONTENT_VIEW_TYPE_OFFSET);\n        } else {\n            // This shouldn't happen as we check that the viewType provided by the client is valid.\n            throw new IllegalStateException();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final void onBindViewHolder(RecyclerView.ViewHolder viewHolder, int position) {\n        // Delegate to proper methods based on the viewType ranges.\n        if (headerItemCount > 0 && position < headerItemCount) {\n            onBindHeaderItemViewHolder(viewHolder, position);\n        } else if (contentItemCount > 0 && position - headerItemCount < contentItemCount) {\n            onBindContentItemViewHolder(viewHolder, position - headerItemCount);\n        } else {\n            onBindFooterItemViewHolder(viewHolder, position - headerItemCount - contentItemCount);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final int getItemCount() {\n        // Cache the counts and return the sum of them.\n        headerItemCount = getHeaderItemCount();\n        contentItemCount = getContentItemCount();\n        footerItemCount = getFooterItemCount();\n        return headerItemCount + contentItemCount + footerItemCount;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final int getItemViewType(int position) {\n        // Delegate to proper methods based on the position, but validate first.\n        if (headerItemCount > 0 && position < headerItemCount) {\n            return validateViewType(getHeaderItemViewType(position)) + HEADER_VIEW_TYPE_OFFSET;\n        } else if (contentItemCount > 0 && position - headerItemCount < contentItemCount) {\n            return validateViewType(getContentItemViewType(position - headerItemCount)) + CONTENT_VIEW_TYPE_OFFSET;\n        } else {\n            return validateViewType(getFooterItemViewType(position - headerItemCount - contentItemCount)) + FOOTER_VIEW_TYPE_OFFSET;\n        }\n    }\n\n    /**\n     * Validates that the view type is within the valid range.\n     *\n     * @param viewType the view type.\n     * @return the given view type.\n     */\n    private int validateViewType(int viewType) {\n        if (viewType < 0 || viewType >= VIEW_TYPE_MAX_COUNT) {\n            throw new IllegalStateException(\"viewType must be between 0 and \" + VIEW_TYPE_MAX_COUNT);\n        }\n        return viewType;\n    }\n\n    /**\n     * Notifies that a header item is inserted.\n     *\n     * @param position the position of the header item.\n     */\n    public final void notifyHeaderItemInserted(int position) {\n        int newHeaderItemCount = getHeaderItemCount();\n        if (position < 0 || position >= newHeaderItemCount) {\n            throw new IndexOutOfBoundsException(\"The given position \" + position + \" is not within the position bounds for header items [0 - \" + (newHeaderItemCount - 1) + \"].\");\n        }\n        notifyItemInserted(position);\n    }\n\n    /**\n     * Notifies that multiple header items are inserted.\n     *\n     * @param positionStart the position.\n     * @param itemCount     the item count.\n     */\n    public final void notifyHeaderItemRangeInserted(int positionStart, int itemCount) {\n        int newHeaderItemCount = getHeaderItemCount();\n        if (positionStart < 0 || itemCount < 0 || positionStart + itemCount > newHeaderItemCount) {\n            throw new IndexOutOfBoundsException(\"The given range [\" + positionStart + \" - \" + (positionStart + itemCount - 1) + \"] is not within the position bounds for header items [0 - \" + (newHeaderItemCount - 1) + \"].\");\n        }\n        notifyItemRangeInserted(positionStart, itemCount);\n    }\n\n    /**\n     * Notifies that a header item is changed.\n     *\n     * @param position the position.\n     */\n    public final void notifyHeaderItemChanged(int position) {\n        if (position < 0 || position >= headerItemCount) {\n            throw new IndexOutOfBoundsException(\"The given position \" + position + \" is not within the position bounds for header items [0 - \" + (headerItemCount - 1) + \"].\");\n        }\n        notifyItemChanged(position);\n    }\n\n    /**\n     * Notifies that multiple header items are changed.\n     *\n     * @param positionStart the position.\n     * @param itemCount     the item count.\n     */\n    public final void notifyHeaderItemRangeChanged(int positionStart, int itemCount) {\n        if (positionStart < 0 || itemCount < 0 || positionStart + itemCount >= headerItemCount) {\n            throw new IndexOutOfBoundsException(\"The given range [\" + positionStart + \" - \" + (positionStart + itemCount - 1) + \"] is not within the position bounds for header items [0 - \" + (headerItemCount - 1) + \"].\");\n        }\n        notifyItemRangeChanged(positionStart, itemCount);\n    }\n\n\n    /**\n     * Notifies that an existing header item is moved to another position.\n     *\n     * @param fromPosition the original position.\n     * @param toPosition   the new position.\n     */\n    public void notifyHeaderItemMoved(int fromPosition, int toPosition) {\n        if (fromPosition < 0 || toPosition < 0 || fromPosition >= headerItemCount || toPosition >= headerItemCount) {\n            throw new IndexOutOfBoundsException(\"The given fromPosition \" + fromPosition + \" or toPosition \" + toPosition + \" is not within the position bounds for header items [0 - \" + (headerItemCount - 1) + \"].\");\n        }\n        notifyItemMoved(fromPosition, toPosition);\n    }\n\n    /**\n     * Notifies that a header item is removed.\n     *\n     * @param position the position.\n     */\n    public void notifyHeaderItemRemoved(int position) {\n        if (position < 0 || position >= headerItemCount) {\n            throw new IndexOutOfBoundsException(\"The given position \" + position + \" is not within the position bounds for header items [0 - \" + (headerItemCount - 1) + \"].\");\n        }\n        notifyItemRemoved(position);\n    }\n\n    /**\n     * Notifies that multiple header items are removed.\n     *\n     * @param positionStart the position.\n     * @param itemCount     the item count.\n     */\n    public void notifyHeaderItemRangeRemoved(int positionStart, int itemCount) {\n        if (positionStart < 0 || itemCount < 0 || positionStart + itemCount > headerItemCount) {\n            throw new IndexOutOfBoundsException(\"The given range [\" + positionStart + \" - \" + (positionStart + itemCount - 1) + \"] is not within the position bounds for header items [0 - \" + (headerItemCount - 1) + \"].\");\n        }\n        notifyItemRangeRemoved(positionStart, itemCount);\n    }\n\n    /**\n     * Notifies that a content item is inserted.\n     *\n     * @param position the position of the content item.\n     */\n    public final void notifyContentItemInserted(int position) {\n        int newHeaderItemCount = getHeaderItemCount();\n        int newContentItemCount = getContentItemCount();\n        if (position < 0 || position >= newContentItemCount) {\n            throw new IndexOutOfBoundsException(\"The given position \" + position + \" is not within the position bounds for content items [0 - \" + (newContentItemCount - 1) + \"].\");\n        }\n        notifyItemInserted(position + newHeaderItemCount);\n    }\n\n    /**\n     * Notifies that multiple content items are inserted.\n     *\n     * @param positionStart the position.\n     * @param itemCount     the item count.\n     */\n    public final void notifyContentItemRangeInserted(int positionStart, int itemCount) {\n        int newHeaderItemCount = getHeaderItemCount();\n        int newContentItemCount = getContentItemCount();\n        if (positionStart < 0 || itemCount < 0 || positionStart + itemCount > newContentItemCount) {\n            throw new IndexOutOfBoundsException(\"The given range [\" + positionStart + \" - \" + (positionStart + itemCount - 1) + \"] is not within the position bounds for content items [0 - \" + (newContentItemCount - 1) + \"].\");\n        }\n        notifyItemRangeInserted(positionStart + newHeaderItemCount, itemCount);\n    }\n\n    /**\n     * Notifies that a content item is changed.\n     *\n     * @param position the position.\n     */\n    public final void notifyContentItemChanged(int position) {\n        if (position < 0 || position >= contentItemCount) {\n            throw new IndexOutOfBoundsException(\"The given position \" + position + \" is not within the position bounds for content items [0 - \" + (contentItemCount - 1) + \"].\");\n        }\n        notifyItemChanged(position + headerItemCount);\n    }\n\n    /**\n     * Notifies that multiple content items are changed.\n     *\n     * @param positionStart the position.\n     * @param itemCount     the item count.\n     */\n    public final void notifyContentItemRangeChanged(int positionStart, int itemCount) {\n        if (positionStart < 0 || itemCount < 0 || positionStart + itemCount > contentItemCount) {\n            throw new IndexOutOfBoundsException(\"The given range [\" + positionStart + \" - \" + (positionStart + itemCount - 1) + \"] is not within the position bounds for content items [0 - \" + (contentItemCount - 1) + \"].\");\n        }\n        notifyItemRangeChanged(positionStart + headerItemCount, itemCount);\n    }\n\n    /**\n     * Notifies that an existing content item is moved to another position.\n     *\n     * @param fromPosition the original position.\n     * @param toPosition   the new position.\n     */\n    public final void notifyContentItemMoved(int fromPosition, int toPosition) {\n        if (fromPosition < 0 || toPosition < 0 || fromPosition >= contentItemCount || toPosition >= contentItemCount) {\n            throw new IndexOutOfBoundsException(\"The given fromPosition \" + fromPosition + \" or toPosition \" + toPosition + \" is not within the position bounds for content items [0 - \" + (contentItemCount - 1) + \"].\");\n        }\n        notifyItemMoved(fromPosition + headerItemCount, toPosition + headerItemCount);\n    }\n\n    /**\n     * Notifies that a content item is removed.\n     *\n     * @param position the position.\n     */\n    public final void notifyContentItemRemoved(int position) {\n        if (position < 0 || position >= contentItemCount) {\n            throw new IndexOutOfBoundsException(\"The given position \" + position + \" is not within the position bounds for content items [0 - \" + (contentItemCount - 1) + \"].\");\n        }\n        notifyItemRemoved(position + headerItemCount);\n    }\n\n    /**\n     * Notifies that multiple content items are removed.\n     *\n     * @param positionStart the position.\n     * @param itemCount     the item count.\n     */\n    public final void notifyContentItemRangeRemoved(int positionStart, int itemCount) {\n        if (positionStart < 0 || itemCount < 0 || positionStart + itemCount > contentItemCount) {\n            throw new IndexOutOfBoundsException(\"The given range [\" + positionStart + \" - \" + (positionStart + itemCount - 1) + \"] is not within the position bounds for content items [0 - \" + (contentItemCount - 1) + \"].\");\n        }\n        notifyItemRangeRemoved(positionStart + headerItemCount, itemCount);\n    }\n\n    /**\n     * Notifies that a footer item is inserted.\n     *\n     * @param position the position of the content item.\n     */\n    public final void notifyFooterItemInserted(int position) {\n        int newHeaderItemCount = getHeaderItemCount();\n        int newContentItemCount = getContentItemCount();\n        int newFooterItemCount = getFooterItemCount();\n        if (position < 0 || position >= newFooterItemCount) {\n            throw new IndexOutOfBoundsException(\"The given position \" + position + \" is not within the position bounds for footer items [0 - \" + (newFooterItemCount - 1) + \"].\");\n        }\n        notifyItemInserted(position + newHeaderItemCount + newContentItemCount);\n    }\n\n    /**\n     * Notifies that multiple footer items are inserted.\n     *\n     * @param positionStart the position.\n     * @param itemCount     the item count.\n     */\n    public final void notifyFooterItemRangeInserted(int positionStart, int itemCount) {\n        int newHeaderItemCount = getHeaderItemCount();\n        int newContentItemCount = getContentItemCount();\n        int newFooterItemCount = getFooterItemCount();\n        if (positionStart < 0 || itemCount < 0 || positionStart + itemCount > newFooterItemCount) {\n            throw new IndexOutOfBoundsException(\"The given range [\" + positionStart + \" - \" + (positionStart + itemCount - 1) + \"] is not within the position bounds for footer items [0 - \" + (newFooterItemCount - 1) + \"].\");\n        }\n        notifyItemRangeInserted(positionStart + newHeaderItemCount + newContentItemCount, itemCount);\n    }\n\n    /**\n     * Notifies that a footer item is changed.\n     *\n     * @param position the position.\n     */\n    public final void notifyFooterItemChanged(int position) {\n        if (position < 0 || position >= footerItemCount) {\n            throw new IndexOutOfBoundsException(\"The given position \" + position + \" is not within the position bounds for footer items [0 - \" + (footerItemCount - 1) + \"].\");\n        }\n        notifyItemChanged(position + headerItemCount + contentItemCount);\n    }\n\n    /**\n     * Notifies that multiple footer items are changed.\n     *\n     * @param positionStart the position.\n     * @param itemCount     the item count.\n     */\n    public final void notifyFooterItemRangeChanged(int positionStart, int itemCount) {\n        if (positionStart < 0 || itemCount < 0 || positionStart + itemCount > footerItemCount) {\n            throw new IndexOutOfBoundsException(\"The given range [\" + positionStart + \" - \" + (positionStart + itemCount - 1) + \"] is not within the position bounds for footer items [0 - \" + (footerItemCount - 1) + \"].\");\n        }\n        notifyItemRangeChanged(positionStart + headerItemCount + contentItemCount, itemCount);\n    }\n\n    /**\n     * Notifies that an existing footer item is moved to another position.\n     *\n     * @param fromPosition the original position.\n     * @param toPosition   the new position.\n     */\n    public final void notifyFooterItemMoved(int fromPosition, int toPosition) {\n        if (fromPosition < 0 || toPosition < 0 || fromPosition >= footerItemCount || toPosition >= footerItemCount) {\n            throw new IndexOutOfBoundsException(\"The given fromPosition \" + fromPosition + \" or toPosition \" + toPosition + \" is not within the position bounds for footer items [0 - \" + (footerItemCount - 1) + \"].\");\n        }\n        notifyItemMoved(fromPosition + headerItemCount + contentItemCount, toPosition + headerItemCount + contentItemCount);\n    }\n\n    /**\n     * Notifies that a footer item is removed.\n     *\n     * @param position the position.\n     */\n    public final void notifyFooterItemRemoved(int position) {\n        if (position < 0 || position >= footerItemCount) {\n            throw new IndexOutOfBoundsException(\"The given position \" + position + \" is not within the position bounds for footer items [0 - \" + (footerItemCount - 1) + \"].\");\n        }\n        notifyItemRemoved(position + headerItemCount + contentItemCount);\n    }\n\n    /**\n     * Notifies that multiple footer items are removed.\n     *\n     * @param positionStart the position.\n     * @param itemCount     the item count.\n     */\n    public final void notifyFooterItemRangeRemoved(int positionStart, int itemCount) {\n        if (positionStart < 0 || itemCount < 0 || positionStart + itemCount > footerItemCount) {\n            throw new IndexOutOfBoundsException(\"The given range [\" + positionStart + \" - \" + (positionStart + itemCount - 1) + \"] is not within the position bounds for footer items [0 - \" + (footerItemCount - 1) + \"].\");\n        }\n        notifyItemRangeRemoved(positionStart + headerItemCount + contentItemCount, itemCount);\n    }\n\n    /**\n     * Gets the header item view type. By default, this method returns 0.\n     *\n     * @param position the position.\n     * @return the header item view type (within the range [0 - VIEW_TYPE_MAX_COUNT-1]).\n     */\n    protected int getHeaderItemViewType(int position) {\n        return 0;\n    }\n\n    /**\n     * Gets the footer item view type. By default, this method returns 0.\n     *\n     * @param position the position.\n     * @return the footer item view type (within the range [0 - VIEW_TYPE_MAX_COUNT-1]).\n     */\n    protected int getFooterItemViewType(int position) {\n        return 0;\n    }\n\n    /**\n     * Gets the content item view type. By default, this method returns 0.\n     *\n     * @param position the position.\n     * @return the content item view type (within the range [0 - VIEW_TYPE_MAX_COUNT-1]).\n     */\n    protected int getContentItemViewType(int position) {\n        return 0;\n    }\n\n    /**\n     * Gets the header item count. This method can be called several times, so it should not calculate the count every time.\n     *\n     * @return the header item count.\n     */\n    protected abstract int getHeaderItemCount();\n\n    /**\n     * Gets the footer item count. This method can be called several times, so it should not calculate the count every time.\n     *\n     * @return the footer item count.\n     */\n    protected abstract int getFooterItemCount();\n\n    /**\n     * Gets the content item count. This method can be called several times, so it should not calculate the count every time.\n     *\n     * @return the content item count.\n     */\n    protected abstract int getContentItemCount();\n\n    /**\n     * This method works exactly the same as {@link #onCreateViewHolder(android.view.ViewGroup, int)}, but for header items.\n     *\n     * @param parent         the parent view.\n     * @param headerViewType the view type for the header.\n     * @return the view holder.\n     */\n    protected abstract RecyclerView.ViewHolder onCreateHeaderItemViewHolder(ViewGroup parent, int headerViewType);\n\n    /**\n     * This method works exactly the same as {@link #onCreateViewHolder(android.view.ViewGroup, int)}, but for footer items.\n     *\n     * @param parent         the parent view.\n     * @param footerViewType the view type for the footer.\n     * @return the view holder.\n     */\n    protected abstract RecyclerView.ViewHolder onCreateFooterItemViewHolder(ViewGroup parent, int footerViewType);\n\n    /**\n     * This method works exactly the same as {@link #onCreateViewHolder(android.view.ViewGroup, int)}, but for content items.\n     *\n     * @param parent          the parent view.\n     * @param contentViewType the view type for the content.\n     * @return the view holder.\n     */\n    protected abstract RecyclerView.ViewHolder onCreateContentItemViewHolder(ViewGroup parent, int contentViewType);\n\n    /**\n     * This method works exactly the same as {@link #onBindViewHolder(android.support.v7.widget.RecyclerView.ViewHolder, int)}, but for header items.\n     *\n     * @param headerViewHolder the view holder for the header item.\n     * @param position         the position.\n     */\n    protected abstract void onBindHeaderItemViewHolder(RecyclerView.ViewHolder headerViewHolder, int position);\n\n    /**\n     * This method works exactly the same as {@link #onBindViewHolder(android.support.v7.widget.RecyclerView.ViewHolder, int)}, but for footer items.\n     *\n     * @param footerViewHolder the view holder for the footer item.\n     * @param position         the position.\n     */\n    protected abstract void onBindFooterItemViewHolder(RecyclerView.ViewHolder footerViewHolder, int position);\n\n    /**\n     * This method works exactly the same as {@link #onBindViewHolder(android.support.v7.widget.RecyclerView.ViewHolder, int)}, but for content items.\n     *\n     * @param contentViewHolder the view holder for the content item.\n     * @param position          the position.\n     */\n    protected abstract void onBindContentItemViewHolder(RecyclerView.ViewHolder contentViewHolder, int position);\n}\n```\n","source":"_posts/那些年我们用过的第三方库.md","raw":"title: 那些年我们用过的第三方库\ndate: 2015-08-21  12:00:00\ntags:\ncategories: 移动组周分享\n---\n\n## SnapKit（Masonry） 的使用 - 杨志平\n\n> 这两个库的用法都是差不多的，只是由两个不同的人来主导开源  <br>\n> **[SnapKit](https://github.com/SnapKit/SnapKit)**是Swift版 <br>\n> **[Masonry](https://github.com/SnapKit/Masonry)**是OC版    \n> \n> 自动布局及交互式编程是iOS开发的趋势，同时Swift也会在不久将来替换OC语言。所以现在的iOS开发者可以开始学习Swift2.0 以及应用 Autolayout 来编程\n\n### 代码对比（概况了解）\n\n##### 开始前OC原生布局代码\n\n```\n\n\tUIView *superview = self;\n\t\n\tUIView *view1 = [[UIView alloc] init];\n\tview1.translatesAutoresizingMaskIntoConstraints = NO;\n\tview1.backgroundColor = [UIColor greenColor];\n\t[superview addSubview:view1];\n\n\tUIEdgeInsets padding = UIEdgeInsetsMake(10, 10, 10, 10);\n\n\t[superview addConstraints:@[\n\n    //view1 constraints\n    [NSLayoutConstraint constraintWithItem:view1\n                                 attribute:NSLayoutAttributeTop\n                                 relatedBy:NSLayoutRelationEqual\n                                    toItem:superview\n                                 attribute:NSLayoutAttributeTop\n                                multiplier:1.0\n                                  constant:padding.top],\n\n    [NSLayoutConstraint constraintWithItem:view1\n                                 attribute:NSLayoutAttributeLeft\n                                 relatedBy:NSLayoutRelationEqual\n                                    toItem:superview\n                                 attribute:NSLayoutAttributeLeft\n                                multiplier:1.0\n                                  constant:padding.left],\n\n    [NSLayoutConstraint constraintWithItem:view1\n                                 attribute:NSLayoutAttributeBottom\n                                 relatedBy:NSLayoutRelationEqual\n                                    toItem:superview\n                                 attribute:NSLayoutAttributeBottom\n                                multiplier:1.0\n                                  constant:-padding.bottom],\n\n    [NSLayoutConstraint constraintWithItem:view1\n                                 attribute:NSLayoutAttributeRight\n                                 relatedBy:NSLayoutRelationEqual\n                                    toItem:superview\n                                 attribute:NSLayoutAttributeRight\n                                multiplier:1\n                                  constant:-padding.right],\n \t]];\n \n```\n\n##### 使用Masonry\n\n精简\n\n```\n\n\tUIEdgeInsets padding = UIEdgeInsetsMake(10, 10, 10, 10);\n\n\t[view1 mas_makeConstraints:^(MASConstraintMaker *make) {\n    make.top.equalTo(superview.mas_top).with.offset(padding.top); //with \tis an optional semantic filler\n\t\tmake.left.equalTo(superview.mas_left).with.offset(padding.left);\n\t\tmake.bottom.equalTo(superview.mas_bottom).with.offset(-\tpadding.bottom);\n\t\tmake.right.equalTo(superview.mas_right).with.offset(-padding.right);\n\t}];\n\n```\n\n更加精简\n\n```\n\t[view1 mas_makeConstraints:^(MASConstraintMaker *make) {\n  \t \t make.edges.equalTo(superview).with.insets(padding);\n\t}];\n```\n\n##### 同理使用SnapKit\n\n精简\n\n```\n\n\tlet box = UIView()\n\tsuperview.addSubview(box)\n\n\tbox.snp_makeConstraints { (make) -> Void in\n\t\tmake.top.equalTo(superview).offset(20)\n\t\tmake.left.equalTo(superview).offset(20)\n\t\tmake.bottom.equalTo(superview).offset(-20)\n    \tmake.right.equalTo(superview).offset(-20)\n\t}\n\n```\n\n更加精简\n\n```\n\tbox.snp_makeConstraints { (make) -> Void in\n    \tmake.edges.equalTo(superview).inset(UIEdgeInsetsMake(20, 20, 20, 20))\n\t}\n```\n### 如何使用 && 原理\n\n#### 常见的约束类型对比\n\nViewAttribute \t\t| NSLayoutAttribute\n------------- \t\t| -------------------\nview.snp_left\t\t| NSLayoutAttribute.Left\nview.snp_right\t\t| NSLayoutAttribute.Right\nview.snp_top \t\t| NSLayoutAttribute.Top\nview.snp_bottom \t| NSLayoutAttribute.Bottom\nview.snp_leading\t| NSLayoutAttribute.Leading\nview.snp_trailing | NSLayoutAttribute.Trailing\nview.snp_width \t| NSLayoutAttribute.Width\nview.snp_height \t| NSLayoutAttribute.Height\nview.snp_centerX\t| NSLayoutAttribute.CenterX\nview.snp_centerY\t| NSLayoutAttribute.CenterY\nview.snp_baseline\t| NSLayoutAttribute.Baseline\n \n \n#### 常见的用法\n\n```\nmake.top.equalTo(42)\nmake.lessThanOrEqualTo.equalTo(SuperView)\nmake.top.equalTo(SuperView)\nmake.size.equalTo(CGSizeMake(50, 100))\nmake.edges.equalTo(UIEdgeInsetsMake(10, 0, 10, 0))\nmake.left.equalTo(view).offset(UIEdgeInsetsMake(10, 0, 10, 0))\n\nmake.height.equalTo(OtherView).offset(10)\nmake.trailing.equalTo(OtherView.snp_trailing).offset(10)\nmake.bottom.equalTo(-20).priority(250)\n\n\n```\n#### 对比交互式编程的约束布局\n\n![image](https://cloud.githubusercontent.com/assets/9360037/9401926/1e572316-4809-11e5-9a96-430e688cda85.png)\n\n----\n\n## JSONModel for swift 的探索 - 曾铭\n\n\n```\n// 可在 Playground 中尝试\nimport Foundation\nimport UIKit\n\n\n// 基本的类型转换\nlet a:String = \"\"\nlet b = \"\"\nvar c:String? = nil\nc = \"test\"\n\nlet d:String = c as String!\nvar e = Int(c!)\ne = Int(\"123\")\n\nvar f = Int(\"123\")!\n\nprint(\"a type:\\(a.dynamicType)\")\nprint(\"b type:\\(b.dynamicType)\")\nprint(\"c type:\\(c.dynamicType)\")\nprint(\"d type:\\(d.dynamicType)\")\nprint(\"e type:\\(e.dynamicType)\")\nprint(\"f type:\\(f.dynamicType)\\n\")\n\n\n// KVC for NSObject\n\nclass FooKVC : NSObject {\n    var p1 : String = \"s\"\n}\n\nlet fk1 = FooKVC()\n\nfk1.p1\n\nfk1.setValue(\"y\", forKey: \"p1\")\n\nfk1.p1\n\n// reflect for swift2.0\n\nclass A\n{\n    var name = \"namevalue\"\n    var age = 123\n    var some:(String, Int) = (\"ming\", 2)\n}\n\nlet a1 = A()\n\na1.age = 456\n\na1.age\n\n\nlet r = Mirror(reflecting: a1)\nfor c in r.children {\n    print(c.label.dynamicType)\n    print(c.label)\n    print(c.value.dynamicType)\n    print(c.value)\n    print(\"===\")\n}\n\n```\n\n\n- KVO for NSObject 略, 注意监听者与被监听者都要是 NSObject 子类\n\n\n### JSONModel for swift?\n\n>\nNB: Swift works in a different way under the hood than Objective-C. Therefore I can't find a way to re-create JSONModel in Swift. JSONModel in Objective-C works in Swift apps through CocoaPods or as an imported Objective-C library.\n\n### JSONModel 做的事情\n- String(NSData) -> Dictionary(Array)\n- Dictionary(Array) -> Model-Object\n\n### 对应实现\n- 容易:\n    - swift 容器取值的坑 https://github.com/SwiftyJSON/SwiftyJSON\n- swift 反射不支持赋值，没办法\n    - 通过 NSObject KVC 解决 https://github.com/PonyCui/PPJSONSerialization\n    - 临时方案？\n\n### 参考链接\n\n- [Swift-KVC (just `valueForKey:`)](https://github.com/leemorgan/Swift-KVC/blob/master/KVC%20Playground.playground/Contents.swift)\n- [Swift: KVO 注意事项和属性观察器](http://www.jianshu.com/p/e036e53d240e)\n- [List of class's properties in swift](http://stackoverflow.com/questions/24844681/list-of-classs-properties-in-swift)\n\n----\n\n## RATreeView的简单使用 - 张超耀\n### RATreeView:实现树形结构的TableView；点击每个cell，都可以展开出现新的cell；可以自定义树的层数\n![](https://camo.githubusercontent.com/87d3db881cf57dba674a89a6e1460c00277245b3/68747470733a2f2f7261772e6769746875622e636f6d2f417567757374796e69616b2f524154726565566965772f6d61737465722f53637265656e732f616e696d6174696f6e2e676966)\n\n### 主要方法介绍\n- cell的高度 \n`-(CGFloat)treeView:(RATreeView *)treeView heightForRowForItem:(id)item treeNodeInfo:(RATreeNodeInfo *)treeNodeInfo`\n- 这个函数决定是否可以展开，通过设定我们可以设置哪些单元格可以展开到下一层，哪些不可以展开  \n`- (BOOL)treeView:(RATreeView *)treeView shouldExpandItem:(id)item treeNodeInfo:(RATreeNodeInfo *)treeNodeInfo  \n` \n- 这个看字面意识就理解了，在单元格显示之前（或者说将要显示时）我们可以做些设置，这里是设置相应深度的颜色背景  \n`- (void)treeView:(RATreeView *)treeView willDisplayCell:(UITableViewCell *)cell forItem:(id)item treeNodeInfo:(RATreeNodeInfo *)treeNodeInfo `\n\n- 这里就是我们最熟悉的点击cell处理函数，看代码慢慢体会treeNodeInfo的使用，不想多说了  \n`-(void)treeView:(RATreeView *)treeView didSelectRowForItem:(id)item treeNodeInfo:(RATreeNodeInfo *)treeNodeInfo  \n`\n- 数据源处理，相当于UITableViewCell处理，关键还是理解treeNodeInfo概念  \n`- (UITableViewCell *)treeView:(RATreeView *)treeView cellForItem:(id)item treeNodeInfo:(RATreeNodeInfo *)treeNodeInfo  \n`\n- 返回每一层包含成员的个数，来制表  \n`- (NSInteger)treeView:(RATreeView *)treeView numberOfChildrenOfItem:(id)item  \n`\n- 返回cell对象  \n`- (id)treeView:(RATreeView *)treeView child:(NSInteger)index ofItem:(id)item  \n`\n### [RATreeView - github](https://github.com/Augustyniak/RATreeView)\n\n----\n\n## Facebook 开源的图片加载库Fresco - 王胜\n\n### Fresco诞生背景\n\n为提高Android中图片的加载速度，一般的图片库都采用了三级缓存：Memory Cache、Disk Cache和Network。但是，Android的系统层是将物理内存平均分配给每一个App。这样每个App所分配的空间都是有限的，早起的android设备，每个App只被分配16MB空间，这样，如果App中使用大量的图片，那么很容易因OOM而Crashes掉。Facebook App正是大量使用图片的App，面临这个问题刻不容缓，所以他们历尽艰难，开发了Fresco图片加载库。 \n  \n### Fresco诞生过程\n\n#### 内存区域分析：\n\n* Java heap\n\n  每个厂商会为App分配一个固定尺寸的运行空间。所有的申请通过Java的new操作申请，操作相对安全，通过GC内存自动回收保证内存不被泄露。但不幸的时，GC不够精确化，回收得不够及时。因此还是会存在OOM。\n  \n* Native heap\n\n  通过C或者C++可绕过Java虚拟机直接操作物理内存，但Java程序员习惯了GC的自动回收，很难操作C++的手动操作内存。\n  \n* Ashmen\n\n  Android还有一块内存区域，叫Ashmen。这里的操作很像Nativew heap，但是这里是系统调用的。Java 应用程序是不能直接访问Ashmen的，但是一些例外的情况可以操作，图片就是一种例外。\n\n  ```Java\n  BitmapFactory.Options = new BitmapFactory.Options();\n  options.inPurgeable = true;\n  Bitmap bitmap = BitmapFactory.decodeByteArray(jpeg, 0, jpeg.length, options);\n  ```\n\n#### 难点突破：\n\n尽管发现了Purgeable bitmaps，但是这个解码的过程是在UI线程操作的，因此他们又采用了异步实现，并保证了UI线程不引用时，unpin的区域不会被释放。\n\n#### 上层构建\n\n提供给上层调用时，采用了MVC的架构：\n\n* Model：DraweeHierarchy\n* Control：DraweeControllers\n* View：DraweeViews\n\n### 使用示例\n\n1. gradle配置中添加库引用\n\n   ```\n  compile 'com.facebook.fresco:fresco:0.6.1+'\n  ```\n2. xml中添加组件\n\n   ```XML\n  <com.facebook.drawee.view.SimpleDraweeView\n        android:id=\"@+id/sdv\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        fresco:roundAsCircle=\"true\"\n        fresco:roundingBorderWidth=\"1dp\"\n        fresco:roundingBorderColor=\"#00ff00\"\n  ```\n3. 代码中指定图片地址\n\n   ```Java\n   SimpleDraweeView sdv = (SimpleDraweeView) findViewById(R.id.sdv);\n   sdv.setImageURI(Uri.parse(\"http://g.hiphotos.baidu.com/image/pic/item/2e2eb9389b504fc2b351980be7dde71190ef6db5.jpg\"));\n  ```\n\n### 参考资料：\n- [Fresco的由来](https://code.facebook.com/posts/366199913563917/introducing-fresco-a-new-image-library-for-android/)\n- [Fresco的源码托管](http://github.com/facebook/fresco)\n- [中文使用手册](http://fresco-cn.org/docs/index.html)\n\n----\n\n#SIAlertView 阅读 - 潘君\n\n- 创建自定义alert view的流程\n\n自定义window->添加自定义view controller->定制view->view引用window\n\n- @class\n```\n@class SIAlertView;\n```\n能不使用import的就不使用 \n用@class代替\n\n- 通知 和 Block\n\n- 层级\n```\nconst UIWindowLevel UIWindowLevelSIAlert = 1996.0;  // don't overlap system's alert\nconst UIWindowLevel UIWindowLevelSIAlertBackground = 1985.0; // below the alert window\n```\n\n- UIViewTintAdjustmentMode\n通过获取keyWindow的`UIViewTintAdjustmentMode`来设置alertWindow的\n该属性能够设置tint的调整模式\n```\ntypedef enum {\n     // 和父视图的一样\n     UIViewTintAdjustmentModeAutomatic,              \n     // 不对tintColor做任何修改\n     UIViewTintAdjustmentModeNormal,\n     // 在原有tintColor基础上变暗\n     UIViewTintAdjustmentModeDimmed,}UIViewTintAdjustmentMode;\n```\n\n\n-  iOS特有版本代码\n```\n#ifdef __IPHONE_7_0\n//some code \n#endif\n此处填写iOS7才能运行的代码\n```\n\n- initialize\n```\n+ (void)initialize\n{\n    if (self != [SIAlertView class])\n        return;\n   \n    // 默认值赋值\n}\n\n一些值放在+(void)initialize；中赋值为默认值，这样不管通过何种方式初始化\n```\n\n- UIAppearance\nSIAlertView *appearance = [self appearance];\nUIView符合UIAppearence协议，能够全局修改所有实例的UI\n\n- 调用Bundle中资源\n[UIImage imageNamed:@\"SIAlertView.bundle/button-default\"]\nbundle中资源的调用方法\n\n\n- _cmd\noc特有的方法，无法通过c语言获取\n\n-  [self invalidateLayout]\n\n- 合理利用循环引用\n\n```\n    if (!self.alertWindow) {\n        UIWindow *window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds];\n        window.autoresizingMask = UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleHeight;\n        window.opaque = NO;\n        window.windowLevel = UIWindowLevelSIAlert;\n        window.rootViewController = viewController;\n        self.alertWindow = window;\n    }\n```\n\n- oldKeyWindow\n通知alert后面的视图转变方向\n取用一些oldKeyWindow的值\n\n----\n\n## android饼图库 -吴明\n- 饼图选择\n\t- [AChartEngine](https://github.com/jondwillis/AChartEngine/tree/master/achartengine):(太丑了)\n\t- [xcl-charts](https://github.com/xcltapestry/XCL-Charts):(接口文档没有)\n\t- [HelloCharts](https://github.com/lecho/hellocharts-android):(接口文档没有)\n\t- [MPAndroidChart](https://github.com/PhilJay/MPAndroidChart):(接口文档多)\n- [MPAndroidChart](https://github.com/PhilJay/MPAndroidChart)\n\t- ![Alt Image Text](https://camo.githubusercontent.com/7e8a4a3c938c21d032d44d999edd781b6e146f2a/68747470733a2f2f7261772e6769746875622e636f6d2f5068696c4a61792f4d50416e64726f696443686172742f6d61737465722f73637265656e73686f74732f73696d706c6564657369676e5f7069656368617274312e706e67)\n\t- 饼图对象:PieChat\n\t- [详见接口文档](https://github.com/PhilJay/MPAndroidChart/wiki)\n\t\n\t\n---- \n\n## HeaderFooterRecyclerViewAdapter——李仙鹏\n[HeaderFooterRecyclerViewAdapter](https://gist.github.com/mheras/0908873267def75dc746)，用于RecyclerView。可方便的添加header或者footer。使用非常简单，只需要按照实际需求，在对应的header、content、footer相关方法进行重写即可。\n\n附上源码\n\n```\npublic abstract class HeaderFooterRecyclerViewAdapter extends RecyclerView.Adapter<RecyclerView.ViewHolder> {\n\n    private static final int VIEW_TYPE_MAX_COUNT = 1000;\n    private static final int HEADER_VIEW_TYPE_OFFSET = 0;\n    private static final int FOOTER_VIEW_TYPE_OFFSET = HEADER_VIEW_TYPE_OFFSET + VIEW_TYPE_MAX_COUNT;\n    private static final int CONTENT_VIEW_TYPE_OFFSET = FOOTER_VIEW_TYPE_OFFSET + VIEW_TYPE_MAX_COUNT;\n\n    private int headerItemCount;\n    private int contentItemCount;\n    private int footerItemCount;\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {\n\n        // Delegate to proper methods based on the viewType ranges.\n        if (viewType >= HEADER_VIEW_TYPE_OFFSET && viewType < HEADER_VIEW_TYPE_OFFSET + VIEW_TYPE_MAX_COUNT) {\n            return onCreateHeaderItemViewHolder(parent, viewType - HEADER_VIEW_TYPE_OFFSET);\n        } else if (viewType >= FOOTER_VIEW_TYPE_OFFSET && viewType < FOOTER_VIEW_TYPE_OFFSET + VIEW_TYPE_MAX_COUNT) {\n            return onCreateFooterItemViewHolder(parent, viewType - FOOTER_VIEW_TYPE_OFFSET);\n        } else if (viewType >= CONTENT_VIEW_TYPE_OFFSET && viewType < CONTENT_VIEW_TYPE_OFFSET + VIEW_TYPE_MAX_COUNT) {\n            return onCreateContentItemViewHolder(parent, viewType - CONTENT_VIEW_TYPE_OFFSET);\n        } else {\n            // This shouldn't happen as we check that the viewType provided by the client is valid.\n            throw new IllegalStateException();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final void onBindViewHolder(RecyclerView.ViewHolder viewHolder, int position) {\n        // Delegate to proper methods based on the viewType ranges.\n        if (headerItemCount > 0 && position < headerItemCount) {\n            onBindHeaderItemViewHolder(viewHolder, position);\n        } else if (contentItemCount > 0 && position - headerItemCount < contentItemCount) {\n            onBindContentItemViewHolder(viewHolder, position - headerItemCount);\n        } else {\n            onBindFooterItemViewHolder(viewHolder, position - headerItemCount - contentItemCount);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final int getItemCount() {\n        // Cache the counts and return the sum of them.\n        headerItemCount = getHeaderItemCount();\n        contentItemCount = getContentItemCount();\n        footerItemCount = getFooterItemCount();\n        return headerItemCount + contentItemCount + footerItemCount;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final int getItemViewType(int position) {\n        // Delegate to proper methods based on the position, but validate first.\n        if (headerItemCount > 0 && position < headerItemCount) {\n            return validateViewType(getHeaderItemViewType(position)) + HEADER_VIEW_TYPE_OFFSET;\n        } else if (contentItemCount > 0 && position - headerItemCount < contentItemCount) {\n            return validateViewType(getContentItemViewType(position - headerItemCount)) + CONTENT_VIEW_TYPE_OFFSET;\n        } else {\n            return validateViewType(getFooterItemViewType(position - headerItemCount - contentItemCount)) + FOOTER_VIEW_TYPE_OFFSET;\n        }\n    }\n\n    /**\n     * Validates that the view type is within the valid range.\n     *\n     * @param viewType the view type.\n     * @return the given view type.\n     */\n    private int validateViewType(int viewType) {\n        if (viewType < 0 || viewType >= VIEW_TYPE_MAX_COUNT) {\n            throw new IllegalStateException(\"viewType must be between 0 and \" + VIEW_TYPE_MAX_COUNT);\n        }\n        return viewType;\n    }\n\n    /**\n     * Notifies that a header item is inserted.\n     *\n     * @param position the position of the header item.\n     */\n    public final void notifyHeaderItemInserted(int position) {\n        int newHeaderItemCount = getHeaderItemCount();\n        if (position < 0 || position >= newHeaderItemCount) {\n            throw new IndexOutOfBoundsException(\"The given position \" + position + \" is not within the position bounds for header items [0 - \" + (newHeaderItemCount - 1) + \"].\");\n        }\n        notifyItemInserted(position);\n    }\n\n    /**\n     * Notifies that multiple header items are inserted.\n     *\n     * @param positionStart the position.\n     * @param itemCount     the item count.\n     */\n    public final void notifyHeaderItemRangeInserted(int positionStart, int itemCount) {\n        int newHeaderItemCount = getHeaderItemCount();\n        if (positionStart < 0 || itemCount < 0 || positionStart + itemCount > newHeaderItemCount) {\n            throw new IndexOutOfBoundsException(\"The given range [\" + positionStart + \" - \" + (positionStart + itemCount - 1) + \"] is not within the position bounds for header items [0 - \" + (newHeaderItemCount - 1) + \"].\");\n        }\n        notifyItemRangeInserted(positionStart, itemCount);\n    }\n\n    /**\n     * Notifies that a header item is changed.\n     *\n     * @param position the position.\n     */\n    public final void notifyHeaderItemChanged(int position) {\n        if (position < 0 || position >= headerItemCount) {\n            throw new IndexOutOfBoundsException(\"The given position \" + position + \" is not within the position bounds for header items [0 - \" + (headerItemCount - 1) + \"].\");\n        }\n        notifyItemChanged(position);\n    }\n\n    /**\n     * Notifies that multiple header items are changed.\n     *\n     * @param positionStart the position.\n     * @param itemCount     the item count.\n     */\n    public final void notifyHeaderItemRangeChanged(int positionStart, int itemCount) {\n        if (positionStart < 0 || itemCount < 0 || positionStart + itemCount >= headerItemCount) {\n            throw new IndexOutOfBoundsException(\"The given range [\" + positionStart + \" - \" + (positionStart + itemCount - 1) + \"] is not within the position bounds for header items [0 - \" + (headerItemCount - 1) + \"].\");\n        }\n        notifyItemRangeChanged(positionStart, itemCount);\n    }\n\n\n    /**\n     * Notifies that an existing header item is moved to another position.\n     *\n     * @param fromPosition the original position.\n     * @param toPosition   the new position.\n     */\n    public void notifyHeaderItemMoved(int fromPosition, int toPosition) {\n        if (fromPosition < 0 || toPosition < 0 || fromPosition >= headerItemCount || toPosition >= headerItemCount) {\n            throw new IndexOutOfBoundsException(\"The given fromPosition \" + fromPosition + \" or toPosition \" + toPosition + \" is not within the position bounds for header items [0 - \" + (headerItemCount - 1) + \"].\");\n        }\n        notifyItemMoved(fromPosition, toPosition);\n    }\n\n    /**\n     * Notifies that a header item is removed.\n     *\n     * @param position the position.\n     */\n    public void notifyHeaderItemRemoved(int position) {\n        if (position < 0 || position >= headerItemCount) {\n            throw new IndexOutOfBoundsException(\"The given position \" + position + \" is not within the position bounds for header items [0 - \" + (headerItemCount - 1) + \"].\");\n        }\n        notifyItemRemoved(position);\n    }\n\n    /**\n     * Notifies that multiple header items are removed.\n     *\n     * @param positionStart the position.\n     * @param itemCount     the item count.\n     */\n    public void notifyHeaderItemRangeRemoved(int positionStart, int itemCount) {\n        if (positionStart < 0 || itemCount < 0 || positionStart + itemCount > headerItemCount) {\n            throw new IndexOutOfBoundsException(\"The given range [\" + positionStart + \" - \" + (positionStart + itemCount - 1) + \"] is not within the position bounds for header items [0 - \" + (headerItemCount - 1) + \"].\");\n        }\n        notifyItemRangeRemoved(positionStart, itemCount);\n    }\n\n    /**\n     * Notifies that a content item is inserted.\n     *\n     * @param position the position of the content item.\n     */\n    public final void notifyContentItemInserted(int position) {\n        int newHeaderItemCount = getHeaderItemCount();\n        int newContentItemCount = getContentItemCount();\n        if (position < 0 || position >= newContentItemCount) {\n            throw new IndexOutOfBoundsException(\"The given position \" + position + \" is not within the position bounds for content items [0 - \" + (newContentItemCount - 1) + \"].\");\n        }\n        notifyItemInserted(position + newHeaderItemCount);\n    }\n\n    /**\n     * Notifies that multiple content items are inserted.\n     *\n     * @param positionStart the position.\n     * @param itemCount     the item count.\n     */\n    public final void notifyContentItemRangeInserted(int positionStart, int itemCount) {\n        int newHeaderItemCount = getHeaderItemCount();\n        int newContentItemCount = getContentItemCount();\n        if (positionStart < 0 || itemCount < 0 || positionStart + itemCount > newContentItemCount) {\n            throw new IndexOutOfBoundsException(\"The given range [\" + positionStart + \" - \" + (positionStart + itemCount - 1) + \"] is not within the position bounds for content items [0 - \" + (newContentItemCount - 1) + \"].\");\n        }\n        notifyItemRangeInserted(positionStart + newHeaderItemCount, itemCount);\n    }\n\n    /**\n     * Notifies that a content item is changed.\n     *\n     * @param position the position.\n     */\n    public final void notifyContentItemChanged(int position) {\n        if (position < 0 || position >= contentItemCount) {\n            throw new IndexOutOfBoundsException(\"The given position \" + position + \" is not within the position bounds for content items [0 - \" + (contentItemCount - 1) + \"].\");\n        }\n        notifyItemChanged(position + headerItemCount);\n    }\n\n    /**\n     * Notifies that multiple content items are changed.\n     *\n     * @param positionStart the position.\n     * @param itemCount     the item count.\n     */\n    public final void notifyContentItemRangeChanged(int positionStart, int itemCount) {\n        if (positionStart < 0 || itemCount < 0 || positionStart + itemCount > contentItemCount) {\n            throw new IndexOutOfBoundsException(\"The given range [\" + positionStart + \" - \" + (positionStart + itemCount - 1) + \"] is not within the position bounds for content items [0 - \" + (contentItemCount - 1) + \"].\");\n        }\n        notifyItemRangeChanged(positionStart + headerItemCount, itemCount);\n    }\n\n    /**\n     * Notifies that an existing content item is moved to another position.\n     *\n     * @param fromPosition the original position.\n     * @param toPosition   the new position.\n     */\n    public final void notifyContentItemMoved(int fromPosition, int toPosition) {\n        if (fromPosition < 0 || toPosition < 0 || fromPosition >= contentItemCount || toPosition >= contentItemCount) {\n            throw new IndexOutOfBoundsException(\"The given fromPosition \" + fromPosition + \" or toPosition \" + toPosition + \" is not within the position bounds for content items [0 - \" + (contentItemCount - 1) + \"].\");\n        }\n        notifyItemMoved(fromPosition + headerItemCount, toPosition + headerItemCount);\n    }\n\n    /**\n     * Notifies that a content item is removed.\n     *\n     * @param position the position.\n     */\n    public final void notifyContentItemRemoved(int position) {\n        if (position < 0 || position >= contentItemCount) {\n            throw new IndexOutOfBoundsException(\"The given position \" + position + \" is not within the position bounds for content items [0 - \" + (contentItemCount - 1) + \"].\");\n        }\n        notifyItemRemoved(position + headerItemCount);\n    }\n\n    /**\n     * Notifies that multiple content items are removed.\n     *\n     * @param positionStart the position.\n     * @param itemCount     the item count.\n     */\n    public final void notifyContentItemRangeRemoved(int positionStart, int itemCount) {\n        if (positionStart < 0 || itemCount < 0 || positionStart + itemCount > contentItemCount) {\n            throw new IndexOutOfBoundsException(\"The given range [\" + positionStart + \" - \" + (positionStart + itemCount - 1) + \"] is not within the position bounds for content items [0 - \" + (contentItemCount - 1) + \"].\");\n        }\n        notifyItemRangeRemoved(positionStart + headerItemCount, itemCount);\n    }\n\n    /**\n     * Notifies that a footer item is inserted.\n     *\n     * @param position the position of the content item.\n     */\n    public final void notifyFooterItemInserted(int position) {\n        int newHeaderItemCount = getHeaderItemCount();\n        int newContentItemCount = getContentItemCount();\n        int newFooterItemCount = getFooterItemCount();\n        if (position < 0 || position >= newFooterItemCount) {\n            throw new IndexOutOfBoundsException(\"The given position \" + position + \" is not within the position bounds for footer items [0 - \" + (newFooterItemCount - 1) + \"].\");\n        }\n        notifyItemInserted(position + newHeaderItemCount + newContentItemCount);\n    }\n\n    /**\n     * Notifies that multiple footer items are inserted.\n     *\n     * @param positionStart the position.\n     * @param itemCount     the item count.\n     */\n    public final void notifyFooterItemRangeInserted(int positionStart, int itemCount) {\n        int newHeaderItemCount = getHeaderItemCount();\n        int newContentItemCount = getContentItemCount();\n        int newFooterItemCount = getFooterItemCount();\n        if (positionStart < 0 || itemCount < 0 || positionStart + itemCount > newFooterItemCount) {\n            throw new IndexOutOfBoundsException(\"The given range [\" + positionStart + \" - \" + (positionStart + itemCount - 1) + \"] is not within the position bounds for footer items [0 - \" + (newFooterItemCount - 1) + \"].\");\n        }\n        notifyItemRangeInserted(positionStart + newHeaderItemCount + newContentItemCount, itemCount);\n    }\n\n    /**\n     * Notifies that a footer item is changed.\n     *\n     * @param position the position.\n     */\n    public final void notifyFooterItemChanged(int position) {\n        if (position < 0 || position >= footerItemCount) {\n            throw new IndexOutOfBoundsException(\"The given position \" + position + \" is not within the position bounds for footer items [0 - \" + (footerItemCount - 1) + \"].\");\n        }\n        notifyItemChanged(position + headerItemCount + contentItemCount);\n    }\n\n    /**\n     * Notifies that multiple footer items are changed.\n     *\n     * @param positionStart the position.\n     * @param itemCount     the item count.\n     */\n    public final void notifyFooterItemRangeChanged(int positionStart, int itemCount) {\n        if (positionStart < 0 || itemCount < 0 || positionStart + itemCount > footerItemCount) {\n            throw new IndexOutOfBoundsException(\"The given range [\" + positionStart + \" - \" + (positionStart + itemCount - 1) + \"] is not within the position bounds for footer items [0 - \" + (footerItemCount - 1) + \"].\");\n        }\n        notifyItemRangeChanged(positionStart + headerItemCount + contentItemCount, itemCount);\n    }\n\n    /**\n     * Notifies that an existing footer item is moved to another position.\n     *\n     * @param fromPosition the original position.\n     * @param toPosition   the new position.\n     */\n    public final void notifyFooterItemMoved(int fromPosition, int toPosition) {\n        if (fromPosition < 0 || toPosition < 0 || fromPosition >= footerItemCount || toPosition >= footerItemCount) {\n            throw new IndexOutOfBoundsException(\"The given fromPosition \" + fromPosition + \" or toPosition \" + toPosition + \" is not within the position bounds for footer items [0 - \" + (footerItemCount - 1) + \"].\");\n        }\n        notifyItemMoved(fromPosition + headerItemCount + contentItemCount, toPosition + headerItemCount + contentItemCount);\n    }\n\n    /**\n     * Notifies that a footer item is removed.\n     *\n     * @param position the position.\n     */\n    public final void notifyFooterItemRemoved(int position) {\n        if (position < 0 || position >= footerItemCount) {\n            throw new IndexOutOfBoundsException(\"The given position \" + position + \" is not within the position bounds for footer items [0 - \" + (footerItemCount - 1) + \"].\");\n        }\n        notifyItemRemoved(position + headerItemCount + contentItemCount);\n    }\n\n    /**\n     * Notifies that multiple footer items are removed.\n     *\n     * @param positionStart the position.\n     * @param itemCount     the item count.\n     */\n    public final void notifyFooterItemRangeRemoved(int positionStart, int itemCount) {\n        if (positionStart < 0 || itemCount < 0 || positionStart + itemCount > footerItemCount) {\n            throw new IndexOutOfBoundsException(\"The given range [\" + positionStart + \" - \" + (positionStart + itemCount - 1) + \"] is not within the position bounds for footer items [0 - \" + (footerItemCount - 1) + \"].\");\n        }\n        notifyItemRangeRemoved(positionStart + headerItemCount + contentItemCount, itemCount);\n    }\n\n    /**\n     * Gets the header item view type. By default, this method returns 0.\n     *\n     * @param position the position.\n     * @return the header item view type (within the range [0 - VIEW_TYPE_MAX_COUNT-1]).\n     */\n    protected int getHeaderItemViewType(int position) {\n        return 0;\n    }\n\n    /**\n     * Gets the footer item view type. By default, this method returns 0.\n     *\n     * @param position the position.\n     * @return the footer item view type (within the range [0 - VIEW_TYPE_MAX_COUNT-1]).\n     */\n    protected int getFooterItemViewType(int position) {\n        return 0;\n    }\n\n    /**\n     * Gets the content item view type. By default, this method returns 0.\n     *\n     * @param position the position.\n     * @return the content item view type (within the range [0 - VIEW_TYPE_MAX_COUNT-1]).\n     */\n    protected int getContentItemViewType(int position) {\n        return 0;\n    }\n\n    /**\n     * Gets the header item count. This method can be called several times, so it should not calculate the count every time.\n     *\n     * @return the header item count.\n     */\n    protected abstract int getHeaderItemCount();\n\n    /**\n     * Gets the footer item count. This method can be called several times, so it should not calculate the count every time.\n     *\n     * @return the footer item count.\n     */\n    protected abstract int getFooterItemCount();\n\n    /**\n     * Gets the content item count. This method can be called several times, so it should not calculate the count every time.\n     *\n     * @return the content item count.\n     */\n    protected abstract int getContentItemCount();\n\n    /**\n     * This method works exactly the same as {@link #onCreateViewHolder(android.view.ViewGroup, int)}, but for header items.\n     *\n     * @param parent         the parent view.\n     * @param headerViewType the view type for the header.\n     * @return the view holder.\n     */\n    protected abstract RecyclerView.ViewHolder onCreateHeaderItemViewHolder(ViewGroup parent, int headerViewType);\n\n    /**\n     * This method works exactly the same as {@link #onCreateViewHolder(android.view.ViewGroup, int)}, but for footer items.\n     *\n     * @param parent         the parent view.\n     * @param footerViewType the view type for the footer.\n     * @return the view holder.\n     */\n    protected abstract RecyclerView.ViewHolder onCreateFooterItemViewHolder(ViewGroup parent, int footerViewType);\n\n    /**\n     * This method works exactly the same as {@link #onCreateViewHolder(android.view.ViewGroup, int)}, but for content items.\n     *\n     * @param parent          the parent view.\n     * @param contentViewType the view type for the content.\n     * @return the view holder.\n     */\n    protected abstract RecyclerView.ViewHolder onCreateContentItemViewHolder(ViewGroup parent, int contentViewType);\n\n    /**\n     * This method works exactly the same as {@link #onBindViewHolder(android.support.v7.widget.RecyclerView.ViewHolder, int)}, but for header items.\n     *\n     * @param headerViewHolder the view holder for the header item.\n     * @param position         the position.\n     */\n    protected abstract void onBindHeaderItemViewHolder(RecyclerView.ViewHolder headerViewHolder, int position);\n\n    /**\n     * This method works exactly the same as {@link #onBindViewHolder(android.support.v7.widget.RecyclerView.ViewHolder, int)}, but for footer items.\n     *\n     * @param footerViewHolder the view holder for the footer item.\n     * @param position         the position.\n     */\n    protected abstract void onBindFooterItemViewHolder(RecyclerView.ViewHolder footerViewHolder, int position);\n\n    /**\n     * This method works exactly the same as {@link #onBindViewHolder(android.support.v7.widget.RecyclerView.ViewHolder, int)}, but for content items.\n     *\n     * @param contentViewHolder the view holder for the content item.\n     * @param position          the position.\n     */\n    protected abstract void onBindContentItemViewHolder(RecyclerView.ViewHolder contentViewHolder, int position);\n}\n```\n","slug":"那些年我们用过的第三方库","published":1,"updated":"2021-09-10T07:04:21.951Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cktfeap4o0038c2xx5rud74pa","content":"<h2 id=\"SnapKit（Masonry）-的使用-杨志平\"><a href=\"#SnapKit（Masonry）-的使用-杨志平\" class=\"headerlink\" title=\"SnapKit（Masonry） 的使用 - 杨志平\"></a>SnapKit（Masonry） 的使用 - 杨志平</h2><blockquote>\n<p>这两个库的用法都是差不多的，只是由两个不同的人来主导开源  <br><br><strong><a href=\"https://github.com/SnapKit/SnapKit\" target=\"_blank\" rel=\"noopener\">SnapKit</a></strong>是Swift版 <br><br><strong><a href=\"https://github.com/SnapKit/Masonry\" target=\"_blank\" rel=\"noopener\">Masonry</a></strong>是OC版    </p>\n<p>自动布局及交互式编程是iOS开发的趋势，同时Swift也会在不久将来替换OC语言。所以现在的iOS开发者可以开始学习Swift2.0 以及应用 Autolayout 来编程</p>\n</blockquote>\n<h3 id=\"代码对比（概况了解）\"><a href=\"#代码对比（概况了解）\" class=\"headerlink\" title=\"代码对比（概况了解）\"></a>代码对比（概况了解）</h3><h5 id=\"开始前OC原生布局代码\"><a href=\"#开始前OC原生布局代码\" class=\"headerlink\" title=\"开始前OC原生布局代码\"></a>开始前OC原生布局代码</h5><pre><code>\n    UIView *superview = self;\n\n    UIView *view1 = [[UIView alloc] init];\n    view1.translatesAutoresizingMaskIntoConstraints = NO;\n    view1.backgroundColor = [UIColor greenColor];\n    [superview addSubview:view1];\n\n    UIEdgeInsets padding = UIEdgeInsetsMake(10, 10, 10, 10);\n\n    [superview addConstraints:@[\n\n    //view1 constraints\n    [NSLayoutConstraint constraintWithItem:view1\n                                 attribute:NSLayoutAttributeTop\n                                 relatedBy:NSLayoutRelationEqual\n                                    toItem:superview\n                                 attribute:NSLayoutAttributeTop\n                                multiplier:1.0\n                                  constant:padding.top],\n\n    [NSLayoutConstraint constraintWithItem:view1\n                                 attribute:NSLayoutAttributeLeft\n                                 relatedBy:NSLayoutRelationEqual\n                                    toItem:superview\n                                 attribute:NSLayoutAttributeLeft\n                                multiplier:1.0\n                                  constant:padding.left],\n\n    [NSLayoutConstraint constraintWithItem:view1\n                                 attribute:NSLayoutAttributeBottom\n                                 relatedBy:NSLayoutRelationEqual\n                                    toItem:superview\n                                 attribute:NSLayoutAttributeBottom\n                                multiplier:1.0\n                                  constant:-padding.bottom],\n\n    [NSLayoutConstraint constraintWithItem:view1\n                                 attribute:NSLayoutAttributeRight\n                                 relatedBy:NSLayoutRelationEqual\n                                    toItem:superview\n                                 attribute:NSLayoutAttributeRight\n                                multiplier:1\n                                  constant:-padding.right],\n     ]];\n</code></pre><h5 id=\"使用Masonry\"><a href=\"#使用Masonry\" class=\"headerlink\" title=\"使用Masonry\"></a>使用Masonry</h5><p>精简</p>\n<pre><code>\n    UIEdgeInsets padding = UIEdgeInsetsMake(10, 10, 10, 10);\n\n    [view1 mas_makeConstraints:^(MASConstraintMaker *make) {\n    make.top.equalTo(superview.mas_top).with.offset(padding.top); //with     is an optional semantic filler\n        make.left.equalTo(superview.mas_left).with.offset(padding.left);\n        make.bottom.equalTo(superview.mas_bottom).with.offset(-    padding.bottom);\n        make.right.equalTo(superview.mas_right).with.offset(-padding.right);\n    }];\n</code></pre><p>更加精简</p>\n<pre><code>    [view1 mas_makeConstraints:^(MASConstraintMaker *make) {\n            make.edges.equalTo(superview).with.insets(padding);\n    }];\n</code></pre><h5 id=\"同理使用SnapKit\"><a href=\"#同理使用SnapKit\" class=\"headerlink\" title=\"同理使用SnapKit\"></a>同理使用SnapKit</h5><p>精简</p>\n<pre><code>\n    let box = UIView()\n    superview.addSubview(box)\n\n    box.snp_makeConstraints { (make) -&gt; Void in\n        make.top.equalTo(superview).offset(20)\n        make.left.equalTo(superview).offset(20)\n        make.bottom.equalTo(superview).offset(-20)\n        make.right.equalTo(superview).offset(-20)\n    }\n</code></pre><p>更加精简</p>\n<pre><code>    box.snp_makeConstraints { (make) -&gt; Void in\n        make.edges.equalTo(superview).inset(UIEdgeInsetsMake(20, 20, 20, 20))\n    }\n</code></pre><h3 id=\"如何使用-amp-amp-原理\"><a href=\"#如何使用-amp-amp-原理\" class=\"headerlink\" title=\"如何使用 &amp;&amp; 原理\"></a>如何使用 &amp;&amp; 原理</h3><h4 id=\"常见的约束类型对比\"><a href=\"#常见的约束类型对比\" class=\"headerlink\" title=\"常见的约束类型对比\"></a>常见的约束类型对比</h4><table>\n<thead>\n<tr>\n<th>ViewAttribute</th>\n<th>NSLayoutAttribute</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>view.snp_left</td>\n<td>NSLayoutAttribute.Left</td>\n</tr>\n<tr>\n<td>view.snp_right</td>\n<td>NSLayoutAttribute.Right</td>\n</tr>\n<tr>\n<td>view.snp_top</td>\n<td>NSLayoutAttribute.Top</td>\n</tr>\n<tr>\n<td>view.snp_bottom</td>\n<td>NSLayoutAttribute.Bottom</td>\n</tr>\n<tr>\n<td>view.snp_leading</td>\n<td>NSLayoutAttribute.Leading</td>\n</tr>\n<tr>\n<td>view.snp_trailing</td>\n<td>NSLayoutAttribute.Trailing</td>\n</tr>\n<tr>\n<td>view.snp_width</td>\n<td>NSLayoutAttribute.Width</td>\n</tr>\n<tr>\n<td>view.snp_height</td>\n<td>NSLayoutAttribute.Height</td>\n</tr>\n<tr>\n<td>view.snp_centerX</td>\n<td>NSLayoutAttribute.CenterX</td>\n</tr>\n<tr>\n<td>view.snp_centerY</td>\n<td>NSLayoutAttribute.CenterY</td>\n</tr>\n<tr>\n<td>view.snp_baseline</td>\n<td>NSLayoutAttribute.Baseline</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"常见的用法\"><a href=\"#常见的用法\" class=\"headerlink\" title=\"常见的用法\"></a>常见的用法</h4><pre><code>make.top.equalTo(42)\nmake.lessThanOrEqualTo.equalTo(SuperView)\nmake.top.equalTo(SuperView)\nmake.size.equalTo(CGSizeMake(50, 100))\nmake.edges.equalTo(UIEdgeInsetsMake(10, 0, 10, 0))\nmake.left.equalTo(view).offset(UIEdgeInsetsMake(10, 0, 10, 0))\n\nmake.height.equalTo(OtherView).offset(10)\nmake.trailing.equalTo(OtherView.snp_trailing).offset(10)\nmake.bottom.equalTo(-20).priority(250)\n</code></pre><h4 id=\"对比交互式编程的约束布局\"><a href=\"#对比交互式编程的约束布局\" class=\"headerlink\" title=\"对比交互式编程的约束布局\"></a>对比交互式编程的约束布局</h4><p><img src=\"https://cloud.githubusercontent.com/assets/9360037/9401926/1e572316-4809-11e5-9a96-430e688cda85.png\" alt=\"image\"></p>\n<hr>\n<h2 id=\"JSONModel-for-swift-的探索-曾铭\"><a href=\"#JSONModel-for-swift-的探索-曾铭\" class=\"headerlink\" title=\"JSONModel for swift 的探索 - 曾铭\"></a>JSONModel for swift 的探索 - 曾铭</h2><pre><code>// 可在 Playground 中尝试\nimport Foundation\nimport UIKit\n\n\n// 基本的类型转换\nlet a:String = &quot;&quot;\nlet b = &quot;&quot;\nvar c:String? = nil\nc = &quot;test&quot;\n\nlet d:String = c as String!\nvar e = Int(c!)\ne = Int(&quot;123&quot;)\n\nvar f = Int(&quot;123&quot;)!\n\nprint(&quot;a type:\\(a.dynamicType)&quot;)\nprint(&quot;b type:\\(b.dynamicType)&quot;)\nprint(&quot;c type:\\(c.dynamicType)&quot;)\nprint(&quot;d type:\\(d.dynamicType)&quot;)\nprint(&quot;e type:\\(e.dynamicType)&quot;)\nprint(&quot;f type:\\(f.dynamicType)\\n&quot;)\n\n\n// KVC for NSObject\n\nclass FooKVC : NSObject {\n    var p1 : String = &quot;s&quot;\n}\n\nlet fk1 = FooKVC()\n\nfk1.p1\n\nfk1.setValue(&quot;y&quot;, forKey: &quot;p1&quot;)\n\nfk1.p1\n\n// reflect for swift2.0\n\nclass A\n{\n    var name = &quot;namevalue&quot;\n    var age = 123\n    var some:(String, Int) = (&quot;ming&quot;, 2)\n}\n\nlet a1 = A()\n\na1.age = 456\n\na1.age\n\n\nlet r = Mirror(reflecting: a1)\nfor c in r.children {\n    print(c.label.dynamicType)\n    print(c.label)\n    print(c.value.dynamicType)\n    print(c.value)\n    print(&quot;===&quot;)\n}\n</code></pre><ul>\n<li>KVO for NSObject 略, 注意监听者与被监听者都要是 NSObject 子类</li>\n</ul>\n<h3 id=\"JSONModel-for-swift\"><a href=\"#JSONModel-for-swift\" class=\"headerlink\" title=\"JSONModel for swift?\"></a>JSONModel for swift?</h3><p>&gt;<br>NB: Swift works in a different way under the hood than Objective-C. Therefore I can’t find a way to re-create JSONModel in Swift. JSONModel in Objective-C works in Swift apps through CocoaPods or as an imported Objective-C library.</p>\n<h3 id=\"JSONModel-做的事情\"><a href=\"#JSONModel-做的事情\" class=\"headerlink\" title=\"JSONModel 做的事情\"></a>JSONModel 做的事情</h3><ul>\n<li>String(NSData) -&gt; Dictionary(Array)</li>\n<li>Dictionary(Array) -&gt; Model-Object</li>\n</ul>\n<h3 id=\"对应实现\"><a href=\"#对应实现\" class=\"headerlink\" title=\"对应实现\"></a>对应实现</h3><ul>\n<li>容易:<ul>\n<li>swift 容器取值的坑 <a href=\"https://github.com/SwiftyJSON/SwiftyJSON\" target=\"_blank\" rel=\"noopener\">https://github.com/SwiftyJSON/SwiftyJSON</a></li>\n</ul>\n</li>\n<li>swift 反射不支持赋值，没办法<ul>\n<li>通过 NSObject KVC 解决 <a href=\"https://github.com/PonyCui/PPJSONSerialization\" target=\"_blank\" rel=\"noopener\">https://github.com/PonyCui/PPJSONSerialization</a></li>\n<li>临时方案？</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h3><ul>\n<li><a href=\"https://github.com/leemorgan/Swift-KVC/blob/master/KVC%20Playground.playground/Contents.swift\" target=\"_blank\" rel=\"noopener\">Swift-KVC (just <code>valueForKey:</code>)</a></li>\n<li><a href=\"http://www.jianshu.com/p/e036e53d240e\" target=\"_blank\" rel=\"noopener\">Swift: KVO 注意事项和属性观察器</a></li>\n<li><a href=\"http://stackoverflow.com/questions/24844681/list-of-classs-properties-in-swift\" target=\"_blank\" rel=\"noopener\">List of class’s properties in swift</a></li>\n</ul>\n<hr>\n<h2 id=\"RATreeView的简单使用-张超耀\"><a href=\"#RATreeView的简单使用-张超耀\" class=\"headerlink\" title=\"RATreeView的简单使用 - 张超耀\"></a>RATreeView的简单使用 - 张超耀</h2><h3 id=\"RATreeView-实现树形结构的TableView；点击每个cell，都可以展开出现新的cell；可以自定义树的层数\"><a href=\"#RATreeView-实现树形结构的TableView；点击每个cell，都可以展开出现新的cell；可以自定义树的层数\" class=\"headerlink\" title=\"RATreeView:实现树形结构的TableView；点击每个cell，都可以展开出现新的cell；可以自定义树的层数\"></a>RATreeView:实现树形结构的TableView；点击每个cell，都可以展开出现新的cell；可以自定义树的层数</h3><p><img src=\"https://camo.githubusercontent.com/87d3db881cf57dba674a89a6e1460c00277245b3/68747470733a2f2f7261772e6769746875622e636f6d2f417567757374796e69616b2f524154726565566965772f6d61737465722f53637265656e732f616e696d6174696f6e2e676966\" alt></p>\n<h3 id=\"主要方法介绍\"><a href=\"#主要方法介绍\" class=\"headerlink\" title=\"主要方法介绍\"></a>主要方法介绍</h3><ul>\n<li>cell的高度<br><code>-(CGFloat)treeView:(RATreeView *)treeView heightForRowForItem:(id)item treeNodeInfo:(RATreeNodeInfo *)treeNodeInfo</code></li>\n<li>这个函数决定是否可以展开，通过设定我们可以设置哪些单元格可以展开到下一层，哪些不可以展开<br><code>- (BOOL)treeView:(RATreeView *)treeView shouldExpandItem:(id)item treeNodeInfo:(RATreeNodeInfo *)treeNodeInfo</code> </li>\n<li><p>这个看字面意识就理解了，在单元格显示之前（或者说将要显示时）我们可以做些设置，这里是设置相应深度的颜色背景<br><code>- (void)treeView:(RATreeView *)treeView willDisplayCell:(UITableViewCell *)cell forItem:(id)item treeNodeInfo:(RATreeNodeInfo *)treeNodeInfo</code></p>\n</li>\n<li><p>这里就是我们最熟悉的点击cell处理函数，看代码慢慢体会treeNodeInfo的使用，不想多说了<br><code>-(void)treeView:(RATreeView *)treeView didSelectRowForItem:(id)item treeNodeInfo:(RATreeNodeInfo *)treeNodeInfo</code></p>\n</li>\n<li>数据源处理，相当于UITableViewCell处理，关键还是理解treeNodeInfo概念<br><code>- (UITableViewCell *)treeView:(RATreeView *)treeView cellForItem:(id)item treeNodeInfo:(RATreeNodeInfo *)treeNodeInfo</code></li>\n<li>返回每一层包含成员的个数，来制表<br><code>- (NSInteger)treeView:(RATreeView *)treeView numberOfChildrenOfItem:(id)item</code></li>\n<li>返回cell对象<br><code>- (id)treeView:(RATreeView *)treeView child:(NSInteger)index ofItem:(id)item</code><h3 id=\"RATreeView-github\"><a href=\"#RATreeView-github\" class=\"headerlink\" title=\"RATreeView - github\"></a><a href=\"https://github.com/Augustyniak/RATreeView\" target=\"_blank\" rel=\"noopener\">RATreeView - github</a></h3></li>\n</ul>\n<hr>\n<h2 id=\"Facebook-开源的图片加载库Fresco-王胜\"><a href=\"#Facebook-开源的图片加载库Fresco-王胜\" class=\"headerlink\" title=\"Facebook 开源的图片加载库Fresco - 王胜\"></a>Facebook 开源的图片加载库Fresco - 王胜</h2><h3 id=\"Fresco诞生背景\"><a href=\"#Fresco诞生背景\" class=\"headerlink\" title=\"Fresco诞生背景\"></a>Fresco诞生背景</h3><p>为提高Android中图片的加载速度，一般的图片库都采用了三级缓存：Memory Cache、Disk Cache和Network。但是，Android的系统层是将物理内存平均分配给每一个App。这样每个App所分配的空间都是有限的，早起的android设备，每个App只被分配16MB空间，这样，如果App中使用大量的图片，那么很容易因OOM而Crashes掉。Facebook App正是大量使用图片的App，面临这个问题刻不容缓，所以他们历尽艰难，开发了Fresco图片加载库。 </p>\n<h3 id=\"Fresco诞生过程\"><a href=\"#Fresco诞生过程\" class=\"headerlink\" title=\"Fresco诞生过程\"></a>Fresco诞生过程</h3><h4 id=\"内存区域分析：\"><a href=\"#内存区域分析：\" class=\"headerlink\" title=\"内存区域分析：\"></a>内存区域分析：</h4><ul>\n<li><p>Java heap</p>\n<p>每个厂商会为App分配一个固定尺寸的运行空间。所有的申请通过Java的new操作申请，操作相对安全，通过GC内存自动回收保证内存不被泄露。但不幸的时，GC不够精确化，回收得不够及时。因此还是会存在OOM。</p>\n</li>\n<li><p>Native heap</p>\n<p>通过C或者C++可绕过Java虚拟机直接操作物理内存，但Java程序员习惯了GC的自动回收，很难操作C++的手动操作内存。</p>\n</li>\n<li><p>Ashmen</p>\n<p>Android还有一块内存区域，叫Ashmen。这里的操作很像Nativew heap，但是这里是系统调用的。Java 应用程序是不能直接访问Ashmen的，但是一些例外的情况可以操作，图片就是一种例外。</p>\n<pre><code class=\"Java\">BitmapFactory.Options = new BitmapFactory.Options();\noptions.inPurgeable = true;\nBitmap bitmap = BitmapFactory.decodeByteArray(jpeg, 0, jpeg.length, options);\n</code></pre>\n</li>\n</ul>\n<h4 id=\"难点突破：\"><a href=\"#难点突破：\" class=\"headerlink\" title=\"难点突破：\"></a>难点突破：</h4><p>尽管发现了Purgeable bitmaps，但是这个解码的过程是在UI线程操作的，因此他们又采用了异步实现，并保证了UI线程不引用时，unpin的区域不会被释放。</p>\n<h4 id=\"上层构建\"><a href=\"#上层构建\" class=\"headerlink\" title=\"上层构建\"></a>上层构建</h4><p>提供给上层调用时，采用了MVC的架构：</p>\n<ul>\n<li>Model：DraweeHierarchy</li>\n<li>Control：DraweeControllers</li>\n<li>View：DraweeViews</li>\n</ul>\n<h3 id=\"使用示例\"><a href=\"#使用示例\" class=\"headerlink\" title=\"使用示例\"></a>使用示例</h3><ol>\n<li><p>gradle配置中添加库引用</p>\n<pre><code>compile &#39;com.facebook.fresco:fresco:0.6.1+&#39;\n</code></pre></li>\n<li><p>xml中添加组件</p>\n<pre><code class=\"XML\">&lt;com.facebook.drawee.view.SimpleDraweeView\n     android:id=&quot;@+id/sdv&quot;\n     android:layout_width=&quot;match_parent&quot;\n     android:layout_height=&quot;match_parent&quot;\n     fresco:roundAsCircle=&quot;true&quot;\n     fresco:roundingBorderWidth=&quot;1dp&quot;\n     fresco:roundingBorderColor=&quot;#00ff00&quot;\n</code></pre>\n</li>\n<li><p>代码中指定图片地址</p>\n<pre><code class=\"Java\">SimpleDraweeView sdv = (SimpleDraweeView) findViewById(R.id.sdv);\nsdv.setImageURI(Uri.parse(&quot;http://g.hiphotos.baidu.com/image/pic/item/2e2eb9389b504fc2b351980be7dde71190ef6db5.jpg&quot;));\n</code></pre>\n</li>\n</ol>\n<h3 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h3><ul>\n<li><a href=\"https://code.facebook.com/posts/366199913563917/introducing-fresco-a-new-image-library-for-android/\" target=\"_blank\" rel=\"noopener\">Fresco的由来</a></li>\n<li><a href=\"http://github.com/facebook/fresco\" target=\"_blank\" rel=\"noopener\">Fresco的源码托管</a></li>\n<li><a href=\"http://fresco-cn.org/docs/index.html\" target=\"_blank\" rel=\"noopener\">中文使用手册</a></li>\n</ul>\n<hr>\n<p>#SIAlertView 阅读 - 潘君</p>\n<ul>\n<li>创建自定义alert view的流程</li>\n</ul>\n<p>自定义window-&gt;添加自定义view controller-&gt;定制view-&gt;view引用window</p>\n<ul>\n<li><p>@class</p>\n<pre><code>@class SIAlertView;\n</code></pre><p>能不使用import的就不使用<br>用@class代替</p>\n</li>\n<li><p>通知 和 Block</p>\n</li>\n<li><p>层级</p>\n<pre><code>const UIWindowLevel UIWindowLevelSIAlert = 1996.0;  // don&#39;t overlap system&#39;s alert\nconst UIWindowLevel UIWindowLevelSIAlertBackground = 1985.0; // below the alert window\n</code></pre></li>\n<li><p>UIViewTintAdjustmentMode<br>通过获取keyWindow的<code>UIViewTintAdjustmentMode</code>来设置alertWindow的<br>该属性能够设置tint的调整模式</p>\n<pre><code>typedef enum {\n   // 和父视图的一样\n   UIViewTintAdjustmentModeAutomatic,              \n   // 不对tintColor做任何修改\n   UIViewTintAdjustmentModeNormal,\n   // 在原有tintColor基础上变暗\n   UIViewTintAdjustmentModeDimmed,}UIViewTintAdjustmentMode;\n</code></pre></li>\n</ul>\n<ul>\n<li><p>iOS特有版本代码</p>\n<pre><code>#ifdef __IPHONE_7_0\n//some code \n#endif\n此处填写iOS7才能运行的代码\n</code></pre></li>\n<li><p>initialize<br>```</p>\n</li>\n</ul>\n<ul>\n<li><p>(void)initialize<br>{<br>  if (self != [SIAlertView class])</p>\n<pre><code>  return;\n</code></pre><p>  // 默认值赋值<br>}</p>\n</li>\n</ul>\n<p>一些值放在+(void)initialize；中赋值为默认值，这样不管通过何种方式初始化</p>\n<pre><code>\n- UIAppearance\nSIAlertView *appearance = [self appearance];\nUIView符合UIAppearence协议，能够全局修改所有实例的UI\n\n- 调用Bundle中资源\n[UIImage imageNamed:@&quot;SIAlertView.bundle/button-default&quot;]\nbundle中资源的调用方法\n\n\n- _cmd\noc特有的方法，无法通过c语言获取\n\n-  [self invalidateLayout]\n\n- 合理利用循环引用\n</code></pre><pre><code>if (!self.alertWindow) {\n    UIWindow *window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds];\n    window.autoresizingMask = UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleHeight;\n    window.opaque = NO;\n    window.windowLevel = UIWindowLevelSIAlert;\n    window.rootViewController = viewController;\n    self.alertWindow = window;\n}\n</code></pre><pre><code>\n- oldKeyWindow\n通知alert后面的视图转变方向\n取用一些oldKeyWindow的值\n\n----\n\n## android饼图库 -吴明\n- 饼图选择\n    - [AChartEngine](https://github.com/jondwillis/AChartEngine/tree/master/achartengine):(太丑了)\n    - [xcl-charts](https://github.com/xcltapestry/XCL-Charts):(接口文档没有)\n    - [HelloCharts](https://github.com/lecho/hellocharts-android):(接口文档没有)\n    - [MPAndroidChart](https://github.com/PhilJay/MPAndroidChart):(接口文档多)\n- [MPAndroidChart](https://github.com/PhilJay/MPAndroidChart)\n    - ![Alt Image Text](https://camo.githubusercontent.com/7e8a4a3c938c21d032d44d999edd781b6e146f2a/68747470733a2f2f7261772e6769746875622e636f6d2f5068696c4a61792f4d50416e64726f696443686172742f6d61737465722f73637265656e73686f74732f73696d706c6564657369676e5f7069656368617274312e706e67)\n    - 饼图对象:PieChat\n    - [详见接口文档](https://github.com/PhilJay/MPAndroidChart/wiki)\n\n\n---- \n\n## HeaderFooterRecyclerViewAdapter——李仙鹏\n[HeaderFooterRecyclerViewAdapter](https://gist.github.com/mheras/0908873267def75dc746)，用于RecyclerView。可方便的添加header或者footer。使用非常简单，只需要按照实际需求，在对应的header、content、footer相关方法进行重写即可。\n\n附上源码\n</code></pre><p>public abstract class HeaderFooterRecyclerViewAdapter extends RecyclerView.Adapter<recyclerview.viewholder> {</recyclerview.viewholder></p>\n<pre><code>private static final int VIEW_TYPE_MAX_COUNT = 1000;\nprivate static final int HEADER_VIEW_TYPE_OFFSET = 0;\nprivate static final int FOOTER_VIEW_TYPE_OFFSET = HEADER_VIEW_TYPE_OFFSET + VIEW_TYPE_MAX_COUNT;\nprivate static final int CONTENT_VIEW_TYPE_OFFSET = FOOTER_VIEW_TYPE_OFFSET + VIEW_TYPE_MAX_COUNT;\n\nprivate int headerItemCount;\nprivate int contentItemCount;\nprivate int footerItemCount;\n\n/**\n * {@inheritDoc}\n */\n@Override\npublic final RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {\n\n    // Delegate to proper methods based on the viewType ranges.\n    if (viewType &gt;= HEADER_VIEW_TYPE_OFFSET &amp;&amp; viewType &lt; HEADER_VIEW_TYPE_OFFSET + VIEW_TYPE_MAX_COUNT) {\n        return onCreateHeaderItemViewHolder(parent, viewType - HEADER_VIEW_TYPE_OFFSET);\n    } else if (viewType &gt;= FOOTER_VIEW_TYPE_OFFSET &amp;&amp; viewType &lt; FOOTER_VIEW_TYPE_OFFSET + VIEW_TYPE_MAX_COUNT) {\n        return onCreateFooterItemViewHolder(parent, viewType - FOOTER_VIEW_TYPE_OFFSET);\n    } else if (viewType &gt;= CONTENT_VIEW_TYPE_OFFSET &amp;&amp; viewType &lt; CONTENT_VIEW_TYPE_OFFSET + VIEW_TYPE_MAX_COUNT) {\n        return onCreateContentItemViewHolder(parent, viewType - CONTENT_VIEW_TYPE_OFFSET);\n    } else {\n        // This shouldn&#39;t happen as we check that the viewType provided by the client is valid.\n        throw new IllegalStateException();\n    }\n}\n\n/**\n * {@inheritDoc}\n */\n@Override\npublic final void onBindViewHolder(RecyclerView.ViewHolder viewHolder, int position) {\n    // Delegate to proper methods based on the viewType ranges.\n    if (headerItemCount &gt; 0 &amp;&amp; position &lt; headerItemCount) {\n        onBindHeaderItemViewHolder(viewHolder, position);\n    } else if (contentItemCount &gt; 0 &amp;&amp; position - headerItemCount &lt; contentItemCount) {\n        onBindContentItemViewHolder(viewHolder, position - headerItemCount);\n    } else {\n        onBindFooterItemViewHolder(viewHolder, position - headerItemCount - contentItemCount);\n    }\n}\n\n/**\n * {@inheritDoc}\n */\n@Override\npublic final int getItemCount() {\n    // Cache the counts and return the sum of them.\n    headerItemCount = getHeaderItemCount();\n    contentItemCount = getContentItemCount();\n    footerItemCount = getFooterItemCount();\n    return headerItemCount + contentItemCount + footerItemCount;\n}\n\n/**\n * {@inheritDoc}\n */\n@Override\npublic final int getItemViewType(int position) {\n    // Delegate to proper methods based on the position, but validate first.\n    if (headerItemCount &gt; 0 &amp;&amp; position &lt; headerItemCount) {\n        return validateViewType(getHeaderItemViewType(position)) + HEADER_VIEW_TYPE_OFFSET;\n    } else if (contentItemCount &gt; 0 &amp;&amp; position - headerItemCount &lt; contentItemCount) {\n        return validateViewType(getContentItemViewType(position - headerItemCount)) + CONTENT_VIEW_TYPE_OFFSET;\n    } else {\n        return validateViewType(getFooterItemViewType(position - headerItemCount - contentItemCount)) + FOOTER_VIEW_TYPE_OFFSET;\n    }\n}\n\n/**\n * Validates that the view type is within the valid range.\n *\n * @param viewType the view type.\n * @return the given view type.\n */\nprivate int validateViewType(int viewType) {\n    if (viewType &lt; 0 || viewType &gt;= VIEW_TYPE_MAX_COUNT) {\n        throw new IllegalStateException(&quot;viewType must be between 0 and &quot; + VIEW_TYPE_MAX_COUNT);\n    }\n    return viewType;\n}\n\n/**\n * Notifies that a header item is inserted.\n *\n * @param position the position of the header item.\n */\npublic final void notifyHeaderItemInserted(int position) {\n    int newHeaderItemCount = getHeaderItemCount();\n    if (position &lt; 0 || position &gt;= newHeaderItemCount) {\n        throw new IndexOutOfBoundsException(&quot;The given position &quot; + position + &quot; is not within the position bounds for header items [0 - &quot; + (newHeaderItemCount - 1) + &quot;].&quot;);\n    }\n    notifyItemInserted(position);\n}\n\n/**\n * Notifies that multiple header items are inserted.\n *\n * @param positionStart the position.\n * @param itemCount     the item count.\n */\npublic final void notifyHeaderItemRangeInserted(int positionStart, int itemCount) {\n    int newHeaderItemCount = getHeaderItemCount();\n    if (positionStart &lt; 0 || itemCount &lt; 0 || positionStart + itemCount &gt; newHeaderItemCount) {\n        throw new IndexOutOfBoundsException(&quot;The given range [&quot; + positionStart + &quot; - &quot; + (positionStart + itemCount - 1) + &quot;] is not within the position bounds for header items [0 - &quot; + (newHeaderItemCount - 1) + &quot;].&quot;);\n    }\n    notifyItemRangeInserted(positionStart, itemCount);\n}\n\n/**\n * Notifies that a header item is changed.\n *\n * @param position the position.\n */\npublic final void notifyHeaderItemChanged(int position) {\n    if (position &lt; 0 || position &gt;= headerItemCount) {\n        throw new IndexOutOfBoundsException(&quot;The given position &quot; + position + &quot; is not within the position bounds for header items [0 - &quot; + (headerItemCount - 1) + &quot;].&quot;);\n    }\n    notifyItemChanged(position);\n}\n\n/**\n * Notifies that multiple header items are changed.\n *\n * @param positionStart the position.\n * @param itemCount     the item count.\n */\npublic final void notifyHeaderItemRangeChanged(int positionStart, int itemCount) {\n    if (positionStart &lt; 0 || itemCount &lt; 0 || positionStart + itemCount &gt;= headerItemCount) {\n        throw new IndexOutOfBoundsException(&quot;The given range [&quot; + positionStart + &quot; - &quot; + (positionStart + itemCount - 1) + &quot;] is not within the position bounds for header items [0 - &quot; + (headerItemCount - 1) + &quot;].&quot;);\n    }\n    notifyItemRangeChanged(positionStart, itemCount);\n}\n\n\n/**\n * Notifies that an existing header item is moved to another position.\n *\n * @param fromPosition the original position.\n * @param toPosition   the new position.\n */\npublic void notifyHeaderItemMoved(int fromPosition, int toPosition) {\n    if (fromPosition &lt; 0 || toPosition &lt; 0 || fromPosition &gt;= headerItemCount || toPosition &gt;= headerItemCount) {\n        throw new IndexOutOfBoundsException(&quot;The given fromPosition &quot; + fromPosition + &quot; or toPosition &quot; + toPosition + &quot; is not within the position bounds for header items [0 - &quot; + (headerItemCount - 1) + &quot;].&quot;);\n    }\n    notifyItemMoved(fromPosition, toPosition);\n}\n\n/**\n * Notifies that a header item is removed.\n *\n * @param position the position.\n */\npublic void notifyHeaderItemRemoved(int position) {\n    if (position &lt; 0 || position &gt;= headerItemCount) {\n        throw new IndexOutOfBoundsException(&quot;The given position &quot; + position + &quot; is not within the position bounds for header items [0 - &quot; + (headerItemCount - 1) + &quot;].&quot;);\n    }\n    notifyItemRemoved(position);\n}\n\n/**\n * Notifies that multiple header items are removed.\n *\n * @param positionStart the position.\n * @param itemCount     the item count.\n */\npublic void notifyHeaderItemRangeRemoved(int positionStart, int itemCount) {\n    if (positionStart &lt; 0 || itemCount &lt; 0 || positionStart + itemCount &gt; headerItemCount) {\n        throw new IndexOutOfBoundsException(&quot;The given range [&quot; + positionStart + &quot; - &quot; + (positionStart + itemCount - 1) + &quot;] is not within the position bounds for header items [0 - &quot; + (headerItemCount - 1) + &quot;].&quot;);\n    }\n    notifyItemRangeRemoved(positionStart, itemCount);\n}\n\n/**\n * Notifies that a content item is inserted.\n *\n * @param position the position of the content item.\n */\npublic final void notifyContentItemInserted(int position) {\n    int newHeaderItemCount = getHeaderItemCount();\n    int newContentItemCount = getContentItemCount();\n    if (position &lt; 0 || position &gt;= newContentItemCount) {\n        throw new IndexOutOfBoundsException(&quot;The given position &quot; + position + &quot; is not within the position bounds for content items [0 - &quot; + (newContentItemCount - 1) + &quot;].&quot;);\n    }\n    notifyItemInserted(position + newHeaderItemCount);\n}\n\n/**\n * Notifies that multiple content items are inserted.\n *\n * @param positionStart the position.\n * @param itemCount     the item count.\n */\npublic final void notifyContentItemRangeInserted(int positionStart, int itemCount) {\n    int newHeaderItemCount = getHeaderItemCount();\n    int newContentItemCount = getContentItemCount();\n    if (positionStart &lt; 0 || itemCount &lt; 0 || positionStart + itemCount &gt; newContentItemCount) {\n        throw new IndexOutOfBoundsException(&quot;The given range [&quot; + positionStart + &quot; - &quot; + (positionStart + itemCount - 1) + &quot;] is not within the position bounds for content items [0 - &quot; + (newContentItemCount - 1) + &quot;].&quot;);\n    }\n    notifyItemRangeInserted(positionStart + newHeaderItemCount, itemCount);\n}\n\n/**\n * Notifies that a content item is changed.\n *\n * @param position the position.\n */\npublic final void notifyContentItemChanged(int position) {\n    if (position &lt; 0 || position &gt;= contentItemCount) {\n        throw new IndexOutOfBoundsException(&quot;The given position &quot; + position + &quot; is not within the position bounds for content items [0 - &quot; + (contentItemCount - 1) + &quot;].&quot;);\n    }\n    notifyItemChanged(position + headerItemCount);\n}\n\n/**\n * Notifies that multiple content items are changed.\n *\n * @param positionStart the position.\n * @param itemCount     the item count.\n */\npublic final void notifyContentItemRangeChanged(int positionStart, int itemCount) {\n    if (positionStart &lt; 0 || itemCount &lt; 0 || positionStart + itemCount &gt; contentItemCount) {\n        throw new IndexOutOfBoundsException(&quot;The given range [&quot; + positionStart + &quot; - &quot; + (positionStart + itemCount - 1) + &quot;] is not within the position bounds for content items [0 - &quot; + (contentItemCount - 1) + &quot;].&quot;);\n    }\n    notifyItemRangeChanged(positionStart + headerItemCount, itemCount);\n}\n\n/**\n * Notifies that an existing content item is moved to another position.\n *\n * @param fromPosition the original position.\n * @param toPosition   the new position.\n */\npublic final void notifyContentItemMoved(int fromPosition, int toPosition) {\n    if (fromPosition &lt; 0 || toPosition &lt; 0 || fromPosition &gt;= contentItemCount || toPosition &gt;= contentItemCount) {\n        throw new IndexOutOfBoundsException(&quot;The given fromPosition &quot; + fromPosition + &quot; or toPosition &quot; + toPosition + &quot; is not within the position bounds for content items [0 - &quot; + (contentItemCount - 1) + &quot;].&quot;);\n    }\n    notifyItemMoved(fromPosition + headerItemCount, toPosition + headerItemCount);\n}\n\n/**\n * Notifies that a content item is removed.\n *\n * @param position the position.\n */\npublic final void notifyContentItemRemoved(int position) {\n    if (position &lt; 0 || position &gt;= contentItemCount) {\n        throw new IndexOutOfBoundsException(&quot;The given position &quot; + position + &quot; is not within the position bounds for content items [0 - &quot; + (contentItemCount - 1) + &quot;].&quot;);\n    }\n    notifyItemRemoved(position + headerItemCount);\n}\n\n/**\n * Notifies that multiple content items are removed.\n *\n * @param positionStart the position.\n * @param itemCount     the item count.\n */\npublic final void notifyContentItemRangeRemoved(int positionStart, int itemCount) {\n    if (positionStart &lt; 0 || itemCount &lt; 0 || positionStart + itemCount &gt; contentItemCount) {\n        throw new IndexOutOfBoundsException(&quot;The given range [&quot; + positionStart + &quot; - &quot; + (positionStart + itemCount - 1) + &quot;] is not within the position bounds for content items [0 - &quot; + (contentItemCount - 1) + &quot;].&quot;);\n    }\n    notifyItemRangeRemoved(positionStart + headerItemCount, itemCount);\n}\n\n/**\n * Notifies that a footer item is inserted.\n *\n * @param position the position of the content item.\n */\npublic final void notifyFooterItemInserted(int position) {\n    int newHeaderItemCount = getHeaderItemCount();\n    int newContentItemCount = getContentItemCount();\n    int newFooterItemCount = getFooterItemCount();\n    if (position &lt; 0 || position &gt;= newFooterItemCount) {\n        throw new IndexOutOfBoundsException(&quot;The given position &quot; + position + &quot; is not within the position bounds for footer items [0 - &quot; + (newFooterItemCount - 1) + &quot;].&quot;);\n    }\n    notifyItemInserted(position + newHeaderItemCount + newContentItemCount);\n}\n\n/**\n * Notifies that multiple footer items are inserted.\n *\n * @param positionStart the position.\n * @param itemCount     the item count.\n */\npublic final void notifyFooterItemRangeInserted(int positionStart, int itemCount) {\n    int newHeaderItemCount = getHeaderItemCount();\n    int newContentItemCount = getContentItemCount();\n    int newFooterItemCount = getFooterItemCount();\n    if (positionStart &lt; 0 || itemCount &lt; 0 || positionStart + itemCount &gt; newFooterItemCount) {\n        throw new IndexOutOfBoundsException(&quot;The given range [&quot; + positionStart + &quot; - &quot; + (positionStart + itemCount - 1) + &quot;] is not within the position bounds for footer items [0 - &quot; + (newFooterItemCount - 1) + &quot;].&quot;);\n    }\n    notifyItemRangeInserted(positionStart + newHeaderItemCount + newContentItemCount, itemCount);\n}\n\n/**\n * Notifies that a footer item is changed.\n *\n * @param position the position.\n */\npublic final void notifyFooterItemChanged(int position) {\n    if (position &lt; 0 || position &gt;= footerItemCount) {\n        throw new IndexOutOfBoundsException(&quot;The given position &quot; + position + &quot; is not within the position bounds for footer items [0 - &quot; + (footerItemCount - 1) + &quot;].&quot;);\n    }\n    notifyItemChanged(position + headerItemCount + contentItemCount);\n}\n\n/**\n * Notifies that multiple footer items are changed.\n *\n * @param positionStart the position.\n * @param itemCount     the item count.\n */\npublic final void notifyFooterItemRangeChanged(int positionStart, int itemCount) {\n    if (positionStart &lt; 0 || itemCount &lt; 0 || positionStart + itemCount &gt; footerItemCount) {\n        throw new IndexOutOfBoundsException(&quot;The given range [&quot; + positionStart + &quot; - &quot; + (positionStart + itemCount - 1) + &quot;] is not within the position bounds for footer items [0 - &quot; + (footerItemCount - 1) + &quot;].&quot;);\n    }\n    notifyItemRangeChanged(positionStart + headerItemCount + contentItemCount, itemCount);\n}\n\n/**\n * Notifies that an existing footer item is moved to another position.\n *\n * @param fromPosition the original position.\n * @param toPosition   the new position.\n */\npublic final void notifyFooterItemMoved(int fromPosition, int toPosition) {\n    if (fromPosition &lt; 0 || toPosition &lt; 0 || fromPosition &gt;= footerItemCount || toPosition &gt;= footerItemCount) {\n        throw new IndexOutOfBoundsException(&quot;The given fromPosition &quot; + fromPosition + &quot; or toPosition &quot; + toPosition + &quot; is not within the position bounds for footer items [0 - &quot; + (footerItemCount - 1) + &quot;].&quot;);\n    }\n    notifyItemMoved(fromPosition + headerItemCount + contentItemCount, toPosition + headerItemCount + contentItemCount);\n}\n\n/**\n * Notifies that a footer item is removed.\n *\n * @param position the position.\n */\npublic final void notifyFooterItemRemoved(int position) {\n    if (position &lt; 0 || position &gt;= footerItemCount) {\n        throw new IndexOutOfBoundsException(&quot;The given position &quot; + position + &quot; is not within the position bounds for footer items [0 - &quot; + (footerItemCount - 1) + &quot;].&quot;);\n    }\n    notifyItemRemoved(position + headerItemCount + contentItemCount);\n}\n\n/**\n * Notifies that multiple footer items are removed.\n *\n * @param positionStart the position.\n * @param itemCount     the item count.\n */\npublic final void notifyFooterItemRangeRemoved(int positionStart, int itemCount) {\n    if (positionStart &lt; 0 || itemCount &lt; 0 || positionStart + itemCount &gt; footerItemCount) {\n        throw new IndexOutOfBoundsException(&quot;The given range [&quot; + positionStart + &quot; - &quot; + (positionStart + itemCount - 1) + &quot;] is not within the position bounds for footer items [0 - &quot; + (footerItemCount - 1) + &quot;].&quot;);\n    }\n    notifyItemRangeRemoved(positionStart + headerItemCount + contentItemCount, itemCount);\n}\n\n/**\n * Gets the header item view type. By default, this method returns 0.\n *\n * @param position the position.\n * @return the header item view type (within the range [0 - VIEW_TYPE_MAX_COUNT-1]).\n */\nprotected int getHeaderItemViewType(int position) {\n    return 0;\n}\n\n/**\n * Gets the footer item view type. By default, this method returns 0.\n *\n * @param position the position.\n * @return the footer item view type (within the range [0 - VIEW_TYPE_MAX_COUNT-1]).\n */\nprotected int getFooterItemViewType(int position) {\n    return 0;\n}\n\n/**\n * Gets the content item view type. By default, this method returns 0.\n *\n * @param position the position.\n * @return the content item view type (within the range [0 - VIEW_TYPE_MAX_COUNT-1]).\n */\nprotected int getContentItemViewType(int position) {\n    return 0;\n}\n\n/**\n * Gets the header item count. This method can be called several times, so it should not calculate the count every time.\n *\n * @return the header item count.\n */\nprotected abstract int getHeaderItemCount();\n\n/**\n * Gets the footer item count. This method can be called several times, so it should not calculate the count every time.\n *\n * @return the footer item count.\n */\nprotected abstract int getFooterItemCount();\n\n/**\n * Gets the content item count. This method can be called several times, so it should not calculate the count every time.\n *\n * @return the content item count.\n */\nprotected abstract int getContentItemCount();\n\n/**\n * This method works exactly the same as {@link #onCreateViewHolder(android.view.ViewGroup, int)}, but for header items.\n *\n * @param parent         the parent view.\n * @param headerViewType the view type for the header.\n * @return the view holder.\n */\nprotected abstract RecyclerView.ViewHolder onCreateHeaderItemViewHolder(ViewGroup parent, int headerViewType);\n\n/**\n * This method works exactly the same as {@link #onCreateViewHolder(android.view.ViewGroup, int)}, but for footer items.\n *\n * @param parent         the parent view.\n * @param footerViewType the view type for the footer.\n * @return the view holder.\n */\nprotected abstract RecyclerView.ViewHolder onCreateFooterItemViewHolder(ViewGroup parent, int footerViewType);\n\n/**\n * This method works exactly the same as {@link #onCreateViewHolder(android.view.ViewGroup, int)}, but for content items.\n *\n * @param parent          the parent view.\n * @param contentViewType the view type for the content.\n * @return the view holder.\n */\nprotected abstract RecyclerView.ViewHolder onCreateContentItemViewHolder(ViewGroup parent, int contentViewType);\n\n/**\n * This method works exactly the same as {@link #onBindViewHolder(android.support.v7.widget.RecyclerView.ViewHolder, int)}, but for header items.\n *\n * @param headerViewHolder the view holder for the header item.\n * @param position         the position.\n */\nprotected abstract void onBindHeaderItemViewHolder(RecyclerView.ViewHolder headerViewHolder, int position);\n\n/**\n * This method works exactly the same as {@link #onBindViewHolder(android.support.v7.widget.RecyclerView.ViewHolder, int)}, but for footer items.\n *\n * @param footerViewHolder the view holder for the footer item.\n * @param position         the position.\n */\nprotected abstract void onBindFooterItemViewHolder(RecyclerView.ViewHolder footerViewHolder, int position);\n\n/**\n * This method works exactly the same as {@link #onBindViewHolder(android.support.v7.widget.RecyclerView.ViewHolder, int)}, but for content items.\n *\n * @param contentViewHolder the view holder for the content item.\n * @param position          the position.\n */\nprotected abstract void onBindContentItemViewHolder(RecyclerView.ViewHolder contentViewHolder, int position);\n</code></pre><p>}<br>```</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"SnapKit（Masonry）-的使用-杨志平\"><a href=\"#SnapKit（Masonry）-的使用-杨志平\" class=\"headerlink\" title=\"SnapKit（Masonry） 的使用 - 杨志平\"></a>SnapKit（Masonry） 的使用 - 杨志平</h2><blockquote>\n<p>这两个库的用法都是差不多的，只是由两个不同的人来主导开源  <br><br><strong><a href=\"https://github.com/SnapKit/SnapKit\" target=\"_blank\" rel=\"noopener\">SnapKit</a></strong>是Swift版 <br><br><strong><a href=\"https://github.com/SnapKit/Masonry\" target=\"_blank\" rel=\"noopener\">Masonry</a></strong>是OC版    </p>\n<p>自动布局及交互式编程是iOS开发的趋势，同时Swift也会在不久将来替换OC语言。所以现在的iOS开发者可以开始学习Swift2.0 以及应用 Autolayout 来编程</p>\n</blockquote>\n<h3 id=\"代码对比（概况了解）\"><a href=\"#代码对比（概况了解）\" class=\"headerlink\" title=\"代码对比（概况了解）\"></a>代码对比（概况了解）</h3><h5 id=\"开始前OC原生布局代码\"><a href=\"#开始前OC原生布局代码\" class=\"headerlink\" title=\"开始前OC原生布局代码\"></a>开始前OC原生布局代码</h5><pre><code>\n    UIView *superview = self;\n\n    UIView *view1 = [[UIView alloc] init];\n    view1.translatesAutoresizingMaskIntoConstraints = NO;\n    view1.backgroundColor = [UIColor greenColor];\n    [superview addSubview:view1];\n\n    UIEdgeInsets padding = UIEdgeInsetsMake(10, 10, 10, 10);\n\n    [superview addConstraints:@[\n\n    //view1 constraints\n    [NSLayoutConstraint constraintWithItem:view1\n                                 attribute:NSLayoutAttributeTop\n                                 relatedBy:NSLayoutRelationEqual\n                                    toItem:superview\n                                 attribute:NSLayoutAttributeTop\n                                multiplier:1.0\n                                  constant:padding.top],\n\n    [NSLayoutConstraint constraintWithItem:view1\n                                 attribute:NSLayoutAttributeLeft\n                                 relatedBy:NSLayoutRelationEqual\n                                    toItem:superview\n                                 attribute:NSLayoutAttributeLeft\n                                multiplier:1.0\n                                  constant:padding.left],\n\n    [NSLayoutConstraint constraintWithItem:view1\n                                 attribute:NSLayoutAttributeBottom\n                                 relatedBy:NSLayoutRelationEqual\n                                    toItem:superview\n                                 attribute:NSLayoutAttributeBottom\n                                multiplier:1.0\n                                  constant:-padding.bottom],\n\n    [NSLayoutConstraint constraintWithItem:view1\n                                 attribute:NSLayoutAttributeRight\n                                 relatedBy:NSLayoutRelationEqual\n                                    toItem:superview\n                                 attribute:NSLayoutAttributeRight\n                                multiplier:1\n                                  constant:-padding.right],\n     ]];\n</code></pre><h5 id=\"使用Masonry\"><a href=\"#使用Masonry\" class=\"headerlink\" title=\"使用Masonry\"></a>使用Masonry</h5><p>精简</p>\n<pre><code>\n    UIEdgeInsets padding = UIEdgeInsetsMake(10, 10, 10, 10);\n\n    [view1 mas_makeConstraints:^(MASConstraintMaker *make) {\n    make.top.equalTo(superview.mas_top).with.offset(padding.top); //with     is an optional semantic filler\n        make.left.equalTo(superview.mas_left).with.offset(padding.left);\n        make.bottom.equalTo(superview.mas_bottom).with.offset(-    padding.bottom);\n        make.right.equalTo(superview.mas_right).with.offset(-padding.right);\n    }];\n</code></pre><p>更加精简</p>\n<pre><code>    [view1 mas_makeConstraints:^(MASConstraintMaker *make) {\n            make.edges.equalTo(superview).with.insets(padding);\n    }];\n</code></pre><h5 id=\"同理使用SnapKit\"><a href=\"#同理使用SnapKit\" class=\"headerlink\" title=\"同理使用SnapKit\"></a>同理使用SnapKit</h5><p>精简</p>\n<pre><code>\n    let box = UIView()\n    superview.addSubview(box)\n\n    box.snp_makeConstraints { (make) -&gt; Void in\n        make.top.equalTo(superview).offset(20)\n        make.left.equalTo(superview).offset(20)\n        make.bottom.equalTo(superview).offset(-20)\n        make.right.equalTo(superview).offset(-20)\n    }\n</code></pre><p>更加精简</p>\n<pre><code>    box.snp_makeConstraints { (make) -&gt; Void in\n        make.edges.equalTo(superview).inset(UIEdgeInsetsMake(20, 20, 20, 20))\n    }\n</code></pre><h3 id=\"如何使用-amp-amp-原理\"><a href=\"#如何使用-amp-amp-原理\" class=\"headerlink\" title=\"如何使用 &amp;&amp; 原理\"></a>如何使用 &amp;&amp; 原理</h3><h4 id=\"常见的约束类型对比\"><a href=\"#常见的约束类型对比\" class=\"headerlink\" title=\"常见的约束类型对比\"></a>常见的约束类型对比</h4><table>\n<thead>\n<tr>\n<th>ViewAttribute</th>\n<th>NSLayoutAttribute</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>view.snp_left</td>\n<td>NSLayoutAttribute.Left</td>\n</tr>\n<tr>\n<td>view.snp_right</td>\n<td>NSLayoutAttribute.Right</td>\n</tr>\n<tr>\n<td>view.snp_top</td>\n<td>NSLayoutAttribute.Top</td>\n</tr>\n<tr>\n<td>view.snp_bottom</td>\n<td>NSLayoutAttribute.Bottom</td>\n</tr>\n<tr>\n<td>view.snp_leading</td>\n<td>NSLayoutAttribute.Leading</td>\n</tr>\n<tr>\n<td>view.snp_trailing</td>\n<td>NSLayoutAttribute.Trailing</td>\n</tr>\n<tr>\n<td>view.snp_width</td>\n<td>NSLayoutAttribute.Width</td>\n</tr>\n<tr>\n<td>view.snp_height</td>\n<td>NSLayoutAttribute.Height</td>\n</tr>\n<tr>\n<td>view.snp_centerX</td>\n<td>NSLayoutAttribute.CenterX</td>\n</tr>\n<tr>\n<td>view.snp_centerY</td>\n<td>NSLayoutAttribute.CenterY</td>\n</tr>\n<tr>\n<td>view.snp_baseline</td>\n<td>NSLayoutAttribute.Baseline</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"常见的用法\"><a href=\"#常见的用法\" class=\"headerlink\" title=\"常见的用法\"></a>常见的用法</h4><pre><code>make.top.equalTo(42)\nmake.lessThanOrEqualTo.equalTo(SuperView)\nmake.top.equalTo(SuperView)\nmake.size.equalTo(CGSizeMake(50, 100))\nmake.edges.equalTo(UIEdgeInsetsMake(10, 0, 10, 0))\nmake.left.equalTo(view).offset(UIEdgeInsetsMake(10, 0, 10, 0))\n\nmake.height.equalTo(OtherView).offset(10)\nmake.trailing.equalTo(OtherView.snp_trailing).offset(10)\nmake.bottom.equalTo(-20).priority(250)\n</code></pre><h4 id=\"对比交互式编程的约束布局\"><a href=\"#对比交互式编程的约束布局\" class=\"headerlink\" title=\"对比交互式编程的约束布局\"></a>对比交互式编程的约束布局</h4><p><img src=\"https://cloud.githubusercontent.com/assets/9360037/9401926/1e572316-4809-11e5-9a96-430e688cda85.png\" alt=\"image\"></p>\n<hr>\n<h2 id=\"JSONModel-for-swift-的探索-曾铭\"><a href=\"#JSONModel-for-swift-的探索-曾铭\" class=\"headerlink\" title=\"JSONModel for swift 的探索 - 曾铭\"></a>JSONModel for swift 的探索 - 曾铭</h2><pre><code>// 可在 Playground 中尝试\nimport Foundation\nimport UIKit\n\n\n// 基本的类型转换\nlet a:String = &quot;&quot;\nlet b = &quot;&quot;\nvar c:String? = nil\nc = &quot;test&quot;\n\nlet d:String = c as String!\nvar e = Int(c!)\ne = Int(&quot;123&quot;)\n\nvar f = Int(&quot;123&quot;)!\n\nprint(&quot;a type:\\(a.dynamicType)&quot;)\nprint(&quot;b type:\\(b.dynamicType)&quot;)\nprint(&quot;c type:\\(c.dynamicType)&quot;)\nprint(&quot;d type:\\(d.dynamicType)&quot;)\nprint(&quot;e type:\\(e.dynamicType)&quot;)\nprint(&quot;f type:\\(f.dynamicType)\\n&quot;)\n\n\n// KVC for NSObject\n\nclass FooKVC : NSObject {\n    var p1 : String = &quot;s&quot;\n}\n\nlet fk1 = FooKVC()\n\nfk1.p1\n\nfk1.setValue(&quot;y&quot;, forKey: &quot;p1&quot;)\n\nfk1.p1\n\n// reflect for swift2.0\n\nclass A\n{\n    var name = &quot;namevalue&quot;\n    var age = 123\n    var some:(String, Int) = (&quot;ming&quot;, 2)\n}\n\nlet a1 = A()\n\na1.age = 456\n\na1.age\n\n\nlet r = Mirror(reflecting: a1)\nfor c in r.children {\n    print(c.label.dynamicType)\n    print(c.label)\n    print(c.value.dynamicType)\n    print(c.value)\n    print(&quot;===&quot;)\n}\n</code></pre><ul>\n<li>KVO for NSObject 略, 注意监听者与被监听者都要是 NSObject 子类</li>\n</ul>\n<h3 id=\"JSONModel-for-swift\"><a href=\"#JSONModel-for-swift\" class=\"headerlink\" title=\"JSONModel for swift?\"></a>JSONModel for swift?</h3><p>&gt;<br>NB: Swift works in a different way under the hood than Objective-C. Therefore I can’t find a way to re-create JSONModel in Swift. JSONModel in Objective-C works in Swift apps through CocoaPods or as an imported Objective-C library.</p>\n<h3 id=\"JSONModel-做的事情\"><a href=\"#JSONModel-做的事情\" class=\"headerlink\" title=\"JSONModel 做的事情\"></a>JSONModel 做的事情</h3><ul>\n<li>String(NSData) -&gt; Dictionary(Array)</li>\n<li>Dictionary(Array) -&gt; Model-Object</li>\n</ul>\n<h3 id=\"对应实现\"><a href=\"#对应实现\" class=\"headerlink\" title=\"对应实现\"></a>对应实现</h3><ul>\n<li>容易:<ul>\n<li>swift 容器取值的坑 <a href=\"https://github.com/SwiftyJSON/SwiftyJSON\" target=\"_blank\" rel=\"noopener\">https://github.com/SwiftyJSON/SwiftyJSON</a></li>\n</ul>\n</li>\n<li>swift 反射不支持赋值，没办法<ul>\n<li>通过 NSObject KVC 解决 <a href=\"https://github.com/PonyCui/PPJSONSerialization\" target=\"_blank\" rel=\"noopener\">https://github.com/PonyCui/PPJSONSerialization</a></li>\n<li>临时方案？</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h3><ul>\n<li><a href=\"https://github.com/leemorgan/Swift-KVC/blob/master/KVC%20Playground.playground/Contents.swift\" target=\"_blank\" rel=\"noopener\">Swift-KVC (just <code>valueForKey:</code>)</a></li>\n<li><a href=\"http://www.jianshu.com/p/e036e53d240e\" target=\"_blank\" rel=\"noopener\">Swift: KVO 注意事项和属性观察器</a></li>\n<li><a href=\"http://stackoverflow.com/questions/24844681/list-of-classs-properties-in-swift\" target=\"_blank\" rel=\"noopener\">List of class’s properties in swift</a></li>\n</ul>\n<hr>\n<h2 id=\"RATreeView的简单使用-张超耀\"><a href=\"#RATreeView的简单使用-张超耀\" class=\"headerlink\" title=\"RATreeView的简单使用 - 张超耀\"></a>RATreeView的简单使用 - 张超耀</h2><h3 id=\"RATreeView-实现树形结构的TableView；点击每个cell，都可以展开出现新的cell；可以自定义树的层数\"><a href=\"#RATreeView-实现树形结构的TableView；点击每个cell，都可以展开出现新的cell；可以自定义树的层数\" class=\"headerlink\" title=\"RATreeView:实现树形结构的TableView；点击每个cell，都可以展开出现新的cell；可以自定义树的层数\"></a>RATreeView:实现树形结构的TableView；点击每个cell，都可以展开出现新的cell；可以自定义树的层数</h3><p><img src=\"https://camo.githubusercontent.com/87d3db881cf57dba674a89a6e1460c00277245b3/68747470733a2f2f7261772e6769746875622e636f6d2f417567757374796e69616b2f524154726565566965772f6d61737465722f53637265656e732f616e696d6174696f6e2e676966\" alt></p>\n<h3 id=\"主要方法介绍\"><a href=\"#主要方法介绍\" class=\"headerlink\" title=\"主要方法介绍\"></a>主要方法介绍</h3><ul>\n<li>cell的高度<br><code>-(CGFloat)treeView:(RATreeView *)treeView heightForRowForItem:(id)item treeNodeInfo:(RATreeNodeInfo *)treeNodeInfo</code></li>\n<li>这个函数决定是否可以展开，通过设定我们可以设置哪些单元格可以展开到下一层，哪些不可以展开<br><code>- (BOOL)treeView:(RATreeView *)treeView shouldExpandItem:(id)item treeNodeInfo:(RATreeNodeInfo *)treeNodeInfo</code> </li>\n<li><p>这个看字面意识就理解了，在单元格显示之前（或者说将要显示时）我们可以做些设置，这里是设置相应深度的颜色背景<br><code>- (void)treeView:(RATreeView *)treeView willDisplayCell:(UITableViewCell *)cell forItem:(id)item treeNodeInfo:(RATreeNodeInfo *)treeNodeInfo</code></p>\n</li>\n<li><p>这里就是我们最熟悉的点击cell处理函数，看代码慢慢体会treeNodeInfo的使用，不想多说了<br><code>-(void)treeView:(RATreeView *)treeView didSelectRowForItem:(id)item treeNodeInfo:(RATreeNodeInfo *)treeNodeInfo</code></p>\n</li>\n<li>数据源处理，相当于UITableViewCell处理，关键还是理解treeNodeInfo概念<br><code>- (UITableViewCell *)treeView:(RATreeView *)treeView cellForItem:(id)item treeNodeInfo:(RATreeNodeInfo *)treeNodeInfo</code></li>\n<li>返回每一层包含成员的个数，来制表<br><code>- (NSInteger)treeView:(RATreeView *)treeView numberOfChildrenOfItem:(id)item</code></li>\n<li>返回cell对象<br><code>- (id)treeView:(RATreeView *)treeView child:(NSInteger)index ofItem:(id)item</code><h3 id=\"RATreeView-github\"><a href=\"#RATreeView-github\" class=\"headerlink\" title=\"RATreeView - github\"></a><a href=\"https://github.com/Augustyniak/RATreeView\" target=\"_blank\" rel=\"noopener\">RATreeView - github</a></h3></li>\n</ul>\n<hr>\n<h2 id=\"Facebook-开源的图片加载库Fresco-王胜\"><a href=\"#Facebook-开源的图片加载库Fresco-王胜\" class=\"headerlink\" title=\"Facebook 开源的图片加载库Fresco - 王胜\"></a>Facebook 开源的图片加载库Fresco - 王胜</h2><h3 id=\"Fresco诞生背景\"><a href=\"#Fresco诞生背景\" class=\"headerlink\" title=\"Fresco诞生背景\"></a>Fresco诞生背景</h3><p>为提高Android中图片的加载速度，一般的图片库都采用了三级缓存：Memory Cache、Disk Cache和Network。但是，Android的系统层是将物理内存平均分配给每一个App。这样每个App所分配的空间都是有限的，早起的android设备，每个App只被分配16MB空间，这样，如果App中使用大量的图片，那么很容易因OOM而Crashes掉。Facebook App正是大量使用图片的App，面临这个问题刻不容缓，所以他们历尽艰难，开发了Fresco图片加载库。 </p>\n<h3 id=\"Fresco诞生过程\"><a href=\"#Fresco诞生过程\" class=\"headerlink\" title=\"Fresco诞生过程\"></a>Fresco诞生过程</h3><h4 id=\"内存区域分析：\"><a href=\"#内存区域分析：\" class=\"headerlink\" title=\"内存区域分析：\"></a>内存区域分析：</h4><ul>\n<li><p>Java heap</p>\n<p>每个厂商会为App分配一个固定尺寸的运行空间。所有的申请通过Java的new操作申请，操作相对安全，通过GC内存自动回收保证内存不被泄露。但不幸的时，GC不够精确化，回收得不够及时。因此还是会存在OOM。</p>\n</li>\n<li><p>Native heap</p>\n<p>通过C或者C++可绕过Java虚拟机直接操作物理内存，但Java程序员习惯了GC的自动回收，很难操作C++的手动操作内存。</p>\n</li>\n<li><p>Ashmen</p>\n<p>Android还有一块内存区域，叫Ashmen。这里的操作很像Nativew heap，但是这里是系统调用的。Java 应用程序是不能直接访问Ashmen的，但是一些例外的情况可以操作，图片就是一种例外。</p>\n<pre><code class=\"Java\">BitmapFactory.Options = new BitmapFactory.Options();\noptions.inPurgeable = true;\nBitmap bitmap = BitmapFactory.decodeByteArray(jpeg, 0, jpeg.length, options);\n</code></pre>\n</li>\n</ul>\n<h4 id=\"难点突破：\"><a href=\"#难点突破：\" class=\"headerlink\" title=\"难点突破：\"></a>难点突破：</h4><p>尽管发现了Purgeable bitmaps，但是这个解码的过程是在UI线程操作的，因此他们又采用了异步实现，并保证了UI线程不引用时，unpin的区域不会被释放。</p>\n<h4 id=\"上层构建\"><a href=\"#上层构建\" class=\"headerlink\" title=\"上层构建\"></a>上层构建</h4><p>提供给上层调用时，采用了MVC的架构：</p>\n<ul>\n<li>Model：DraweeHierarchy</li>\n<li>Control：DraweeControllers</li>\n<li>View：DraweeViews</li>\n</ul>\n<h3 id=\"使用示例\"><a href=\"#使用示例\" class=\"headerlink\" title=\"使用示例\"></a>使用示例</h3><ol>\n<li><p>gradle配置中添加库引用</p>\n<pre><code>compile &#39;com.facebook.fresco:fresco:0.6.1+&#39;\n</code></pre></li>\n<li><p>xml中添加组件</p>\n<pre><code class=\"XML\">&lt;com.facebook.drawee.view.SimpleDraweeView\n     android:id=&quot;@+id/sdv&quot;\n     android:layout_width=&quot;match_parent&quot;\n     android:layout_height=&quot;match_parent&quot;\n     fresco:roundAsCircle=&quot;true&quot;\n     fresco:roundingBorderWidth=&quot;1dp&quot;\n     fresco:roundingBorderColor=&quot;#00ff00&quot;\n</code></pre>\n</li>\n<li><p>代码中指定图片地址</p>\n<pre><code class=\"Java\">SimpleDraweeView sdv = (SimpleDraweeView) findViewById(R.id.sdv);\nsdv.setImageURI(Uri.parse(&quot;http://g.hiphotos.baidu.com/image/pic/item/2e2eb9389b504fc2b351980be7dde71190ef6db5.jpg&quot;));\n</code></pre>\n</li>\n</ol>\n<h3 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h3><ul>\n<li><a href=\"https://code.facebook.com/posts/366199913563917/introducing-fresco-a-new-image-library-for-android/\" target=\"_blank\" rel=\"noopener\">Fresco的由来</a></li>\n<li><a href=\"http://github.com/facebook/fresco\" target=\"_blank\" rel=\"noopener\">Fresco的源码托管</a></li>\n<li><a href=\"http://fresco-cn.org/docs/index.html\" target=\"_blank\" rel=\"noopener\">中文使用手册</a></li>\n</ul>\n<hr>\n<p>#SIAlertView 阅读 - 潘君</p>\n<ul>\n<li>创建自定义alert view的流程</li>\n</ul>\n<p>自定义window-&gt;添加自定义view controller-&gt;定制view-&gt;view引用window</p>\n<ul>\n<li><p>@class</p>\n<pre><code>@class SIAlertView;\n</code></pre><p>能不使用import的就不使用<br>用@class代替</p>\n</li>\n<li><p>通知 和 Block</p>\n</li>\n<li><p>层级</p>\n<pre><code>const UIWindowLevel UIWindowLevelSIAlert = 1996.0;  // don&#39;t overlap system&#39;s alert\nconst UIWindowLevel UIWindowLevelSIAlertBackground = 1985.0; // below the alert window\n</code></pre></li>\n<li><p>UIViewTintAdjustmentMode<br>通过获取keyWindow的<code>UIViewTintAdjustmentMode</code>来设置alertWindow的<br>该属性能够设置tint的调整模式</p>\n<pre><code>typedef enum {\n   // 和父视图的一样\n   UIViewTintAdjustmentModeAutomatic,              \n   // 不对tintColor做任何修改\n   UIViewTintAdjustmentModeNormal,\n   // 在原有tintColor基础上变暗\n   UIViewTintAdjustmentModeDimmed,}UIViewTintAdjustmentMode;\n</code></pre></li>\n</ul>\n<ul>\n<li><p>iOS特有版本代码</p>\n<pre><code>#ifdef __IPHONE_7_0\n//some code \n#endif\n此处填写iOS7才能运行的代码\n</code></pre></li>\n<li><p>initialize<br>```</p>\n</li>\n</ul>\n<ul>\n<li><p>(void)initialize<br>{<br>  if (self != [SIAlertView class])</p>\n<pre><code>  return;\n</code></pre><p>  // 默认值赋值<br>}</p>\n</li>\n</ul>\n<p>一些值放在+(void)initialize；中赋值为默认值，这样不管通过何种方式初始化</p>\n<pre><code>\n- UIAppearance\nSIAlertView *appearance = [self appearance];\nUIView符合UIAppearence协议，能够全局修改所有实例的UI\n\n- 调用Bundle中资源\n[UIImage imageNamed:@&quot;SIAlertView.bundle/button-default&quot;]\nbundle中资源的调用方法\n\n\n- _cmd\noc特有的方法，无法通过c语言获取\n\n-  [self invalidateLayout]\n\n- 合理利用循环引用\n</code></pre><pre><code>if (!self.alertWindow) {\n    UIWindow *window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds];\n    window.autoresizingMask = UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleHeight;\n    window.opaque = NO;\n    window.windowLevel = UIWindowLevelSIAlert;\n    window.rootViewController = viewController;\n    self.alertWindow = window;\n}\n</code></pre><pre><code>\n- oldKeyWindow\n通知alert后面的视图转变方向\n取用一些oldKeyWindow的值\n\n----\n\n## android饼图库 -吴明\n- 饼图选择\n    - [AChartEngine](https://github.com/jondwillis/AChartEngine/tree/master/achartengine):(太丑了)\n    - [xcl-charts](https://github.com/xcltapestry/XCL-Charts):(接口文档没有)\n    - [HelloCharts](https://github.com/lecho/hellocharts-android):(接口文档没有)\n    - [MPAndroidChart](https://github.com/PhilJay/MPAndroidChart):(接口文档多)\n- [MPAndroidChart](https://github.com/PhilJay/MPAndroidChart)\n    - ![Alt Image Text](https://camo.githubusercontent.com/7e8a4a3c938c21d032d44d999edd781b6e146f2a/68747470733a2f2f7261772e6769746875622e636f6d2f5068696c4a61792f4d50416e64726f696443686172742f6d61737465722f73637265656e73686f74732f73696d706c6564657369676e5f7069656368617274312e706e67)\n    - 饼图对象:PieChat\n    - [详见接口文档](https://github.com/PhilJay/MPAndroidChart/wiki)\n\n\n---- \n\n## HeaderFooterRecyclerViewAdapter——李仙鹏\n[HeaderFooterRecyclerViewAdapter](https://gist.github.com/mheras/0908873267def75dc746)，用于RecyclerView。可方便的添加header或者footer。使用非常简单，只需要按照实际需求，在对应的header、content、footer相关方法进行重写即可。\n\n附上源码\n</code></pre><p>public abstract class HeaderFooterRecyclerViewAdapter extends RecyclerView.Adapter<recyclerview.viewholder> {</recyclerview.viewholder></p>\n<pre><code>private static final int VIEW_TYPE_MAX_COUNT = 1000;\nprivate static final int HEADER_VIEW_TYPE_OFFSET = 0;\nprivate static final int FOOTER_VIEW_TYPE_OFFSET = HEADER_VIEW_TYPE_OFFSET + VIEW_TYPE_MAX_COUNT;\nprivate static final int CONTENT_VIEW_TYPE_OFFSET = FOOTER_VIEW_TYPE_OFFSET + VIEW_TYPE_MAX_COUNT;\n\nprivate int headerItemCount;\nprivate int contentItemCount;\nprivate int footerItemCount;\n\n/**\n * {@inheritDoc}\n */\n@Override\npublic final RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {\n\n    // Delegate to proper methods based on the viewType ranges.\n    if (viewType &gt;= HEADER_VIEW_TYPE_OFFSET &amp;&amp; viewType &lt; HEADER_VIEW_TYPE_OFFSET + VIEW_TYPE_MAX_COUNT) {\n        return onCreateHeaderItemViewHolder(parent, viewType - HEADER_VIEW_TYPE_OFFSET);\n    } else if (viewType &gt;= FOOTER_VIEW_TYPE_OFFSET &amp;&amp; viewType &lt; FOOTER_VIEW_TYPE_OFFSET + VIEW_TYPE_MAX_COUNT) {\n        return onCreateFooterItemViewHolder(parent, viewType - FOOTER_VIEW_TYPE_OFFSET);\n    } else if (viewType &gt;= CONTENT_VIEW_TYPE_OFFSET &amp;&amp; viewType &lt; CONTENT_VIEW_TYPE_OFFSET + VIEW_TYPE_MAX_COUNT) {\n        return onCreateContentItemViewHolder(parent, viewType - CONTENT_VIEW_TYPE_OFFSET);\n    } else {\n        // This shouldn&#39;t happen as we check that the viewType provided by the client is valid.\n        throw new IllegalStateException();\n    }\n}\n\n/**\n * {@inheritDoc}\n */\n@Override\npublic final void onBindViewHolder(RecyclerView.ViewHolder viewHolder, int position) {\n    // Delegate to proper methods based on the viewType ranges.\n    if (headerItemCount &gt; 0 &amp;&amp; position &lt; headerItemCount) {\n        onBindHeaderItemViewHolder(viewHolder, position);\n    } else if (contentItemCount &gt; 0 &amp;&amp; position - headerItemCount &lt; contentItemCount) {\n        onBindContentItemViewHolder(viewHolder, position - headerItemCount);\n    } else {\n        onBindFooterItemViewHolder(viewHolder, position - headerItemCount - contentItemCount);\n    }\n}\n\n/**\n * {@inheritDoc}\n */\n@Override\npublic final int getItemCount() {\n    // Cache the counts and return the sum of them.\n    headerItemCount = getHeaderItemCount();\n    contentItemCount = getContentItemCount();\n    footerItemCount = getFooterItemCount();\n    return headerItemCount + contentItemCount + footerItemCount;\n}\n\n/**\n * {@inheritDoc}\n */\n@Override\npublic final int getItemViewType(int position) {\n    // Delegate to proper methods based on the position, but validate first.\n    if (headerItemCount &gt; 0 &amp;&amp; position &lt; headerItemCount) {\n        return validateViewType(getHeaderItemViewType(position)) + HEADER_VIEW_TYPE_OFFSET;\n    } else if (contentItemCount &gt; 0 &amp;&amp; position - headerItemCount &lt; contentItemCount) {\n        return validateViewType(getContentItemViewType(position - headerItemCount)) + CONTENT_VIEW_TYPE_OFFSET;\n    } else {\n        return validateViewType(getFooterItemViewType(position - headerItemCount - contentItemCount)) + FOOTER_VIEW_TYPE_OFFSET;\n    }\n}\n\n/**\n * Validates that the view type is within the valid range.\n *\n * @param viewType the view type.\n * @return the given view type.\n */\nprivate int validateViewType(int viewType) {\n    if (viewType &lt; 0 || viewType &gt;= VIEW_TYPE_MAX_COUNT) {\n        throw new IllegalStateException(&quot;viewType must be between 0 and &quot; + VIEW_TYPE_MAX_COUNT);\n    }\n    return viewType;\n}\n\n/**\n * Notifies that a header item is inserted.\n *\n * @param position the position of the header item.\n */\npublic final void notifyHeaderItemInserted(int position) {\n    int newHeaderItemCount = getHeaderItemCount();\n    if (position &lt; 0 || position &gt;= newHeaderItemCount) {\n        throw new IndexOutOfBoundsException(&quot;The given position &quot; + position + &quot; is not within the position bounds for header items [0 - &quot; + (newHeaderItemCount - 1) + &quot;].&quot;);\n    }\n    notifyItemInserted(position);\n}\n\n/**\n * Notifies that multiple header items are inserted.\n *\n * @param positionStart the position.\n * @param itemCount     the item count.\n */\npublic final void notifyHeaderItemRangeInserted(int positionStart, int itemCount) {\n    int newHeaderItemCount = getHeaderItemCount();\n    if (positionStart &lt; 0 || itemCount &lt; 0 || positionStart + itemCount &gt; newHeaderItemCount) {\n        throw new IndexOutOfBoundsException(&quot;The given range [&quot; + positionStart + &quot; - &quot; + (positionStart + itemCount - 1) + &quot;] is not within the position bounds for header items [0 - &quot; + (newHeaderItemCount - 1) + &quot;].&quot;);\n    }\n    notifyItemRangeInserted(positionStart, itemCount);\n}\n\n/**\n * Notifies that a header item is changed.\n *\n * @param position the position.\n */\npublic final void notifyHeaderItemChanged(int position) {\n    if (position &lt; 0 || position &gt;= headerItemCount) {\n        throw new IndexOutOfBoundsException(&quot;The given position &quot; + position + &quot; is not within the position bounds for header items [0 - &quot; + (headerItemCount - 1) + &quot;].&quot;);\n    }\n    notifyItemChanged(position);\n}\n\n/**\n * Notifies that multiple header items are changed.\n *\n * @param positionStart the position.\n * @param itemCount     the item count.\n */\npublic final void notifyHeaderItemRangeChanged(int positionStart, int itemCount) {\n    if (positionStart &lt; 0 || itemCount &lt; 0 || positionStart + itemCount &gt;= headerItemCount) {\n        throw new IndexOutOfBoundsException(&quot;The given range [&quot; + positionStart + &quot; - &quot; + (positionStart + itemCount - 1) + &quot;] is not within the position bounds for header items [0 - &quot; + (headerItemCount - 1) + &quot;].&quot;);\n    }\n    notifyItemRangeChanged(positionStart, itemCount);\n}\n\n\n/**\n * Notifies that an existing header item is moved to another position.\n *\n * @param fromPosition the original position.\n * @param toPosition   the new position.\n */\npublic void notifyHeaderItemMoved(int fromPosition, int toPosition) {\n    if (fromPosition &lt; 0 || toPosition &lt; 0 || fromPosition &gt;= headerItemCount || toPosition &gt;= headerItemCount) {\n        throw new IndexOutOfBoundsException(&quot;The given fromPosition &quot; + fromPosition + &quot; or toPosition &quot; + toPosition + &quot; is not within the position bounds for header items [0 - &quot; + (headerItemCount - 1) + &quot;].&quot;);\n    }\n    notifyItemMoved(fromPosition, toPosition);\n}\n\n/**\n * Notifies that a header item is removed.\n *\n * @param position the position.\n */\npublic void notifyHeaderItemRemoved(int position) {\n    if (position &lt; 0 || position &gt;= headerItemCount) {\n        throw new IndexOutOfBoundsException(&quot;The given position &quot; + position + &quot; is not within the position bounds for header items [0 - &quot; + (headerItemCount - 1) + &quot;].&quot;);\n    }\n    notifyItemRemoved(position);\n}\n\n/**\n * Notifies that multiple header items are removed.\n *\n * @param positionStart the position.\n * @param itemCount     the item count.\n */\npublic void notifyHeaderItemRangeRemoved(int positionStart, int itemCount) {\n    if (positionStart &lt; 0 || itemCount &lt; 0 || positionStart + itemCount &gt; headerItemCount) {\n        throw new IndexOutOfBoundsException(&quot;The given range [&quot; + positionStart + &quot; - &quot; + (positionStart + itemCount - 1) + &quot;] is not within the position bounds for header items [0 - &quot; + (headerItemCount - 1) + &quot;].&quot;);\n    }\n    notifyItemRangeRemoved(positionStart, itemCount);\n}\n\n/**\n * Notifies that a content item is inserted.\n *\n * @param position the position of the content item.\n */\npublic final void notifyContentItemInserted(int position) {\n    int newHeaderItemCount = getHeaderItemCount();\n    int newContentItemCount = getContentItemCount();\n    if (position &lt; 0 || position &gt;= newContentItemCount) {\n        throw new IndexOutOfBoundsException(&quot;The given position &quot; + position + &quot; is not within the position bounds for content items [0 - &quot; + (newContentItemCount - 1) + &quot;].&quot;);\n    }\n    notifyItemInserted(position + newHeaderItemCount);\n}\n\n/**\n * Notifies that multiple content items are inserted.\n *\n * @param positionStart the position.\n * @param itemCount     the item count.\n */\npublic final void notifyContentItemRangeInserted(int positionStart, int itemCount) {\n    int newHeaderItemCount = getHeaderItemCount();\n    int newContentItemCount = getContentItemCount();\n    if (positionStart &lt; 0 || itemCount &lt; 0 || positionStart + itemCount &gt; newContentItemCount) {\n        throw new IndexOutOfBoundsException(&quot;The given range [&quot; + positionStart + &quot; - &quot; + (positionStart + itemCount - 1) + &quot;] is not within the position bounds for content items [0 - &quot; + (newContentItemCount - 1) + &quot;].&quot;);\n    }\n    notifyItemRangeInserted(positionStart + newHeaderItemCount, itemCount);\n}\n\n/**\n * Notifies that a content item is changed.\n *\n * @param position the position.\n */\npublic final void notifyContentItemChanged(int position) {\n    if (position &lt; 0 || position &gt;= contentItemCount) {\n        throw new IndexOutOfBoundsException(&quot;The given position &quot; + position + &quot; is not within the position bounds for content items [0 - &quot; + (contentItemCount - 1) + &quot;].&quot;);\n    }\n    notifyItemChanged(position + headerItemCount);\n}\n\n/**\n * Notifies that multiple content items are changed.\n *\n * @param positionStart the position.\n * @param itemCount     the item count.\n */\npublic final void notifyContentItemRangeChanged(int positionStart, int itemCount) {\n    if (positionStart &lt; 0 || itemCount &lt; 0 || positionStart + itemCount &gt; contentItemCount) {\n        throw new IndexOutOfBoundsException(&quot;The given range [&quot; + positionStart + &quot; - &quot; + (positionStart + itemCount - 1) + &quot;] is not within the position bounds for content items [0 - &quot; + (contentItemCount - 1) + &quot;].&quot;);\n    }\n    notifyItemRangeChanged(positionStart + headerItemCount, itemCount);\n}\n\n/**\n * Notifies that an existing content item is moved to another position.\n *\n * @param fromPosition the original position.\n * @param toPosition   the new position.\n */\npublic final void notifyContentItemMoved(int fromPosition, int toPosition) {\n    if (fromPosition &lt; 0 || toPosition &lt; 0 || fromPosition &gt;= contentItemCount || toPosition &gt;= contentItemCount) {\n        throw new IndexOutOfBoundsException(&quot;The given fromPosition &quot; + fromPosition + &quot; or toPosition &quot; + toPosition + &quot; is not within the position bounds for content items [0 - &quot; + (contentItemCount - 1) + &quot;].&quot;);\n    }\n    notifyItemMoved(fromPosition + headerItemCount, toPosition + headerItemCount);\n}\n\n/**\n * Notifies that a content item is removed.\n *\n * @param position the position.\n */\npublic final void notifyContentItemRemoved(int position) {\n    if (position &lt; 0 || position &gt;= contentItemCount) {\n        throw new IndexOutOfBoundsException(&quot;The given position &quot; + position + &quot; is not within the position bounds for content items [0 - &quot; + (contentItemCount - 1) + &quot;].&quot;);\n    }\n    notifyItemRemoved(position + headerItemCount);\n}\n\n/**\n * Notifies that multiple content items are removed.\n *\n * @param positionStart the position.\n * @param itemCount     the item count.\n */\npublic final void notifyContentItemRangeRemoved(int positionStart, int itemCount) {\n    if (positionStart &lt; 0 || itemCount &lt; 0 || positionStart + itemCount &gt; contentItemCount) {\n        throw new IndexOutOfBoundsException(&quot;The given range [&quot; + positionStart + &quot; - &quot; + (positionStart + itemCount - 1) + &quot;] is not within the position bounds for content items [0 - &quot; + (contentItemCount - 1) + &quot;].&quot;);\n    }\n    notifyItemRangeRemoved(positionStart + headerItemCount, itemCount);\n}\n\n/**\n * Notifies that a footer item is inserted.\n *\n * @param position the position of the content item.\n */\npublic final void notifyFooterItemInserted(int position) {\n    int newHeaderItemCount = getHeaderItemCount();\n    int newContentItemCount = getContentItemCount();\n    int newFooterItemCount = getFooterItemCount();\n    if (position &lt; 0 || position &gt;= newFooterItemCount) {\n        throw new IndexOutOfBoundsException(&quot;The given position &quot; + position + &quot; is not within the position bounds for footer items [0 - &quot; + (newFooterItemCount - 1) + &quot;].&quot;);\n    }\n    notifyItemInserted(position + newHeaderItemCount + newContentItemCount);\n}\n\n/**\n * Notifies that multiple footer items are inserted.\n *\n * @param positionStart the position.\n * @param itemCount     the item count.\n */\npublic final void notifyFooterItemRangeInserted(int positionStart, int itemCount) {\n    int newHeaderItemCount = getHeaderItemCount();\n    int newContentItemCount = getContentItemCount();\n    int newFooterItemCount = getFooterItemCount();\n    if (positionStart &lt; 0 || itemCount &lt; 0 || positionStart + itemCount &gt; newFooterItemCount) {\n        throw new IndexOutOfBoundsException(&quot;The given range [&quot; + positionStart + &quot; - &quot; + (positionStart + itemCount - 1) + &quot;] is not within the position bounds for footer items [0 - &quot; + (newFooterItemCount - 1) + &quot;].&quot;);\n    }\n    notifyItemRangeInserted(positionStart + newHeaderItemCount + newContentItemCount, itemCount);\n}\n\n/**\n * Notifies that a footer item is changed.\n *\n * @param position the position.\n */\npublic final void notifyFooterItemChanged(int position) {\n    if (position &lt; 0 || position &gt;= footerItemCount) {\n        throw new IndexOutOfBoundsException(&quot;The given position &quot; + position + &quot; is not within the position bounds for footer items [0 - &quot; + (footerItemCount - 1) + &quot;].&quot;);\n    }\n    notifyItemChanged(position + headerItemCount + contentItemCount);\n}\n\n/**\n * Notifies that multiple footer items are changed.\n *\n * @param positionStart the position.\n * @param itemCount     the item count.\n */\npublic final void notifyFooterItemRangeChanged(int positionStart, int itemCount) {\n    if (positionStart &lt; 0 || itemCount &lt; 0 || positionStart + itemCount &gt; footerItemCount) {\n        throw new IndexOutOfBoundsException(&quot;The given range [&quot; + positionStart + &quot; - &quot; + (positionStart + itemCount - 1) + &quot;] is not within the position bounds for footer items [0 - &quot; + (footerItemCount - 1) + &quot;].&quot;);\n    }\n    notifyItemRangeChanged(positionStart + headerItemCount + contentItemCount, itemCount);\n}\n\n/**\n * Notifies that an existing footer item is moved to another position.\n *\n * @param fromPosition the original position.\n * @param toPosition   the new position.\n */\npublic final void notifyFooterItemMoved(int fromPosition, int toPosition) {\n    if (fromPosition &lt; 0 || toPosition &lt; 0 || fromPosition &gt;= footerItemCount || toPosition &gt;= footerItemCount) {\n        throw new IndexOutOfBoundsException(&quot;The given fromPosition &quot; + fromPosition + &quot; or toPosition &quot; + toPosition + &quot; is not within the position bounds for footer items [0 - &quot; + (footerItemCount - 1) + &quot;].&quot;);\n    }\n    notifyItemMoved(fromPosition + headerItemCount + contentItemCount, toPosition + headerItemCount + contentItemCount);\n}\n\n/**\n * Notifies that a footer item is removed.\n *\n * @param position the position.\n */\npublic final void notifyFooterItemRemoved(int position) {\n    if (position &lt; 0 || position &gt;= footerItemCount) {\n        throw new IndexOutOfBoundsException(&quot;The given position &quot; + position + &quot; is not within the position bounds for footer items [0 - &quot; + (footerItemCount - 1) + &quot;].&quot;);\n    }\n    notifyItemRemoved(position + headerItemCount + contentItemCount);\n}\n\n/**\n * Notifies that multiple footer items are removed.\n *\n * @param positionStart the position.\n * @param itemCount     the item count.\n */\npublic final void notifyFooterItemRangeRemoved(int positionStart, int itemCount) {\n    if (positionStart &lt; 0 || itemCount &lt; 0 || positionStart + itemCount &gt; footerItemCount) {\n        throw new IndexOutOfBoundsException(&quot;The given range [&quot; + positionStart + &quot; - &quot; + (positionStart + itemCount - 1) + &quot;] is not within the position bounds for footer items [0 - &quot; + (footerItemCount - 1) + &quot;].&quot;);\n    }\n    notifyItemRangeRemoved(positionStart + headerItemCount + contentItemCount, itemCount);\n}\n\n/**\n * Gets the header item view type. By default, this method returns 0.\n *\n * @param position the position.\n * @return the header item view type (within the range [0 - VIEW_TYPE_MAX_COUNT-1]).\n */\nprotected int getHeaderItemViewType(int position) {\n    return 0;\n}\n\n/**\n * Gets the footer item view type. By default, this method returns 0.\n *\n * @param position the position.\n * @return the footer item view type (within the range [0 - VIEW_TYPE_MAX_COUNT-1]).\n */\nprotected int getFooterItemViewType(int position) {\n    return 0;\n}\n\n/**\n * Gets the content item view type. By default, this method returns 0.\n *\n * @param position the position.\n * @return the content item view type (within the range [0 - VIEW_TYPE_MAX_COUNT-1]).\n */\nprotected int getContentItemViewType(int position) {\n    return 0;\n}\n\n/**\n * Gets the header item count. This method can be called several times, so it should not calculate the count every time.\n *\n * @return the header item count.\n */\nprotected abstract int getHeaderItemCount();\n\n/**\n * Gets the footer item count. This method can be called several times, so it should not calculate the count every time.\n *\n * @return the footer item count.\n */\nprotected abstract int getFooterItemCount();\n\n/**\n * Gets the content item count. This method can be called several times, so it should not calculate the count every time.\n *\n * @return the content item count.\n */\nprotected abstract int getContentItemCount();\n\n/**\n * This method works exactly the same as {@link #onCreateViewHolder(android.view.ViewGroup, int)}, but for header items.\n *\n * @param parent         the parent view.\n * @param headerViewType the view type for the header.\n * @return the view holder.\n */\nprotected abstract RecyclerView.ViewHolder onCreateHeaderItemViewHolder(ViewGroup parent, int headerViewType);\n\n/**\n * This method works exactly the same as {@link #onCreateViewHolder(android.view.ViewGroup, int)}, but for footer items.\n *\n * @param parent         the parent view.\n * @param footerViewType the view type for the footer.\n * @return the view holder.\n */\nprotected abstract RecyclerView.ViewHolder onCreateFooterItemViewHolder(ViewGroup parent, int footerViewType);\n\n/**\n * This method works exactly the same as {@link #onCreateViewHolder(android.view.ViewGroup, int)}, but for content items.\n *\n * @param parent          the parent view.\n * @param contentViewType the view type for the content.\n * @return the view holder.\n */\nprotected abstract RecyclerView.ViewHolder onCreateContentItemViewHolder(ViewGroup parent, int contentViewType);\n\n/**\n * This method works exactly the same as {@link #onBindViewHolder(android.support.v7.widget.RecyclerView.ViewHolder, int)}, but for header items.\n *\n * @param headerViewHolder the view holder for the header item.\n * @param position         the position.\n */\nprotected abstract void onBindHeaderItemViewHolder(RecyclerView.ViewHolder headerViewHolder, int position);\n\n/**\n * This method works exactly the same as {@link #onBindViewHolder(android.support.v7.widget.RecyclerView.ViewHolder, int)}, but for footer items.\n *\n * @param footerViewHolder the view holder for the footer item.\n * @param position         the position.\n */\nprotected abstract void onBindFooterItemViewHolder(RecyclerView.ViewHolder footerViewHolder, int position);\n\n/**\n * This method works exactly the same as {@link #onBindViewHolder(android.support.v7.widget.RecyclerView.ViewHolder, int)}, but for content items.\n *\n * @param contentViewHolder the view holder for the content item.\n * @param position          the position.\n */\nprotected abstract void onBindContentItemViewHolder(RecyclerView.ViewHolder contentViewHolder, int position);\n</code></pre><p>}<br>```</p>\n"},{"title":"谈谈未来、梦想、职业规划","date":"2015-10-16T10:30:00.000Z","_content":"\n## 实现时间自由 - 王胜\n\n- 近期技术打工、为公司技术出一份力\n- 伺机合伙创业\n  - 自己作为技术的Partner\n  - 需求靠谱的产品经理合伙创业\n  - 如果有靠谱的市场/资方人事的合伙人就更完美了\n- 财富自由和时间自由后\n  - 周游开拓视野\n  - 做一些自己感兴趣的东西，不求有市场，只求自己感觉有价值，好玩就行\n\n## 品质生活 - 吴明\n\n- 短期目标\n\t- 学习和开发使用Material Design\n- 长期目标：以下目标之一\n\t- 技术专家\n\t- 管理和技术\n\t- 换行业\n- 第二职业\n\t- 除工作之外培养第二职业\n\t- 第二职业主要兴趣爱好方向\n\t- 不求工资和市场价值高低，只追求兴趣快乐\n  \n## 兴趣主导，快乐很重要 - 杨志平\n\n- 兴趣\n  - 在失去当前工作兴趣之前，不会转行\n  - 职业规划随兴趣走\n  \n- 肉身翻墙\n  - 出去走一遭，趁年轻（工作或打工旅行）\n  - 去牛逼公司镀金\n  \n- 终极目标\n  - 年轻时，向往自由工作者的工作方式，能够养活自己的游行工作方式\n  - 适当年纪收心回归平常心（保持感兴趣的工作即可）\n \n## 一步一个脚印，顺其自然-王进\n- 近期目标，一步一个脚印，不断提高自己\n - 做好现在工作，打下坚实的基础\n - 专注于技术，近期不考虑创业，转行等\n - 顺其自然，当未来出现创业等机会，自己也准备好了，也不错过\n \n- 未来愿景：\n - 看好移动端的未来发展，以会后向智能家居，物联网方向发展\n - 最终希望能在未来能有时间与机会出去走走\n","source":"_posts/谈谈未来，职业规划，梦想.md","raw":"title: 谈谈未来、梦想、职业规划\ndate: 2015-10-16  10:30:00\ntags: 移动组周分享\n---\n\n## 实现时间自由 - 王胜\n\n- 近期技术打工、为公司技术出一份力\n- 伺机合伙创业\n  - 自己作为技术的Partner\n  - 需求靠谱的产品经理合伙创业\n  - 如果有靠谱的市场/资方人事的合伙人就更完美了\n- 财富自由和时间自由后\n  - 周游开拓视野\n  - 做一些自己感兴趣的东西，不求有市场，只求自己感觉有价值，好玩就行\n\n## 品质生活 - 吴明\n\n- 短期目标\n\t- 学习和开发使用Material Design\n- 长期目标：以下目标之一\n\t- 技术专家\n\t- 管理和技术\n\t- 换行业\n- 第二职业\n\t- 除工作之外培养第二职业\n\t- 第二职业主要兴趣爱好方向\n\t- 不求工资和市场价值高低，只追求兴趣快乐\n  \n## 兴趣主导，快乐很重要 - 杨志平\n\n- 兴趣\n  - 在失去当前工作兴趣之前，不会转行\n  - 职业规划随兴趣走\n  \n- 肉身翻墙\n  - 出去走一遭，趁年轻（工作或打工旅行）\n  - 去牛逼公司镀金\n  \n- 终极目标\n  - 年轻时，向往自由工作者的工作方式，能够养活自己的游行工作方式\n  - 适当年纪收心回归平常心（保持感兴趣的工作即可）\n \n## 一步一个脚印，顺其自然-王进\n- 近期目标，一步一个脚印，不断提高自己\n - 做好现在工作，打下坚实的基础\n - 专注于技术，近期不考虑创业，转行等\n - 顺其自然，当未来出现创业等机会，自己也准备好了，也不错过\n \n- 未来愿景：\n - 看好移动端的未来发展，以会后向智能家居，物联网方向发展\n - 最终希望能在未来能有时间与机会出去走走\n","slug":"谈谈未来，职业规划，梦想","published":1,"updated":"2021-09-10T07:04:21.950Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cktfeap4p003ac2xxlk6esila","content":"<h2 id=\"实现时间自由-王胜\"><a href=\"#实现时间自由-王胜\" class=\"headerlink\" title=\"实现时间自由 - 王胜\"></a>实现时间自由 - 王胜</h2><ul>\n<li>近期技术打工、为公司技术出一份力</li>\n<li>伺机合伙创业<ul>\n<li>自己作为技术的Partner</li>\n<li>需求靠谱的产品经理合伙创业</li>\n<li>如果有靠谱的市场/资方人事的合伙人就更完美了</li>\n</ul>\n</li>\n<li>财富自由和时间自由后<ul>\n<li>周游开拓视野</li>\n<li>做一些自己感兴趣的东西，不求有市场，只求自己感觉有价值，好玩就行</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"品质生活-吴明\"><a href=\"#品质生活-吴明\" class=\"headerlink\" title=\"品质生活 - 吴明\"></a>品质生活 - 吴明</h2><ul>\n<li>短期目标<ul>\n<li>学习和开发使用Material Design</li>\n</ul>\n</li>\n<li>长期目标：以下目标之一<ul>\n<li>技术专家</li>\n<li>管理和技术</li>\n<li>换行业</li>\n</ul>\n</li>\n<li>第二职业<ul>\n<li>除工作之外培养第二职业</li>\n<li>第二职业主要兴趣爱好方向</li>\n<li>不求工资和市场价值高低，只追求兴趣快乐</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"兴趣主导，快乐很重要-杨志平\"><a href=\"#兴趣主导，快乐很重要-杨志平\" class=\"headerlink\" title=\"兴趣主导，快乐很重要 - 杨志平\"></a>兴趣主导，快乐很重要 - 杨志平</h2><ul>\n<li><p>兴趣</p>\n<ul>\n<li>在失去当前工作兴趣之前，不会转行</li>\n<li>职业规划随兴趣走</li>\n</ul>\n</li>\n<li><p>肉身翻墙</p>\n<ul>\n<li>出去走一遭，趁年轻（工作或打工旅行）</li>\n<li>去牛逼公司镀金</li>\n</ul>\n</li>\n<li><p>终极目标</p>\n<ul>\n<li>年轻时，向往自由工作者的工作方式，能够养活自己的游行工作方式</li>\n<li>适当年纪收心回归平常心（保持感兴趣的工作即可）</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"一步一个脚印，顺其自然-王进\"><a href=\"#一步一个脚印，顺其自然-王进\" class=\"headerlink\" title=\"一步一个脚印，顺其自然-王进\"></a>一步一个脚印，顺其自然-王进</h2><ul>\n<li><p>近期目标，一步一个脚印，不断提高自己</p>\n<ul>\n<li>做好现在工作，打下坚实的基础</li>\n<li>专注于技术，近期不考虑创业，转行等</li>\n<li>顺其自然，当未来出现创业等机会，自己也准备好了，也不错过</li>\n</ul>\n</li>\n<li><p>未来愿景：</p>\n<ul>\n<li>看好移动端的未来发展，以会后向智能家居，物联网方向发展</li>\n<li>最终希望能在未来能有时间与机会出去走走</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"实现时间自由-王胜\"><a href=\"#实现时间自由-王胜\" class=\"headerlink\" title=\"实现时间自由 - 王胜\"></a>实现时间自由 - 王胜</h2><ul>\n<li>近期技术打工、为公司技术出一份力</li>\n<li>伺机合伙创业<ul>\n<li>自己作为技术的Partner</li>\n<li>需求靠谱的产品经理合伙创业</li>\n<li>如果有靠谱的市场/资方人事的合伙人就更完美了</li>\n</ul>\n</li>\n<li>财富自由和时间自由后<ul>\n<li>周游开拓视野</li>\n<li>做一些自己感兴趣的东西，不求有市场，只求自己感觉有价值，好玩就行</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"品质生活-吴明\"><a href=\"#品质生活-吴明\" class=\"headerlink\" title=\"品质生活 - 吴明\"></a>品质生活 - 吴明</h2><ul>\n<li>短期目标<ul>\n<li>学习和开发使用Material Design</li>\n</ul>\n</li>\n<li>长期目标：以下目标之一<ul>\n<li>技术专家</li>\n<li>管理和技术</li>\n<li>换行业</li>\n</ul>\n</li>\n<li>第二职业<ul>\n<li>除工作之外培养第二职业</li>\n<li>第二职业主要兴趣爱好方向</li>\n<li>不求工资和市场价值高低，只追求兴趣快乐</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"兴趣主导，快乐很重要-杨志平\"><a href=\"#兴趣主导，快乐很重要-杨志平\" class=\"headerlink\" title=\"兴趣主导，快乐很重要 - 杨志平\"></a>兴趣主导，快乐很重要 - 杨志平</h2><ul>\n<li><p>兴趣</p>\n<ul>\n<li>在失去当前工作兴趣之前，不会转行</li>\n<li>职业规划随兴趣走</li>\n</ul>\n</li>\n<li><p>肉身翻墙</p>\n<ul>\n<li>出去走一遭，趁年轻（工作或打工旅行）</li>\n<li>去牛逼公司镀金</li>\n</ul>\n</li>\n<li><p>终极目标</p>\n<ul>\n<li>年轻时，向往自由工作者的工作方式，能够养活自己的游行工作方式</li>\n<li>适当年纪收心回归平常心（保持感兴趣的工作即可）</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"一步一个脚印，顺其自然-王进\"><a href=\"#一步一个脚印，顺其自然-王进\" class=\"headerlink\" title=\"一步一个脚印，顺其自然-王进\"></a>一步一个脚印，顺其自然-王进</h2><ul>\n<li><p>近期目标，一步一个脚印，不断提高自己</p>\n<ul>\n<li>做好现在工作，打下坚实的基础</li>\n<li>专注于技术，近期不考虑创业，转行等</li>\n<li>顺其自然，当未来出现创业等机会，自己也准备好了，也不错过</li>\n</ul>\n</li>\n<li><p>未来愿景：</p>\n<ul>\n<li>看好移动端的未来发展，以会后向智能家居，物联网方向发展</li>\n<li>最终希望能在未来能有时间与机会出去走走</li>\n</ul>\n</li>\n</ul>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cktfeap380006c2xxglhs1q8f","category_id":"cktfeap350004c2xxipki8rmg","_id":"cktfeap3f000bc2xxy6lv4kkj"},{"post_id":"cktfeap2y0000c2xx5paq3lzc","category_id":"cktfeap350004c2xxipki8rmg","_id":"cktfeap3g000ec2xxum7y6zdl"},{"post_id":"cktfeap390007c2xxksfz29nt","category_id":"cktfeap350004c2xxipki8rmg","_id":"cktfeap3i000gc2xx8nmt3ch6"},{"post_id":"cktfeap3c0009c2xxc9n289kn","category_id":"cktfeap350004c2xxipki8rmg","_id":"cktfeap3j000jc2xx8df5sefm"},{"post_id":"cktfeap330002c2xxm39fue5j","category_id":"cktfeap350004c2xxipki8rmg","_id":"cktfeap3l000lc2xx64xlgrnb"},{"post_id":"cktfeap3d000ac2xxf0c4vn8u","category_id":"cktfeap350004c2xxipki8rmg","_id":"cktfeap3m000oc2xxuzref9q7"},{"post_id":"cktfeap370005c2xxbpdqkx6u","category_id":"cktfeap350004c2xxipki8rmg","_id":"cktfeap3o000qc2xx6rbajkbp"},{"post_id":"cktfeap3i000ic2xxpjn17y2v","category_id":"cktfeap350004c2xxipki8rmg","_id":"cktfeap3p000sc2xxg9pdpq9h"},{"post_id":"cktfeap3k000kc2xx467ns9fp","category_id":"cktfeap350004c2xxipki8rmg","_id":"cktfeap3q000uc2xxp8rw3el3"},{"post_id":"cktfeap3g000dc2xxlhb0ffz8","category_id":"cktfeap3i000hc2xxnrjrafmu","_id":"cktfeap3r000wc2xxvqv1rbmt"},{"post_id":"cktfeap3m000mc2xxis7g9wsa","category_id":"cktfeap350004c2xxipki8rmg","_id":"cktfeap3s000yc2xx90ll4dc9"},{"post_id":"cktfeap3n000pc2xxd90ygf4q","category_id":"cktfeap350004c2xxipki8rmg","_id":"cktfeap3t0011c2xxmbz2al3r"},{"post_id":"cktfeap3h000fc2xxqky80v90","category_id":"cktfeap3m000nc2xx5yvorc8p","_id":"cktfeap3u0013c2xx9i1sctsg"},{"post_id":"cktfeap3o000rc2xx1y8rniww","category_id":"cktfeap350004c2xxipki8rmg","_id":"cktfeap3v0016c2xxru3n82z0"},{"post_id":"cktfeap3p000tc2xxc13bvjih","category_id":"cktfeap3i000hc2xxnrjrafmu","_id":"cktfeap3w0018c2xxr6017mg9"},{"post_id":"cktfeap3t0012c2xxkpnhf76p","category_id":"cktfeap3s000zc2xx20ec1094","_id":"cktfeap3x001bc2xxgofzrkki"},{"post_id":"cktfeap3q000vc2xxcscy29ea","category_id":"cktfeap3s000zc2xx20ec1094","_id":"cktfeap3y001dc2xx7x5chwgh"},{"post_id":"cktfeap3u0014c2xx1q76vg60","category_id":"cktfeap3s000zc2xx20ec1094","_id":"cktfeap3z001fc2xxekynmg7k"},{"post_id":"cktfeap3v0017c2xxqfubl8dt","category_id":"cktfeap3s000zc2xx20ec1094","_id":"cktfeap3z001hc2xxymsnxthv"},{"post_id":"cktfeap3r000xc2xx1q56j5vv","category_id":"cktfeap3s000zc2xx20ec1094","_id":"cktfeap40001jc2xxwrdzcqhj"},{"post_id":"cktfeap3w0019c2xxcs5i9c2s","category_id":"cktfeap3s000zc2xx20ec1094","_id":"cktfeap41001lc2xxquyufn8p"},{"post_id":"cktfeap3x001cc2xxj1cleyz4","category_id":"cktfeap3s000zc2xx20ec1094","_id":"cktfeap42001oc2xxasa301be"},{"post_id":"cktfeap3s0010c2xxmnhsn1l3","category_id":"cktfeap3s000zc2xx20ec1094","_id":"cktfeap44001rc2xxfj2iksx3"},{"post_id":"cktfeap3y001ec2xxs2gm0pui","category_id":"cktfeap3i000hc2xxnrjrafmu","_id":"cktfeap45001tc2xxuj6s0eru"},{"post_id":"cktfeap3z001gc2xxkq0x1zqt","category_id":"cktfeap350004c2xxipki8rmg","_id":"cktfeap46001wc2xxoeoanfdy"},{"post_id":"cktfeap41001kc2xxl7tca3lp","category_id":"cktfeap3i000hc2xxnrjrafmu","_id":"cktfeap47001yc2xxwr69g6eo"},{"post_id":"cktfeap42001nc2xxm9hp1tbm","category_id":"cktfeap3i000hc2xxnrjrafmu","_id":"cktfeap480020c2xxt0kik5uj"},{"post_id":"cktfeap43001qc2xxc3ng3zkn","category_id":"cktfeap350004c2xxipki8rmg","_id":"cktfeap490024c2xx1z373kd1"},{"post_id":"cktfeap40001ic2xxzfe3riws","category_id":"cktfeap42001mc2xxra2ucy3y","_id":"cktfeap4a0027c2xx3bcxqvey"},{"post_id":"cktfeap44001sc2xx0iuvc4mw","category_id":"cktfeap3i000hc2xxnrjrafmu","_id":"cktfeap4b002ac2xxrkciky83"},{"post_id":"cktfeap45001uc2xxy9j6w16m","category_id":"cktfeap3i000hc2xxnrjrafmu","_id":"cktfeap4c002dc2xx98etpagb"},{"post_id":"cktfeap46001xc2xx5kyctiek","category_id":"cktfeap3i000hc2xxnrjrafmu","_id":"cktfeap4d002gc2xx590lkj4g"},{"post_id":"cktfeap480022c2xxa2a4568q","category_id":"cktfeap3m000nc2xx5yvorc8p","_id":"cktfeap4e002ic2xxyfdn94ap"},{"post_id":"cktfeap490025c2xxf4iktke5","category_id":"cktfeap3i000hc2xxnrjrafmu","_id":"cktfeap4f002mc2xxr6ds6kpu"},{"post_id":"cktfeap4a0029c2xxtnp36j6h","category_id":"cktfeap3i000hc2xxnrjrafmu","_id":"cktfeap4g002oc2xx625lyqrr"},{"post_id":"cktfeap4b002cc2xxs2yyc287","category_id":"cktfeap3i000hc2xxnrjrafmu","_id":"cktfeap4h002qc2xx9rfg291a"},{"post_id":"cktfeap4d002hc2xxrykmzra5","category_id":"cktfeap3i000hc2xxnrjrafmu","_id":"cktfeap4i002uc2xxpm917kdz"},{"post_id":"cktfeap4f002kc2xxstyy197h","category_id":"cktfeap3i000hc2xxnrjrafmu","_id":"cktfeap4j002xc2xxrdr3vcj3"},{"post_id":"cktfeap4g002nc2xxwxwhx8g6","category_id":"cktfeap3i000hc2xxnrjrafmu","_id":"cktfeap4l0031c2xxy34gv48e"},{"post_id":"cktfeap4c002fc2xx2fwo6oxd","category_id":"cktfeap4e002jc2xxbf8605cy","_id":"cktfeap4m0034c2xxemliepcb"},{"post_id":"cktfeap4g002pc2xx4ct1lmku","category_id":"cktfeap3i000hc2xxnrjrafmu","_id":"cktfeap4n0037c2xxl6l3bbu2"},{"post_id":"cktfeap4i002sc2xx137pqwtf","category_id":"cktfeap3i000hc2xxnrjrafmu","_id":"cktfeap4p0039c2xxed10jvv5"},{"post_id":"cktfeap4j002vc2xxby0fowxx","category_id":"cktfeap3i000hc2xxnrjrafmu","_id":"cktfeap4q003cc2xxh9437yis"},{"post_id":"cktfeap4k002zc2xx6sjzuqzk","category_id":"cktfeap3i000hc2xxnrjrafmu","_id":"cktfeap4r003ec2xx628ss8h1"},{"post_id":"cktfeap4l0032c2xx35ayzs61","category_id":"cktfeap3i000hc2xxnrjrafmu","_id":"cktfeap4r003gc2xxl6a606bv"},{"post_id":"cktfeap4n0036c2xx9r533ish","category_id":"cktfeap3i000hc2xxnrjrafmu","_id":"cktfeap4r003jc2xx2tiayw1g"},{"post_id":"cktfeap4o0038c2xx5rud74pa","category_id":"cktfeap3i000hc2xxnrjrafmu","_id":"cktfeap4s003kc2xxdws2e1zg"}],"PostTag":[{"post_id":"cktfeap41001kc2xxl7tca3lp","tag_id":"cktfeap43001pc2xxt9p4cm9b","_id":"cktfeap490023c2xxstigiyz4"},{"post_id":"cktfeap41001kc2xxl7tca3lp","tag_id":"cktfeap46001vc2xx81jvjnho","_id":"cktfeap4a0026c2xx5ir0qqs7"},{"post_id":"cktfeap42001nc2xxm9hp1tbm","tag_id":"cktfeap480021c2xxtim8k4sl","_id":"cktfeap4b002bc2xxq0o3ipw5"},{"post_id":"cktfeap43001qc2xxc3ng3zkn","tag_id":"cktfeap4a0028c2xxd06ras4g","_id":"cktfeap4i002tc2xx5ftdc0ac"},{"post_id":"cktfeap43001qc2xxc3ng3zkn","tag_id":"cktfeap4c002ec2xx6di7mtv1","_id":"cktfeap4j002wc2xxqpqfw0r0"},{"post_id":"cktfeap43001qc2xxc3ng3zkn","tag_id":"cktfeap4f002lc2xxhjmrxccf","_id":"cktfeap4l0030c2xx6xbiee8o"},{"post_id":"cktfeap47001zc2xxrc5623lw","tag_id":"cktfeap4h002rc2xxlte76gox","_id":"cktfeap4m0033c2xxa14fyv2n"},{"post_id":"cktfeap490025c2xxf4iktke5","tag_id":"cktfeap4k002yc2xx6mdob1p9","_id":"cktfeap4r003dc2xxc888g7jh"},{"post_id":"cktfeap490025c2xxf4iktke5","tag_id":"cktfeap4m0035c2xx5k69u0j3","_id":"cktfeap4r003fc2xx2u82o276"},{"post_id":"cktfeap4f002kc2xxstyy197h","tag_id":"cktfeap4q003bc2xxqb116vz8","_id":"cktfeap4r003ic2xxo4gdb1dp"},{"post_id":"cktfeap4g002pc2xx4ct1lmku","tag_id":"cktfeap4r003hc2xx35ysavt5","_id":"cktfeap4s003nc2xxdh365wse"},{"post_id":"cktfeap4g002pc2xx4ct1lmku","tag_id":"cktfeap4s003lc2xxhpk18lnb","_id":"cktfeap4t003oc2xxvvkibbeq"},{"post_id":"cktfeap4p003ac2xxlk6esila","tag_id":"cktfeap4s003mc2xxim1c4qmy","_id":"cktfeap4t003pc2xx5m7z582q"}],"Tag":[{"name":"开发效率","_id":"cktfeap43001pc2xxt9p4cm9b"},{"name":"效率","_id":"cktfeap46001vc2xx81jvjnho"},{"name":"git","_id":"cktfeap480021c2xxtim8k4sl"},{"name":"tablayout","_id":"cktfeap4a0028c2xxd06ras4g"},{"name":"Chrome","_id":"cktfeap4c002ec2xx6di7mtv1"},{"name":"坑","_id":"cktfeap4f002lc2xxhjmrxccf"},{"name":"Android,dp,单位","_id":"cktfeap4h002rc2xxlte76gox"},{"name":"博客","_id":"cktfeap4k002yc2xx6mdob1p9"},{"name":"网站","_id":"cktfeap4m0035c2xx5k69u0j3"},{"name":"研发杂谈","_id":"cktfeap4q003bc2xxqb116vz8"},{"name":"线程","_id":"cktfeap4r003hc2xx35ysavt5"},{"name":"同步异步","_id":"cktfeap4s003lc2xxhpk18lnb"},{"name":"移动组周分享","_id":"cktfeap4s003mc2xxim1c4qmy"}]}}